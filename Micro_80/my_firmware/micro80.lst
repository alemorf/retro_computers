0001   0000                 device zxspectrum48 ; It has nothing to do with ZX Spectrum 48K, it is needed for the sjasmplus compiler.
0002   0000             rst30opcode equ 48
0003   0000             rst30address equ 49
0004   0000             rst38opcode equ 56
0005   0000             rst38address equ 57
0006   0000             keybuffer equ 63318
0007   0000             keycode equ 63319
0008   0000             keyboardmode equ 63320
0009   0000             color equ 63321
0010   0000             cursor equ 63322
0011   0000             tapereadspeed equ 63324
0012   0000             tapewritespeed equ 63325
0013   0000             cursorvisible equ 63326
0014   0000             escstate equ 63327
0015   0000             keydelay equ 63328
0016   0000             keylast equ 63329
0017   0000             regpc equ 63330
0018   0000             reghl equ 63332
0019   0000             regbc equ 63334
0020   0000             regde equ 63336
0021   0000             regsp equ 63338
0022   0000             regaf equ 63340
0023   0000             breakpointaddress equ 63345
0024   0000             breakpointvalue equ 63347
0025   0000             jmpparam1opcode equ 63348
0026   0000             param1 equ 63349
0027   0000             param2 equ 63351
0028   0000             param3 equ 63353
0029   0000             param2exists equ 63355
0030   0000             tapepolarity equ 63356
0031   0000             ramtop equ 63361
0032   0000             inputbuffer equ 63363
0033   0000             jmpparam1 equ 63348
0034   0000              .org 0xF800
0035   F800             ; 66  uint8_t rst30Opcode __address(0x30);
0036   F800             ; 67 extern uint16_t rst30Address __address(0x31);
0037   F800             ; 68 extern uint8_t rst38Opcode __address(0x38);
0038   F800             ; 69 extern uint16_t rst38Address __address(0x39);
0039   F800             ; 70 
0040   F800             ; 71 // Прототипы
0041   F800             ; 72 void Reboot(...);
0042   F800             ; 73 void EntryF86C_Monitor(...);
0043   F800             ; 74 void Monitor(...);
0044   F800             ; 75 void Monitor2();
0045   F800             ; 76 void ReadString(...);
0046   F800             ; 77 void PrintString(...);
0047   F800             ; 78 void ParseParams(...);
0048   F800             ; 79 void ParseWord(...);
0049   F800             ; 80 void CompareHlDe(...);
0050   F800             ; 81 void LoopWithBreak(...);
0051   F800             ; 82 void Loop(...);
0052   F800             ; 83 void PopRet();
0053   F800             ; 84 void IncHl(...);
0054   F800             ; 85 void CtrlC(...);
0055   F800             ; 86 void PrintCrLfTab();
0056   F800             ; 87 void PrintHexByteFromHlSpace(...);
0057   F800             ; 88 void PrintHexByteSpace(...);
0058   F800             ; 89 #ifdef CMD_R_ENABLED
0059   F800             ; 90 void CmdR(...);
0060   F800             ; 91 #endif
0061   F800             ; 92 void GetRamTop(...);
0062   F800             ; 93 void SetRamTop(...);
0063   F800             ; 94 #ifdef CMD_A_ENABLED
0064   F800             ; 95 void CmdA(...);
0065   F800             ; 96 #endif
0066   F800             ; 97 void CmdD(...);
0067   F800             ; 98 void PrintSpacesTo(...);
0068   F800             ; 99 void PrintSpace();
0069   F800             ; 100 void CmdC(...);
0070   F800             ; 101 void CmdF(...);
0071   F800             ; 102 void CmdS(...);
0072   F800             ; 103 void CmdW(...);
0073   F800             ; 104 void CmdT(...);
0074   F800             ; 105 void CmdM(...);
0075   F800             ; 106 void CmdG(...);
0076   F800             ; 107 void BreakPointHandler(...);
0077   F800             ; 108 void CmdX(...);
0078   F800             ; 109 void GetCursor();
0079   F800             ; 110 void GetCursorChar();
0080   F800             ; 111 void CmdH(...);
0081   F800             ; 112 void CmdI(...);
0082   F800             ; 113 void MonitorError();
0083   F800             ; 114 void ReadTapeFile(...);
0084   F800             ; 115 void ReadTapeWordNext();
0085   F800             ; 116 void ReadTapeWord(...);
0086   F800             ; 117 void ReadTapeBlock(...);
0087   F800             ; 118 void CalculateCheckSum(...);
0088   F800             ; 119 void CmdO(...);
0089   F800             ; 120 void WriteTapeFile(...);
0090   F800             ; 121 void PrintCrLfTabHexWordSpace(...);
0091   F800             ; 122 void PrintHexWordSpace(...);
0092   F800             ; 123 void WriteTapeBlock(...);
0093   F800             ; 124 void WriteTapeWord(...);
0094   F800             ; 125 void ReadTapeByte(...);
0095   F800             ; 126 void ReadTapeByteInternal(...);
0096   F800             ; 127 void ReadTapeByteTimeout(...);
0097   F800             ; 128 void WriteTapeByte(...);
0098   F800             ; 129 void PrintHexByte(...);
0099   F800             ; 130 void PrintHexNibble(...);
0100   F800             ; 131 void PrintCharA(...);
0101   F800             ; 132 void PrintChar(...);
0102   F800             ; 133 void PrintCharSetEscState(...);
0103   F800             ; 134 void PrintCharSaveCursor(...);
0104   F800             ; 135 void PrintCharExit(...);
0105   F800             ; 136 void DrawCursor(...);
0106   F800             ; 137 void PrintCharEscY2(...);
0107   F800             ; 138 void PrintCharResetEscState(...);
0108   F800             ; 139 void PrintCharEsc(...);
0109   F800             ; 140 void SetCursorVisible(...);
0110   F800             ; 141 void PrintCharNoEsc(...);
0111   F800             ; 142 void PrintChar4(...);
0112   F800             ; 143 void ClearScreen(...);
0113   F800             ; 144 void MoveCursorHome(...);
0114   F800             ; 145 void PrintChar3(...);
0115   F800             ; 146 void PrintCharBeep(...);
0116   F800             ; 147 void MoveCursorCr(...);
0117   F800             ; 148 void MoveCursorRight(...);
0118   F800             ; 149 void MoveCursorBoundary(...);
0119   F800             ; 150 void MoveCursorLeft(...);
0120   F800             ; 151 void MoveCursorLf(...);
0121   F800             ; 152 void MoveCursorUp(...);
0122   F800             ; 153 void MoveCursor(...);
0123   F800             ; 154 void MoveCursorDown(...);
0124   F800             ; 155 void IsAnyKeyPressed();
0125   F800             ; 156 void IsAnyKeyPressed2();
0126   F800             ; 157 void ReadKey();
0127   F800             ; 158 void ReadKeyInternal(...);
0128   F800             ; 159 void ScanKey();
0129   F800             ; 160 void ScanKey2(...);
0130   F800             ; 161 void ScanKey3(...);
0131   F800             ; 162 void ScanKeyExit(...);
0132   F800             ; 163 void ScanKeyControl(...);
0133   F800             ; 164 void ScanKeySpecial(...);
0134   F800             ; 165 #ifdef CMD_A_ENABLED
0135   F800             ; 166 void TranslateCodePageDefault(...);
0136   F800             ; 167 #endif
0137   F800             ; 168 void TryScrollUp(...);
0138   F800             ; 169 void PrintKeyStatusInt(...);
0139   F800             ; 170 void PrintKeyStatus();
0140   F800             ; 171 
0141   F800             ; 172 // Переменные Монитора
0142   F800             ; 173 
0143   F800             ; 174 extern uint8_t keyBuffer __address(0xF756);
0144   F800             ; 175 extern uint8_t keyCode __address(0xF757);
0145   F800             ; 176 extern uint8_t keyboardMode __address(0xF758);
0146   F800             ; 177 extern uint8_t color __address(0xF759);
0147   F800             ; 178 extern uint16_t cursor __address(0xF75A);
0148   F800             ; 179 extern uint8_t tapeReadSpeed __address(0xF75C);
0149   F800             ; 180 extern uint8_t tapeWriteSpeed __address(0xF75D);
0150   F800             ; 181 extern uint8_t cursorVisible __address(0xF75E);
0151   F800             ; 182 extern uint8_t escState __address(0xF75F);
0152   F800             ; 183 extern uint16_t keyDelay __address(0xF760);
0153   F800             ; 184 extern uint16_t keyLast __address(0xF761);
0154   F800             ; 185 extern uint16_t regPC __address(0xF762);
0155   F800             ; 186 extern uint16_t regHL __address(0xF764);
0156   F800             ; 187 extern uint16_t regBC __address(0xF766);
0157   F800             ; 188 extern uint16_t regDE __address(0xF768);
0158   F800             ; 189 extern uint16_t regSP __address(0xF76A);
0159   F800             ; 190 extern uint16_t regAF __address(0xF76C);
0160   F800             ; 191 extern uint16_t breakPointAddress __address(0xF771);
0161   F800             ; 192 extern uint8_t breakPointValue __address(0xF773);
0162   F800             ; 193 extern uint8_t jmpParam1Opcode __address(0xF774);
0163   F800             ; 194 extern uint16_t param1 __address(0xF775);
0164   F800             ; 195 extern uint16_t param2 __address(0xF777);
0165   F800             ; 196 extern uint16_t param3 __address(0xF779);
0166   F800             ; 197 extern uint8_t param2Exists __address(0xF77B);
0167   F800             ; 198 extern uint8_t tapePolarity __address(0xF77C);
0168   F800             ; 199 #ifdef CMD_A_ENABLED
0169   F800             ; 200 extern uint8_t translateCodeEnabled __address(0xF77D);
0170   F800             ; 201 extern uint8_t translateCodePageJump __address(0xF77E);
0171   F800             ; 202 extern uint16_t translateCodePageAddress __address(0xF77F);
0172   F800             ; 203 #endif
0173   F800             ; 204 extern uint16_t ramTop __address(0xF781);
0174   F800             ; 205 extern uint8_t inputBuffer[32] __address(0xF783);
0175   F800             ; 206 
0176   F800             ; 207 #define firstVariableAddress (&keyBuffer)
0177   F800             ; 208 #define lastVariableAddress (&inputBuffer[sizeof(inputBuffer) - 1])
0178   F800             ; 209 
0179   F800             ; 210 extern uint8_t specialKeyTable[9];
0180   F800             ; 211 extern uint8_t aPrompt[6];
0181   F800             ; 212 extern uint8_t aCrLfTab[6];
0182   F800             ; 213 extern uint8_t aRegisters[37];
0183   F800             ; 214 extern uint8_t aBackspace[4];
0184   F800             ; 215 extern uint8_t aHello[12];
0185   F800             ; 216 
0186   F800             ; 217 // Для удобства
0187   F800             ; 218 
0188   F800             ; 219 void JmpParam1() __address(0xF774);
0189   F800             ; 220 #ifdef CMD_A_ENABLED
0190   F800             ; 221 void TranslateCodePage() __address(0xF77E);
0191   F800             ; 222 #endif
0192   F800             ; 223 
0193   F800             ; 224 // Точки входа
0194   F800             ; 225 
0195   F800             ; 226 void EntryF800_Reboot() {
0196   F800             entryf800_reboot: 
0197   F800             ; 227     Reboot();
0198   F800 C3 63 F8    	jp reboot
0199   F803             ; 228 }
0200   F803             ; 229 
0201   F803             ; 230 void EntryF803_ReadKey() {
0202   F803             entryf803_readkey: 
0203   F803             ; 231     ReadKey();
0204   F803 C3 D5 FE    	jp readkey
0205   F806             ; 232 }
0206   F806             ; 233 
0207   F806             ; 234 void EntryF806_ReadTapeByte(...) {
0208   F806             entryf806_readtapebyte: 
0209   F806             ; 235     ReadTapeByte(a);
0210   F806 C3 34 FC    	jp readtapebyte
0211   F809             ; 236 }
0212   F809             ; 237 
0213   F809             ; 238 void EntryF809_PrintChar(...) {
0214   F809             entryf809_printchar: 
0215   F809             ; 239     PrintChar(c);
0216   F809 C3 E3 FC    	jp printchar
0217   F80C             ; 240 }
0218   F80C             ; 241 
0219   F80C             ; 242 void EntryF80C_WriteTapeByte(...) {
0220   F80C             entryf80c_writetapebyte: 
0221   F80C             ; 243     WriteTapeByte(c);
0222   F80C C3 9D FC    	jp writetapebyte
0223   F80F             ; 244 }
0224   F80F             ; 245 
0225   F80F             ; 246 void EntryF80F_TranslateCodePage(...) {
0226   F80F             entryf80f_translatecodepage: 
0227   F80F             ; 247 #ifdef CMD_A_ENABLED
0228   F80F             ; 248     TranslateCodePage(c);
0229   F80F             ; 249 #else
0230   F80F             ; 250     return;
0231   F80F C9          	ret
0232   F810             ; 251     return;
0233   F810 C9          	ret
0234   F811             ; 252     return;
0235   F811 C9          	ret
0236   F812             ; 253 #endif
0237   F812             ; 254 }
0238   F812             ; 255 
0239   F812             ; 256 void EntryF812_IsAnyKeyPressed() {
0240   F812             entryf812_isanykeypressed: 
0241   F812             ; 257     IsAnyKeyPressed();
0242   F812 C3 61 FE    	jp isanykeypressed
0243   F815             ; 258 }
0244   F815             ; 259 
0245   F815             ; 260 void EntryF815_PrintHexByte(...) {
0246   F815             entryf815_printhexbyte: 
0247   F815             ; 261     PrintHexByte(a);
0248   F815 C3 CE FC    	jp printhexbyte
0249   F818             ; 262 }
0250   F818             ; 263 
0251   F818             ; 264 void EntryF818_PrintString(...) {
0252   F818             entryf818_printstring: 
0253   F818             ; 265     PrintString(hl);
0254   F818 C3 1F F9    	jp printstring
0255   F81B             ; 266 }
0256   F81B             ; 267 
0257   F81B             ; 268 void EntryF81B_ScanKey() {
0258   F81B             entryf81b_scankey: 
0259   F81B             ; 269     ScanKey();
0260   F81B C3 E9 FE    	jp scankey
0261   F81E             ; 270 }
0262   F81E             ; 271 
0263   F81E             ; 272 void EntryF81E_GetCursor() {
0264   F81E             entryf81e_getcursor: 
0265   F81E             ; 273     GetCursor();
0266   F81E C3 0A FB    	jp getcursor
0267   F821             ; 274 }
0268   F821             ; 275 
0269   F821             ; 276 void EntryF821_GetCursorChar() {
0270   F821             entryf821_getcursorchar: 
0271   F821             ; 277     GetCursorChar();
0272   F821 C3 1F FB    	jp getcursorchar
0273   F824             ; 278 }
0274   F824             ; 279 
0275   F824             ; 280 void EntryF824_ReadTapeFile(...) {
0276   F824             entryf824_readtapefile: 
0277   F824             ; 281     ReadTapeFile(hl);
0278   F824 C3 7B FB    	jp readtapefile
0279   F827             ; 282 }
0280   F827             ; 283 
0281   F827             ; 284 void EntryF827_WriteTapeFile(...) {
0282   F827             entryf827_writetapefile: 
0283   F827             ; 285     WriteTapeFile(bc, de, hl);
0284   F827 C3 03 FC    	jp writetapefile
0285   F82A             ; 286 }
0286   F82A             ; 287 
0287   F82A             ; 288 void EntryF82A_CalculateCheckSum(...) {
0288   F82A             entryf82a_calculatechecksum: 
0289   F82A             ; 289     CalculateCheckSum(hl, de);
0290   F82A C3 B2 FB    	jp calculatechecksum
0291   F82D             ; 290 }
0292   F82D             ; 291 
0293   F82D             ; 292 void EntryF82D_EnableScreen() {
0294   F82D             entryf82d_enablescreen: 
0295   F82D             ; 293     return;
0296   F82D C9          	ret
0297   F82E             ; 294     return;
0298   F82E C9          	ret
0299   F82F             ; 295     return;
0300   F82F C9          	ret
0301   F830             ; 296 }
0302   F830             ; 297 
0303   F830             ; 298 void EntryF830_GetRamTop() {
0304   F830             entryf830_getramtop: 
0305   F830             ; 299     GetRamTop();
0306   F830 C3 BD F9    	jp getramtop
0307   F833             ; 300 }
0308   F833             ; 301 
0309   F833             ; 302 void EntryF833_SetRamTop(...) {
0310   F833             entryf833_setramtop: 
0311   F833             ; 303     SetRamTop(hl);
0312   F833 C3 C1 F9    	jp setramtop
0313   F836             ; 304 }
0314   F836             ; 305 
0315   F836             ; 306 void EntryF836_InitMonitor(...) {
0316   F836             entryf836_initmonitor: 
0317   F836             ; 307     // Очистка памяти
0318   F836             ; 308     hl = firstVariableAddress;
0319   F836 21 56 F7    	ld hl, 0FFFFh & (keybuffer)
0320   F839             ; 309     de = lastVariableAddress;
0321   F839 11 A2 F7    	ld de, 0FFFFh & ((inputbuffer) + (31))
0322   F83C             ; 310     c = 0;
0323   F83C 0E 00       	ld c, 0
0324   F83E             ; 311     CmdF();
0325   F83E CD 43 FA    	call cmdf
0326   F841             ; 312 
0327   F841             ; 313     color = a = SCREEN_ATTRIB_DEFAULT;
0328   F841 3E 17       	ld a, 23
0329   F843 32 59 F7    	ld (color), a
0330   F846             ; 314 #ifdef CMD_A_ENABLED
0331   F846             ; 315     translateCodePageJump = a = OPCODE_JMP;
0332   F846             ; 316 #endif
0333   F846             ; 317 
0334   F846             ; 318     PrintString(hl = aHello);
0335   F846 21 BF FF    	ld hl, 0FFFFh & (ahello)
0336   F849 CD 1F F9    	call printstring
0337   F84C             ; 319 
0338   F84C             ; 320     ramTop = hl = SCREEN_ATTRIB_BEGIN - 1;
0339   F84C 21 FF DF    	ld hl, 57343
0340   F84F 22 81 F7    	ld (ramtop), hl
0341   F852             ; 321     tapeReadSpeed = hl = TAPE_SPEED;
0342   F852 21 54 38    	ld hl, 14420
0343   F855 22 5C F7    	ld (tapereadspeed), hl
0344   F858             ; 322 #ifdef CMD_A_ENABLED
0345   F858             ; 323     translateCodePageAddress = hl = &TranslateCodePageDefault;
0346   F858             ; 324 #endif
0347   F858             ; 325     regSP = hl = STACK_TOP - 2;
0348   F858 21 FE F7    	ld hl, 63486
0349   F85B 22 6A F7    	ld (regsp), hl
0350   F85E             ; 326     
0351   F85E             ; 327     out(PORT_KEYBOARD_MODE, a = 0x83);
0352   F85E 3E 83       	ld a, 131
0353   F860 D3 04       	out (4), a
0354   F862 C9          	ret
0355   F863             ; 328 }
0356   F863             ; 329 
0357   F863             ; 330 // Инициализация. Выполняется после перезагрузки или пользовательской программой.
0358   F863             ; 331 // Параметры: нет. Функция никогда не завершается.
0359   F863             ; 332 
0360   F863             ; 333 void Reboot(...) {
0361   F863             reboot: 
0362   F863             ; 334     disable_interrupts();
0363   F863 F3          	di
0364   F864             ; 335     sp = STACK_TOP;
0365   F864 31 00 F8    	ld sp, 63488
0366   F867             ; 336     EntryF836_InitMonitor();
0367   F867 CD 36 F8    	call entryf836_initmonitor
0368   F86A             ; 337     asm(" nop");
0369   F86A 00           nop
0370   F86B             ; 338     asm(" nop");
0371   F86B 00           nop
0372   F86C C9          	ret
0373   F86D              .org 0xF86C
0374   F86C             ; 339 }
0375   F86C             ; 340 
0376   F86C             ; 341 asm(" .org 0xF86C");
0377   F86C             ; 342 
0378   F86C             ; 343 void EntryF86C_Monitor() {
0379   F86C             entryf86c_monitor: 
0380   F86C             ; 344     Monitor();
0381   F86C             ; 345 }
0382   F86C             ; 346 
0383   F86C             ; 347 void Monitor() {
0384   F86C             monitor: 
0385   F86C             ; 348     out(PORT_KEYBOARD_MODE, a = 0x83);
0386   F86C 3E 83       	ld a, 131
0387   F86E D3 04       	out (4), a
0388   F870             ; 349     jmpParam1Opcode = a = OPCODE_JMP;
0389   F870 3E C3       	ld a, 195
0390   F872 32 74 F7    	ld (jmpparam1opcode), a
0391   F875             ; 350     Monitor2();
0392   F875             ; 351 }
0393   F875             ; 352 
0394   F875             ; 353 void Monitor2() {
0395   F875             monitor2: 
0396   F875             ; 354     sp = STACK_TOP;
0397   F875 31 00 F8    	ld sp, 63488
0398   F878             ; 355     PrintString(hl = aPrompt);
0399   F878 21 8A FF    	ld hl, 0FFFFh & (aprompt)
0400   F87B CD 1F F9    	call printstring
0401   F87E             ; 356 
0402   F87E             ; 357     ReadString();
0403   F87E CD DB F8    	call readstring
0404   F881             ; 358 
0405   F881             ; 359     push(hl = &EntryF86C_Monitor);
0406   F881 21 6C F8    	ld hl, 0FFFFh & (entryf86c_monitor)
0407   F884 E5          	push hl
0408   F885             ; 360 
0409   F885             ; 361     hl = inputBuffer;
0410   F885 21 83 F7    	ld hl, 0FFFFh & (inputbuffer)
0411   F888             ; 362     a = *hl;
0412   F888 7E          	ld a, (hl)
0413   F889             ; 363     a &= 0x7F;
0414   F889 E6 7F       	and 127
0415   F88B             ; 364 
0416   F88B             ; 365     if (a == 'X')
0417   F88B FE 58       	cp 88
0418   F88D             ; 366         return CmdX();
0419   F88D CA DD FA    	jp z, cmdx
0420   F890             ; 367 
0421   F890             ; 368     push_pop(a) {
0422   F890 F5          	push af
0423   F891             ; 369         ParseParams();
0424   F891 CD 29 F9    	call parseparams
0425   F894             ; 370         hl = param3;
0426   F894 2A 79 F7    	ld hl, (param3)
0427   F897             ; 371         c = l;
0428   F897 4D          	ld c, l
0429   F898             ; 372         b = h;
0430   F898 44          	ld b, h
0431   F899             ; 373         hl = param2;
0432   F899 2A 77 F7    	ld hl, (param2)
0433   F89C             ; 374         swap(hl, de);
0434   F89C EB          	ex hl, de
0435   F89D             ; 375         hl = param1;
0436   F89D 2A 75 F7    	ld hl, (param1)
0437   F8A0 F1          	pop af
0438   F8A1             ; 376     }
0439   F8A1             ; 377 
0440   F8A1             ; 378     if (a == 'D')
0441   F8A1 FE 44       	cp 68
0442   F8A3             ; 379         return CmdD();
0443   F8A3 CA C5 F9    	jp z, cmdd
0444   F8A6             ; 380     if (a == 'C')
0445   F8A6 FE 43       	cp 67
0446   F8A8             ; 381         return CmdC();
0447   F8A8 CA 2D FA    	jp z, cmdc
0448   F8AB             ; 382     if (a == 'F')
0449   F8AB FE 46       	cp 70
0450   F8AD             ; 383         return CmdF();
0451   F8AD CA 43 FA    	jp z, cmdf
0452   F8B0             ; 384     if (a == 'S')
0453   F8B0 FE 53       	cp 83
0454   F8B2             ; 385         return CmdS();
0455   F8B2 CA 4A FA    	jp z, cmds
0456   F8B5             ; 386     if (a == 'T')
0457   F8B5 FE 54       	cp 84
0458   F8B7             ; 387         return CmdT();
0459   F8B7 CA 67 FA    	jp z, cmdt
0460   F8BA             ; 388     if (a == 'M')
0461   F8BA FE 4D       	cp 77
0462   F8BC             ; 389         return CmdM();
0463   F8BC CA 70 FA    	jp z, cmdm
0464   F8BF             ; 390     if (a == 'G')
0465   F8BF FE 47       	cp 71
0466   F8C1             ; 391         return CmdG();
0467   F8C1 CA 89 FA    	jp z, cmdg
0468   F8C4             ; 392     if (a == 'I')
0469   F8C4 FE 49       	cp 73
0470   F8C6             ; 393         return CmdI();
0471   F8C6 CA 4B FB    	jp z, cmdi
0472   F8C9             ; 394     if (a == 'O')
0473   F8C9 FE 4F       	cp 79
0474   F8CB             ; 395         return CmdO();
0475   F8CB CA C9 FB    	jp z, cmdo
0476   F8CE             ; 396     if (a == 'W')
0477   F8CE FE 57       	cp 87
0478   F8D0             ; 397         return CmdW();
0479   F8D0 CA 55 FA    	jp z, cmdw
0480   F8D3             ; 398 #ifdef CMD_A_ENABLED
0481   F8D3             ; 399     if (a == 'A')
0482   F8D3             ; 400         return CmdA();
0483   F8D3             ; 401 #endif
0484   F8D3             ; 402     if (a == 'H')
0485   F8D3 FE 48       	cp 72
0486   F8D5             ; 403         return CmdH();
0487   F8D5 CA 26 FB    	jp z, cmdh
0488   F8D8             ; 404 #ifdef CMD_R_ENABLED
0489   F8D8             ; 405     if (a == 'R')
0490   F8D8             ; 406         return CmdR();
0491   F8D8             ; 407 #endif
0492   F8D8             ; 408     MonitorError();
0493   F8D8 C3 73 FB    	jp monitorerror
0494   F8DB             ; 409 }
0495   F8DB             ; 410 
0496   F8DB             ; 411 void ReadString() {
0497   F8DB             readstring: 
0498   F8DB             ; 412     de = inputBuffer;
0499   F8DB 11 83 F7    	ld de, 0FFFFh & (inputbuffer)
0500   F8DE             ; 413     h = d;
0501   F8DE 62          	ld h, d
0502   F8DF             ; 414     l = e;
0503   F8DF 6B          	ld l, e
0504   F8E0             ; 415     for (;;) {
0505   F8E0             l_1: 
0506   F8E0             ; 416         ReadKey();
0507   F8E0 CD D5 FE    	call readkey
0508   F8E3             ; 417         if (a == KEY_BACKSPACE) {
0509   F8E3 FE 7F       	cp 127
0510   F8E5 C2 F9 F8    	jp nz, l_3
0511   F8E8             ; 418             if ((a = e) == l)
0512   F8E8 7B          	ld a, e
0513   F8E9 BD          	cp l
0514   F8EA             ; 419                 continue;
0515   F8EA CA E0 F8    	jp z, l_1
0516   F8ED             ; 420             hl--;
0517   F8ED 2B          	dec hl
0518   F8EE             ; 421             push_pop(hl) {
0519   F8EE E5          	push hl
0520   F8EF             ; 422                 PrintString(hl = aBackspace);
0521   F8EF 21 BB FF    	ld hl, 0FFFFh & (abackspace)
0522   F8F2 CD 1F F9    	call printstring
0523   F8F5 E1          	pop hl
0524   F8F6             ; 423             }
0525   F8F6             ; 424             continue;
0526   F8F6 C3 E0 F8    	jp l_1
0527   F8F9             l_3: 
0528   F8F9             ; 425         }
0529   F8F9             ; 426         *hl = a;
0530   F8F9 77          	ld (hl), a
0531   F8FA             ; 427         if (a == 13) {
0532   F8FA FE 0D       	cp 13
0533   F8FC C2 06 F9    	jp nz, l_5
0534   F8FF             ; 428             if ((a = e) != l)
0535   F8FF 7B          	ld a, e
0536   F900 BD          	cp l
0537   F901             ; 429                 set_flag_c();
0538   F901 CA 05 F9    	jp z, l_7
0539   F904 37          	scf
0540   F905             l_7: 
0541   F905             ; 430             return;
0542   F905 C9          	ret
0543   F906             l_5: 
0544   F906             ; 431         }
0545   F906             ; 432         if (a == '.')
0546   F906 FE 2E       	cp 46
0547   F908             ; 433             return Monitor2();
0548   F908 CA 75 F8    	jp z, monitor2
0549   F90B             ; 434         if (a < 32)
0550   F90B FE 20       	cp 32
0551   F90D             ; 435             a = '.';
0552   F90D D2 12 F9    	jp nc, l_9
0553   F910 3E 2E       	ld a, 46
0554   F912             l_9: 
0555   F912             ; 436         PrintCharA(a);
0556   F912 CD E2 FC    	call printchara
0557   F915             ; 437         if ((a = inputBuffer + sizeof(inputBuffer) - 1) == l)
0558   F915 3E A2       	ld a, 0FFh & (((inputbuffer) + (32)) - (1))
0559   F917 BD          	cp l
0560   F918             ; 438             return MonitorError();
0561   F918 CA 73 FB    	jp z, monitorerror
0562   F91B             ; 439         hl++;
0563   F91B 23          	inc hl
0564   F91C C3 E0 F8    	jp l_1
0565   F91F             ; 440     }
0566   F91F             ; 441 }
0567   F91F             ; 442 
0568   F91F             ; 443 // Функция для пользовательской программы.
0569   F91F             ; 444 // Вывод строки на экран.
0570   F91F             ; 445 // Параметры: hl - адрес стороки. Результат: hl - следующий адрес за терминатором строки. Сохраняются: b, de.
0571   F91F             ; 446 
0572   F91F             ; 447 void PrintString(...) {
0573   F91F             printstring: 
0574   F91F             ; 448     for (;;) {
0575   F91F             l_12: 
0576   F91F             ; 449         a = *hl;
0577   F91F 7E          	ld a, (hl)
0578   F920             ; 450         if (a == 0)
0579   F920 B7          	or a
0580   F921             ; 451             return;
0581   F921 C8          	ret z
0582   F922             ; 452         PrintCharA(a);
0583   F922 CD E2 FC    	call printchara
0584   F925             ; 453         hl++;
0585   F925 23          	inc hl
0586   F926 C3 1F F9    	jp l_12
0587   F929             ; 454     }
0588   F929             ; 455 }
0589   F929             ; 456 
0590   F929             ; 457 void ParseParams(...) {
0591   F929             parseparams: 
0592   F929             ; 458     hl = &param1;
0593   F929 21 75 F7    	ld hl, 0FFFFh & (param1)
0594   F92C             ; 459     de = &param2Exists;
0595   F92C 11 7B F7    	ld de, 0FFFFh & (param2exists)
0596   F92F             ; 460     c = 0;
0597   F92F 0E 00       	ld c, 0
0598   F931             ; 461     CmdF();
0599   F931 CD 43 FA    	call cmdf
0600   F934             ; 462 
0601   F934             ; 463     de = inputBuffer + 1;
0602   F934 11 84 F7    	ld de, 0FFFFh & ((inputbuffer) + (1))
0603   F937             ; 464 
0604   F937             ; 465     ParseWord();
0605   F937 CD 56 F9    	call parseword
0606   F93A             ; 466     param1 = hl;
0607   F93A 22 75 F7    	ld (param1), hl
0608   F93D             ; 467     param2 = hl;
0609   F93D 22 77 F7    	ld (param2), hl
0610   F940             ; 468     if (flag_c)
0611   F940             ; 469         return;
0612   F940 D8          	ret c
0613   F941             ; 470 
0614   F941             ; 471     param2Exists = a = d; /* Not 0 */
0615   F941 7A          	ld a, d
0616   F942 32 7B F7    	ld (param2exists), a
0617   F945             ; 472     ParseWord();
0618   F945 CD 56 F9    	call parseword
0619   F948             ; 473     param2 = hl;
0620   F948 22 77 F7    	ld (param2), hl
0621   F94B             ; 474     if (flag_c)
0622   F94B             ; 475         return;
0623   F94B D8          	ret c
0624   F94C             ; 476 
0625   F94C             ; 477     ParseWord();
0626   F94C CD 56 F9    	call parseword
0627   F94F             ; 478     param3 = hl;
0628   F94F 22 79 F7    	ld (param3), hl
0629   F952             ; 479     if (flag_c)
0630   F952             ; 480         return;
0631   F952 D8          	ret c
0632   F953             ; 481 
0633   F953             ; 482     MonitorError();
0634   F953 C3 73 FB    	jp monitorerror
0635   F956             ; 483 }
0636   F956             ; 484 
0637   F956             ; 485 void ParseWord(...) {
0638   F956             parseword: 
0639   F956             ; 486     hl = 0;
0640   F956 21 00 00    	ld hl, 0
0641   F959             ; 487     for (;;) {
0642   F959             l_15: 
0643   F959             ; 488         a = *de;
0644   F959 1A          	ld a, (de)
0645   F95A             ; 489         compare(a, 13);
0646   F95A FE 0D       	cp 13
0647   F95C             ; 490         set_flag_c();
0648   F95C 37          	scf
0649   F95D             ; 491         if (flag_z)
0650   F95D             ; 492             return;
0651   F95D C8          	ret z
0652   F95E             ; 493         de++;
0653   F95E 13          	inc de
0654   F95F             ; 494         if (a == ',')
0655   F95F FE 2C       	cp 44
0656   F961             ; 495             return;
0657   F961 C8          	ret z
0658   F962             ; 496         if (a == ' ')
0659   F962 FE 20       	cp 32
0660   F964             ; 497             continue;
0661   F964 CA 59 F9    	jp z, l_15
0662   F967             ; 498         push(bc = &MonitorError);
0663   F967 01 73 FB    	ld bc, 0FFFFh & (monitorerror)
0664   F96A C5          	push bc
0665   F96B             ; 499         a &= 0x7F;
0666   F96B E6 7F       	and 127
0667   F96D             ; 500         a -= '0';
0668   F96D D6 30       	sub 48
0669   F96F             ; 501         if (flag_c)
0670   F96F             ; 502             return;
0671   F96F D8          	ret c
0672   F970             ; 503         if (a >= 10) {
0673   F970 FE 0A       	cp 10
0674   F972 DA 7D F9    	jp c, l_17
0675   F975             ; 504             if (a < 17)
0676   F975 FE 11       	cp 17
0677   F977             ; 505                 return;
0678   F977 D8          	ret c
0679   F978             ; 506             if (a >= 23)
0680   F978 FE 17       	cp 23
0681   F97A             ; 507                 return;
0682   F97A D0          	ret nc
0683   F97B             ; 508             a -= 7;
0684   F97B D6 07       	sub 7
0685   F97D             l_17: 
0686   F97D             ; 509         }
0687   F97D             ; 510         hl += hl;
0688   F97D 29          	add hl, hl
0689   F97E             ; 511         if (flag_c)
0690   F97E             ; 512             return;
0691   F97E D8          	ret c
0692   F97F             ; 513         hl += hl;
0693   F97F 29          	add hl, hl
0694   F980             ; 514         if (flag_c)
0695   F980             ; 515             return;
0696   F980 D8          	ret c
0697   F981             ; 516         hl += hl;
0698   F981 29          	add hl, hl
0699   F982             ; 517         if (flag_c)
0700   F982             ; 518             return;
0701   F982 D8          	ret c
0702   F983             ; 519         hl += hl;
0703   F983 29          	add hl, hl
0704   F984             ; 520         if (flag_c)
0705   F984             ; 521             return;
0706   F984 D8          	ret c
0707   F985             ; 522         b = 0;
0708   F985 06 00       	ld b, 0
0709   F987             ; 523         c = a;
0710   F987 4F          	ld c, a
0711   F988             ; 524         hl += bc;
0712   F988 09          	add hl, bc
0713   F989             ; 525         pop(bc);
0714   F989 C1          	pop bc
0715   F98A C3 59 F9    	jp l_15
0716   F98D             ; 526     }
0717   F98D             ; 527 }
0718   F98D             ; 528 
0719   F98D             ; 529 void CompareHlDe(...) {
0720   F98D             comparehlde: 
0721   F98D             ; 530     if ((a = h) != d)
0722   F98D 7C          	ld a, h
0723   F98E BA          	cp d
0724   F98F             ; 531         return;
0725   F98F C0          	ret nz
0726   F990             ; 532     compare(a = l, e);
0727   F990 7D          	ld a, l
0728   F991 BB          	cp e
0729   F992 C9          	ret
0730   F993             ; 533 }
0731   F993             ; 534 
0732   F993             ; 535 void LoopWithBreak(...) {
0733   F993             loopwithbreak: 
0734   F993             ; 536     CtrlC();
0735   F993 CD A1 F9    	call ctrlc
0736   F996             ; 537     Loop(hl, de);
0737   F996             ; 538 }
0738   F996             ; 539 
0739   F996             ; 540 void Loop(...) {
0740   F996             loop: 
0741   F996             ; 541     CompareHlDe(hl, de);
0742   F996 CD 8D F9    	call comparehlde
0743   F999             ; 542     if (flag_nz)
0744   F999             ; 543         return IncHl(hl);
0745   F999 C2 9F F9    	jp nz, inchl
0746   F99C             ; 544     PopRet();
0747   F99C             ; 545 }
0748   F99C             ; 546 
0749   F99C             ; 547 void PopRet() {
0750   F99C             popret: 
0751   F99C             ; 548     sp++;
0752   F99C 33          	inc sp
0753   F99D             ; 549     sp++;
0754   F99D 33          	inc sp
0755   F99E C9          	ret
0756   F99F             ; 550 }
0757   F99F             ; 551 
0758   F99F             ; 552 void IncHl(...) {
0759   F99F             inchl: 
0760   F99F             ; 553     hl++;
0761   F99F 23          	inc hl
0762   F9A0 C9          	ret
0763   F9A1             ; 554 }
0764   F9A1             ; 555 
0765   F9A1             ; 556 void CtrlC() {
0766   F9A1             ctrlc: 
0767   F9A1             ; 557     ScanKey();
0768   F9A1 CD E9 FE    	call scankey
0769   F9A4             ; 558     if (a != 3)  // УПР + C
0770   F9A4 FE 03       	cp 3
0771   F9A6             ; 559         return;
0772   F9A6 C0          	ret nz
0773   F9A7             ; 560     MonitorError();
0774   F9A7 C3 73 FB    	jp monitorerror
0775   F9AA             ; 561 }
0776   F9AA             ; 562 
0777   F9AA             ; 563 void PrintCrLfTab() {
0778   F9AA             printcrlftab: 
0779   F9AA             ; 564     push_pop(hl) {
0780   F9AA E5          	push hl
0781   F9AB             ; 565         PrintString(hl = aCrLfTab);
0782   F9AB 21 90 FF    	ld hl, 0FFFFh & (acrlftab)
0783   F9AE CD 1F F9    	call printstring
0784   F9B1 E1          	pop hl
0785   F9B2 C9          	ret
0786   F9B3             ; 566     }
0787   F9B3             ; 567 }
0788   F9B3             ; 568 
0789   F9B3             ; 569 void PrintHexByteFromHlSpace(...) {
0790   F9B3             printhexbytefromhlspace: 
0791   F9B3             ; 570     PrintHexByteSpace(a = *hl);
0792   F9B3 7E          	ld a, (hl)
0793   F9B4             ; 571 }
0794   F9B4             ; 572 
0795   F9B4             ; 573 void PrintHexByteSpace(...) {
0796   F9B4             printhexbytespace: 
0797   F9B4             ; 574     push_pop(bc) {
0798   F9B4 C5          	push bc
0799   F9B5             ; 575         PrintHexByte(a);
0800   F9B5 CD CE FC    	call printhexbyte
0801   F9B8             ; 576         PrintSpace();
0802   F9B8 CD 28 FA    	call printspace
0803   F9BB C1          	pop bc
0804   F9BC C9          	ret
0805   F9BD             ; 577     }
0806   F9BD             ; 578 }
0807   F9BD             ; 579 
0808   F9BD             ; 580 #ifdef CMD_R_ENABLED
0809   F9BD             ; 581 // Команда R <начальный адрес ПЗУ> <конечный адрес ПЗУ> <начальный адрес назаначения>
0810   F9BD             ; 582 // Скопировать блок из внешнего ПЗУ в адресное пространство процессора
0811   F9BD             ; 583 
0812   F9BD             ; 584 void CmdR(...) {
0813   F9BD             ; 585     out(PORT_EXT_MODE, a = 0x90);
0814   F9BD             ; 586     for (;;) {
0815   F9BD             ; 587         out(PORT_EXT_ADDR_LOW, a = l);
0816   F9BD             ; 588         out(PORT_EXT_ADDR_HIGH, a = h);
0817   F9BD             ; 589         *bc = a = in(PORT_EXT_DATA);
0818   F9BD             ; 590         bc++;
0819   F9BD             ; 591         Loop();
0820   F9BD             ; 592     }
0821   F9BD             ; 593 }
0822   F9BD             ; 594 #endif
0823   F9BD             ; 595 
0824   F9BD             ; 596 // Функция для пользовательской программы.
0825   F9BD             ; 597 // Получить адрес последнего доступного байта оперативной памяти.
0826   F9BD             ; 598 // Параметры: нет. Результат: hl - адрес. Сохраняет: a, bc, de.
0827   F9BD             ; 599 
0828   F9BD             ; 600 void GetRamTop(...) {
0829   F9BD             getramtop: 
0830   F9BD             ; 601     hl = ramTop;
0831   F9BD 2A 81 F7    	ld hl, (ramtop)
0832   F9C0 C9          	ret
0833   F9C1             ; 602 }
0834   F9C1             ; 603 
0835   F9C1             ; 604 // Функция для пользовательской программы.
0836   F9C1             ; 605 // Установить адрес последнего доступного байта оперативной памяти.
0837   F9C1             ; 606 // Параметры: hl - адрес. Результат: нет. Сохраняет: a, bc, de, hl.
0838   F9C1             ; 607 
0839   F9C1             ; 608 void SetRamTop(...) {
0840   F9C1             setramtop: 
0841   F9C1             ; 609     ramTop = hl;
0842   F9C1 22 81 F7    	ld (ramtop), hl
0843   F9C4 C9          	ret
0844   F9C5             ; 610 }
0845   F9C5             ; 611 
0846   F9C5             ; 612 #ifdef CMD_A_ENABLED
0847   F9C5             ; 613 // Команда A <адрес>
0848   F9C5             ; 614 // Установить программу преобразования кодировки символов выводимых на экран
0849   F9C5             ; 615 
0850   F9C5             ; 616 void CmdA(...) {
0851   F9C5             ; 617     translateCodePageAddress = hl;
0852   F9C5             ; 618 }
0853   F9C5             ; 619 #endif
0854   F9C5             ; 620 
0855   F9C5             ; 621 // Команда D <начальный адрес> <конечный адрес>
0856   F9C5             ; 622 // Вывод блока данных из адресного пространства на экран в 16-ричном виде
0857   F9C5             ; 623 
0858   F9C5             ; 624 void CmdD(...) {
0859   F9C5             cmdd: 
0860   F9C5             ; 625     for (;;) {
0861   F9C5             l_20: 
0862   F9C5             ; 626         PrintChar(c = 13);
0863   F9C5 0E 0D       	ld c, 13
0864   F9C7 CD E3 FC    	call printchar
0865   F9CA             ; 627         PrintChar(c = 10);
0866   F9CA 0E 0A       	ld c, 10
0867   F9CC CD E3 FC    	call printchar
0868   F9CF             ; 628         PrintHexWordSpace(hl);
0869   F9CF CD F1 FB    	call printhexwordspace
0870   F9D2             ; 629         push_pop(hl) {
0871   F9D2 E5          	push hl
0872   F9D3             ; 630             c = ((a = l) &= 0x0F);
0873   F9D3 7D          	ld a, l
0874   F9D4 E6 0F       	and 15
0875   F9D6 4F          	ld c, a
0876   F9D7             ; 631             carry_rotate_right(a, 1);
0877   F9D7 1F          	rra
0878   F9D8             ; 632             b = (((a += c) += c) += 5);
0879   F9D8 81          	add c
0880   F9D9 81          	add c
0881   F9DA C6 05       	add 5
0882   F9DC 47          	ld b, a
0883   F9DD             ; 633             PrintSpacesTo();
0884   F9DD CD 1B FA    	call printspacesto
0885   F9E0             ; 634             do {
0886   F9E0             l_22: 
0887   F9E0             ; 635                 PrintHexByte(a = *hl);
0888   F9E0 7E          	ld a, (hl)
0889   F9E1 CD CE FC    	call printhexbyte
0890   F9E4             ; 636                 CompareHlDe(hl, de);
0891   F9E4 CD 8D F9    	call comparehlde
0892   F9E7             ; 637                 hl++;
0893   F9E7 23          	inc hl
0894   F9E8             ; 638                 if (flag_z)
0895   F9E8             ; 639                     break;
0896   F9E8 CA F8 F9    	jp z, l_24
0897   F9EB             ; 640                 (a = l) &= 0x0F;
0898   F9EB 7D          	ld a, l
0899   F9EC E6 0F       	and 15
0900   F9EE             ; 641                 push_pop(a) {
0901   F9EE F5          	push af
0902   F9EF             ; 642                     a &= 1;
0903   F9EF E6 01       	and 1
0904   F9F1             ; 643                     if (flag_z)
0905   F9F1             ; 644                         PrintSpace();
0906   F9F1 CC 28 FA    	call z, printspace
0907   F9F4 F1          	pop af
0908   F9F5             l_23: 
0909   F9F5 C2 E0 F9    	jp nz, l_22
0910   F9F8             l_24: 
0911   F9F8 E1          	pop hl
0912   F9F9             ; 645                 }
0913   F9F9             ; 646             } while (flag_nz);
0914   F9F9             ; 647         }
0915   F9F9             ; 648 
0916   F9F9             ; 649         b = (((a = l) &= 0x0F) += 46);
0917   F9F9 7D          	ld a, l
0918   F9FA E6 0F       	and 15
0919   F9FC C6 2E       	add 46
0920   F9FE 47          	ld b, a
0921   F9FF             ; 650         PrintSpacesTo(b);
0922   F9FF CD 1B FA    	call printspacesto
0923   FA02             ; 651 
0924   FA02             ; 652         do {
0925   FA02             l_25: 
0926   FA02             ; 653             a = *hl;
0927   FA02 7E          	ld a, (hl)
0928   FA03             ; 654             if (a < 32)
0929   FA03 FE 20       	cp 32
0930   FA05             ; 655                 a = '.';
0931   FA05 D2 0A FA    	jp nc, l_28
0932   FA08 3E 2E       	ld a, 46
0933   FA0A             l_28: 
0934   FA0A             ; 656             PrintCharA(a);
0935   FA0A CD E2 FC    	call printchara
0936   FA0D             ; 657             CompareHlDe(hl, de);
0937   FA0D CD 8D F9    	call comparehlde
0938   FA10             ; 658             if (flag_z)
0939   FA10             ; 659                 return;
0940   FA10 C8          	ret z
0941   FA11             ; 660             hl++;
0942   FA11 23          	inc hl
0943   FA12             ; 661             (a = l) &= 0x0F;
0944   FA12 7D          	ld a, l
0945   FA13 E6 0F       	and 15
0946   FA15             l_26: 
0947   FA15 C2 02 FA    	jp nz, l_25
0948   FA18 C3 C5 F9    	jp l_20
0949   FA1B             ; 662         } while (flag_nz);
0950   FA1B             ; 663     }
0951   FA1B             ; 664 }
0952   FA1B             ; 665 
0953   FA1B             ; 666 void PrintSpacesTo(...) {
0954   FA1B             printspacesto: 
0955   FA1B             ; 667     for (;;) {
0956   FA1B             l_31: 
0957   FA1B             ; 668         if (((a = cursor) &= (SCREEN_WIDTH - 1)) >= b)
0958   FA1B 3A 5A F7    	ld a, (cursor)
0959   FA1E E6 3F       	and 63
0960   FA20 B8          	cp b
0961   FA21             ; 669             return;
0962   FA21 D0          	ret nc
0963   FA22             ; 670         PrintSpace();
0964   FA22 CD 28 FA    	call printspace
0965   FA25 C3 1B FA    	jp l_31
0966   FA28             ; 671     }
0967   FA28             ; 672 }
0968   FA28             ; 673 
0969   FA28             ; 674 void PrintSpace() {
0970   FA28             printspace: 
0971   FA28             ; 675     PrintCharA(a = ' ');
0972   FA28 3E 20       	ld a, 32
0973   FA2A C3 E2 FC    	jp printchara
0974   FA2D             ; 676 }
0975   FA2D             ; 677 
0976   FA2D             ; 678 // Команда С <начальный адрес 1> <конечный адрес 1> <начальный адрес 2>
0977   FA2D             ; 679 // Сравнить два блока адресного пространство
0978   FA2D             ; 680 
0979   FA2D             ; 681 void CmdC(...) {
0980   FA2D             cmdc: 
0981   FA2D             ; 682     for (;;) {
0982   FA2D             l_34: 
0983   FA2D             ; 683         if ((a = *bc) != *hl) {
0984   FA2D 0A          	ld a, (bc)
0985   FA2E BE          	cp (hl)
0986   FA2F CA 3C FA    	jp z, l_36
0987   FA32             ; 684             PrintCrLfTabHexWordSpace(hl);
0988   FA32 CD E8 FB    	call printcrlftabhexwordspace
0989   FA35             ; 685             PrintHexByteFromHlSpace(hl);
0990   FA35 CD B3 F9    	call printhexbytefromhlspace
0991   FA38             ; 686             PrintHexByteSpace(a = *bc);
0992   FA38 0A          	ld a, (bc)
0993   FA39 CD B4 F9    	call printhexbytespace
0994   FA3C             l_36: 
0995   FA3C             ; 687         }
0996   FA3C             ; 688         bc++;
0997   FA3C 03          	inc bc
0998   FA3D             ; 689         LoopWithBreak();
0999   FA3D CD 93 F9    	call loopwithbreak
1000   FA40 C3 2D FA    	jp l_34
1001   FA43             ; 690     }
1002   FA43             ; 691 }
1003   FA43             ; 692 
1004   FA43             ; 693 // Команда F <начальный адрес> <конечный адрес> <байт>
1005   FA43             ; 694 // Заполнить блок в адресном пространстве одним байтом
1006   FA43             ; 695 
1007   FA43             ; 696 void CmdF(...) {
1008   FA43             cmdf: 
1009   FA43             ; 697     for (;;) {
1010   FA43             l_39: 
1011   FA43             ; 698         *hl = c;
1012   FA43 71          	ld (hl), c
1013   FA44             ; 699         Loop();
1014   FA44 CD 96 F9    	call loop
1015   FA47 C3 43 FA    	jp l_39
1016   FA4A             ; 700     }
1017   FA4A             ; 701 }
1018   FA4A             ; 702 
1019   FA4A             ; 703 // Команда S <начальный адрес> <конечный адрес> <байт>
1020   FA4A             ; 704 // Найти байт (8 битное значение) в адресном пространстве
1021   FA4A             ; 705 
1022   FA4A             ; 706 void CmdS(...) {
1023   FA4A             cmds: 
1024   FA4A             ; 707     for (;;) {
1025   FA4A             l_42: 
1026   FA4A             ; 708         if ((a = c) == *hl)
1027   FA4A 79          	ld a, c
1028   FA4B BE          	cp (hl)
1029   FA4C             ; 709             PrintCrLfTabHexWordSpace(hl);
1030   FA4C CC E8 FB    	call z, printcrlftabhexwordspace
1031   FA4F             ; 710         LoopWithBreak();
1032   FA4F CD 93 F9    	call loopwithbreak
1033   FA52 C3 4A FA    	jp l_42
1034   FA55             ; 711     }
1035   FA55             ; 712 }
1036   FA55             ; 713 
1037   FA55             ; 714 // Команда W <начальный адрес> <конечный адрес> <слово>
1038   FA55             ; 715 // Найти слово (16 битное значение) в адресном пространстве
1039   FA55             ; 716 
1040   FA55             ; 717 void CmdW(...) {
1041   FA55             cmdw: 
1042   FA55             ; 718     for (;;) {
1043   FA55             l_45: 
1044   FA55             ; 719         if ((a = *hl) == c) {
1045   FA55 7E          	ld a, (hl)
1046   FA56 B9          	cp c
1047   FA57 C2 61 FA    	jp nz, l_47
1048   FA5A             ; 720             hl++;
1049   FA5A 23          	inc hl
1050   FA5B             ; 721             compare((a = *hl), b);
1051   FA5B 7E          	ld a, (hl)
1052   FA5C B8          	cp b
1053   FA5D             ; 722             hl--;
1054   FA5D 2B          	dec hl
1055   FA5E             ; 723             if (flag_z)
1056   FA5E             ; 724                 PrintCrLfTabHexWordSpace(hl);
1057   FA5E CC E8 FB    	call z, printcrlftabhexwordspace
1058   FA61             l_47: 
1059   FA61             ; 725         }
1060   FA61             ; 726         LoopWithBreak();
1061   FA61 CD 93 F9    	call loopwithbreak
1062   FA64 C3 55 FA    	jp l_45
1063   FA67             ; 727     }
1064   FA67             ; 728 }
1065   FA67             ; 729 
1066   FA67             ; 730 // Команда T <начальный адрес источника> <конечный адрес источника> <начальный адрес назначения>
1067   FA67             ; 731 // Копировать блок в адресном пространстве
1068   FA67             ; 732 
1069   FA67             ; 733 void CmdT(...) {
1070   FA67             cmdt: 
1071   FA67             ; 734     for (;;) {
1072   FA67             l_50: 
1073   FA67             ; 735         *bc = a = *hl;
1074   FA67 7E          	ld a, (hl)
1075   FA68 02          	ld (bc), a
1076   FA69             ; 736         bc++;
1077   FA69 03          	inc bc
1078   FA6A             ; 737         Loop();
1079   FA6A CD 96 F9    	call loop
1080   FA6D C3 67 FA    	jp l_50
1081   FA70             ; 738     }
1082   FA70             ; 739 }
1083   FA70             ; 740 
1084   FA70             ; 741 // Команда M <начальный адрес>
1085   FA70             ; 742 // Вывести на экран адресное пространство побайтно с возможностью изменения
1086   FA70             ; 743 
1087   FA70             ; 744 void CmdM(...) {
1088   FA70             cmdm: 
1089   FA70             ; 745     for (;;) {
1090   FA70             l_53: 
1091   FA70             ; 746         PrintCrLfTabHexWordSpace(hl);
1092   FA70 CD E8 FB    	call printcrlftabhexwordspace
1093   FA73             ; 747         PrintHexByteFromHlSpace();
1094   FA73 CD B3 F9    	call printhexbytefromhlspace
1095   FA76             ; 748         push_pop(hl) {
1096   FA76 E5          	push hl
1097   FA77             ; 749             ReadString();
1098   FA77 CD DB F8    	call readstring
1099   FA7A E1          	pop hl
1100   FA7B             ; 750         }
1101   FA7B             ; 751         if (flag_c) {
1102   FA7B D2 85 FA    	jp nc, l_55
1103   FA7E             ; 752             push_pop(hl) {
1104   FA7E E5          	push hl
1105   FA7F             ; 753                 ParseWord();
1106   FA7F CD 56 F9    	call parseword
1107   FA82             ; 754                 a = l;
1108   FA82 7D          	ld a, l
1109   FA83 E1          	pop hl
1110   FA84             ; 755             }
1111   FA84             ; 756             *hl = a;
1112   FA84 77          	ld (hl), a
1113   FA85             l_55: 
1114   FA85             ; 757         }
1115   FA85             ; 758         hl++;
1116   FA85 23          	inc hl
1117   FA86 C3 70 FA    	jp l_53
1118   FA89             ; 759     }
1119   FA89             ; 760 }
1120   FA89             ; 761 
1121   FA89             ; 762 // Команда G <начальный адрес> <конечный адрес>
1122   FA89             ; 763 // Запуск программы и возможным указанием точки останова.
1123   FA89             ; 764 
1124   FA89             ; 765 void CmdG(...) {
1125   FA89             cmdg: 
1126   FA89             ; 766     CompareHlDe(hl, de);
1127   FA89 CD 8D F9    	call comparehlde
1128   FA8C             ; 767     if (flag_nz) {
1129   FA8C CA A4 FA    	jp z, l_57
1130   FA8F             ; 768         swap(hl, de);
1131   FA8F EB          	ex hl, de
1132   FA90             ; 769         breakPointAddress = hl;
1133   FA90 22 71 F7    	ld (breakpointaddress), hl
1134   FA93             ; 770         breakPointValue = a = *hl;
1135   FA93 7E          	ld a, (hl)
1136   FA94 32 73 F7    	ld (breakpointvalue), a
1137   FA97             ; 771         *hl = OPCODE_RST_30;
1138   FA97 36 F7       	ld (hl), 247
1139   FA99             ; 772         rst30Opcode = a = OPCODE_JMP;
1140   FA99 3E C3       	ld a, 195
1141   FA9B 32 30 00    	ld (rst30opcode), a
1142   FA9E             ; 773         rst30Address = hl = &BreakPointHandler;
1143   FA9E 21 B2 FA    	ld hl, 0FFFFh & (breakpointhandler)
1144   FAA1 22 31 00    	ld (rst30address), hl
1145   FAA4             l_57: 
1146   FAA4             ; 774     }
1147   FAA4             ; 775     sp = &regBC;
1148   FAA4 31 66 F7    	ld sp, 0FFFFh & (regbc)
1149   FAA7             ; 776     pop(bc);
1150   FAA7 C1          	pop bc
1151   FAA8             ; 777     pop(de);
1152   FAA8 D1          	pop de
1153   FAA9             ; 778     pop(hl);
1154   FAA9 E1          	pop hl
1155   FAAA             ; 779     pop(a);
1156   FAAA F1          	pop af
1157   FAAB             ; 780     sp = hl;
1158   FAAB F9          	ld sp, hl
1159   FAAC             ; 781     hl = regHL;
1160   FAAC 2A 64 F7    	ld hl, (reghl)
1161   FAAF             ; 782     JmpParam1();
1162   FAAF C3 74 F7    	jp jmpparam1
1163   FAB2             ; 783 }
1164   FAB2             ; 784 
1165   FAB2             ; 785 void BreakPointHandler(...) {
1166   FAB2             breakpointhandler: 
1167   FAB2             ; 786     regHL = hl;
1168   FAB2 22 64 F7    	ld (reghl), hl
1169   FAB5             ; 787     push(a);
1170   FAB5 F5          	push af
1171   FAB6             ; 788     pop(hl);
1172   FAB6 E1          	pop hl
1173   FAB7             ; 789     regAF = hl;
1174   FAB7 22 6C F7    	ld (regaf), hl
1175   FABA             ; 790     pop(hl);
1176   FABA E1          	pop hl
1177   FABB             ; 791     hl--;
1178   FABB 2B          	dec hl
1179   FABC             ; 792     regPC = hl;
1180   FABC 22 62 F7    	ld (regpc), hl
1181   FABF             ; 793     (hl = 0) += sp;
1182   FABF 21 00 00    	ld hl, 0
1183   FAC2 39          	add hl, sp
1184   FAC3             ; 794     sp = &regAF;
1185   FAC3 31 6C F7    	ld sp, 0FFFFh & (regaf)
1186   FAC6             ; 795     push(hl);
1187   FAC6 E5          	push hl
1188   FAC7             ; 796     push(de);
1189   FAC7 D5          	push de
1190   FAC8             ; 797     push(bc);
1191   FAC8 C5          	push bc
1192   FAC9             ; 798     sp = STACK_TOP;
1193   FAC9 31 00 F8    	ld sp, 63488
1194   FACC             ; 799     hl = regPC;
1195   FACC 2A 62 F7    	ld hl, (regpc)
1196   FACF             ; 800     swap(hl, de);
1197   FACF EB          	ex hl, de
1198   FAD0             ; 801     hl = breakPointAddress;
1199   FAD0 2A 71 F7    	ld hl, (breakpointaddress)
1200   FAD3             ; 802     CompareHlDe(hl, de);
1201   FAD3 CD 8D F9    	call comparehlde
1202   FAD6             ; 803     if (flag_nz)
1203   FAD6             ; 804         return CmdX();
1204   FAD6 C2 DD FA    	jp nz, cmdx
1205   FAD9             ; 805     *hl = a = breakPointValue;
1206   FAD9 3A 73 F7    	ld a, (breakpointvalue)
1207   FADC 77          	ld (hl), a
1208   FADD             ; 806     CmdX();
1209   FADD             ; 807 }
1210   FADD             ; 808 
1211   FADD             ; 809 // Команда X
1212   FADD             ; 810 // Вывод на экран содержимого регистров микропроцессора с возможностью их изменения.
1213   FADD             ; 811 
1214   FADD             ; 812 void CmdX(...) {
1215   FADD             cmdx: 
1216   FADD             ; 813     PrintString(hl = aRegisters);
1217   FADD 21 96 FF    	ld hl, 0FFFFh & (aregisters)
1218   FAE0 CD 1F F9    	call printstring
1219   FAE3             ; 814     hl = &regPC;
1220   FAE3 21 62 F7    	ld hl, 0FFFFh & (regpc)
1221   FAE6             ; 815     b = 6;
1222   FAE6 06 06       	ld b, 6
1223   FAE8             ; 816     do {
1224   FAE8             l_59: 
1225   FAE8             ; 817         e = *hl;
1226   FAE8 5E          	ld e, (hl)
1227   FAE9             ; 818         hl++;
1228   FAE9 23          	inc hl
1229   FAEA             ; 819         d = *hl;
1230   FAEA 56          	ld d, (hl)
1231   FAEB             ; 820         push(bc);
1232   FAEB C5          	push bc
1233   FAEC             ; 821         push(hl);
1234   FAEC E5          	push hl
1235   FAED             ; 822         swap(hl, de);
1236   FAED EB          	ex hl, de
1237   FAEE             ; 823         PrintCrLfTabHexWordSpace(hl);
1238   FAEE CD E8 FB    	call printcrlftabhexwordspace
1239   FAF1             ; 824         ReadString();
1240   FAF1 CD DB F8    	call readstring
1241   FAF4             ; 825         if (flag_c) {
1242   FAF4 D2 00 FB    	jp nc, l_62
1243   FAF7             ; 826             ParseWord();
1244   FAF7 CD 56 F9    	call parseword
1245   FAFA             ; 827             pop(de);
1246   FAFA D1          	pop de
1247   FAFB             ; 828             push(de);
1248   FAFB D5          	push de
1249   FAFC             ; 829             swap(hl, de);
1250   FAFC EB          	ex hl, de
1251   FAFD             ; 830             *hl = d;
1252   FAFD 72          	ld (hl), d
1253   FAFE             ; 831             hl--;
1254   FAFE 2B          	dec hl
1255   FAFF             ; 832             *hl = e;
1256   FAFF 73          	ld (hl), e
1257   FB00             l_62: 
1258   FB00             ; 833         }
1259   FB00             ; 834         pop(hl);
1260   FB00 E1          	pop hl
1261   FB01             ; 835         pop(bc);
1262   FB01 C1          	pop bc
1263   FB02             ; 836         b--;
1264   FB02 05          	dec b
1265   FB03             ; 837         hl++;
1266   FB03 23          	inc hl
1267   FB04             l_60: 
1268   FB04 C2 E8 FA    	jp nz, l_59
1269   FB07             ; 838     } while (flag_nz);
1270   FB07             ; 839     EntryF86C_Monitor();
1271   FB07 C3 6C F8    	jp entryf86c_monitor
1272   FB0A             ; 840 }
1273   FB0A             ; 841 
1274   FB0A             ; 842 // Функция для пользовательской программы.
1275   FB0A             ; 843 // Получить координаты курсора.
1276   FB0A             ; 844 // Параметры: нет. Результат: l = x + 8, h = y + 3. Сохраняет регистры: bc, de, hl.
1277   FB0A             ; 845 
1278   FB0A             ; 846 void GetCursor() {
1279   FB0A             getcursor: 
1280   FB0A             ; 847     push_pop(a) {
1281   FB0A F5          	push af
1282   FB0B             ; 848         hl = cursor;
1283   FB0B 2A 5A F7    	ld hl, (cursor)
1284   FB0E             ; 849         h = ((a = h) &= 7);
1285   FB0E 7C          	ld a, h
1286   FB0F E6 07       	and 7
1287   FB11 67          	ld h, a
1288   FB12             ; 850 
1289   FB12             ; 851         // Вычисление X
1290   FB12             ; 852         a = l;
1291   FB12 7D          	ld a, l
1292   FB13             ; 853         a &= (SCREEN_WIDTH - 1);
1293   FB13 E6 3F       	and 63
1294   FB15             ; 854         a += 8;  // Смещение Радио 86РК
1295   FB15 C6 08       	add 8
1296   FB17             ; 855 
1297   FB17             ; 856         // Вычисление Y
1298   FB17             ; 857         hl += hl;
1299   FB17 29          	add hl, hl
1300   FB18             ; 858         hl += hl;
1301   FB18 29          	add hl, hl
1302   FB19             ; 859         h++;  // Смещение Радио 86РК
1303   FB19 24          	inc h
1304   FB1A             ; 860         h++;
1305   FB1A 24          	inc h
1306   FB1B             ; 861         h++;
1307   FB1B 24          	inc h
1308   FB1C             ; 862 
1309   FB1C             ; 863         l = a;
1310   FB1C 6F          	ld l, a
1311   FB1D F1          	pop af
1312   FB1E C9          	ret
1313   FB1F             ; 864     }
1314   FB1F             ; 865 }
1315   FB1F             ; 866 
1316   FB1F             ; 867 // Функция для пользовательской программы.
1317   FB1F             ; 868 // Получить символ под курсором.
1318   FB1F             ; 869 // Параметры: нет. Результат: a - код символа. Сохраняет регистры: bc, de, hl.
1319   FB1F             ; 870 
1320   FB1F             ; 871 void GetCursorChar() {
1321   FB1F             getcursorchar: 
1322   FB1F             ; 872     push_pop(hl) {
1323   FB1F E5          	push hl
1324   FB20             ; 873         hl = cursor;
1325   FB20 2A 5A F7    	ld hl, (cursor)
1326   FB23             ; 874         a = *hl;
1327   FB23 7E          	ld a, (hl)
1328   FB24 E1          	pop hl
1329   FB25 C9          	ret
1330   FB26             ; 875     }
1331   FB26             ; 876 }
1332   FB26             ; 877 
1333   FB26             ; 878 // Команда H
1334   FB26             ; 879 // Определить скорости записанной программы.
1335   FB26             ; 880 // Выводит 4 цифры на экран.
1336   FB26             ; 881 // Первые две цифры - константа вывода для команды O
1337   FB26             ; 882 // Последние две цифры - константа вввода для команды I
1338   FB26             ; 883 
1339   FB26             ; 884 void CmdH(...) {
1340   FB26             cmdh: 
1341   FB26             ; 885     PrintCrLfTab();
1342   FB26 CD AA F9    	call printcrlftab
1343   FB29             ; 886     hl = 65408;
1344   FB29 21 80 FF    	ld hl, 65408
1345   FB2C             ; 887     b = 123;
1346   FB2C 06 7B       	ld b, 123
1347   FB2E             ; 888 
1348   FB2E             ; 889     c = a = in(PORT_TAPE);
1349   FB2E DB 01       	in a, (1)
1350   FB30 4F          	ld c, a
1351   FB31             ; 890 
1352   FB31             ; 891     do {
1353   FB31             l_64: 
1354   FB31             l_65: 
1355   FB31             ; 892     } while ((a = in(PORT_TAPE)) == c);
1356   FB31 DB 01       	in a, (1)
1357   FB33 B9          	cp c
1358   FB34 CA 31 FB    	jp z, l_64
1359   FB37             ; 893 
1360   FB37             ; 894     do {
1361   FB37             l_67: 
1362   FB37             ; 895         c = a;
1363   FB37 4F          	ld c, a
1364   FB38             ; 896         do {
1365   FB38             l_70: 
1366   FB38             ; 897             hl++;
1367   FB38 23          	inc hl
1368   FB39             l_71: 
1369   FB39             ; 898         } while ((a = in(PORT_TAPE)) == c);
1370   FB39 DB 01       	in a, (1)
1371   FB3B B9          	cp c
1372   FB3C CA 38 FB    	jp z, l_70
1373   FB3F             l_68: 
1374   FB3F             ; 899     } while (flag_nz(b--));
1375   FB3F 05          	dec b
1376   FB40 C2 37 FB    	jp nz, l_67
1377   FB43             ; 900 
1378   FB43             ; 901     hl += hl;
1379   FB43 29          	add hl, hl
1380   FB44             ; 902     a = h;
1381   FB44 7C          	ld a, h
1382   FB45             ; 903     hl += hl;
1383   FB45 29          	add hl, hl
1384   FB46             ; 904     l = (a += h);
1385   FB46 84          	add h
1386   FB47 6F          	ld l, a
1387   FB48             ; 905 
1388   FB48             ; 906     PrintHexWordSpace();
1389   FB48 C3 F1 FB    	jp printhexwordspace
1390   FB4B             ; 907 }
1391   FB4B             ; 908 
1392   FB4B             ; 909 // Команда I <смещение> <скорость>
1393   FB4B             ; 910 // Загрузить файл с магнитной ленты
1394   FB4B             ; 911 
1395   FB4B             ; 912 void CmdI(...) {
1396   FB4B             cmdi: 
1397   FB4B             ; 913     if ((a = param2Exists) != 0)
1398   FB4B 3A 7B F7    	ld a, (param2exists)
1399   FB4E B7          	or a
1400   FB4F             ; 914         tapeReadSpeed = a = e;
1401   FB4F CA 56 FB    	jp z, l_73
1402   FB52 7B          	ld a, e
1403   FB53 32 5C F7    	ld (tapereadspeed), a
1404   FB56             l_73: 
1405   FB56             ; 915     ReadTapeFile();
1406   FB56 CD 7B FB    	call readtapefile
1407   FB59             ; 916     PrintCrLfTabHexWordSpace(hl);
1408   FB59 CD E8 FB    	call printcrlftabhexwordspace
1409   FB5C             ; 917     swap(hl, de);
1410   FB5C EB          	ex hl, de
1411   FB5D             ; 918     PrintCrLfTabHexWordSpace(hl);
1412   FB5D CD E8 FB    	call printcrlftabhexwordspace
1413   FB60             ; 919     swap(hl, de);
1414   FB60 EB          	ex hl, de
1415   FB61             ; 920     push(bc);
1416   FB61 C5          	push bc
1417   FB62             ; 921     CalculateCheckSum();
1418   FB62 CD B2 FB    	call calculatechecksum
1419   FB65             ; 922     h = b;
1420   FB65 60          	ld h, b
1421   FB66             ; 923     l = c;
1422   FB66 69          	ld l, c
1423   FB67             ; 924     PrintCrLfTabHexWordSpace(hl);
1424   FB67 CD E8 FB    	call printcrlftabhexwordspace
1425   FB6A             ; 925     pop(de);
1426   FB6A D1          	pop de
1427   FB6B             ; 926     CompareHlDe(hl, de);
1428   FB6B CD 8D F9    	call comparehlde
1429   FB6E             ; 927     if (flag_z)
1430   FB6E             ; 928         return;
1431   FB6E C8          	ret z
1432   FB6F             ; 929     swap(hl, de);
1433   FB6F EB          	ex hl, de
1434   FB70             ; 930     PrintCrLfTabHexWordSpace(hl);
1435   FB70 CD E8 FB    	call printcrlftabhexwordspace
1436   FB73             ; 931     MonitorError();
1437   FB73             ; 932 }
1438   FB73             ; 933 
1439   FB73             ; 934 void MonitorError() {
1440   FB73             monitorerror: 
1441   FB73             ; 935     PrintCharA(a = '?');
1442   FB73 3E 3F       	ld a, 63
1443   FB75 CD E2 FC    	call printchara
1444   FB78             ; 936     Monitor2();
1445   FB78 C3 75 F8    	jp monitor2
1446   FB7B             ; 937 }
1447   FB7B             ; 938 
1448   FB7B             ; 939 // Функция для пользовательской программы.
1449   FB7B             ; 940 // Загрузить файл с магнитной ленты.
1450   FB7B             ; 941 // Параметры: hl - смещение загрузки. Результат: bc - прочитанная КС, hl - адрес загрузки
1451   FB7B             ; 942 
1452   FB7B             ; 943 void ReadTapeFile(...) {
1453   FB7B             readtapefile: 
1454   FB7B             ; 944     ReadTapeWord(a = READ_TAPE_FIRST_BYTE);
1455   FB7B 3E FF       	ld a, 255
1456   FB7D CD 9B FB    	call readtapeword
1457   FB80             ; 945     push_pop(hl) {
1458   FB80 E5          	push hl
1459   FB81             ; 946         hl += bc;
1460   FB81 09          	add hl, bc
1461   FB82             ; 947         swap(hl, de);
1462   FB82 EB          	ex hl, de
1463   FB83             ; 948         ReadTapeWordNext();
1464   FB83 CD 99 FB    	call readtapewordnext
1465   FB86 E1          	pop hl
1466   FB87             ; 949     }
1467   FB87             ; 950     hl += bc;
1468   FB87 09          	add hl, bc
1469   FB88             ; 951     swap(hl, de);
1470   FB88 EB          	ex hl, de
1471   FB89             ; 952 
1472   FB89             ; 953     a = in(PORT_KEYBOARD_MODS);
1473   FB89 DB 05       	in a, (5)
1474   FB8B             ; 954     a &= KEYBOARD_SHIFT_MOD;
1475   FB8B E6 04       	and 4
1476   FB8D             ; 955     if (flag_z)
1477   FB8D             ; 956         return;
1478   FB8D C8          	ret z
1479   FB8E             ; 957 
1480   FB8E             ; 958     push_pop(hl) {
1481   FB8E E5          	push hl
1482   FB8F             ; 959         ReadTapeBlock();
1483   FB8F CD A6 FB    	call readtapeblock
1484   FB92             ; 960         ReadTapeWord(a = READ_TAPE_FIRST_BYTE);
1485   FB92 3E FF       	ld a, 255
1486   FB94 CD 9B FB    	call readtapeword
1487   FB97 E1          	pop hl
1488   FB98 C9          	ret
1489   FB99             ; 961     }
1490   FB99             ; 962 }
1491   FB99             ; 963 
1492   FB99             ; 964 void ReadTapeWordNext() {
1493   FB99             readtapewordnext: 
1494   FB99             ; 965     ReadTapeWord(a = READ_TAPE_NEXT_BYTE);
1495   FB99 3E 08       	ld a, 8
1496   FB9B             ; 966 }
1497   FB9B             ; 967 
1498   FB9B             ; 968 void ReadTapeWord(...) {
1499   FB9B             readtapeword: 
1500   FB9B             ; 969     ReadTapeByte(a);
1501   FB9B CD 34 FC    	call readtapebyte
1502   FB9E             ; 970     b = a;
1503   FB9E 47          	ld b, a
1504   FB9F             ; 971     ReadTapeByte(a = READ_TAPE_NEXT_BYTE);
1505   FB9F 3E 08       	ld a, 8
1506   FBA1 CD 34 FC    	call readtapebyte
1507   FBA4             ; 972     c = a;
1508   FBA4 4F          	ld c, a
1509   FBA5 C9          	ret
1510   FBA6             ; 973 }
1511   FBA6             ; 974 
1512   FBA6             ; 975 void ReadTapeBlock(...) {
1513   FBA6             readtapeblock: 
1514   FBA6             ; 976     for (;;) {
1515   FBA6             l_76: 
1516   FBA6             ; 977         ReadTapeByte(a = READ_TAPE_NEXT_BYTE);
1517   FBA6 3E 08       	ld a, 8
1518   FBA8 CD 34 FC    	call readtapebyte
1519   FBAB             ; 978         *hl = a;
1520   FBAB 77          	ld (hl), a
1521   FBAC             ; 979         Loop();
1522   FBAC CD 96 F9    	call loop
1523   FBAF C3 A6 FB    	jp l_76
1524   FBB2             ; 980     }
1525   FBB2             ; 981 }
1526   FBB2             ; 982 
1527   FBB2             ; 983 // Функция для пользовательской программы.
1528   FBB2             ; 984 // Вычистить 16-битную сумму всех байт по адресам hl..de.
1529   FBB2             ; 985 // Параметры: hl - начальный адрес, de - конечный адрес. Результат: bc - сумма. Сохраяет: de.
1530   FBB2             ; 986 
1531   FBB2             ; 987 void CalculateCheckSum(...) {
1532   FBB2             calculatechecksum: 
1533   FBB2             ; 988     bc = 0;
1534   FBB2 01 00 00    	ld bc, 0
1535   FBB5             ; 989     for (;;) {
1536   FBB5             l_79: 
1537   FBB5             ; 990         c = ((a = *hl) += c);
1538   FBB5 7E          	ld a, (hl)
1539   FBB6 81          	add c
1540   FBB7 4F          	ld c, a
1541   FBB8             ; 991         push_pop(a) {
1542   FBB8 F5          	push af
1543   FBB9             ; 992             CompareHlDe(hl, de);
1544   FBB9 CD 8D F9    	call comparehlde
1545   FBBC             ; 993             if (flag_z)
1546   FBBC             ; 994                 return PopRet();
1547   FBBC CA 9C F9    	jp z, popret
1548   FBBF F1          	pop af
1549   FBC0             ; 995         }
1550   FBC0             ; 996         a = b;
1551   FBC0 78          	ld a, b
1552   FBC1             ; 997         carry_add(a, *hl);
1553   FBC1 8E          	adc (hl)
1554   FBC2             ; 998         b = a;
1555   FBC2 47          	ld b, a
1556   FBC3             ; 999         Loop();
1557   FBC3 CD 96 F9    	call loop
1558   FBC6 C3 B5 FB    	jp l_79
1559   FBC9             ; 1000     }
1560   FBC9             ; 1001 }
1561   FBC9             ; 1002 
1562   FBC9             ; 1003 // Команда O <начальный адрес> <конечный адрес> <скорость>
1563   FBC9             ; 1004 // Сохранить блок данных на магнитную ленту
1564   FBC9             ; 1005 
1565   FBC9             ; 1006 void CmdO(...) {
1566   FBC9             cmdo: 
1567   FBC9             ; 1007     if ((a = c) != 0)
1568   FBC9 79          	ld a, c
1569   FBCA B7          	or a
1570   FBCB             ; 1008         tapeWriteSpeed = a;
1571   FBCB CA D1 FB    	jp z, l_81
1572   FBCE 32 5D F7    	ld (tapewritespeed), a
1573   FBD1             l_81: 
1574   FBD1             ; 1009     push_pop(hl) {
1575   FBD1 E5          	push hl
1576   FBD2             ; 1010         CalculateCheckSum(hl, de);
1577   FBD2 CD B2 FB    	call calculatechecksum
1578   FBD5 E1          	pop hl
1579   FBD6             ; 1011     }
1580   FBD6             ; 1012     PrintCrLfTabHexWordSpace(hl);
1581   FBD6 CD E8 FB    	call printcrlftabhexwordspace
1582   FBD9             ; 1013     swap(hl, de);
1583   FBD9 EB          	ex hl, de
1584   FBDA             ; 1014     PrintCrLfTabHexWordSpace(hl);
1585   FBDA CD E8 FB    	call printcrlftabhexwordspace
1586   FBDD             ; 1015     swap(hl, de);
1587   FBDD EB          	ex hl, de
1588   FBDE             ; 1016     push_pop(hl) {
1589   FBDE E5          	push hl
1590   FBDF             ; 1017         h = b;
1591   FBDF 60          	ld h, b
1592   FBE0             ; 1018         l = c;
1593   FBE0 69          	ld l, c
1594   FBE1             ; 1019         PrintCrLfTabHexWordSpace(hl);
1595   FBE1 CD E8 FB    	call printcrlftabhexwordspace
1596   FBE4 E1          	pop hl
1597   FBE5             ; 1020     }
1598   FBE5             ; 1021     WriteTapeFile(hl, de);
1599   FBE5 C3 03 FC    	jp writetapefile
1600   FBE8             ; 1022 }
1601   FBE8             ; 1023 
1602   FBE8             ; 1024 void PrintCrLfTabHexWordSpace(...) {
1603   FBE8             printcrlftabhexwordspace: 
1604   FBE8             ; 1025     push_pop(bc) {
1605   FBE8 C5          	push bc
1606   FBE9             ; 1026         PrintCrLfTab();
1607   FBE9 CD AA F9    	call printcrlftab
1608   FBEC             ; 1027         PrintHexWordSpace(hl);
1609   FBEC CD F1 FB    	call printhexwordspace
1610   FBEF C1          	pop bc
1611   FBF0 C9          	ret
1612   FBF1             ; 1028     }
1613   FBF1             ; 1029 }
1614   FBF1             ; 1030 
1615   FBF1             ; 1031 void PrintHexWordSpace(...) {
1616   FBF1             printhexwordspace: 
1617   FBF1             ; 1032     PrintHexByte(a = h);
1618   FBF1 7C          	ld a, h
1619   FBF2 CD CE FC    	call printhexbyte
1620   FBF5             ; 1033     PrintHexByteSpace(a = l);
1621   FBF5 7D          	ld a, l
1622   FBF6 C3 B4 F9    	jp printhexbytespace
1623   FBF9             ; 1034 }
1624   FBF9             ; 1035 
1625   FBF9             ; 1036 void WriteTapeBlock(...) {
1626   FBF9             writetapeblock: 
1627   FBF9             ; 1037     for (;;) {
1628   FBF9             l_84: 
1629   FBF9             ; 1038         WriteTapeByte(c = *hl);
1630   FBF9 4E          	ld c, (hl)
1631   FBFA CD 9D FC    	call writetapebyte
1632   FBFD             ; 1039         Loop();
1633   FBFD CD 96 F9    	call loop
1634   FC00 C3 F9 FB    	jp l_84
1635   FC03             ; 1040     }
1636   FC03             ; 1041 }
1637   FC03             ; 1042 
1638   FC03             ; 1043 // Функция для пользовательской программы.
1639   FC03             ; 1044 // Запись файла на магнитную ленту.
1640   FC03             ; 1045 // Параметры: de - начальный адрес, hl - конечный адрес, bc - контрольная сумма. Результат: нет.
1641   FC03             ; 1046 
1642   FC03             ; 1047 void WriteTapeFile(...) {
1643   FC03             writetapefile: 
1644   FC03             ; 1048     push(bc);
1645   FC03 C5          	push bc
1646   FC04             ; 1049     bc = 0;
1647   FC04 01 00 00    	ld bc, 0
1648   FC07             ; 1050     do {
1649   FC07             l_86: 
1650   FC07             ; 1051         WriteTapeByte(c);
1651   FC07 CD 9D FC    	call writetapebyte
1652   FC0A             ; 1052         b--;
1653   FC0A 05          	dec b
1654   FC0B             ; 1053         swap(hl, *sp);
1655   FC0B E3          	ex (sp), hl
1656   FC0C             ; 1054         swap(hl, *sp);
1657   FC0C E3          	ex (sp), hl
1658   FC0D             l_87: 
1659   FC0D C2 07 FC    	jp nz, l_86
1660   FC10             ; 1055     } while (flag_nz);
1661   FC10             ; 1056     WriteTapeByte(c = TAPE_START);
1662   FC10 0E E6       	ld c, 230
1663   FC12 CD 9D FC    	call writetapebyte
1664   FC15             ; 1057     WriteTapeWord(hl);
1665   FC15 CD 2C FC    	call writetapeword
1666   FC18             ; 1058     swap(hl, de);
1667   FC18 EB          	ex hl, de
1668   FC19             ; 1059     WriteTapeWord(hl);
1669   FC19 CD 2C FC    	call writetapeword
1670   FC1C             ; 1060     swap(hl, de);
1671   FC1C EB          	ex hl, de
1672   FC1D             ; 1061     WriteTapeBlock(hl, de);
1673   FC1D CD F9 FB    	call writetapeblock
1674   FC20             ; 1062     WriteTapeWord(hl = 0);
1675   FC20 21 00 00    	ld hl, 0
1676   FC23 CD 2C FC    	call writetapeword
1677   FC26             ; 1063     WriteTapeByte(c = TAPE_START);
1678   FC26 0E E6       	ld c, 230
1679   FC28 CD 9D FC    	call writetapebyte
1680   FC2B             ; 1064     pop(hl);
1681   FC2B E1          	pop hl
1682   FC2C             ; 1065     WriteTapeWord(hl);
1683   FC2C             ; 1066 }
1684   FC2C             ; 1067 
1685   FC2C             ; 1068 void WriteTapeWord(...) {
1686   FC2C             writetapeword: 
1687   FC2C             ; 1069     WriteTapeByte(c = h);
1688   FC2C 4C          	ld c, h
1689   FC2D CD 9D FC    	call writetapebyte
1690   FC30             ; 1070     WriteTapeByte(c = l);
1691   FC30 4D          	ld c, l
1692   FC31 C3 9D FC    	jp writetapebyte
1693   FC34             ; 1071 }
1694   FC34             ; 1072 
1695   FC34             ; 1073 // Загрузка байта с магнитной ленты.
1696   FC34             ; 1074 // Параметры: a = 0xFF с синхронизацией, = 8 без синхронизации.
1697   FC34             ; 1075 // Результат: a = прочитанный байт.
1698   FC34             ; 1076 
1699   FC34             ; 1077 void ReadTapeByte(...) {
1700   FC34             readtapebyte: 
1701   FC34             ; 1078     push(hl, bc, de);
1702   FC34 E5          	push hl
1703   FC35 C5          	push bc
1704   FC36 D5          	push de
1705   FC37             ; 1079     d = a;
1706   FC37 57          	ld d, a
1707   FC38             ; 1080     ReadTapeByteInternal(d);
1708   FC38             ; 1081 }
1709   FC38             ; 1082 
1710   FC38             ; 1083 void ReadTapeByteInternal(...) {
1711   FC38             readtapebyteinternal: 
1712   FC38             ; 1084     c = 0;
1713   FC38 0E 00       	ld c, 0
1714   FC3A             ; 1085     e = ((a = in(PORT_TAPE)) &= PORT_TAPE_BIT);
1715   FC3A DB 01       	in a, (1)
1716   FC3C E6 01       	and 1
1717   FC3E 5F          	ld e, a
1718   FC3F             ; 1086     do {
1719   FC3F             l_89: 
1720   FC3F             ; 1087 retry:  // Сдвиг результата
1721   FC3F             retry: 
1722   FC3F             ; 1088         (a = c) &= 0x7F;
1723   FC3F 79          	ld a, c
1724   FC40 E6 7F       	and 127
1725   FC42             ; 1089         cyclic_rotate_left(a, 1);
1726   FC42 07          	rlca
1727   FC43             ; 1090         c = a;
1728   FC43 4F          	ld c, a
1729   FC44             ; 1091 
1730   FC44             ; 1092         // Ожидание изменения бита
1731   FC44             ; 1093         h = 0;
1732   FC44 26 00       	ld h, 0
1733   FC46             ; 1094         do {
1734   FC46             l_92: 
1735   FC46             ; 1095             h--;
1736   FC46 25          	dec h
1737   FC47             ; 1096             if (flag_z)
1738   FC47             ; 1097                 return ReadTapeByteTimeout(d);
1739   FC47 CA 92 FC    	jp z, readtapebytetimeout
1740   FC4A             l_93: 
1741   FC4A             ; 1098         } while (((a = in(PORT_TAPE)) &= PORT_TAPE_BIT) == e);
1742   FC4A DB 01       	in a, (1)
1743   FC4C E6 01       	and 1
1744   FC4E BB          	cp e
1745   FC4F CA 46 FC    	jp z, l_92
1746   FC52             ; 1099 
1747   FC52             ; 1100         // Сохранение бита
1748   FC52             ; 1101         c = (a |= c);
1749   FC52 B1          	or c
1750   FC53 4F          	ld c, a
1751   FC54             ; 1102 
1752   FC54             ; 1103         // Задержка
1753   FC54             ; 1104         d--;
1754   FC54 15          	dec d
1755   FC55             ; 1105         a = tapeReadSpeed;
1756   FC55 3A 5C F7    	ld a, (tapereadspeed)
1757   FC58             ; 1106         if (flag_z)
1758   FC58             ; 1107             a -= 18;
1759   FC58 C2 5D FC    	jp nz, l_95
1760   FC5B D6 12       	sub 18
1761   FC5D             l_95: 
1762   FC5D             ; 1108         b = a;
1763   FC5D 47          	ld b, a
1764   FC5E             ; 1109         do {
1765   FC5E             l_97: 
1766   FC5E             l_98: 
1767   FC5E             ; 1110         } while (flag_nz(b--));
1768   FC5E 05          	dec b
1769   FC5F C2 5E FC    	jp nz, l_97
1770   FC62             ; 1111         d++;
1771   FC62 14          	inc d
1772   FC63             ; 1112 
1773   FC63             ; 1113         // Новое значение бита
1774   FC63             ; 1114         e = ((a = in(PORT_TAPE)) &= PORT_TAPE_BIT);
1775   FC63 DB 01       	in a, (1)
1776   FC65 E6 01       	and 1
1777   FC67 5F          	ld e, a
1778   FC68             ; 1115 
1779   FC68             ; 1116         // Режим поиска синхробайта
1780   FC68             ; 1117         if (flag_m((a = d) |= a)) {
1781   FC68 7A          	ld a, d
1782   FC69 B7          	or a
1783   FC6A F2 86 FC    	jp p, l_100
1784   FC6D             ; 1118             if ((a = c) == TAPE_START) {
1785   FC6D 79          	ld a, c
1786   FC6E FE E6       	cp 230
1787   FC70 C2 7A FC    	jp nz, l_102
1788   FC73             ; 1119                 tapePolarity = (a ^= a);
1789   FC73 AF          	xor a
1790   FC74 32 7C F7    	ld (tapepolarity), a
1791   FC77 C3 84 FC    	jp l_103
1792   FC7A             l_102: 
1793   FC7A             ; 1120             } else {
1794   FC7A             ; 1121                 if (a != ~TAPE_START)
1795   FC7A FE 19       	cp 65305
1796   FC7C             ; 1122                     goto retry;
1797   FC7C C2 3F FC    	jp nz, retry
1798   FC7F             ; 1123                 tapePolarity = a = 255;
1799   FC7F 3E FF       	ld a, 255
1800   FC81 32 7C F7    	ld (tapepolarity), a
1801   FC84             l_103: 
1802   FC84             ; 1124             }
1803   FC84             ; 1125             d = 8 + 1;
1804   FC84 16 09       	ld d, 9
1805   FC86             l_100: 
1806   FC86             l_90: 
1807   FC86             ; 1126         }
1808   FC86             ; 1127     } while (flag_nz(d--));
1809   FC86 15          	dec d
1810   FC87 C2 3F FC    	jp nz, l_89
1811   FC8A             ; 1128     (a = tapePolarity) ^= c;
1812   FC8A 3A 7C F7    	ld a, (tapepolarity)
1813   FC8D A9          	xor c
1814   FC8E             ; 1129     pop(hl, bc, de);
1815   FC8E D1          	pop de
1816   FC8F C1          	pop bc
1817   FC90 E1          	pop hl
1818   FC91 C9          	ret
1819   FC92             ; 1130 }
1820   FC92             ; 1131 
1821   FC92             ; 1132 void ReadTapeByteTimeout(...) {
1822   FC92             readtapebytetimeout: 
1823   FC92             ; 1133     if (flag_p((a = d) |= a))
1824   FC92 7A          	ld a, d
1825   FC93 B7          	or a
1826   FC94             ; 1134         return MonitorError();
1827   FC94 F2 73 FB    	jp p, monitorerror
1828   FC97             ; 1135     CtrlC();
1829   FC97 CD A1 F9    	call ctrlc
1830   FC9A             ; 1136     ReadTapeByteInternal();
1831   FC9A C3 38 FC    	jp readtapebyteinternal
1832   FC9D             ; 1137 }
1833   FC9D             ; 1138 
1834   FC9D             ; 1139 // Функция для пользовательской программы.
1835   FC9D             ; 1140 // Запись байта на магнитную ленту.
1836   FC9D             ; 1141 // Параметры: c = байт. Результат: нет. Сохрнаяет: a, bc, de, hl.
1837   FC9D             ; 1142 
1838   FC9D             ; 1143 void WriteTapeByte(...) {
1839   FC9D             writetapebyte: 
1840   FC9D             ; 1144     push_pop(bc, de, a) {
1841   FC9D C5          	push bc
1842   FC9E D5          	push de
1843   FC9F F5          	push af
1844   FCA0             ; 1145         d = 8;
1845   FCA0 16 08       	ld d, 8
1846   FCA2             ; 1146         do {
1847   FCA2             l_104: 
1848   FCA2             ; 1147             // Сдвиг исходного байта
1849   FCA2             ; 1148             a = c;
1850   FCA2 79          	ld a, c
1851   FCA3             ; 1149             cyclic_rotate_left(a, 1);
1852   FCA3 07          	rlca
1853   FCA4             ; 1150             c = a;
1854   FCA4 4F          	ld c, a
1855   FCA5             ; 1151 
1856   FCA5             ; 1152             // Вывод
1857   FCA5             ; 1153             (a = PORT_TAPE_BIT) ^= c;
1858   FCA5 3E 01       	ld a, 1
1859   FCA7 A9          	xor c
1860   FCA8             ; 1154             out(PORT_TAPE, a);
1861   FCA8 D3 01       	out (1), a
1862   FCAA             ; 1155 
1863   FCAA             ; 1156             // Задержка
1864   FCAA             ; 1157             b = a = tapeWriteSpeed;
1865   FCAA 3A 5D F7    	ld a, (tapewritespeed)
1866   FCAD 47          	ld b, a
1867   FCAE             ; 1158             do {
1868   FCAE             l_107: 
1869   FCAE             ; 1159                 b--;
1870   FCAE 05          	dec b
1871   FCAF             l_108: 
1872   FCAF C2 AE FC    	jp nz, l_107
1873   FCB2             ; 1160             } while (flag_nz);
1874   FCB2             ; 1161 
1875   FCB2             ; 1162             // Вывод
1876   FCB2             ; 1163             (a = 0) ^= c;
1877   FCB2 3E 00       	ld a, 0
1878   FCB4 A9          	xor c
1879   FCB5             ; 1164             out(PORT_TAPE, a);
1880   FCB5 D3 01       	out (1), a
1881   FCB7             ; 1165 
1882   FCB7             ; 1166             // Задержка
1883   FCB7             ; 1167             d--;
1884   FCB7 15          	dec d
1885   FCB8             ; 1168             a = tapeWriteSpeed;
1886   FCB8 3A 5D F7    	ld a, (tapewritespeed)
1887   FCBB             ; 1169             if (flag_z)
1888   FCBB             ; 1170                 a -= 14;
1889   FCBB C2 C0 FC    	jp nz, l_110
1890   FCBE D6 0E       	sub 14
1891   FCC0             l_110: 
1892   FCC0             ; 1171             b = a;
1893   FCC0 47          	ld b, a
1894   FCC1             ; 1172             do {
1895   FCC1             l_112: 
1896   FCC1             ; 1173                 b--;
1897   FCC1 05          	dec b
1898   FCC2             l_113: 
1899   FCC2 C2 C1 FC    	jp nz, l_112
1900   FCC5             ; 1174             } while (flag_nz);
1901   FCC5             ; 1175             d++;
1902   FCC5 14          	inc d
1903   FCC6             l_105: 
1904   FCC6             ; 1176         } while (flag_nz(d--));
1905   FCC6 15          	dec d
1906   FCC7 C2 A2 FC    	jp nz, l_104
1907   FCCA F1          	pop af
1908   FCCB D1          	pop de
1909   FCCC C1          	pop bc
1910   FCCD C9          	ret
1911   FCCE             ; 1177     }
1912   FCCE             ; 1178 }
1913   FCCE             ; 1179 
1914   FCCE             ; 1180 // Функция для пользовательской программы.
1915   FCCE             ; 1181 // Вывод 8 битного числа на экран.
1916   FCCE             ; 1182 // Параметры: а - число. Результат: нет. Сохраняет: bc, de, hl.
1917   FCCE             ; 1183 
1918   FCCE             ; 1184 void PrintHexByte(...) {
1919   FCCE             printhexbyte: 
1920   FCCE             ; 1185     push_pop(a) {
1921   FCCE F5          	push af
1922   FCCF             ; 1186         cyclic_rotate_right(a, 4);
1923   FCCF 0F          	rrca
1924   FCD0 0F          	rrca
1925   FCD1 0F          	rrca
1926   FCD2 0F          	rrca
1927   FCD3             ; 1187         PrintHexNibble(a);
1928   FCD3 CD D7 FC    	call printhexnibble
1929   FCD6 F1          	pop af
1930   FCD7             ; 1188     }
1931   FCD7             ; 1189     PrintHexNibble(a);
1932   FCD7             ; 1190 }
1933   FCD7             ; 1191 
1934   FCD7             ; 1192 void PrintHexNibble(...) {
1935   FCD7             printhexnibble: 
1936   FCD7             ; 1193     a &= 0x0F;
1937   FCD7 E6 0F       	and 15
1938   FCD9             ; 1194     if (flag_p(compare(a, 10)))
1939   FCD9 FE 0A       	cp 10
1940   FCDB             ; 1195         a += 'A' - '0' - 10;
1941   FCDB FA E0 FC    	jp m, l_115
1942   FCDE C6 07       	add 7
1943   FCE0             l_115: 
1944   FCE0             ; 1196     a += '0';
1945   FCE0 C6 30       	add 48
1946   FCE2             ; 1197     PrintCharA(a);
1947   FCE2             ; 1198 }
1948   FCE2             ; 1199 
1949   FCE2             ; 1200 // Вывод символа на экран.
1950   FCE2             ; 1201 // Параметры: а - символ. Результат: a и c - символ. Сохраняет: a, b, de, hl.
1951   FCE2             ; 1202 
1952   FCE2             ; 1203 void PrintCharA(...) {
1953   FCE2             printchara: 
1954   FCE2             ; 1204     PrintChar(c = a);
1955   FCE2 4F          	ld c, a
1956   FCE3             ; 1205 }
1957   FCE3             ; 1206 
1958   FCE3             ; 1207 // Функция для пользовательской программы.
1959   FCE3             ; 1208 // Вывод символа на экран.
1960   FCE3             ; 1209 // Параметры: c - символ. Результат: нет. Сохраняет: a, b, de, hl.
1961   FCE3             ; 1210 
1962   FCE3             ; 1211 void PrintChar(...) {
1963   FCE3             printchar: 
1964   FCE3             ; 1212     push(a, bc, de, hl);
1965   FCE3 F5          	push af
1966   FCE4 C5          	push bc
1967   FCE5 D5          	push de
1968   FCE6 E5          	push hl
1969   FCE7             ; 1213     hl = cursor;
1970   FCE7 2A 5A F7    	ld hl, (cursor)
1971   FCEA             ; 1214     DrawCursor(hl);
1972   FCEA CD 30 FD    	call drawcursor
1973   FCED             ; 1215     a = escState;
1974   FCED 3A 5F F7    	ld a, (escstate)
1975   FCF0             ; 1216     a--;
1976   FCF0 3D          	dec a
1977   FCF1             ; 1217     if (flag_m)
1978   FCF1             ; 1218         return PrintCharNoEsc();
1979   FCF1 FA 79 FD    	jp m, printcharnoesc
1980   FCF4             ; 1219     if (flag_z)
1981   FCF4             ; 1220         return PrintCharEsc();
1982   FCF4 CA 5A FD    	jp z, printcharesc
1983   FCF7             ; 1221     a--;
1984   FCF7 3D          	dec a
1985   FCF8             ; 1222     if (flag_nz)
1986   FCF8             ; 1223         return PrintCharEscY2();
1987   FCF8 C2 3F FD    	jp nz, printcharescy2
1988   FCFB             ; 1224 
1989   FCFB             ; 1225     // Первый параметр ESC Y
1990   FCFB             ; 1226     a = c;
1991   FCFB 79          	ld a, c
1992   FCFC             ; 1227     a -= ' ';
1993   FCFC D6 20       	sub 32
1994   FCFE             ; 1228     if (flag_m) {
1995   FCFE F2 05 FD    	jp p, l_117
1996   FD01             ; 1229         a ^= a;
1997   FD01 AF          	xor a
1998   FD02 C3 0C FD    	jp l_118
1999   FD05             l_117: 
2000   FD05             ; 1230     } else {
2001   FD05             ; 1231         if (flag_p(compare(a, SCREEN_HEIGHT)))
2002   FD05 FE 19       	cp 25
2003   FD07             ; 1232             a = SCREEN_HEIGHT - 1;
2004   FD07 FA 0C FD    	jp m, l_119
2005   FD0A 3E 18       	ld a, 24
2006   FD0C             l_119: 
2007   FD0C             l_118: 
2008   FD0C             ; 1233     }
2009   FD0C             ; 1234     cyclic_rotate_right(a, 2);
2010   FD0C 0F          	rrca
2011   FD0D 0F          	rrca
2012   FD0E             ; 1235     c = a;
2013   FD0E 4F          	ld c, a
2014   FD0F             ; 1236     b = (a &= 192);
2015   FD0F E6 C0       	and 192
2016   FD11 47          	ld b, a
2017   FD12             ; 1237     l = (((a = l) &= 63) |= b);
2018   FD12 7D          	ld a, l
2019   FD13 E6 3F       	and 63
2020   FD15 B0          	or b
2021   FD16 6F          	ld l, a
2022   FD17             ; 1238     b = ((a = c) &= 7);
2023   FD17 79          	ld a, c
2024   FD18 E6 07       	and 7
2025   FD1A 47          	ld b, a
2026   FD1B             ; 1239     h = (((a = h) &= 248) |= b);
2027   FD1B 7C          	ld a, h
2028   FD1C E6 F8       	and 248
2029   FD1E B0          	or b
2030   FD1F 67          	ld h, a
2031   FD20             ; 1240     PrintCharSetEscState(hl, a = 3);
2032   FD20 3E 03       	ld a, 3
2033   FD22             ; 1241 }
2034   FD22             ; 1242 
2035   FD22             ; 1243 void PrintCharSetEscState(...) {
2036   FD22             printcharsetescstate: 
2037   FD22             ; 1244     escState = a;
2038   FD22 32 5F F7    	ld (escstate), a
2039   FD25             ; 1245     PrintCharSaveCursor(hl);
2040   FD25             ; 1246 }
2041   FD25             ; 1247 
2042   FD25             ; 1248 void PrintCharSaveCursor(...) {
2043   FD25             printcharsavecursor: 
2044   FD25             ; 1249     cursor = hl;
2045   FD25 22 5A F7    	ld (cursor), hl
2046   FD28             ; 1250     PrintCharExit();
2047   FD28             ; 1251 }
2048   FD28             ; 1252 
2049   FD28             ; 1253 void PrintCharExit(...) {
2050   FD28             printcharexit: 
2051   FD28             ; 1254     DrawCursor(hl);
2052   FD28 CD 30 FD    	call drawcursor
2053   FD2B             ; 1255     pop(a, bc, de, hl);
2054   FD2B E1          	pop hl
2055   FD2C D1          	pop de
2056   FD2D C1          	pop bc
2057   FD2E F1          	pop af
2058   FD2F C9          	ret
2059   FD30             ; 1256 }
2060   FD30             ; 1257 
2061   FD30             ; 1258 void DrawCursor(...) {
2062   FD30             drawcursor: 
2063   FD30             ; 1259     if ((a = cursorVisible) == 0)
2064   FD30 3A 5E F7    	ld a, (cursorvisible)
2065   FD33 B7          	or a
2066   FD34             ; 1260         return;
2067   FD34 C8          	ret z
2068   FD35             ; 1261     d = ((a = h) -= (SCREEN_SIZE >> 8));
2069   FD35 7C          	ld a, h
2070   FD36 D6 08       	sub 8
2071   FD38 57          	ld d, a
2072   FD39             ; 1262     e = l;
2073   FD39 5D          	ld e, l
2074   FD3A             ; 1263     a = *de;
2075   FD3A 1A          	ld a, (de)
2076   FD3B             ; 1264     a ^= SCREEN_ATTRIB_UNDERLINE;
2077   FD3B EE 80       	xor 128
2078   FD3D             ; 1265     *de = a;
2079   FD3D 12          	ld (de), a
2080   FD3E C9          	ret
2081   FD3F             ; 1266 }
2082   FD3F             ; 1267 
2083   FD3F             ; 1268 void PrintCharEscY2(...) {
2084   FD3F             printcharescy2: 
2085   FD3F             ; 1269     a = c;
2086   FD3F 79          	ld a, c
2087   FD40             ; 1270     a -= ' ';
2088   FD40 D6 20       	sub 32
2089   FD42             ; 1271     if (flag_m) {
2090   FD42 F2 49 FD    	jp p, l_121
2091   FD45             ; 1272         a ^= a;
2092   FD45 AF          	xor a
2093   FD46 C3 50 FD    	jp l_122
2094   FD49             l_121: 
2095   FD49             ; 1273     } else {
2096   FD49             ; 1274         if (flag_p(compare(a, SCREEN_WIDTH)))
2097   FD49 FE 40       	cp 64
2098   FD4B             ; 1275             a = SCREEN_WIDTH - 1;
2099   FD4B FA 50 FD    	jp m, l_123
2100   FD4E 3E 3F       	ld a, 63
2101   FD50             l_123: 
2102   FD50             l_122: 
2103   FD50             ; 1276     }
2104   FD50             ; 1277     b = a;
2105   FD50 47          	ld b, a
2106   FD51             ; 1278     l = (((a = l) &= 192) |= b);
2107   FD51 7D          	ld a, l
2108   FD52 E6 C0       	and 192
2109   FD54 B0          	or b
2110   FD55 6F          	ld l, a
2111   FD56             ; 1279     PrintCharResetEscState();
2112   FD56             ; 1280 }
2113   FD56             ; 1281 
2114   FD56             ; 1282 void PrintCharResetEscState(...) {
2115   FD56             printcharresetescstate: 
2116   FD56             ; 1283     a ^= a;
2117   FD56 AF          	xor a
2118   FD57             ; 1284     PrintCharSetEscState();
2119   FD57 C3 22 FD    	jp printcharsetescstate
2120   FD5A             ; 1285 }
2121   FD5A             ; 1286 
2122   FD5A             ; 1287 void PrintCharEsc(...) {
2123   FD5A             printcharesc: 
2124   FD5A             ; 1288     a = c;
2125   FD5A 79          	ld a, c
2126   FD5B             ; 1289     if (a == 'Y') {
2127   FD5B FE 59       	cp 89
2128   FD5D C2 65 FD    	jp nz, l_125
2129   FD60             ; 1290         a = 2;
2130   FD60 3E 02       	ld a, 2
2131   FD62             ; 1291         return PrintCharSetEscState();
2132   FD62 C3 22 FD    	jp printcharsetescstate
2133   FD65             l_125: 
2134   FD65             ; 1292     }
2135   FD65             ; 1293     if (a == 97) {
2136   FD65 FE 61       	cp 97
2137   FD67 C2 6E FD    	jp nz, l_127
2138   FD6A             ; 1294         a ^= a;
2139   FD6A AF          	xor a
2140   FD6B             ; 1295         return SetCursorVisible();
2141   FD6B C3 73 FD    	jp setcursorvisible
2142   FD6E             l_127: 
2143   FD6E             ; 1296     }
2144   FD6E             ; 1297     if (a != 98)
2145   FD6E FE 62       	cp 98
2146   FD70             ; 1298         return PrintCharResetEscState();
2147   FD70 C2 56 FD    	jp nz, printcharresetescstate
2148   FD73             ; 1299     SetCursorVisible();
2149   FD73             ; 1300 }
2150   FD73             ; 1301 
2151   FD73             ; 1302 void SetCursorVisible(...) {
2152   FD73             setcursorvisible: 
2153   FD73             ; 1303     cursorVisible = a;
2154   FD73 32 5E F7    	ld (cursorvisible), a
2155   FD76             ; 1304     PrintCharResetEscState();
2156   FD76 C3 56 FD    	jp printcharresetescstate
2157   FD79             ; 1305 }
2158   FD79             ; 1306 
2159   FD79             ; 1307 void PrintCharNoEsc(...) {
2160   FD79             printcharnoesc: 
2161   FD79             ; 1308     // Остановка вывода нажатием УС + Шифт
2162   FD79             ; 1309     do {
2163   FD79             l_129: 
2164   FD79             ; 1310         a = in(PORT_KEYBOARD_MODS);
2165   FD79 DB 05       	in a, (5)
2166   FD7B             l_130: 
2167   FD7B             ; 1311     } while (flag_z(a &= (KEYBOARD_US_MOD | KEYBOARD_SHIFT_MOD)));
2168   FD7B E6 06       	and 6
2169   FD7D CA 79 FD    	jp z, l_129
2170   FD80             ; 1312 
2171   FD80             ; 1313 #ifdef CMD_A_ENABLED
2172   FD80             ; 1314     compare(a = 16, c);
2173   FD80             ; 1315     a = translateCodeEnabled;
2174   FD80             ; 1316     if (flag_z) {
2175   FD80             ; 1317         invert(a);
2176   FD80             ; 1318         translateCodeEnabled = a;
2177   FD80             ; 1319         return PrintCharSaveCursor();
2178   FD80             ; 1320     }
2179   FD80             ; 1321     if (a != 0)
2180   FD80             ; 1322         TranslateCodePage(c);
2181   FD80             ; 1323 #endif
2182   FD80             ; 1324     a = c;
2183   FD80 79          	ld a, c
2184   FD81             ; 1325     if (a == 31)
2185   FD81 FE 1F       	cp 31
2186   FD83             ; 1326         return ClearScreen();
2187   FD83 CA A5 FD    	jp z, clearscreen
2188   FD86             ; 1327     if (flag_m)
2189   FD86             ; 1328         return PrintChar3(a);
2190   FD86 FA C5 FD    	jp m, printchar3
2191   FD89             ; 1329     PrintChar4(a);
2192   FD89             ; 1330 }
2193   FD89             ; 1331 
2194   FD89             ; 1332 void PrintChar4(...) {
2195   FD89             printchar4: 
2196   FD89             ; 1333     *hl = a;
2197   FD89 77          	ld (hl), a
2198   FD8A             ; 1334     d = ((a = h) -= (SCREEN_SIZE >> 8));
2199   FD8A 7C          	ld a, h
2200   FD8B D6 08       	sub 8
2201   FD8D 57          	ld d, a
2202   FD8E             ; 1335     e = l;
2203   FD8E 5D          	ld e, l
2204   FD8F             ; 1336     *de = a = color;
2205   FD8F 3A 59 F7    	ld a, (color)
2206   FD92 12          	ld (de), a
2207   FD93             ; 1337     hl++;
2208   FD93 23          	inc hl
2209   FD94             ; 1338     TryScrollUp(hl);
2210   FD94 C3 21 FE    	jp tryscrollup
2211   FD97             ; 1339 }
2212   FD97             ; 1340 
2213   FD97             ; 1341 void ClearScreenInt(...) {
2214   FD97             clearscreenint: 
2215   FD97             ; 1342     do {
2216   FD97             l_132: 
2217   FD97             ; 1343         do {
2218   FD97             l_135: 
2219   FD97             ; 1344             *hl = 0;
2220   FD97 36 00       	ld (hl), 0
2221   FD99             ; 1345             hl++;
2222   FD99 23          	inc hl
2223   FD9A             ; 1346             *de = a;
2224   FD9A 12          	ld (de), a
2225   FD9B             ; 1347             de++;
2226   FD9B 13          	inc de
2227   FD9C             l_136: 
2228   FD9C             ; 1348         } while (flag_nz(c--));
2229   FD9C 0D          	dec c
2230   FD9D C2 97 FD    	jp nz, l_135
2231   FDA0             l_133: 
2232   FDA0             ; 1349     } while (flag_nz(b--));
2233   FDA0 05          	dec b
2234   FDA1 C2 97 FD    	jp nz, l_132
2235   FDA4 C9          	ret
2236   FDA5             ; 1350 }
2237   FDA5             ; 1351 
2238   FDA5             ; 1352 void ClearScreen() {
2239   FDA5             clearscreen: 
2240   FDA5             ; 1353     hl = SCREEN_BEGIN;
2241   FDA5 21 00 E8    	ld hl, 59392
2242   FDA8             ; 1354     de = SCREEN_ATTRIB_BEGIN;
2243   FDA8 11 00 E0    	ld de, 57344
2244   FDAB             ; 1355     bc = 25 * SCREEN_WIDTH + 0x100;  // 25 строк
2245   FDAB 01 40 07    	ld bc, 1856
2246   FDAE             ; 1356     a = color;
2247   FDAE 3A 59 F7    	ld a, (color)
2248   FDB1             ; 1357     ClearScreenInt();
2249   FDB1 CD 97 FD    	call clearscreenint
2250   FDB4             ; 1358     a = SCREEN_ATTRIB_BLANK;
2251   FDB4 3E 07       	ld a, 7
2252   FDB6             ; 1359     bc = 7 * SCREEN_WIDTH + 0x100;  // 7 строк
2253   FDB6 01 C0 02    	ld bc, 704
2254   FDB9             ; 1360     ClearScreenInt();
2255   FDB9 CD 97 FD    	call clearscreenint
2256   FDBC             ; 1361     PrintKeyStatus();
2257   FDBC CD D7 FF    	call printkeystatus
2258   FDBF             ; 1362     MoveCursorHome();
2259   FDBF             ; 1363 }
2260   FDBF             ; 1364 
2261   FDBF             ; 1365 void MoveCursorHome(...) {
2262   FDBF             movecursorhome: 
2263   FDBF             ; 1366     PrintCharSaveCursor(hl = SCREEN_BEGIN);
2264   FDBF 21 00 E8    	ld hl, 59392
2265   FDC2 C3 25 FD    	jp printcharsavecursor
2266   FDC5             ; 1367 }
2267   FDC5             ; 1368 
2268   FDC5             ; 1369 void PrintChar3(...) {
2269   FDC5             printchar3: 
2270   FDC5             ; 1370     if (a == 12)
2271   FDC5 FE 0C       	cp 12
2272   FDC7             ; 1371         return MoveCursorHome();
2273   FDC7 CA BF FD    	jp z, movecursorhome
2274   FDCA             ; 1372     if (a == 13)
2275   FDCA FE 0D       	cp 13
2276   FDCC             ; 1373         return MoveCursorCr(hl);
2277   FDCC CA F7 FD    	jp z, movecursorcr
2278   FDCF             ; 1374     if (a == 10)
2279   FDCF FE 0A       	cp 10
2280   FDD1             ; 1375         return MoveCursorLf(hl);
2281   FDD1 CA 1D FE    	jp z, movecursorlf
2282   FDD4             ; 1376     if (a == 8)
2283   FDD4 FE 08       	cp 8
2284   FDD6             ; 1377         return MoveCursorLeft(hl);
2285   FDD6 CA 19 FE    	jp z, movecursorleft
2286   FDD9             ; 1378     if (a == 24)
2287   FDD9 FE 18       	cp 24
2288   FDDB             ; 1379         return MoveCursorRight(hl);
2289   FDDB CA FE FD    	jp z, movecursorright
2290   FDDE             ; 1380     if (a == 25)
2291   FDDE FE 19       	cp 25
2292   FDE0             ; 1381         return MoveCursorUp(hl);
2293   FDE0 CA 54 FE    	jp z, movecursorup
2294   FDE3             ; 1382     if (a == 7)
2295   FDE3 FE 07       	cp 7
2296   FDE5             ; 1383 #ifdef BEEP_ENABLED
2297   FDE5             ; 1384         return PrintCharBeep();
2298   FDE5             ; 1385 #else
2299   FDE5             ; 1386         return PrintCharExit();
2300   FDE5 CA 28 FD    	jp z, printcharexit
2301   FDE8             ; 1387 #endif
2302   FDE8             ; 1388     if (a == 26)
2303   FDE8 FE 1A       	cp 26
2304   FDEA             ; 1389         return MoveCursorDown();
2305   FDEA CA 5B FE    	jp z, movecursordown
2306   FDED             ; 1390     if (a != 27)
2307   FDED FE 1B       	cp 27
2308   FDEF             ; 1391         return PrintChar4(hl, a);
2309   FDEF C2 89 FD    	jp nz, printchar4
2310   FDF2             ; 1392     a = 1;
2311   FDF2 3E 01       	ld a, 1
2312   FDF4             ; 1393     PrintCharSetEscState();
2313   FDF4 C3 22 FD    	jp printcharsetescstate
2314   FDF7             ; 1394 }
2315   FDF7             ; 1395 
2316   FDF7             ; 1396 #ifdef BEEP_ENABLED
2317   FDF7             ; 1397 void PrintCharBeep(...) {
2318   FDF7             ; 1398     bc = (32 << 8) | 128; // Частота, Длительность
2319   FDF7             ; 1399     do {
2320   FDF7             ; 1400         e = b;
2321   FDF7             ; 1401         do {
2322   FDF7             ; 1402             out(PORT_KEYBOARD_MODE, a = 1 | (7 << 1));
2323   FDF7             ; 1403         } while (flag_nz(e--));
2324   FDF7             ; 1404         e = b;
2325   FDF7             ; 1405         do {
2326   FDF7             ; 1406             out(PORT_KEYBOARD_MODE, a = (7 << 1));
2327   FDF7             ; 1407         } while (flag_nz(e--));
2328   FDF7             ; 1408     } while (flag_nz(c--));
2329   FDF7             ; 1409 
2330   FDF7             ; 1410     PrintCharExit();
2331   FDF7             ; 1411 }
2332   FDF7             ; 1412 #endif
2333   FDF7             ; 1413 
2334   FDF7             ; 1414 void MoveCursorCr(...) {
2335   FDF7             movecursorcr: 
2336   FDF7             ; 1415     l = ((a = l) &= ~(SCREEN_WIDTH - 1));
2337   FDF7 7D          	ld a, l
2338   FDF8 E6 C0       	and 192
2339   FDFA 6F          	ld l, a
2340   FDFB             ; 1416     PrintCharSaveCursor(hl);
2341   FDFB C3 25 FD    	jp printcharsavecursor
2342   FDFE             ; 1417 }
2343   FDFE             ; 1418 
2344   FDFE             ; 1419 void MoveCursorRight(...) {
2345   FDFE             movecursorright: 
2346   FDFE             ; 1420     hl++;
2347   FDFE 23          	inc hl
2348   FDFF             ; 1421     MoveCursorBoundary(hl);
2349   FDFF             ; 1422 }
2350   FDFF             ; 1423 
2351   FDFF             ; 1424 const int ZERO_LINE = (SCREEN_BEGIN >> 6) & 0xFF;
2352   FDFF             ; 1425 
2353   FDFF             ; 1426 void MoveCursorBoundary(...) {
2354   FDFF             movecursorboundary: 
2355   FDFF             ; 1427     push_pop(hl) {
2356   FDFF E5          	push hl
2357   FE00             ; 1428         hl += hl;
2358   FE00 29          	add hl, hl
2359   FE01             ; 1429         hl += hl;
2360   FE01 29          	add hl, hl
2361   FE02             ; 1430         a = h;
2362   FE02 7C          	ld a, h
2363   FE03 E1          	pop hl
2364   FE04             ; 1431     }
2365   FE04             ; 1432 
2366   FE04             ; 1433     if (a < ZERO_LINE)
2367   FE04 FE A0       	cp 160
2368   FE06             ; 1434         hl += (de = SCREEN_WIDTH * SCREEN_HEIGHT);
2369   FE06 D2 0D FE    	jp nc, l_138
2370   FE09 11 40 06    	ld de, 1600
2371   FE0C 19          	add hl, de
2372   FE0D             l_138: 
2373   FE0D             ; 1435 
2374   FE0D             ; 1436     if (a >= SCREEN_HEIGHT + ZERO_LINE)
2375   FE0D FE B9       	cp 185
2376   FE0F             ; 1437         hl += (de = -SCREEN_WIDTH * SCREEN_HEIGHT);
2377   FE0F DA 16 FE    	jp c, l_140
2378   FE12 11 C0 F9    	ld de, 63936
2379   FE15 19          	add hl, de
2380   FE16             l_140: 
2381   FE16             ; 1438 
2382   FE16             ; 1439     PrintCharSaveCursor(hl);
2383   FE16 C3 25 FD    	jp printcharsavecursor
2384   FE19             ; 1440 }
2385   FE19             ; 1441 
2386   FE19             ; 1442 void MoveCursorLeft(...) {
2387   FE19             movecursorleft: 
2388   FE19             ; 1443     hl--;
2389   FE19 2B          	dec hl
2390   FE1A             ; 1444     MoveCursorBoundary(hl);
2391   FE1A C3 FF FD    	jp movecursorboundary
2392   FE1D             ; 1445 }
2393   FE1D             ; 1446 
2394   FE1D             ; 1447 void MoveCursorLf(...) {
2395   FE1D             movecursorlf: 
2396   FE1D             ; 1448     hl += (bc = SCREEN_WIDTH);
2397   FE1D 01 40 00    	ld bc, 64
2398   FE20 09          	add hl, bc
2399   FE21             ; 1449     TryScrollUp(hl);
2400   FE21             ; 1450 }
2401   FE21             ; 1451 
2402   FE21             ; 1452 void TryScrollUp(...) {
2403   FE21             tryscrollup: 
2404   FE21             ; 1453     swap(hl, de);
2405   FE21 EB          	ex hl, de
2406   FE22             ; 1454     hl = -(SCREEN_BEGIN + SCREEN_WIDTH * SCREEN_HEIGHT);
2407   FE22 21 C0 11    	ld hl, 4544
2408   FE25             ; 1455     hl += de;
2409   FE25 19          	add hl, de
2410   FE26             ; 1456     swap(hl, de);
2411   FE26 EB          	ex hl, de
2412   FE27             ; 1457     if (flag_nc)
2413   FE27             ; 1458         return PrintCharSaveCursor(hl);
2414   FE27 D2 25 FD    	jp nc, printcharsavecursor
2415   FE2A             ; 1459 
2416   FE2A             ; 1460     push_pop(hl) {
2417   FE2A E5          	push hl
2418   FE2B             ; 1461         hl = SCREEN_BEGIN + SCREEN_WIDTH * SCREEN_HEIGHT - 1;
2419   FE2B 21 3F EE    	ld hl, 60991
2420   FE2E             ; 1462         c = SCREEN_WIDTH;
2421   FE2E 0E 40       	ld c, 64
2422   FE30             ; 1463         do {
2423   FE30             l_142: 
2424   FE30             ; 1464             push_pop(hl) {
2425   FE30 E5          	push hl
2426   FE31             ; 1465                 de = SCREEN_SIZE - SCREEN_WIDTH;
2427   FE31 11 C0 07    	ld de, 1984
2428   FE34             ; 1466                 b = 0;
2429   FE34 06 00       	ld b, 0
2430   FE36             ; 1467                 c = a = color;
2431   FE36 3A 59 F7    	ld a, (color)
2432   FE39 4F          	ld c, a
2433   FE3A             ; 1468                 do {
2434   FE3A             l_145: 
2435   FE3A             ; 1469                     a = b;
2436   FE3A 78          	ld a, b
2437   FE3B             ; 1470                     b = *hl;
2438   FE3B 46          	ld b, (hl)
2439   FE3C             ; 1471                     *hl = a;
2440   FE3C 77          	ld (hl), a
2441   FE3D             ; 1472                     h = ((a = h) -= (SCREEN_SIZE >> 8));
2442   FE3D 7C          	ld a, h
2443   FE3E D6 08       	sub 8
2444   FE40 67          	ld h, a
2445   FE41             ; 1473                     a = c;
2446   FE41 79          	ld a, c
2447   FE42             ; 1474                     c = *hl;
2448   FE42 4E          	ld c, (hl)
2449   FE43             ; 1475                     *hl = a;
2450   FE43 77          	ld (hl), a
2451   FE44             ; 1476                     hl += de;
2452   FE44 19          	add hl, de
2453   FE45             l_146: 
2454   FE45             ; 1477                 } while ((a = h) != (SCREEN_BEGIN >> 8) - 1);
2455   FE45 7C          	ld a, h
2456   FE46 FE E7       	cp 65511
2457   FE48 C2 3A FE    	jp nz, l_145
2458   FE4B E1          	pop hl
2459   FE4C             ; 1478             }
2460   FE4C             ; 1479             l--;
2461   FE4C 2D          	dec l
2462   FE4D             l_143: 
2463   FE4D             ; 1480         } while ((a = l) != SCREEN_BEGIN + SCREEN_WIDTH * SCREEN_HEIGHT - 1 - SCREEN_WIDTH);
2464   FE4D 7D          	ld a, l
2465   FE4E FE FF       	cp 60927
2466   FE50 C2 30 FE    	jp nz, l_142
2467   FE53 E1          	pop hl
2468   FE54             ; 1481     }
2469   FE54             ; 1482     MoveCursorUp();
2470   FE54             ; 1483 }
2471   FE54             ; 1484 
2472   FE54             ; 1485 void MoveCursorUp(...) {
2473   FE54             movecursorup: 
2474   FE54             ; 1486     MoveCursor(hl, bc = -SCREEN_WIDTH);
2475   FE54 01 C0 FF    	ld bc, 65472
2476   FE57             ; 1487 }
2477   FE57             ; 1488 
2478   FE57             ; 1489 void MoveCursor(...) {
2479   FE57             movecursor: 
2480   FE57             ; 1490     hl += bc;
2481   FE57 09          	add hl, bc
2482   FE58             ; 1491     MoveCursorBoundary(hl);
2483   FE58 C3 FF FD    	jp movecursorboundary
2484   FE5B             ; 1492 }
2485   FE5B             ; 1493 
2486   FE5B             ; 1494 void MoveCursorDown(...) {
2487   FE5B             movecursordown: 
2488   FE5B             ; 1495     MoveCursor(hl, bc = SCREEN_WIDTH);
2489   FE5B 01 40 00    	ld bc, 64
2490   FE5E C3 57 FE    	jp movecursor
2491   FE61             ; 1496 }
2492   FE61             ; 1497 
2493   FE61             ; 1498 // Функция для пользовательской программы.
2494   FE61             ; 1499 // 1) Эта функция вызывается из CP/M при выводе каждого символа.
2495   FE61             ; 1500 // 2) Эта функция вызывается из игры Zork перед вызовом ReadKey
2496   FE61             ; 1501 // Нажата ли хотя бы одна клавиша на клавиатуре?
2497   FE61             ; 1502 // Параметры: нет. Результат:  a - 0xFF если клавиша нажата, 0 если нет. Сохраняет: bc, de, hl.
2498   FE61             ; 1503 
2499   FE61             ; 1504 void IsAnyKeyPressed3();
2500   FE61             ; 1505 
2501   FE61             ; 1506 void IsAnyKeyPressed() {
2502   FE61             isanykeypressed: 
2503   FE61             ; 1507     // Если ли клавиша в буфере
2504   FE61             ; 1508     IsAnyKeyPressed3();
2505   FE61 CD B4 FE    	call isanykeypressed3
2506   FE64             ; 1509     if (flag_nz)
2507   FE64             ; 1510         return;
2508   FE64 C0          	ret nz
2509   FE65             ; 1511     
2510   FE65             ; 1512     // Если при прошлом вызове была нажата клавиша
2511   FE65             ; 1513     a = keyLast;
2512   FE65 3A 61 F7    	ld a, (keylast)
2513   FE68             ; 1514     a++;
2514   FE68 3C          	inc a
2515   FE69             ; 1515     if (flag_nz) {
2516   FE69 CA 76 FE    	jp z, l_148
2517   FE6C             ; 1516         // Если клавиша все еще нажата
2518   FE6C             ; 1517         out(PORT_KEYBOARD_COLUMN, a ^= a);
2519   FE6C AF          	xor a
2520   FE6D D3 07       	out (7), a
2521   FE6F             ; 1518         a = in(PORT_KEYBOARD_ROW);
2522   FE6F DB 06       	in a, (6)
2523   FE71             ; 1519         invert(a);
2524   FE71 2F          	cpl
2525   FE72             ; 1520         a += a;
2526   FE72 87          	add a
2527   FE73             ; 1521         // Выход с кодом 0, если клавиша все еще нажата 
2528   FE73             ; 1522         a = 0;
2529   FE73 3E 00       	ld a, 0
2530   FE75             ; 1523         if (flag_nz)
2531   FE75             ; 1524             return;
2532   FE75 C0          	ret nz
2533   FE76             l_148: 
2534   FE76             ; 1525     }
2535   FE76             ; 1526     
2536   FE76             ; 1527     IsAnyKeyPressed2();
2537   FE76             ; 1528 }
2538   FE76             ; 1529 
2539   FE76             ; 1530 void IsAnyKeyPressed2() {
2540   FE76             isanykeypressed2: 
2541   FE76             ; 1531     push_pop(bc, de, hl) {
2542   FE76 C5          	push bc
2543   FE77 D5          	push de
2544   FE78 E5          	push hl
2545   FE79             ; 1532         hl = keyDelay;
2546   FE79 2A 60 F7    	ld hl, (keydelay)
2547   FE7C             ; 1533         ReadKeyInternal(hl);
2548   FE7C CD BB FE    	call readkeyinternal
2549   FE7F             ; 1534         l = 32; // Задержка повтора нажатия клавиши
2550   FE7F 2E 20       	ld l, 32
2551   FE81             ; 1535         if (flag_nz) { // Это было первое нажатие клавиши. Антидребезг.
2552   FE81 CA 90 FE    	jp z, l_150
2553   FE84             ; 1536             l = 2;
2554   FE84 2E 02       	ld l, 2
2555   FE86             ; 1537             ReadKeyInternal(hl);
2556   FE86 CD BB FE    	call readkeyinternal
2557   FE89             ; 1538             if (flag_nz)
2558   FE89             ; 1539                 a = 0xFF;
2559   FE89 CA 8E FE    	jp z, l_152
2560   FE8C 3E FF       	ld a, 255
2561   FE8E             l_152: 
2562   FE8E             ; 1540             l = 128; // Задержка повтора первого нажатия клавиши
2563   FE8E 2E 80       	ld l, 128
2564   FE90             l_150: 
2565   FE90             ; 1541         }
2566   FE90             ; 1542         keyDelay = hl;
2567   FE90 22 60 F7    	ld (keydelay), hl
2568   FE93             ; 1543 
2569   FE93             ; 1544         if (a == SCAN_RUS) {
2570   FE93 FE 36       	cp 54
2571   FE95 C2 AC FE    	jp nz, l_154
2572   FE98             ; 1545             a = in(PORT_KEYBOARD_MODS);
2573   FE98 DB 05       	in a, (5)
2574   FE9A             ; 1546             carry_rotate_right(a, 3); // Shift
2575   FE9A 1F          	rra
2576   FE9B 1F          	rra
2577   FE9C 1F          	rra
2578   FE9D             ; 1547             a = KEYBOARD_MODE_CAP;
2579   FE9D 3E 02       	ld a, 2
2580   FE9F             ; 1548             carry_sub(a, 0); // KEYBOARD_MODE_CAP -> KEYBOARD_MODE_RUS
2581   FE9F DE 00       	sbc 0
2582   FEA1             ; 1549             hl = &keyboardMode;
2583   FEA1 21 58 F7    	ld hl, 0FFFFh & (keyboardmode)
2584   FEA4             ; 1550             a ^= *hl;
2585   FEA4 AE          	xor (hl)
2586   FEA5             ; 1551             *hl = a;
2587   FEA5 77          	ld (hl), a
2588   FEA6             ; 1552             PrintKeyStatus();
2589   FEA6 CD D7 FF    	call printkeystatus
2590   FEA9 C3 B1 FE    	jp l_155
2591   FEAC             l_154: 
2592   FEAC             ; 1553         } else {
2593   FEAC             ; 1554             a = c;
2594   FEAC 79          	ld a, c
2595   FEAD             ; 1555             a++;
2596   FEAD 3C          	inc a
2597   FEAE             ; 1556             keyBuffer = a;
2598   FEAE 32 56 F7    	ld (keybuffer), a
2599   FEB1             l_155: 
2600   FEB1 E1          	pop hl
2601   FEB2 D1          	pop de
2602   FEB3 C1          	pop bc
2603   FEB4             ; 1557         }
2604   FEB4             ; 1558     }
2605   FEB4             ; 1559     IsAnyKeyPressed3();
2606   FEB4             ; 1560 }
2607   FEB4             ; 1561 
2608   FEB4             ; 1562 void IsAnyKeyPressed3() {
2609   FEB4             isanykeypressed3: 
2610   FEB4             ; 1563     a = keyBuffer;
2611   FEB4 3A 56 F7    	ld a, (keybuffer)
2612   FEB7             ; 1564     a += 0xFF;
2613   FEB7 C6 FF       	add 255
2614   FEB9             ; 1565     carry_sub(a, a);
2615   FEB9 9F          	sbc a
2616   FEBA C9          	ret
2617   FEBB             ; 1566 }
2618   FEBB             ; 1567 
2619   FEBB             ; 1568 void ReadKeyInternal(...) {
2620   FEBB             readkeyinternal: 
2621   FEBB             ; 1569     do {
2622   FEBB             l_156: 
2623   FEBB             ; 1570         ScanKey();
2624   FEBB CD E9 FE    	call scankey
2625   FEBE             ; 1571         c = a;
2626   FEBE 4F          	ld c, a
2627   FEBF             ; 1572         a = keyCode;
2628   FEBF 3A 57 F7    	ld a, (keycode)
2629   FEC2             ; 1573         compare(a, h);
2630   FEC2 BC          	cp h
2631   FEC3             ; 1574         h = a;
2632   FEC3 67          	ld h, a
2633   FEC4             ; 1575         if (flag_nz) // Нажата другая клавиша
2634   FEC4             ; 1576             return;
2635   FEC4 C0          	ret nz
2636   FEC5             ; 1577         if (a == 0xFF)
2637   FEC5 FE FF       	cp 255
2638   FEC7             ; 1578             return; // Ни одна клавиша не нажата
2639   FEC7 C8          	ret z
2640   FEC8             ; 1579         
2641   FEC8             ; 1580         // Задержка
2642   FEC8             ; 1581         b = 0;
2643   FEC8 06 00       	ld b, 0
2644   FECA             ; 1582         do {
2645   FECA             l_159: 
2646   FECA             ; 1583             swap(hl, de);
2647   FECA EB          	ex hl, de
2648   FECB             ; 1584             swap(hl, de);
2649   FECB EB          	ex hl, de
2650   FECC             l_160: 
2651   FECC             ; 1585         } while (flag_nz(b--));
2652   FECC 05          	dec b
2653   FECD C2 CA FE    	jp nz, l_159
2654   FED0             l_157: 
2655   FED0             ; 1586     } while (flag_nz(l--));
2656   FED0 2D          	dec l
2657   FED1 C2 BB FE    	jp nz, l_156
2658   FED4 C9          	ret
2659   FED5             ; 1587 }
2660   FED5             ; 1588 
2661   FED5             ; 1589 
2662   FED5             ; 1590 // Функция для пользовательской программы.
2663   FED5             ; 1591 // Получить код нажатой клавиши на клавиатуре.
2664   FED5             ; 1592 // В отличии от функции ScanKey, в этой функции есть задержка повтора.
2665   FED5             ; 1593 // Параметры: нет. Результат: a. Сохраняет: bc, de, hl.
2666   FED5             ; 1594 
2667   FED5             ; 1595 void ReadKey() {
2668   FED5             readkey: 
2669   FED5             ; 1596     push_pop(hl) {
2670   FED5 E5          	push hl
2671   FED6             ; 1597         hl = &keyBuffer;
2672   FED6 21 56 F7    	ld hl, 0FFFFh & (keybuffer)
2673   FED9             ; 1598         for (;;) {
2674   FED9             l_163: 
2675   FED9             ; 1599             a = *hl;
2676   FED9 7E          	ld a, (hl)
2677   FEDA             ; 1600             if (a != 0)
2678   FEDA B7          	or a
2679   FEDB             ; 1601                 break;
2680   FEDB C2 E4 FE    	jp nz, l_164
2681   FEDE             ; 1602             IsAnyKeyPressed2();
2682   FEDE CD 76 FE    	call isanykeypressed2
2683   FEE1 C3 D9 FE    	jp l_163
2684   FEE4             l_164: 
2685   FEE4             ; 1603         }
2686   FEE4             ; 1604         *hl = 0;
2687   FEE4 36 00       	ld (hl), 0
2688   FEE6             ; 1605         a--;
2689   FEE6 3D          	dec a
2690   FEE7 E1          	pop hl
2691   FEE8 C9          	ret
2692   FEE9             ; 1606     }
2693   FEE9             ; 1607 }
2694   FEE9             ; 1608     
2695   FEE9             ; 1609 // Функция для пользовательской программы.
2696   FEE9             ; 1610 // Получить код нажатой клавиши на клавиатуре.
2697   FEE9             ; 1611 // Параметры: нет. Результат: a. Сохраняет: bc, de, hl.
2698   FEE9             ; 1612 
2699   FEE9             ; 1613 void ScanKey() {
2700   FEE9             scankey: 
2701   FEE9             ; 1614     push(bc, de, hl);
2702   FEE9 C5          	push bc
2703   FEEA D5          	push de
2704   FEEB E5          	push hl
2705   FEEC             ; 1615 
2706   FEEC             ; 1616     bc = 0xFEFE;
2707   FEEC 01 FE FE    	ld bc, 65278
2708   FEEF             ; 1617     do {
2709   FEEF             l_165: 
2710   FEEF             ; 1618         a = c;
2711   FEEF 79          	ld a, c
2712   FEF0             ; 1619         out(PORT_KEYBOARD_COLUMN, a);
2713   FEF0 D3 07       	out (7), a
2714   FEF2             ; 1620         a = in(PORT_KEYBOARD_ROW);
2715   FEF2 DB 06       	in a, (6)
2716   FEF4             ; 1621         invert(a);
2717   FEF4 2F          	cpl
2718   FEF5             ; 1622         a += a;
2719   FEF5 87          	add a
2720   FEF6             ; 1623         if (flag_nz)
2721   FEF6             ; 1624             return ScanKey2(a);
2722   FEF6 C2 13 FF    	jp nz, scankey2
2723   FEF9             ; 1625         b = ((a = b) += KEYBOARD_ROW_COUNT);
2724   FEF9 78          	ld a, b
2725   FEFA C6 07       	add 7
2726   FEFC 47          	ld b, a
2727   FEFD             ; 1626         a = c;
2728   FEFD 79          	ld a, c
2729   FEFE             ; 1627         cyclic_rotate_left(a, 1);
2730   FEFE 07          	rlca
2731   FEFF             ; 1628         c = a;
2732   FEFF 4F          	ld c, a
2733   FF00             l_166: 
2734   FF00 DA EF FE    	jp c, l_165
2735   FF03             ; 1629     } while (flag_c);
2736   FF03             ; 1630 
2737   FF03             ; 1631     a = in(PORT_KEYBOARD_MODS);
2738   FF03 DB 05       	in a, (5)
2739   FF05             ; 1632     carry_rotate_right(a, 1);
2740   FF05 1F          	rra
2741   FF06             ; 1633     b++;
2742   FF06 04          	inc b
2743   FF07             ; 1634     b++;
2744   FF07 04          	inc b
2745   FF08             ; 1635     if (flag_nc)
2746   FF08             ; 1636         return ScanKey3(b);
2747   FF08 D2 18 FF    	jp nc, scankey3
2748   FF0B             ; 1637     keyCode = a = 0xFF;
2749   FF0B 3E FF       	ld a, 255
2750   FF0D 32 57 F7    	ld (keycode), a
2751   FF10             ; 1638     ScanKeyExit(a);
2752   FF10 C3 6E FF    	jp scankeyexit
2753   FF13             ; 1639 }
2754   FF13             ; 1640 
2755   FF13             ; 1641 void ScanKey2(...) {
2756   FF13             scankey2: 
2757   FF13             ; 1642     do {
2758   FF13             l_168: 
2759   FF13             ; 1643         b++;
2760   FF13 04          	inc b
2761   FF14             ; 1644         carry_rotate_right(a, 1);
2762   FF14 1F          	rra
2763   FF15             l_169: 
2764   FF15 D2 13 FF    	jp nc, l_168
2765   FF18             ; 1645     } while (flag_nc);
2766   FF18             ; 1646     ScanKey3(b);
2767   FF18             ; 1647 }
2768   FF18             ; 1648 
2769   FF18             ; 1649 void ScanKey3(...) {
2770   FF18             scankey3: 
2771   FF18             ; 1650     // b - key number
2772   FF18             ; 1651 
2773   FF18             ; 1652     //  0    0    1 !   2 "   3 #   4 $   5 %   6 &   7 ,
2774   FF18             ; 1653     //  8   8 (   9 )   : *   ; +   , <   - =   . >   / ?
2775   FF18             ; 1654     // 16   @ Ю   A А   B Б   C Ц   D Д   E Е   F Ф   G Г
2776   FF18             ; 1655     // 24   H Х   I И   J Й   K К   L Л   M М   N Н   O О
2777   FF18             ; 1656     // 32   P П   Q Я   R Р   S С   T Т   U У   V Ж   W В
2778   FF18             ; 1657     // 40   X Ь   Y Ы   Z З   [ Ш   \ Э   ] Щ   ^ Ч    _
2779   FF18             ; 1658     // 48   Space Right Left  Up    Down  Vk    Str   Home
2780   FF18             ; 1659 
2781   FF18             ; 1660     a = b;
2782   FF18 78          	ld a, b
2783   FF19             ; 1661     keyCode = a;
2784   FF19 32 57 F7    	ld (keycode), a
2785   FF1C             ; 1662     if (a >= 48)
2786   FF1C FE 30       	cp 48
2787   FF1E             ; 1663         return ScanKeySpecial(a);
2788   FF1E D2 78 FF    	jp nc, scankeyspecial
2789   FF21             ; 1664     a += 48;
2790   FF21 C6 30       	add 48
2791   FF23             ; 1665     if (a >= 60)
2792   FF23 FE 3C       	cp 60
2793   FF25             ; 1666         if (a < 64)
2794   FF25 DA 2F FF    	jp c, l_171
2795   FF28 FE 40       	cp 64
2796   FF2A             ; 1667             a &= 47;
2797   FF2A D2 2F FF    	jp nc, l_173
2798   FF2D E6 2F       	and 47
2799   FF2F             l_173: 
2800   FF2F             l_171: 
2801   FF2F             ; 1668 
2802   FF2F             ; 1669     c = a;
2803   FF2F 4F          	ld c, a
2804   FF30             ; 1670 
2805   FF30             ; 1671     a = keyboardMode;
2806   FF30 3A 58 F7    	ld a, (keyboardmode)
2807   FF33             ; 1672     carry_rotate_right(a, 1);
2808   FF33 1F          	rra
2809   FF34             ; 1673     d = a;
2810   FF34 57          	ld d, a
2811   FF35             ; 1674     if (flag_c) { // KEYBOARD_MODE_RUS
2812   FF35 D2 3C FF    	jp nc, l_175
2813   FF38             ; 1675         a = c;
2814   FF38 79          	ld a, c
2815   FF39             ; 1676         a |= 0x20;
2816   FF39 F6 20       	or 32
2817   FF3B             ; 1677         c = a;
2818   FF3B 4F          	ld c, a
2819   FF3C             l_175: 
2820   FF3C             ; 1678     }
2821   FF3C             ; 1679 
2822   FF3C             ; 1680     a = in(PORT_KEYBOARD_MODS);
2823   FF3C DB 05       	in a, (5)
2824   FF3E             ; 1681     carry_rotate_right(a, 2);
2825   FF3E 1F          	rra
2826   FF3F 1F          	rra
2827   FF40             ; 1682     if (flag_nc)
2828   FF40             ; 1683         return ScanKeyControl(c);
2829   FF40 D2 72 FF    	jp nc, scankeycontrol
2830   FF43             ; 1684     carry_rotate_right(a, 1);
2831   FF43 1F          	rra
2832   FF44             ; 1685     a = c;
2833   FF44 79          	ld a, c
2834   FF45             ; 1686     if (flag_nc) {
2835   FF45 DA 51 FF    	jp c, l_177
2836   FF48             ; 1687         a ^= 0x10;
2837   FF48 EE 10       	xor 16
2838   FF4A             ; 1688         if (a >= 64)
2839   FF4A FE 40       	cp 64
2840   FF4C             ; 1689             a ^= 0x80 | 0x10;
2841   FF4C DA 51 FF    	jp c, l_179
2842   FF4F EE 90       	xor 144
2843   FF51             l_179: 
2844   FF51             l_177: 
2845   FF51             ; 1690     }
2846   FF51             ; 1691     c = a;
2847   FF51 4F          	ld c, a
2848   FF52             ; 1692     a = d;
2849   FF52 7A          	ld a, d
2850   FF53             ; 1693     carry_rotate_right(a, 1);
2851   FF53 1F          	rra
2852   FF54             ; 1694     if (flag_c) { // KEYBOARD_MODE_CAP
2853   FF54 D2 6D FF    	jp nc, l_181
2854   FF57             ; 1695         a = c;
2855   FF57 79          	ld a, c
2856   FF58             ; 1696         a &= 0x7F;
2857   FF58 E6 7F       	and 127
2858   FF5A             ; 1697         if (a >= 0x60)  // Кириллица
2859   FF5A FE 60       	cp 96
2860   FF5C             ; 1698             goto convert;
2861   FF5C D2 69 FF    	jp nc, convert
2862   FF5F             ; 1699         if (a >= 'A') {
2863   FF5F FE 41       	cp 65
2864   FF61 DA 6D FF    	jp c, l_183
2865   FF64             ; 1700             if (a < 'Z' + 1) {
2866   FF64 FE 5B       	cp 91
2867   FF66 D2 6D FF    	jp nc, l_185
2868   FF69             ; 1701 convert:        a = c;
2869   FF69             convert: 
2870   FF69 79          	ld a, c
2871   FF6A             ; 1702                 a ^= 0x80;
2872   FF6A EE 80       	xor 128
2873   FF6C             ; 1703                 c = a;
2874   FF6C 4F          	ld c, a
2875   FF6D             l_185: 
2876   FF6D             l_183: 
2877   FF6D             l_181: 
2878   FF6D             ; 1704             }
2879   FF6D             ; 1705         }
2880   FF6D             ; 1706     }
2881   FF6D             ; 1707     a = c;
2882   FF6D 79          	ld a, c
2883   FF6E             ; 1708     ScanKeyExit(a);
2884   FF6E             ; 1709 }
2885   FF6E             ; 1710 
2886   FF6E             ; 1711 void ScanKeyExit(...) {
2887   FF6E             scankeyexit: 
2888   FF6E             ; 1712     pop(bc, de, hl);
2889   FF6E E1          	pop hl
2890   FF6F D1          	pop de
2891   FF70 C1          	pop bc
2892   FF71 C9          	ret
2893   FF72             ; 1713 }
2894   FF72             ; 1714 
2895   FF72             ; 1715 void ScanKeyControl(...) {
2896   FF72             scankeycontrol: 
2897   FF72             ; 1716     a = c;
2898   FF72 79          	ld a, c
2899   FF73             ; 1717     a &= 0x1F;
2900   FF73 E6 1F       	and 31
2901   FF75             ; 1718     ScanKeyExit(a);
2902   FF75 C3 6E FF    	jp scankeyexit
2903   FF78             ; 1719 }
2904   FF78             ; 1720 
2905   FF78             ; 1721 void ScanKeySpecial(...) {
2906   FF78             scankeyspecial: 
2907   FF78             ; 1722     h = (uintptr_t)specialKeyTable >> 8;
2908   FF78 26 FF       	ld h, 0FFh & ((0FFFFh & (0FFFFh & (specialkeytable))) >> (8))
2909   FF7A             ; 1723     l = (a += (uintptr_t)specialKeyTable - 48);
2910   FF7A C6 51       	add 0FFh & ((0FFFFh & (0FFFFh & (specialkeytable))) - (48))
2911   FF7C 6F          	ld l, a
2912   FF7D             ; 1724     a = *hl;
2913   FF7D 7E          	ld a, (hl)
2914   FF7E             ; 1725     ScanKeyExit(a);
2915   FF7E C3 6E FF    	jp scankeyexit
2916   FF81             ; 1726 }
2917   FF81             ; 1727 
2918   FF81             ; 1728 uint8_t specialKeyTable[] = {
2919   FF81             specialkeytable: 
2920   FF81 20          	db 32
2921   FF82 18          	db 24
2922   FF83 08          	db 8
2923   FF84 19          	db 25
2924   FF85 1A          	db 26
2925   FF86 0D          	db 13
2926   FF87 1F          	db 31
2927   FF88 0C          	db 12
2928   FF89 7F          	db 127
2929   FF8A             ; 1740  aPrompt[] = "\r\n-->";
2930   FF8A             aprompt: 
2931   FF8A 0D          	db 13
2932   FF8B 0A          	db 10
2933   FF8C 2D          	db 45
2934   FF8D 2D          	db 45
2935   FF8E 3E          	db 62
2936   FF8F 00          	ds 1
2937   FF90             ; 1741  aCrLfTab[] = "\r\n\x18\x18\x18";
2938   FF90             acrlftab: 
2939   FF90 0D          	db 13
2940   FF91 0A          	db 10
2941   FF92 18          	db 24
2942   FF93 18          	db 24
2943   FF94 18          	db 24
2944   FF95 00          	ds 1
2945   FF96             ; 1742  aRegisters[] = "\r\nPC-\r\nHL-\r\nBC-\r\nDE-\r\nSP-\r\nAF-\x19\x19\x19\x19\x19\x19";
2946   FF96             aregisters: 
2947   FF96 0D          	db 13
2948   FF97 0A          	db 10
2949   FF98 50          	db 80
2950   FF99 43          	db 67
2951   FF9A 2D          	db 45
2952   FF9B 0D          	db 13
2953   FF9C 0A          	db 10
2954   FF9D 48          	db 72
2955   FF9E 4C          	db 76
2956   FF9F 2D          	db 45
2957   FFA0 0D          	db 13
2958   FFA1 0A          	db 10
2959   FFA2 42          	db 66
2960   FFA3 43          	db 67
2961   FFA4 2D          	db 45
2962   FFA5 0D          	db 13
2963   FFA6 0A          	db 10
2964   FFA7 44          	db 68
2965   FFA8 45          	db 69
2966   FFA9 2D          	db 45
2967   FFAA 0D          	db 13
2968   FFAB 0A          	db 10
2969   FFAC 53          	db 83
2970   FFAD 50          	db 80
2971   FFAE 2D          	db 45
2972   FFAF 0D          	db 13
2973   FFB0 0A          	db 10
2974   FFB1 41          	db 65
2975   FFB2 46          	db 70
2976   FFB3 2D          	db 45
2977   FFB4 19          	db 25
2978   FFB5 19          	db 25
2979   FFB6 19          	db 25
2980   FFB7 19          	db 25
2981   FFB8 19          	db 25
2982   FFB9 19          	db 25
2983   FFBA 00          	ds 1
2984   FFBB             ; 1743  aBackspace[] = "\x08 \x08";
2985   FFBB             abackspace: 
2986   FFBB 08          	db 8
2987   FFBC 20          	db 32
2988   FFBD 08          	db 8
2989   FFBE 00          	ds 1
2990   FFBF             ; 1744  aHello[] = "\x1FМИКРО 80\x1BБ";
2991   FFBF             ahello: 
2992   FFBF 1F          	db 31
2993   FFC0 6D          	db 109
2994   FFC1 69          	db 105
2995   FFC2 6B          	db 107
2996   FFC3 72          	db 114
2997   FFC4 6F          	db 111
2998   FFC5 20          	db 32
2999   FFC6 38          	db 56
3000   FFC7 30          	db 48
3001   FFC8 1B          	db 27
3002   FFC9 62          	db 98
3003   FFCA 00          	ds 1
3004   FFCB             ; 1751  aZag[3] = "Заг";
3005   FFCB             azag: 
3006   FFCB 7A          	db 122
3007   FFCC E1          	db 225
3008   FFCD E7          	db 231
3009   FFCE             ; 1752  aStr[3] = "Стр";
3010   FFCE             astr: 
3011   FFCE 73          	db 115
3012   FFCF F4          	db 244
3013   FFD0 F2          	db 242
3014   FFD1             ; 1753  aLat[3] = "Лат";
3015   FFD1             alat: 
3016   FFD1 6C          	db 108
3017   FFD2 E1          	db 225
3018   FFD3 F4          	db 244
3019   FFD4             ; 1754  aRus[3] = "Рус";
3020   FFD4             arus: 
3021   FFD4 72          	db 114
3022   FFD5 F5          	db 245
3023   FFD6 F3          	db 243
3024   FFD7             ; 1756  PrintKeyStatus() {
3025   FFD7             printkeystatus: 
3026   FFD7             ; 1757     bc = SCREEN_BEGIN + 56 + 31 * SCREEN_WIDTH;
3027   FFD7 01 F8 EF    	ld bc, 61432
3028   FFDA             ; 1758     a = keyboardMode;
3029   FFDA 3A 58 F7    	ld a, (keyboardmode)
3030   FFDD             ; 1759     hl = aLat;
3031   FFDD 21 D1 FF    	ld hl, 0FFFFh & (alat)
3032   FFE0             ; 1760     PrintKeyStatusInt(a, bc, hl);
3033   FFE0 CD E6 FF    	call printkeystatusint
3034   FFE3             ; 1761     bc++;
3035   FFE3 03          	inc bc
3036   FFE4             ; 1762     l = aZag;
3037   FFE4 2E CB       	ld l, 0FFh & (azag)
3038   FFE6             ; 1763     PrintKeyStatusInt(a, bc, hl);
3039   FFE6             ; 1764 }
3040   FFE6             ; 1765 
3041   FFE6             ; 1766 void PrintKeyStatusInt(...) {
3042   FFE6             printkeystatusint: 
3043   FFE6             ; 1767     de = sizeof(aZag);
3044   FFE6 11 03 00    	ld de, 3
3045   FFE9             ; 1768     cyclic_rotate_right(a, 1);
3046   FFE9 0F          	rrca
3047   FFEA             ; 1769     if (flag_c)
3048   FFEA             ; 1770         hl += de;
3049   FFEA D2 EE FF    	jp nc, l_187
3050   FFED 19          	add hl, de
3051   FFEE             l_187: 
3052   FFEE             ; 1771     d = a;
3053   FFEE 57          	ld d, a
3054   FFEF             ; 1772     do {
3055   FFEF             l_189: 
3056   FFEF             ; 1773         *bc = a = *hl;
3057   FFEF 7E          	ld a, (hl)
3058   FFF0 02          	ld (bc), a
3059   FFF1             ; 1774         bc++;
3060   FFF1 03          	inc bc
3061   FFF2             ; 1775         hl++;
3062   FFF2 23          	inc hl
3063   FFF3             l_190: 
3064   FFF3             ; 1776     } while (flag_nz(e--));
3065   FFF3 1D          	dec e
3066   FFF4 C2 EF FF    	jp nz, l_189
3067   FFF7             ; 1777     a = d;
3068   FFF7 7A          	ld a, d
3069   FFF8 C9          	ret
3070   FFF9              savebin "micro80.bin", 0xF800, 0x10000
3071   FFF9             
