0001   0000                 device zxspectrum48 ; It has nothing to do with ZX Spectrum 48K, it is needed for the sjasmplus compiler.
0002   0000             rst30opcode equ 48
0003   0000             rst30address equ 49
0004   0000             rst38opcode equ 56
0005   0000             rst38address equ 57
0006   0000             keycode equ 63319
0007   0000             keyboardmode equ 63320
0008   0000             color equ 63321
0009   0000             cursor equ 63322
0010   0000             tapereadspeed equ 63324
0011   0000             tapewritespeed equ 63325
0012   0000             cursorvisible equ 63326
0013   0000             escstate equ 63327
0014   0000             keydelay equ 63328
0015   0000             regpc equ 63330
0016   0000             reghl equ 63332
0017   0000             regbc equ 63334
0018   0000             regde equ 63336
0019   0000             regsp equ 63338
0020   0000             regaf equ 63340
0021   0000             breakpointaddress equ 63345
0022   0000             breakpointvalue equ 63347
0023   0000             jmpparam1opcode equ 63348
0024   0000             param1 equ 63349
0025   0000             param2 equ 63351
0026   0000             param3 equ 63353
0027   0000             param2exists equ 63355
0028   0000             tapepolarity equ 63356
0029   0000             ramtop equ 63361
0030   0000             inputbuffer equ 63363
0031   0000             jmpparam1 equ 63348
0032   0000              .org 0xF800
0033   F800             ; 67  uint8_t rst30Opcode __address(0x30);
0034   F800             ; 68 extern uint16_t rst30Address __address(0x31);
0035   F800             ; 69 extern uint8_t rst38Opcode __address(0x38);
0036   F800             ; 70 extern uint16_t rst38Address __address(0x39);
0037   F800             ; 71 
0038   F800             ; 72 // Прототипы
0039   F800             ; 73 void Reboot(...);
0040   F800             ; 74 void EntryF86C_Monitor(...);
0041   F800             ; 75 void Monitor(...);
0042   F800             ; 76 void Monitor2();
0043   F800             ; 77 void ReadString(...);
0044   F800             ; 78 void PrintString(...);
0045   F800             ; 79 void ParseParams(...);
0046   F800             ; 80 void ParseWord(...);
0047   F800             ; 81 void CompareHlDe(...);
0048   F800             ; 82 void LoopWithBreak(...);
0049   F800             ; 83 void Loop(...);
0050   F800             ; 84 void PopRet();
0051   F800             ; 85 void IncHl(...);
0052   F800             ; 86 void CtrlC(...);
0053   F800             ; 87 void PrintCrLfTab();
0054   F800             ; 88 void PrintHexByteFromHlSpace(...);
0055   F800             ; 89 void PrintHexByteSpace(...);
0056   F800             ; 90 #ifdef CMD_R_ENABLED
0057   F800             ; 91 void CmdR(...);
0058   F800             ; 92 #endif
0059   F800             ; 93 void GetRamTop(...);
0060   F800             ; 94 void SetRamTop(...);
0061   F800             ; 95 #ifdef CMD_A_ENABLED
0062   F800             ; 96 void CmdA(...);
0063   F800             ; 97 #endif
0064   F800             ; 98 void CmdD(...);
0065   F800             ; 99 void PrintSpacesTo(...);
0066   F800             ; 100 void PrintSpace();
0067   F800             ; 101 void CmdC(...);
0068   F800             ; 102 void CmdF(...);
0069   F800             ; 103 void CmdS(...);
0070   F800             ; 104 void CmdW(...);
0071   F800             ; 105 void CmdT(...);
0072   F800             ; 106 void CmdM(...);
0073   F800             ; 107 void CmdG(...);
0074   F800             ; 108 void BreakPointHandler(...);
0075   F800             ; 109 void CmdX(...);
0076   F800             ; 110 void GetCursor();
0077   F800             ; 111 void GetCursorChar();
0078   F800             ; 112 void CmdH(...);
0079   F800             ; 113 void CmdI(...);
0080   F800             ; 114 void MonitorError();
0081   F800             ; 115 void ReadTapeFile(...);
0082   F800             ; 116 void ReadTapeWordNext();
0083   F800             ; 117 void ReadTapeWord(...);
0084   F800             ; 118 void ReadTapeBlock(...);
0085   F800             ; 119 void CalculateCheckSum(...);
0086   F800             ; 120 void CmdO(...);
0087   F800             ; 121 void WriteTapeFile(...);
0088   F800             ; 122 void PrintCrLfTabHexWordSpace(...);
0089   F800             ; 123 void PrintHexWordSpace(...);
0090   F800             ; 124 void WriteTapeBlock(...);
0091   F800             ; 125 void WriteTapeWord(...);
0092   F800             ; 126 void ReadTapeByte(...);
0093   F800             ; 127 void ReadTapeByteInternal(...);
0094   F800             ; 128 void ReadTapeByteTimeout(...);
0095   F800             ; 129 void WriteTapeByte(...);
0096   F800             ; 130 void PrintHexByte(...);
0097   F800             ; 131 void PrintHexNibble(...);
0098   F800             ; 132 void PrintCharA(...);
0099   F800             ; 133 void PrintChar(...);
0100   F800             ; 134 void PrintCharSetEscState(...);
0101   F800             ; 135 void PrintCharSaveCursor(...);
0102   F800             ; 136 void PrintCharExit(...);
0103   F800             ; 137 void DrawCursor(...);
0104   F800             ; 138 void PrintCharEscY2(...);
0105   F800             ; 139 void PrintCharResetEscState(...);
0106   F800             ; 140 void PrintCharEsc(...);
0107   F800             ; 141 void SetCursorVisible(...);
0108   F800             ; 142 void PrintCharNoEsc(...);
0109   F800             ; 143 void PrintChar4(...);
0110   F800             ; 144 void ClearScreen(...);
0111   F800             ; 145 void MoveCursorHome(...);
0112   F800             ; 146 void PrintChar3(...);
0113   F800             ; 147 void PrintCharBeep(...);
0114   F800             ; 148 void MoveCursorCr(...);
0115   F800             ; 149 void MoveCursorRight(...);
0116   F800             ; 150 void MoveCursorBoundary(...);
0117   F800             ; 151 void MoveCursorLeft(...);
0118   F800             ; 152 void MoveCursorLf(...);
0119   F800             ; 153 void MoveCursorUp(...);
0120   F800             ; 154 void MoveCursor(...);
0121   F800             ; 155 void MoveCursorDown(...);
0122   F800             ; 156 void IsAnyKeyPressed();
0123   F800             ; 157 void ReadKey();
0124   F800             ; 158 void ReadKeyInternal(...);
0125   F800             ; 159 void ScanKey();
0126   F800             ; 160 void ScanKey2(...);
0127   F800             ; 161 void ScanKey3(...);
0128   F800             ; 162 void ScanKeyExit(...);
0129   F800             ; 163 void ScanKeyControl(...);
0130   F800             ; 164 void ScanKeySpecial(...);
0131   F800             ; 165 #ifdef CMD_A_ENABLED
0132   F800             ; 166 void TranslateCodePageDefault(...);
0133   F800             ; 167 #endif
0134   F800             ; 168 void TryScrollUp(...);
0135   F800             ; 169 void PrintKeyStatusInt(...);
0136   F800             ; 170 void PrintKeyStatus();
0137   F800             ; 171 
0138   F800             ; 172 // Переменные Монитора
0139   F800             ; 173 
0140   F800             ; 174 extern uint8_t keyCode __address(0xF757);
0141   F800             ; 175 extern uint8_t keyboardMode __address(0xF758);
0142   F800             ; 176 extern uint8_t color __address(0xF759);
0143   F800             ; 177 extern uint16_t cursor __address(0xF75A);
0144   F800             ; 178 extern uint8_t tapeReadSpeed __address(0xF75C);
0145   F800             ; 179 extern uint8_t tapeWriteSpeed __address(0xF75D);
0146   F800             ; 180 extern uint8_t cursorVisible __address(0xF75E);
0147   F800             ; 181 extern uint8_t escState __address(0xF75F);
0148   F800             ; 182 extern uint16_t keyDelay __address(0xF760);
0149   F800             ; 183 extern uint16_t regPC __address(0xF762);
0150   F800             ; 184 extern uint16_t regHL __address(0xF764);
0151   F800             ; 185 extern uint16_t regBC __address(0xF766);
0152   F800             ; 186 extern uint16_t regDE __address(0xF768);
0153   F800             ; 187 extern uint16_t regSP __address(0xF76A);
0154   F800             ; 188 extern uint16_t regAF __address(0xF76C);
0155   F800             ; 189 extern uint16_t breakPointAddress __address(0xF771);
0156   F800             ; 190 extern uint8_t breakPointValue __address(0xF773);
0157   F800             ; 191 extern uint8_t jmpParam1Opcode __address(0xF774);
0158   F800             ; 192 extern uint16_t param1 __address(0xF775);
0159   F800             ; 193 extern uint16_t param2 __address(0xF777);
0160   F800             ; 194 extern uint16_t param3 __address(0xF779);
0161   F800             ; 195 extern uint8_t param2Exists __address(0xF77B);
0162   F800             ; 196 extern uint8_t tapePolarity __address(0xF77C);
0163   F800             ; 197 #ifdef CMD_A_ENABLED
0164   F800             ; 198 extern uint8_t translateCodeEnabled __address(0xF77D);
0165   F800             ; 199 extern uint8_t translateCodePageJump __address(0xF77E);
0166   F800             ; 200 extern uint16_t translateCodePageAddress __address(0xF77F);
0167   F800             ; 201 #endif
0168   F800             ; 202 extern uint16_t ramTop __address(0xF781);
0169   F800             ; 203 extern uint8_t inputBuffer[32] __address(0xF783);
0170   F800             ; 204 
0171   F800             ; 205 #define firstVariableAddress (&keyboardMode)
0172   F800             ; 206 #define lastVariableAddress (&inputBuffer[sizeof(inputBuffer) - 1])
0173   F800             ; 207 
0174   F800             ; 208 extern uint8_t specialKeyTable[9];
0175   F800             ; 209 extern uint8_t aPrompt[6];
0176   F800             ; 210 extern uint8_t aCrLfTab[6];
0177   F800             ; 211 extern uint8_t aRegisters[37];
0178   F800             ; 212 extern uint8_t aBackspace[4];
0179   F800             ; 213 extern uint8_t aHello[12];
0180   F800             ; 214 
0181   F800             ; 215 // Для удобства
0182   F800             ; 216 
0183   F800             ; 217 void JmpParam1() __address(0xF774);
0184   F800             ; 218 #ifdef CMD_A_ENABLED
0185   F800             ; 219 void TranslateCodePage() __address(0xF77E);
0186   F800             ; 220 #endif
0187   F800             ; 221 
0188   F800             ; 222 // Точки входа
0189   F800             ; 223 
0190   F800             ; 224 void EntryF800_Reboot() {
0191   F800             entryf800_reboot: 
0192   F800             ; 225     Reboot();
0193   F800 C3 36 F8    	jp reboot
0194   F803             ; 226 }
0195   F803             ; 227 
0196   F803             ; 228 void EntryF803_ReadKey() {
0197   F803             entryf803_readkey: 
0198   F803             ; 229     ReadKey();
0199   F803 C3 88 FE    	jp readkey
0200   F806             ; 230 }
0201   F806             ; 231 
0202   F806             ; 232 void EntryF806_ReadTapeByte(...) {
0203   F806             entryf806_readtapebyte: 
0204   F806             ; 233     ReadTapeByte(a);
0205   F806 C3 34 FC    	jp readtapebyte
0206   F809             ; 234 }
0207   F809             ; 235 
0208   F809             ; 236 void EntryF809_PrintChar(...) {
0209   F809             entryf809_printchar: 
0210   F809             ; 237     PrintChar(c);
0211   F809 C3 E3 FC    	jp printchar
0212   F80C             ; 238 }
0213   F80C             ; 239 
0214   F80C             ; 240 void EntryF80C_WriteTapeByte(...) {
0215   F80C             entryf80c_writetapebyte: 
0216   F80C             ; 241     WriteTapeByte(c);
0217   F80C C3 9D FC    	jp writetapebyte
0218   F80F             ; 242 }
0219   F80F             ; 243 
0220   F80F             ; 244 void EntryF80F_TranslateCodePage(...) {
0221   F80F             entryf80f_translatecodepage: 
0222   F80F             ; 245 #ifdef CMD_A_ENABLED
0223   F80F             ; 246     TranslateCodePage(c);
0224   F80F             ; 247 #else
0225   F80F             ; 248     return;
0226   F80F C9          	ret
0227   F810             ; 249     return;
0228   F810 C9          	ret
0229   F811             ; 250     return;
0230   F811 C9          	ret
0231   F812             ; 251 #endif
0232   F812             ; 252 }
0233   F812             ; 253 
0234   F812             ; 254 void EntryF812_IsAnyKeyPressed() {
0235   F812             entryf812_isanykeypressed: 
0236   F812             ; 255     IsAnyKeyPressed();
0237   F812 C3 7D FE    	jp isanykeypressed
0238   F815             ; 256 }
0239   F815             ; 257 
0240   F815             ; 258 void EntryF815_PrintHexByte(...) {
0241   F815             entryf815_printhexbyte: 
0242   F815             ; 259     PrintHexByte(a);
0243   F815 C3 CE FC    	jp printhexbyte
0244   F818             ; 260 }
0245   F818             ; 261 
0246   F818             ; 262 void EntryF818_PrintString(...) {
0247   F818             entryf818_printstring: 
0248   F818             ; 263     PrintString(hl);
0249   F818 C3 1F F9    	jp printstring
0250   F81B             ; 264 }
0251   F81B             ; 265 
0252   F81B             ; 266 void EntryF81B_ScanKey() {
0253   F81B             entryf81b_scankey: 
0254   F81B             ; 267     ScanKey();
0255   F81B C3 DF FE    	jp scankey
0256   F81E             ; 268 }
0257   F81E             ; 269 
0258   F81E             ; 270 void EntryF81E_GetCursor() {
0259   F81E             entryf81e_getcursor: 
0260   F81E             ; 271     GetCursor();
0261   F81E C3 0A FB    	jp getcursor
0262   F821             ; 272 }
0263   F821             ; 273 
0264   F821             ; 274 void EntryF821_GetCursorChar() {
0265   F821             entryf821_getcursorchar: 
0266   F821             ; 275     GetCursorChar();
0267   F821 C3 1F FB    	jp getcursorchar
0268   F824             ; 276 }
0269   F824             ; 277 
0270   F824             ; 278 void EntryF824_ReadTapeFile(...) {
0271   F824             entryf824_readtapefile: 
0272   F824             ; 279     ReadTapeFile(hl);
0273   F824 C3 7B FB    	jp readtapefile
0274   F827             ; 280 }
0275   F827             ; 281 
0276   F827             ; 282 void EntryF827_WriteTapeFile(...) {
0277   F827             entryf827_writetapefile: 
0278   F827             ; 283     WriteTapeFile(bc, de, hl);
0279   F827 C3 03 FC    	jp writetapefile
0280   F82A             ; 284 }
0281   F82A             ; 285 
0282   F82A             ; 286 void EntryF82A_CalculateCheckSum(...) {
0283   F82A             entryf82a_calculatechecksum: 
0284   F82A             ; 287     CalculateCheckSum(hl, de);
0285   F82A C3 B2 FB    	jp calculatechecksum
0286   F82D             ; 288 }
0287   F82D             ; 289 
0288   F82D             ; 290 void EntryF82D_EnableScreen() {
0289   F82D             entryf82d_enablescreen: 
0290   F82D             ; 291     return;
0291   F82D C9          	ret
0292   F82E             ; 292     return;
0293   F82E C9          	ret
0294   F82F             ; 293     return;
0295   F82F C9          	ret
0296   F830             ; 294 }
0297   F830             ; 295 
0298   F830             ; 296 void EntryF830_GetRamTop() {
0299   F830             entryf830_getramtop: 
0300   F830             ; 297     GetRamTop();
0301   F830 C3 BD F9    	jp getramtop
0302   F833             ; 298 }
0303   F833             ; 299 
0304   F833             ; 300 void EntryF833_SetRamTop(...) {
0305   F833             entryf833_setramtop: 
0306   F833             ; 301     SetRamTop(hl);
0307   F833 C3 C1 F9    	jp setramtop
0308   F836             ; 302 }
0309   F836             ; 303 
0310   F836             ; 304 // Инициализация. Выполняется после перезагрузки или пользовательской программой.
0311   F836             ; 305 // Параметры: нет. Функция никогда не завершается.
0312   F836             ; 306 
0313   F836             ; 307 void Reboot(...) {
0314   F836             reboot: 
0315   F836             ; 308     disable_interrupts();
0316   F836 F3          	di
0317   F837             ; 309     sp = STACK_TOP;
0318   F837 31 00 F8    	ld sp, 63488
0319   F83A             ; 310 
0320   F83A             ; 311     // Очистка памяти
0321   F83A             ; 312     hl = firstVariableAddress;
0322   F83A 21 58 F7    	ld hl, 0FFFFh & (keyboardmode)
0323   F83D             ; 313     de = lastVariableAddress;
0324   F83D 11 A2 F7    	ld de, 0FFFFh & ((inputbuffer) + (31))
0325   F840             ; 314     c = 0;
0326   F840 0E 00       	ld c, 0
0327   F842             ; 315     CmdF();
0328   F842 CD 43 FA    	call cmdf
0329   F845             ; 316 
0330   F845             ; 317     color = a = SCREEN_ATTRIB_DEFAULT;
0331   F845 3E 27       	ld a, 39
0332   F847 32 59 F7    	ld (color), a
0333   F84A             ; 318 #ifdef CMD_A_ENABLED
0334   F84A             ; 319     translateCodePageJump = a = OPCODE_JMP;
0335   F84A             ; 320 #endif
0336   F84A             ; 321 
0337   F84A             ; 322     PrintString(hl = aHello);
0338   F84A 21 B5 FF    	ld hl, 0FFFFh & (ahello)
0339   F84D CD 1F F9    	call printstring
0340   F850             ; 323 
0341   F850             ; 324     ramTop = hl = SCREEN_ATTRIB_BEGIN - 1;
0342   F850 21 FF DF    	ld hl, 57343
0343   F853 22 81 F7    	ld (ramtop), hl
0344   F856             ; 325     tapeReadSpeed = hl = TAPE_SPEED;
0345   F856 21 54 38    	ld hl, 14420
0346   F859 22 5C F7    	ld (tapereadspeed), hl
0347   F85C             ; 326 #ifdef CMD_A_ENABLED
0348   F85C             ; 327     translateCodePageAddress = hl = &TranslateCodePageDefault;
0349   F85C             ; 328 #endif
0350   F85C             ; 329     regSP = hl = 0xF7FE;
0351   F85C 21 FE F7    	ld hl, 63486
0352   F85F 22 6A F7    	ld (regsp), hl
0353   F862             ; 330     EntryF86C_Monitor();
0354   F862 C3 6C F8    	jp entryf86c_monitor
0355   F865              .org 0xF86C
0356   F86C             ; 331 }
0357   F86C             ; 332 
0358   F86C             ; 333 asm(" .org 0xF86C");
0359   F86C             ; 334 
0360   F86C             ; 335 void EntryF86C_Monitor() {
0361   F86C             entryf86c_monitor: 
0362   F86C             ; 336     Monitor();
0363   F86C             ; 337 }
0364   F86C             ; 338 
0365   F86C             ; 339 void Monitor() {
0366   F86C             monitor: 
0367   F86C             ; 340     out(PORT_KEYBOARD_MODE, a = 0x83);
0368   F86C 3E 83       	ld a, 131
0369   F86E D3 04       	out (4), a
0370   F870             ; 341     jmpParam1Opcode = a = OPCODE_JMP;
0371   F870 3E C3       	ld a, 195
0372   F872 32 74 F7    	ld (jmpparam1opcode), a
0373   F875             ; 342     Monitor2();
0374   F875             ; 343 }
0375   F875             ; 344 
0376   F875             ; 345 void Monitor2() {
0377   F875             monitor2: 
0378   F875             ; 346     sp = STACK_TOP;
0379   F875 31 00 F8    	ld sp, 63488
0380   F878             ; 347     PrintString(hl = aPrompt);
0381   F878 21 80 FF    	ld hl, 0FFFFh & (aprompt)
0382   F87B CD 1F F9    	call printstring
0383   F87E             ; 348 
0384   F87E             ; 349     ReadString();
0385   F87E CD DB F8    	call readstring
0386   F881             ; 350 
0387   F881             ; 351     push(hl = &EntryF86C_Monitor);
0388   F881 21 6C F8    	ld hl, 0FFFFh & (entryf86c_monitor)
0389   F884 E5          	push hl
0390   F885             ; 352 
0391   F885             ; 353     hl = inputBuffer;
0392   F885 21 83 F7    	ld hl, 0FFFFh & (inputbuffer)
0393   F888             ; 354     a = *hl;
0394   F888 7E          	ld a, (hl)
0395   F889             ; 355     a &= 0x7F;
0396   F889 E6 7F       	and 127
0397   F88B             ; 356 
0398   F88B             ; 357     if (a == 'X')
0399   F88B FE 58       	cp 88
0400   F88D             ; 358         return CmdX();
0401   F88D CA DD FA    	jp z, cmdx
0402   F890             ; 359 
0403   F890             ; 360     push_pop(a) {
0404   F890 F5          	push af
0405   F891             ; 361         ParseParams();
0406   F891 CD 29 F9    	call parseparams
0407   F894             ; 362         hl = param3;
0408   F894 2A 79 F7    	ld hl, (param3)
0409   F897             ; 363         c = l;
0410   F897 4D          	ld c, l
0411   F898             ; 364         b = h;
0412   F898 44          	ld b, h
0413   F899             ; 365         hl = param2;
0414   F899 2A 77 F7    	ld hl, (param2)
0415   F89C             ; 366         swap(hl, de);
0416   F89C EB          	ex hl, de
0417   F89D             ; 367         hl = param1;
0418   F89D 2A 75 F7    	ld hl, (param1)
0419   F8A0 F1          	pop af
0420   F8A1             ; 368     }
0421   F8A1             ; 369 
0422   F8A1             ; 370     if (a == 'D')
0423   F8A1 FE 44       	cp 68
0424   F8A3             ; 371         return CmdD();
0425   F8A3 CA C5 F9    	jp z, cmdd
0426   F8A6             ; 372     if (a == 'C')
0427   F8A6 FE 43       	cp 67
0428   F8A8             ; 373         return CmdC();
0429   F8A8 CA 2D FA    	jp z, cmdc
0430   F8AB             ; 374     if (a == 'F')
0431   F8AB FE 46       	cp 70
0432   F8AD             ; 375         return CmdF();
0433   F8AD CA 43 FA    	jp z, cmdf
0434   F8B0             ; 376     if (a == 'S')
0435   F8B0 FE 53       	cp 83
0436   F8B2             ; 377         return CmdS();
0437   F8B2 CA 4A FA    	jp z, cmds
0438   F8B5             ; 378     if (a == 'T')
0439   F8B5 FE 54       	cp 84
0440   F8B7             ; 379         return CmdT();
0441   F8B7 CA 67 FA    	jp z, cmdt
0442   F8BA             ; 380     if (a == 'M')
0443   F8BA FE 4D       	cp 77
0444   F8BC             ; 381         return CmdM();
0445   F8BC CA 70 FA    	jp z, cmdm
0446   F8BF             ; 382     if (a == 'G')
0447   F8BF FE 47       	cp 71
0448   F8C1             ; 383         return CmdG();
0449   F8C1 CA 89 FA    	jp z, cmdg
0450   F8C4             ; 384     if (a == 'I')
0451   F8C4 FE 49       	cp 73
0452   F8C6             ; 385         return CmdI();
0453   F8C6 CA 4B FB    	jp z, cmdi
0454   F8C9             ; 386     if (a == 'O')
0455   F8C9 FE 4F       	cp 79
0456   F8CB             ; 387         return CmdO();
0457   F8CB CA C9 FB    	jp z, cmdo
0458   F8CE             ; 388     if (a == 'W')
0459   F8CE FE 57       	cp 87
0460   F8D0             ; 389         return CmdW();
0461   F8D0 CA 55 FA    	jp z, cmdw
0462   F8D3             ; 390 #ifdef CMD_A_ENABLED
0463   F8D3             ; 391     if (a == 'A')
0464   F8D3             ; 392         return CmdA();
0465   F8D3             ; 393 #endif
0466   F8D3             ; 394     if (a == 'H')
0467   F8D3 FE 48       	cp 72
0468   F8D5             ; 395         return CmdH();
0469   F8D5 CA 26 FB    	jp z, cmdh
0470   F8D8             ; 396 #ifdef CMD_R_ENABLED
0471   F8D8             ; 397     if (a == 'R')
0472   F8D8             ; 398         return CmdR();
0473   F8D8             ; 399 #endif
0474   F8D8             ; 400     MonitorError();
0475   F8D8 C3 73 FB    	jp monitorerror
0476   F8DB             ; 401 }
0477   F8DB             ; 402 
0478   F8DB             ; 403 void ReadString() {
0479   F8DB             readstring: 
0480   F8DB             ; 404     de = inputBuffer;
0481   F8DB 11 83 F7    	ld de, 0FFFFh & (inputbuffer)
0482   F8DE             ; 405     h = d;
0483   F8DE 62          	ld h, d
0484   F8DF             ; 406     l = e;
0485   F8DF 6B          	ld l, e
0486   F8E0             ; 407     for (;;) {
0487   F8E0             l_1: 
0488   F8E0             ; 408         ReadKey();
0489   F8E0 CD 88 FE    	call readkey
0490   F8E3             ; 409         if (a == KEY_BACKSPACE) {
0491   F8E3 FE 7F       	cp 127
0492   F8E5 C2 F9 F8    	jp nz, l_3
0493   F8E8             ; 410             if ((a = e) == l)
0494   F8E8 7B          	ld a, e
0495   F8E9 BD          	cp l
0496   F8EA             ; 411                 continue;
0497   F8EA CA E0 F8    	jp z, l_1
0498   F8ED             ; 412             hl--;
0499   F8ED 2B          	dec hl
0500   F8EE             ; 413             push_pop(hl) {
0501   F8EE E5          	push hl
0502   F8EF             ; 414                 PrintString(hl = aBackspace);
0503   F8EF 21 B1 FF    	ld hl, 0FFFFh & (abackspace)
0504   F8F2 CD 1F F9    	call printstring
0505   F8F5 E1          	pop hl
0506   F8F6             ; 415             }
0507   F8F6             ; 416             continue;
0508   F8F6 C3 E0 F8    	jp l_1
0509   F8F9             l_3: 
0510   F8F9             ; 417         }
0511   F8F9             ; 418         *hl = a;
0512   F8F9 77          	ld (hl), a
0513   F8FA             ; 419         if (a == 13) {
0514   F8FA FE 0D       	cp 13
0515   F8FC C2 06 F9    	jp nz, l_5
0516   F8FF             ; 420             if ((a = e) != l)
0517   F8FF 7B          	ld a, e
0518   F900 BD          	cp l
0519   F901             ; 421                 set_flag_c();
0520   F901 CA 05 F9    	jp z, l_7
0521   F904 37          	scf
0522   F905             l_7: 
0523   F905             ; 422             return;
0524   F905 C9          	ret
0525   F906             l_5: 
0526   F906             ; 423         }
0527   F906             ; 424         if (a == '.')
0528   F906 FE 2E       	cp 46
0529   F908             ; 425             return Monitor2();
0530   F908 CA 75 F8    	jp z, monitor2
0531   F90B             ; 426         if (a < 32)
0532   F90B FE 20       	cp 32
0533   F90D             ; 427             a = '.';
0534   F90D D2 12 F9    	jp nc, l_9
0535   F910 3E 2E       	ld a, 46
0536   F912             l_9: 
0537   F912             ; 428         PrintCharA(a);
0538   F912 CD E2 FC    	call printchara
0539   F915             ; 429         if ((a = inputBuffer + sizeof(inputBuffer) - 1) == l)
0540   F915 3E A2       	ld a, 0FFh & (((inputbuffer) + (32)) - (1))
0541   F917 BD          	cp l
0542   F918             ; 430             return MonitorError();
0543   F918 CA 73 FB    	jp z, monitorerror
0544   F91B             ; 431         hl++;
0545   F91B 23          	inc hl
0546   F91C C3 E0 F8    	jp l_1
0547   F91F             ; 432     }
0548   F91F             ; 433 }
0549   F91F             ; 434 
0550   F91F             ; 435 // Функция для пользовательской программы.
0551   F91F             ; 436 // Вывод строки на экран.
0552   F91F             ; 437 // Параметры: hl - адрес стороки. Результат: hl - следующий адрес за терминатором строки. Сохраняются: b, de.
0553   F91F             ; 438 
0554   F91F             ; 439 void PrintString(...) {
0555   F91F             printstring: 
0556   F91F             ; 440     for (;;) {
0557   F91F             l_12: 
0558   F91F             ; 441         a = *hl;
0559   F91F 7E          	ld a, (hl)
0560   F920             ; 442         if (a == 0)
0561   F920 B7          	or a
0562   F921             ; 443             return;
0563   F921 C8          	ret z
0564   F922             ; 444         PrintCharA(a);
0565   F922 CD E2 FC    	call printchara
0566   F925             ; 445         hl++;
0567   F925 23          	inc hl
0568   F926 C3 1F F9    	jp l_12
0569   F929             ; 446     }
0570   F929             ; 447 }
0571   F929             ; 448 
0572   F929             ; 449 void ParseParams(...) {
0573   F929             parseparams: 
0574   F929             ; 450     hl = &param1;
0575   F929 21 75 F7    	ld hl, 0FFFFh & (param1)
0576   F92C             ; 451     de = &param2Exists;
0577   F92C 11 7B F7    	ld de, 0FFFFh & (param2exists)
0578   F92F             ; 452     c = 0;
0579   F92F 0E 00       	ld c, 0
0580   F931             ; 453     CmdF();
0581   F931 CD 43 FA    	call cmdf
0582   F934             ; 454 
0583   F934             ; 455     de = inputBuffer + 1;
0584   F934 11 84 F7    	ld de, 0FFFFh & ((inputbuffer) + (1))
0585   F937             ; 456 
0586   F937             ; 457     ParseWord();
0587   F937 CD 56 F9    	call parseword
0588   F93A             ; 458     param1 = hl;
0589   F93A 22 75 F7    	ld (param1), hl
0590   F93D             ; 459     param2 = hl;
0591   F93D 22 77 F7    	ld (param2), hl
0592   F940             ; 460     if (flag_c)
0593   F940             ; 461         return;
0594   F940 D8          	ret c
0595   F941             ; 462 
0596   F941             ; 463     param2Exists = a = d; /* Not 0 */
0597   F941 7A          	ld a, d
0598   F942 32 7B F7    	ld (param2exists), a
0599   F945             ; 464     ParseWord();
0600   F945 CD 56 F9    	call parseword
0601   F948             ; 465     param2 = hl;
0602   F948 22 77 F7    	ld (param2), hl
0603   F94B             ; 466     if (flag_c)
0604   F94B             ; 467         return;
0605   F94B D8          	ret c
0606   F94C             ; 468 
0607   F94C             ; 469     ParseWord();
0608   F94C CD 56 F9    	call parseword
0609   F94F             ; 470     param3 = hl;
0610   F94F 22 79 F7    	ld (param3), hl
0611   F952             ; 471     if (flag_c)
0612   F952             ; 472         return;
0613   F952 D8          	ret c
0614   F953             ; 473 
0615   F953             ; 474     MonitorError();
0616   F953 C3 73 FB    	jp monitorerror
0617   F956             ; 475 }
0618   F956             ; 476 
0619   F956             ; 477 void ParseWord(...) {
0620   F956             parseword: 
0621   F956             ; 478     hl = 0;
0622   F956 21 00 00    	ld hl, 0
0623   F959             ; 479     for (;;) {
0624   F959             l_15: 
0625   F959             ; 480         a = *de;
0626   F959 1A          	ld a, (de)
0627   F95A             ; 481         compare(a, 13);
0628   F95A FE 0D       	cp 13
0629   F95C             ; 482         set_flag_c();
0630   F95C 37          	scf
0631   F95D             ; 483         if (flag_z)
0632   F95D             ; 484             return;
0633   F95D C8          	ret z
0634   F95E             ; 485         de++;
0635   F95E 13          	inc de
0636   F95F             ; 486         if (a == ',')
0637   F95F FE 2C       	cp 44
0638   F961             ; 487             return;
0639   F961 C8          	ret z
0640   F962             ; 488         if (a == ' ')
0641   F962 FE 20       	cp 32
0642   F964             ; 489             continue;
0643   F964 CA 59 F9    	jp z, l_15
0644   F967             ; 490         push(bc = &MonitorError);
0645   F967 01 73 FB    	ld bc, 0FFFFh & (monitorerror)
0646   F96A C5          	push bc
0647   F96B             ; 491         a &= 0x7F;
0648   F96B E6 7F       	and 127
0649   F96D             ; 492         a -= '0';
0650   F96D D6 30       	sub 48
0651   F96F             ; 493         if (flag_c)
0652   F96F             ; 494             return;
0653   F96F D8          	ret c
0654   F970             ; 495         if (a >= 10) {
0655   F970 FE 0A       	cp 10
0656   F972 DA 7D F9    	jp c, l_17
0657   F975             ; 496             if (a < 17)
0658   F975 FE 11       	cp 17
0659   F977             ; 497                 return;
0660   F977 D8          	ret c
0661   F978             ; 498             if (a >= 23)
0662   F978 FE 17       	cp 23
0663   F97A             ; 499                 return;
0664   F97A D0          	ret nc
0665   F97B             ; 500             a -= 7;
0666   F97B D6 07       	sub 7
0667   F97D             l_17: 
0668   F97D             ; 501         }
0669   F97D             ; 502         hl += hl;
0670   F97D 29          	add hl, hl
0671   F97E             ; 503         if (flag_c)
0672   F97E             ; 504             return;
0673   F97E D8          	ret c
0674   F97F             ; 505         hl += hl;
0675   F97F 29          	add hl, hl
0676   F980             ; 506         if (flag_c)
0677   F980             ; 507             return;
0678   F980 D8          	ret c
0679   F981             ; 508         hl += hl;
0680   F981 29          	add hl, hl
0681   F982             ; 509         if (flag_c)
0682   F982             ; 510             return;
0683   F982 D8          	ret c
0684   F983             ; 511         hl += hl;
0685   F983 29          	add hl, hl
0686   F984             ; 512         if (flag_c)
0687   F984             ; 513             return;
0688   F984 D8          	ret c
0689   F985             ; 514         b = 0;
0690   F985 06 00       	ld b, 0
0691   F987             ; 515         c = a;
0692   F987 4F          	ld c, a
0693   F988             ; 516         hl += bc;
0694   F988 09          	add hl, bc
0695   F989             ; 517         pop(bc);
0696   F989 C1          	pop bc
0697   F98A C3 59 F9    	jp l_15
0698   F98D             ; 518     }
0699   F98D             ; 519 }
0700   F98D             ; 520 
0701   F98D             ; 521 void CompareHlDe(...) {
0702   F98D             comparehlde: 
0703   F98D             ; 522     if ((a = h) != d)
0704   F98D 7C          	ld a, h
0705   F98E BA          	cp d
0706   F98F             ; 523         return;
0707   F98F C0          	ret nz
0708   F990             ; 524     compare(a = l, e);
0709   F990 7D          	ld a, l
0710   F991 BB          	cp e
0711   F992 C9          	ret
0712   F993             ; 525 }
0713   F993             ; 526 
0714   F993             ; 527 void LoopWithBreak(...) {
0715   F993             loopwithbreak: 
0716   F993             ; 528     CtrlC();
0717   F993 CD A1 F9    	call ctrlc
0718   F996             ; 529     Loop(hl, de);
0719   F996             ; 530 }
0720   F996             ; 531 
0721   F996             ; 532 void Loop(...) {
0722   F996             loop: 
0723   F996             ; 533     CompareHlDe(hl, de);
0724   F996 CD 8D F9    	call comparehlde
0725   F999             ; 534     if (flag_nz)
0726   F999             ; 535         return IncHl(hl);
0727   F999 C2 9F F9    	jp nz, inchl
0728   F99C             ; 536     PopRet();
0729   F99C             ; 537 }
0730   F99C             ; 538 
0731   F99C             ; 539 void PopRet() {
0732   F99C             popret: 
0733   F99C             ; 540     sp++;
0734   F99C 33          	inc sp
0735   F99D             ; 541     sp++;
0736   F99D 33          	inc sp
0737   F99E C9          	ret
0738   F99F             ; 542 }
0739   F99F             ; 543 
0740   F99F             ; 544 void IncHl(...) {
0741   F99F             inchl: 
0742   F99F             ; 545     hl++;
0743   F99F 23          	inc hl
0744   F9A0 C9          	ret
0745   F9A1             ; 546 }
0746   F9A1             ; 547 
0747   F9A1             ; 548 void CtrlC() {
0748   F9A1             ctrlc: 
0749   F9A1             ; 549     ScanKey();
0750   F9A1 CD DF FE    	call scankey
0751   F9A4             ; 550     if (a != 3)  // УПР + C
0752   F9A4 FE 03       	cp 3
0753   F9A6             ; 551         return;
0754   F9A6 C0          	ret nz
0755   F9A7             ; 552     MonitorError();
0756   F9A7 C3 73 FB    	jp monitorerror
0757   F9AA             ; 553 }
0758   F9AA             ; 554 
0759   F9AA             ; 555 void PrintCrLfTab() {
0760   F9AA             printcrlftab: 
0761   F9AA             ; 556     push_pop(hl) {
0762   F9AA E5          	push hl
0763   F9AB             ; 557         PrintString(hl = aCrLfTab);
0764   F9AB 21 86 FF    	ld hl, 0FFFFh & (acrlftab)
0765   F9AE CD 1F F9    	call printstring
0766   F9B1 E1          	pop hl
0767   F9B2 C9          	ret
0768   F9B3             ; 558     }
0769   F9B3             ; 559 }
0770   F9B3             ; 560 
0771   F9B3             ; 561 void PrintHexByteFromHlSpace(...) {
0772   F9B3             printhexbytefromhlspace: 
0773   F9B3             ; 562     PrintHexByteSpace(a = *hl);
0774   F9B3 7E          	ld a, (hl)
0775   F9B4             ; 563 }
0776   F9B4             ; 564 
0777   F9B4             ; 565 void PrintHexByteSpace(...) {
0778   F9B4             printhexbytespace: 
0779   F9B4             ; 566     push_pop(bc) {
0780   F9B4 C5          	push bc
0781   F9B5             ; 567         PrintHexByte(a);
0782   F9B5 CD CE FC    	call printhexbyte
0783   F9B8             ; 568         PrintSpace();
0784   F9B8 CD 28 FA    	call printspace
0785   F9BB C1          	pop bc
0786   F9BC C9          	ret
0787   F9BD             ; 569     }
0788   F9BD             ; 570 }
0789   F9BD             ; 571 
0790   F9BD             ; 572 #ifdef CMD_R_ENABLED
0791   F9BD             ; 573 // Команда R <начальный адрес ПЗУ> <конечный адрес ПЗУ> <начальный адрес назаначения>
0792   F9BD             ; 574 // Скопировать блок из внешнего ПЗУ в адресное пространство процессора
0793   F9BD             ; 575 
0794   F9BD             ; 576 void CmdR(...) {
0795   F9BD             ; 577     out(PORT_EXT_MODE, a = 0x90);
0796   F9BD             ; 578     for (;;) {
0797   F9BD             ; 579         out(PORT_EXT_ADDR_LOW, a = l);
0798   F9BD             ; 580         out(PORT_EXT_ADDR_HIGH, a = h);
0799   F9BD             ; 581         *bc = a = in(PORT_EXT_DATA);
0800   F9BD             ; 582         bc++;
0801   F9BD             ; 583         Loop();
0802   F9BD             ; 584     }
0803   F9BD             ; 585 }
0804   F9BD             ; 586 #endif
0805   F9BD             ; 587 
0806   F9BD             ; 588 // Функция для пользовательской программы.
0807   F9BD             ; 589 // Получить адрес последнего доступного байта оперативной памяти.
0808   F9BD             ; 590 // Параметры: нет. Результат: hl - адрес. Сохраняет: a, bc, de.
0809   F9BD             ; 591 
0810   F9BD             ; 592 void GetRamTop(...) {
0811   F9BD             getramtop: 
0812   F9BD             ; 593     hl = ramTop;
0813   F9BD 2A 81 F7    	ld hl, (ramtop)
0814   F9C0 C9          	ret
0815   F9C1             ; 594 }
0816   F9C1             ; 595 
0817   F9C1             ; 596 // Функция для пользовательской программы.
0818   F9C1             ; 597 // Установить адрес последнего доступного байта оперативной памяти.
0819   F9C1             ; 598 // Параметры: hl - адрес. Результат: нет. Сохраняет: a, bc, de, hl.
0820   F9C1             ; 599 
0821   F9C1             ; 600 void SetRamTop(...) {
0822   F9C1             setramtop: 
0823   F9C1             ; 601     ramTop = hl;
0824   F9C1 22 81 F7    	ld (ramtop), hl
0825   F9C4 C9          	ret
0826   F9C5             ; 602 }
0827   F9C5             ; 603 
0828   F9C5             ; 604 #ifdef CMD_A_ENABLED
0829   F9C5             ; 605 // Команда A <адрес>
0830   F9C5             ; 606 // Установить программу преобразования кодировки символов выводимых на экран
0831   F9C5             ; 607 
0832   F9C5             ; 608 void CmdA(...) {
0833   F9C5             ; 609     translateCodePageAddress = hl;
0834   F9C5             ; 610 }
0835   F9C5             ; 611 #endif
0836   F9C5             ; 612 
0837   F9C5             ; 613 // Команда D <начальный адрес> <конечный адрес>
0838   F9C5             ; 614 // Вывод блока данных из адресного пространства на экран в 16-ричном виде
0839   F9C5             ; 615 
0840   F9C5             ; 616 void CmdD(...) {
0841   F9C5             cmdd: 
0842   F9C5             ; 617     for (;;) {
0843   F9C5             l_20: 
0844   F9C5             ; 618         PrintChar(c = 13);
0845   F9C5 0E 0D       	ld c, 13
0846   F9C7 CD E3 FC    	call printchar
0847   F9CA             ; 619         PrintChar(c = 10);
0848   F9CA 0E 0A       	ld c, 10
0849   F9CC CD E3 FC    	call printchar
0850   F9CF             ; 620         PrintHexWordSpace(hl);
0851   F9CF CD F1 FB    	call printhexwordspace
0852   F9D2             ; 621         push_pop(hl) {
0853   F9D2 E5          	push hl
0854   F9D3             ; 622             c = ((a = l) &= 0x0F);
0855   F9D3 7D          	ld a, l
0856   F9D4 E6 0F       	and 15
0857   F9D6 4F          	ld c, a
0858   F9D7             ; 623             carry_rotate_right(a, 1);
0859   F9D7 1F          	rra
0860   F9D8             ; 624             b = (((a += c) += c) += 5);
0861   F9D8 81          	add c
0862   F9D9 81          	add c
0863   F9DA C6 05       	add 5
0864   F9DC 47          	ld b, a
0865   F9DD             ; 625             PrintSpacesTo();
0866   F9DD CD 1B FA    	call printspacesto
0867   F9E0             ; 626             do {
0868   F9E0             l_22: 
0869   F9E0             ; 627                 PrintHexByte(a = *hl);
0870   F9E0 7E          	ld a, (hl)
0871   F9E1 CD CE FC    	call printhexbyte
0872   F9E4             ; 628                 CompareHlDe(hl, de);
0873   F9E4 CD 8D F9    	call comparehlde
0874   F9E7             ; 629                 hl++;
0875   F9E7 23          	inc hl
0876   F9E8             ; 630                 if (flag_z)
0877   F9E8             ; 631                     break;
0878   F9E8 CA F8 F9    	jp z, l_24
0879   F9EB             ; 632                 (a = l) &= 0x0F;
0880   F9EB 7D          	ld a, l
0881   F9EC E6 0F       	and 15
0882   F9EE             ; 633                 push_pop(a) {
0883   F9EE F5          	push af
0884   F9EF             ; 634                     a &= 1;
0885   F9EF E6 01       	and 1
0886   F9F1             ; 635                     if (flag_z)
0887   F9F1             ; 636                         PrintSpace();
0888   F9F1 CC 28 FA    	call z, printspace
0889   F9F4 F1          	pop af
0890   F9F5             l_23: 
0891   F9F5 C2 E0 F9    	jp nz, l_22
0892   F9F8             l_24: 
0893   F9F8 E1          	pop hl
0894   F9F9             ; 637                 }
0895   F9F9             ; 638             } while (flag_nz);
0896   F9F9             ; 639         }
0897   F9F9             ; 640 
0898   F9F9             ; 641         b = (((a = l) &= 0x0F) += 46);
0899   F9F9 7D          	ld a, l
0900   F9FA E6 0F       	and 15
0901   F9FC C6 2E       	add 46
0902   F9FE 47          	ld b, a
0903   F9FF             ; 642         PrintSpacesTo(b);
0904   F9FF CD 1B FA    	call printspacesto
0905   FA02             ; 643 
0906   FA02             ; 644         do {
0907   FA02             l_25: 
0908   FA02             ; 645             a = *hl;
0909   FA02 7E          	ld a, (hl)
0910   FA03             ; 646             if (a < 32)
0911   FA03 FE 20       	cp 32
0912   FA05             ; 647                 a = '.';
0913   FA05 D2 0A FA    	jp nc, l_28
0914   FA08 3E 2E       	ld a, 46
0915   FA0A             l_28: 
0916   FA0A             ; 648             PrintCharA(a);
0917   FA0A CD E2 FC    	call printchara
0918   FA0D             ; 649             CompareHlDe(hl, de);
0919   FA0D CD 8D F9    	call comparehlde
0920   FA10             ; 650             if (flag_z)
0921   FA10             ; 651                 return;
0922   FA10 C8          	ret z
0923   FA11             ; 652             hl++;
0924   FA11 23          	inc hl
0925   FA12             ; 653             (a = l) &= 0x0F;
0926   FA12 7D          	ld a, l
0927   FA13 E6 0F       	and 15
0928   FA15             l_26: 
0929   FA15 C2 02 FA    	jp nz, l_25
0930   FA18 C3 C5 F9    	jp l_20
0931   FA1B             ; 654         } while (flag_nz);
0932   FA1B             ; 655     }
0933   FA1B             ; 656 }
0934   FA1B             ; 657 
0935   FA1B             ; 658 void PrintSpacesTo(...) {
0936   FA1B             printspacesto: 
0937   FA1B             ; 659     for (;;) {
0938   FA1B             l_31: 
0939   FA1B             ; 660         if (((a = cursor) &= (SCREEN_WIDTH - 1)) >= b)
0940   FA1B 3A 5A F7    	ld a, (cursor)
0941   FA1E E6 3F       	and 63
0942   FA20 B8          	cp b
0943   FA21             ; 661             return;
0944   FA21 D0          	ret nc
0945   FA22             ; 662         PrintSpace();
0946   FA22 CD 28 FA    	call printspace
0947   FA25 C3 1B FA    	jp l_31
0948   FA28             ; 663     }
0949   FA28             ; 664 }
0950   FA28             ; 665 
0951   FA28             ; 666 void PrintSpace() {
0952   FA28             printspace: 
0953   FA28             ; 667     PrintCharA(a = ' ');
0954   FA28 3E 20       	ld a, 32
0955   FA2A C3 E2 FC    	jp printchara
0956   FA2D             ; 668 }
0957   FA2D             ; 669 
0958   FA2D             ; 670 // Команда С <начальный адрес 1> <конечный адрес 1> <начальный адрес 2>
0959   FA2D             ; 671 // Сравнить два блока адресного пространство
0960   FA2D             ; 672 
0961   FA2D             ; 673 void CmdC(...) {
0962   FA2D             cmdc: 
0963   FA2D             ; 674     for (;;) {
0964   FA2D             l_34: 
0965   FA2D             ; 675         if ((a = *bc) != *hl) {
0966   FA2D 0A          	ld a, (bc)
0967   FA2E BE          	cp (hl)
0968   FA2F CA 3C FA    	jp z, l_36
0969   FA32             ; 676             PrintCrLfTabHexWordSpace(hl);
0970   FA32 CD E8 FB    	call printcrlftabhexwordspace
0971   FA35             ; 677             PrintHexByteFromHlSpace(hl);
0972   FA35 CD B3 F9    	call printhexbytefromhlspace
0973   FA38             ; 678             PrintHexByteSpace(a = *bc);
0974   FA38 0A          	ld a, (bc)
0975   FA39 CD B4 F9    	call printhexbytespace
0976   FA3C             l_36: 
0977   FA3C             ; 679         }
0978   FA3C             ; 680         bc++;
0979   FA3C 03          	inc bc
0980   FA3D             ; 681         LoopWithBreak();
0981   FA3D CD 93 F9    	call loopwithbreak
0982   FA40 C3 2D FA    	jp l_34
0983   FA43             ; 682     }
0984   FA43             ; 683 }
0985   FA43             ; 684 
0986   FA43             ; 685 // Команда F <начальный адрес> <конечный адрес> <байт>
0987   FA43             ; 686 // Заполнить блок в адресном пространстве одним байтом
0988   FA43             ; 687 
0989   FA43             ; 688 void CmdF(...) {
0990   FA43             cmdf: 
0991   FA43             ; 689     for (;;) {
0992   FA43             l_39: 
0993   FA43             ; 690         *hl = c;
0994   FA43 71          	ld (hl), c
0995   FA44             ; 691         Loop();
0996   FA44 CD 96 F9    	call loop
0997   FA47 C3 43 FA    	jp l_39
0998   FA4A             ; 692     }
0999   FA4A             ; 693 }
1000   FA4A             ; 694 
1001   FA4A             ; 695 // Команда S <начальный адрес> <конечный адрес> <байт>
1002   FA4A             ; 696 // Найти байт (8 битное значение) в адресном пространстве
1003   FA4A             ; 697 
1004   FA4A             ; 698 void CmdS(...) {
1005   FA4A             cmds: 
1006   FA4A             ; 699     for (;;) {
1007   FA4A             l_42: 
1008   FA4A             ; 700         if ((a = c) == *hl)
1009   FA4A 79          	ld a, c
1010   FA4B BE          	cp (hl)
1011   FA4C             ; 701             PrintCrLfTabHexWordSpace(hl);
1012   FA4C CC E8 FB    	call z, printcrlftabhexwordspace
1013   FA4F             ; 702         LoopWithBreak();
1014   FA4F CD 93 F9    	call loopwithbreak
1015   FA52 C3 4A FA    	jp l_42
1016   FA55             ; 703     }
1017   FA55             ; 704 }
1018   FA55             ; 705 
1019   FA55             ; 706 // Команда W <начальный адрес> <конечный адрес> <слово>
1020   FA55             ; 707 // Найти слово (16 битное значение) в адресном пространстве
1021   FA55             ; 708 
1022   FA55             ; 709 void CmdW(...) {
1023   FA55             cmdw: 
1024   FA55             ; 710     for (;;) {
1025   FA55             l_45: 
1026   FA55             ; 711         if ((a = *hl) == c) {
1027   FA55 7E          	ld a, (hl)
1028   FA56 B9          	cp c
1029   FA57 C2 61 FA    	jp nz, l_47
1030   FA5A             ; 712             hl++;
1031   FA5A 23          	inc hl
1032   FA5B             ; 713             compare((a = *hl), b);
1033   FA5B 7E          	ld a, (hl)
1034   FA5C B8          	cp b
1035   FA5D             ; 714             hl--;
1036   FA5D 2B          	dec hl
1037   FA5E             ; 715             if (flag_z)
1038   FA5E             ; 716                 PrintCrLfTabHexWordSpace(hl);
1039   FA5E CC E8 FB    	call z, printcrlftabhexwordspace
1040   FA61             l_47: 
1041   FA61             ; 717         }
1042   FA61             ; 718         LoopWithBreak();
1043   FA61 CD 93 F9    	call loopwithbreak
1044   FA64 C3 55 FA    	jp l_45
1045   FA67             ; 719     }
1046   FA67             ; 720 }
1047   FA67             ; 721 
1048   FA67             ; 722 // Команда T <начальный адрес источника> <конечный адрес источника> <начальный адрес назначения>
1049   FA67             ; 723 // Копировать блок в адресном пространстве
1050   FA67             ; 724 
1051   FA67             ; 725 void CmdT(...) {
1052   FA67             cmdt: 
1053   FA67             ; 726     for (;;) {
1054   FA67             l_50: 
1055   FA67             ; 727         *bc = a = *hl;
1056   FA67 7E          	ld a, (hl)
1057   FA68 02          	ld (bc), a
1058   FA69             ; 728         bc++;
1059   FA69 03          	inc bc
1060   FA6A             ; 729         Loop();
1061   FA6A CD 96 F9    	call loop
1062   FA6D C3 67 FA    	jp l_50
1063   FA70             ; 730     }
1064   FA70             ; 731 }
1065   FA70             ; 732 
1066   FA70             ; 733 // Команда M <начальный адрес>
1067   FA70             ; 734 // Вывести на экран адресное пространство побайтно с возможностью изменения
1068   FA70             ; 735 
1069   FA70             ; 736 void CmdM(...) {
1070   FA70             cmdm: 
1071   FA70             ; 737     for (;;) {
1072   FA70             l_53: 
1073   FA70             ; 738         PrintCrLfTabHexWordSpace(hl);
1074   FA70 CD E8 FB    	call printcrlftabhexwordspace
1075   FA73             ; 739         PrintHexByteFromHlSpace();
1076   FA73 CD B3 F9    	call printhexbytefromhlspace
1077   FA76             ; 740         push_pop(hl) {
1078   FA76 E5          	push hl
1079   FA77             ; 741             ReadString();
1080   FA77 CD DB F8    	call readstring
1081   FA7A E1          	pop hl
1082   FA7B             ; 742         }
1083   FA7B             ; 743         if (flag_c) {
1084   FA7B D2 85 FA    	jp nc, l_55
1085   FA7E             ; 744             push_pop(hl) {
1086   FA7E E5          	push hl
1087   FA7F             ; 745                 ParseWord();
1088   FA7F CD 56 F9    	call parseword
1089   FA82             ; 746                 a = l;
1090   FA82 7D          	ld a, l
1091   FA83 E1          	pop hl
1092   FA84             ; 747             }
1093   FA84             ; 748             *hl = a;
1094   FA84 77          	ld (hl), a
1095   FA85             l_55: 
1096   FA85             ; 749         }
1097   FA85             ; 750         hl++;
1098   FA85 23          	inc hl
1099   FA86 C3 70 FA    	jp l_53
1100   FA89             ; 751     }
1101   FA89             ; 752 }
1102   FA89             ; 753 
1103   FA89             ; 754 // Команда G <начальный адрес> <конечный адрес>
1104   FA89             ; 755 // Запуск программы и возможным указанием точки останова.
1105   FA89             ; 756 
1106   FA89             ; 757 void CmdG(...) {
1107   FA89             cmdg: 
1108   FA89             ; 758     CompareHlDe(hl, de);
1109   FA89 CD 8D F9    	call comparehlde
1110   FA8C             ; 759     if (flag_nz) {
1111   FA8C CA A4 FA    	jp z, l_57
1112   FA8F             ; 760         swap(hl, de);
1113   FA8F EB          	ex hl, de
1114   FA90             ; 761         breakPointAddress = hl;
1115   FA90 22 71 F7    	ld (breakpointaddress), hl
1116   FA93             ; 762         breakPointValue = a = *hl;
1117   FA93 7E          	ld a, (hl)
1118   FA94 32 73 F7    	ld (breakpointvalue), a
1119   FA97             ; 763         *hl = OPCODE_RST_30;
1120   FA97 36 F7       	ld (hl), 247
1121   FA99             ; 764         rst30Opcode = a = OPCODE_JMP;
1122   FA99 3E C3       	ld a, 195
1123   FA9B 32 30 00    	ld (rst30opcode), a
1124   FA9E             ; 765         rst30Address = hl = &BreakPointHandler;
1125   FA9E 21 B2 FA    	ld hl, 0FFFFh & (breakpointhandler)
1126   FAA1 22 31 00    	ld (rst30address), hl
1127   FAA4             l_57: 
1128   FAA4             ; 766     }
1129   FAA4             ; 767     sp = &regBC;
1130   FAA4 31 66 F7    	ld sp, 0FFFFh & (regbc)
1131   FAA7             ; 768     pop(bc);
1132   FAA7 C1          	pop bc
1133   FAA8             ; 769     pop(de);
1134   FAA8 D1          	pop de
1135   FAA9             ; 770     pop(hl);
1136   FAA9 E1          	pop hl
1137   FAAA             ; 771     pop(a);
1138   FAAA F1          	pop af
1139   FAAB             ; 772     sp = hl;
1140   FAAB F9          	ld sp, hl
1141   FAAC             ; 773     hl = regHL;
1142   FAAC 2A 64 F7    	ld hl, (reghl)
1143   FAAF             ; 774     JmpParam1();
1144   FAAF C3 74 F7    	jp jmpparam1
1145   FAB2             ; 775 }
1146   FAB2             ; 776 
1147   FAB2             ; 777 void BreakPointHandler(...) {
1148   FAB2             breakpointhandler: 
1149   FAB2             ; 778     regHL = hl;
1150   FAB2 22 64 F7    	ld (reghl), hl
1151   FAB5             ; 779     push(a);
1152   FAB5 F5          	push af
1153   FAB6             ; 780     pop(hl);
1154   FAB6 E1          	pop hl
1155   FAB7             ; 781     regAF = hl;
1156   FAB7 22 6C F7    	ld (regaf), hl
1157   FABA             ; 782     pop(hl);
1158   FABA E1          	pop hl
1159   FABB             ; 783     hl--;
1160   FABB 2B          	dec hl
1161   FABC             ; 784     regPC = hl;
1162   FABC 22 62 F7    	ld (regpc), hl
1163   FABF             ; 785     (hl = 0) += sp;
1164   FABF 21 00 00    	ld hl, 0
1165   FAC2 39          	add hl, sp
1166   FAC3             ; 786     sp = &regAF;
1167   FAC3 31 6C F7    	ld sp, 0FFFFh & (regaf)
1168   FAC6             ; 787     push(hl);
1169   FAC6 E5          	push hl
1170   FAC7             ; 788     push(de);
1171   FAC7 D5          	push de
1172   FAC8             ; 789     push(bc);
1173   FAC8 C5          	push bc
1174   FAC9             ; 790     sp = STACK_TOP;
1175   FAC9 31 00 F8    	ld sp, 63488
1176   FACC             ; 791     hl = regPC;
1177   FACC 2A 62 F7    	ld hl, (regpc)
1178   FACF             ; 792     swap(hl, de);
1179   FACF EB          	ex hl, de
1180   FAD0             ; 793     hl = breakPointAddress;
1181   FAD0 2A 71 F7    	ld hl, (breakpointaddress)
1182   FAD3             ; 794     CompareHlDe(hl, de);
1183   FAD3 CD 8D F9    	call comparehlde
1184   FAD6             ; 795     if (flag_nz)
1185   FAD6             ; 796         return CmdX();
1186   FAD6 C2 DD FA    	jp nz, cmdx
1187   FAD9             ; 797     *hl = a = breakPointValue;
1188   FAD9 3A 73 F7    	ld a, (breakpointvalue)
1189   FADC 77          	ld (hl), a
1190   FADD             ; 798     CmdX();
1191   FADD             ; 799 }
1192   FADD             ; 800 
1193   FADD             ; 801 // Команда X
1194   FADD             ; 802 // Вывод на экран содержимого регистров микропроцессора с возможностью их изменения.
1195   FADD             ; 803 
1196   FADD             ; 804 void CmdX(...) {
1197   FADD             cmdx: 
1198   FADD             ; 805     PrintString(hl = aRegisters);
1199   FADD 21 8C FF    	ld hl, 0FFFFh & (aregisters)
1200   FAE0 CD 1F F9    	call printstring
1201   FAE3             ; 806     hl = &regPC;
1202   FAE3 21 62 F7    	ld hl, 0FFFFh & (regpc)
1203   FAE6             ; 807     b = 6;
1204   FAE6 06 06       	ld b, 6
1205   FAE8             ; 808     do {
1206   FAE8             l_59: 
1207   FAE8             ; 809         e = *hl;
1208   FAE8 5E          	ld e, (hl)
1209   FAE9             ; 810         hl++;
1210   FAE9 23          	inc hl
1211   FAEA             ; 811         d = *hl;
1212   FAEA 56          	ld d, (hl)
1213   FAEB             ; 812         push(bc);
1214   FAEB C5          	push bc
1215   FAEC             ; 813         push(hl);
1216   FAEC E5          	push hl
1217   FAED             ; 814         swap(hl, de);
1218   FAED EB          	ex hl, de
1219   FAEE             ; 815         PrintCrLfTabHexWordSpace(hl);
1220   FAEE CD E8 FB    	call printcrlftabhexwordspace
1221   FAF1             ; 816         ReadString();
1222   FAF1 CD DB F8    	call readstring
1223   FAF4             ; 817         if (flag_c) {
1224   FAF4 D2 00 FB    	jp nc, l_62
1225   FAF7             ; 818             ParseWord();
1226   FAF7 CD 56 F9    	call parseword
1227   FAFA             ; 819             pop(de);
1228   FAFA D1          	pop de
1229   FAFB             ; 820             push(de);
1230   FAFB D5          	push de
1231   FAFC             ; 821             swap(hl, de);
1232   FAFC EB          	ex hl, de
1233   FAFD             ; 822             *hl = d;
1234   FAFD 72          	ld (hl), d
1235   FAFE             ; 823             hl--;
1236   FAFE 2B          	dec hl
1237   FAFF             ; 824             *hl = e;
1238   FAFF 73          	ld (hl), e
1239   FB00             l_62: 
1240   FB00             ; 825         }
1241   FB00             ; 826         pop(hl);
1242   FB00 E1          	pop hl
1243   FB01             ; 827         pop(bc);
1244   FB01 C1          	pop bc
1245   FB02             ; 828         b--;
1246   FB02 05          	dec b
1247   FB03             ; 829         hl++;
1248   FB03 23          	inc hl
1249   FB04             l_60: 
1250   FB04 C2 E8 FA    	jp nz, l_59
1251   FB07             ; 830     } while (flag_nz);
1252   FB07             ; 831     EntryF86C_Monitor();
1253   FB07 C3 6C F8    	jp entryf86c_monitor
1254   FB0A             ; 832 }
1255   FB0A             ; 833 
1256   FB0A             ; 834 // Функция для пользовательской программы.
1257   FB0A             ; 835 // Получить координаты курсора.
1258   FB0A             ; 836 // Параметры: нет. Результат: l = x + 8, h = y + 3. Сохраняет регистры: bc, de, hl.
1259   FB0A             ; 837 
1260   FB0A             ; 838 void GetCursor() {
1261   FB0A             getcursor: 
1262   FB0A             ; 839     push_pop(a) {
1263   FB0A F5          	push af
1264   FB0B             ; 840         hl = cursor;
1265   FB0B 2A 5A F7    	ld hl, (cursor)
1266   FB0E             ; 841         h = ((a = h) &= 7);
1267   FB0E 7C          	ld a, h
1268   FB0F E6 07       	and 7
1269   FB11 67          	ld h, a
1270   FB12             ; 842 
1271   FB12             ; 843         // Вычисление X
1272   FB12             ; 844         a = l;
1273   FB12 7D          	ld a, l
1274   FB13             ; 845         a &= (SCREEN_WIDTH - 1);
1275   FB13 E6 3F       	and 63
1276   FB15             ; 846         a += 8;  // Смещение Радио 86РК
1277   FB15 C6 08       	add 8
1278   FB17             ; 847 
1279   FB17             ; 848         // Вычисление Y
1280   FB17             ; 849         hl += hl;
1281   FB17 29          	add hl, hl
1282   FB18             ; 850         hl += hl;
1283   FB18 29          	add hl, hl
1284   FB19             ; 851         h++;  // Смещение Радио 86РК
1285   FB19 24          	inc h
1286   FB1A             ; 852         h++;
1287   FB1A 24          	inc h
1288   FB1B             ; 853         h++;
1289   FB1B 24          	inc h
1290   FB1C             ; 854 
1291   FB1C             ; 855         l = a;
1292   FB1C 6F          	ld l, a
1293   FB1D F1          	pop af
1294   FB1E C9          	ret
1295   FB1F             ; 856     }
1296   FB1F             ; 857 }
1297   FB1F             ; 858 
1298   FB1F             ; 859 // Функция для пользовательской программы.
1299   FB1F             ; 860 // Получить символ под курсором.
1300   FB1F             ; 861 // Параметры: нет. Результат: a - код символа. Сохраняет регистры: bc, de, hl.
1301   FB1F             ; 862 
1302   FB1F             ; 863 void GetCursorChar() {
1303   FB1F             getcursorchar: 
1304   FB1F             ; 864     push_pop(hl) {
1305   FB1F E5          	push hl
1306   FB20             ; 865         hl = cursor;
1307   FB20 2A 5A F7    	ld hl, (cursor)
1308   FB23             ; 866         a = *hl;
1309   FB23 7E          	ld a, (hl)
1310   FB24 E1          	pop hl
1311   FB25 C9          	ret
1312   FB26             ; 867     }
1313   FB26             ; 868 }
1314   FB26             ; 869 
1315   FB26             ; 870 // Команда H
1316   FB26             ; 871 // Определить скорости записанной программы.
1317   FB26             ; 872 // Выводит 4 цифры на экран.
1318   FB26             ; 873 // Первые две цифры - константа вывода для команды O
1319   FB26             ; 874 // Последние две цифры - константа вввода для команды I
1320   FB26             ; 875 
1321   FB26             ; 876 void CmdH(...) {
1322   FB26             cmdh: 
1323   FB26             ; 877     PrintCrLfTab();
1324   FB26 CD AA F9    	call printcrlftab
1325   FB29             ; 878     hl = 65408;
1326   FB29 21 80 FF    	ld hl, 65408
1327   FB2C             ; 879     b = 123;
1328   FB2C 06 7B       	ld b, 123
1329   FB2E             ; 880 
1330   FB2E             ; 881     c = a = in(PORT_TAPE);
1331   FB2E DB 01       	in a, (1)
1332   FB30 4F          	ld c, a
1333   FB31             ; 882 
1334   FB31             ; 883     do {
1335   FB31             l_64: 
1336   FB31             l_65: 
1337   FB31             ; 884     } while ((a = in(PORT_TAPE)) == c);
1338   FB31 DB 01       	in a, (1)
1339   FB33 B9          	cp c
1340   FB34 CA 31 FB    	jp z, l_64
1341   FB37             ; 885 
1342   FB37             ; 886     do {
1343   FB37             l_67: 
1344   FB37             ; 887         c = a;
1345   FB37 4F          	ld c, a
1346   FB38             ; 888         do {
1347   FB38             l_70: 
1348   FB38             ; 889             hl++;
1349   FB38 23          	inc hl
1350   FB39             l_71: 
1351   FB39             ; 890         } while ((a = in(PORT_TAPE)) == c);
1352   FB39 DB 01       	in a, (1)
1353   FB3B B9          	cp c
1354   FB3C CA 38 FB    	jp z, l_70
1355   FB3F             l_68: 
1356   FB3F             ; 891     } while (flag_nz(b--));
1357   FB3F 05          	dec b
1358   FB40 C2 37 FB    	jp nz, l_67
1359   FB43             ; 892 
1360   FB43             ; 893     hl += hl;
1361   FB43 29          	add hl, hl
1362   FB44             ; 894     a = h;
1363   FB44 7C          	ld a, h
1364   FB45             ; 895     hl += hl;
1365   FB45 29          	add hl, hl
1366   FB46             ; 896     l = (a += h);
1367   FB46 84          	add h
1368   FB47 6F          	ld l, a
1369   FB48             ; 897 
1370   FB48             ; 898     PrintHexWordSpace();
1371   FB48 C3 F1 FB    	jp printhexwordspace
1372   FB4B             ; 899 }
1373   FB4B             ; 900 
1374   FB4B             ; 901 // Команда I <смещение> <скорость>
1375   FB4B             ; 902 // Загрузить файл с магнитной ленты
1376   FB4B             ; 903 
1377   FB4B             ; 904 void CmdI(...) {
1378   FB4B             cmdi: 
1379   FB4B             ; 905     if ((a = param2Exists) != 0)
1380   FB4B 3A 7B F7    	ld a, (param2exists)
1381   FB4E B7          	or a
1382   FB4F             ; 906         tapeReadSpeed = a = e;
1383   FB4F CA 56 FB    	jp z, l_73
1384   FB52 7B          	ld a, e
1385   FB53 32 5C F7    	ld (tapereadspeed), a
1386   FB56             l_73: 
1387   FB56             ; 907     ReadTapeFile();
1388   FB56 CD 7B FB    	call readtapefile
1389   FB59             ; 908     PrintCrLfTabHexWordSpace(hl);
1390   FB59 CD E8 FB    	call printcrlftabhexwordspace
1391   FB5C             ; 909     swap(hl, de);
1392   FB5C EB          	ex hl, de
1393   FB5D             ; 910     PrintCrLfTabHexWordSpace(hl);
1394   FB5D CD E8 FB    	call printcrlftabhexwordspace
1395   FB60             ; 911     swap(hl, de);
1396   FB60 EB          	ex hl, de
1397   FB61             ; 912     push(bc);
1398   FB61 C5          	push bc
1399   FB62             ; 913     CalculateCheckSum();
1400   FB62 CD B2 FB    	call calculatechecksum
1401   FB65             ; 914     h = b;
1402   FB65 60          	ld h, b
1403   FB66             ; 915     l = c;
1404   FB66 69          	ld l, c
1405   FB67             ; 916     PrintCrLfTabHexWordSpace(hl);
1406   FB67 CD E8 FB    	call printcrlftabhexwordspace
1407   FB6A             ; 917     pop(de);
1408   FB6A D1          	pop de
1409   FB6B             ; 918     CompareHlDe(hl, de);
1410   FB6B CD 8D F9    	call comparehlde
1411   FB6E             ; 919     if (flag_z)
1412   FB6E             ; 920         return;
1413   FB6E C8          	ret z
1414   FB6F             ; 921     swap(hl, de);
1415   FB6F EB          	ex hl, de
1416   FB70             ; 922     PrintCrLfTabHexWordSpace(hl);
1417   FB70 CD E8 FB    	call printcrlftabhexwordspace
1418   FB73             ; 923     MonitorError();
1419   FB73             ; 924 }
1420   FB73             ; 925 
1421   FB73             ; 926 void MonitorError() {
1422   FB73             monitorerror: 
1423   FB73             ; 927     PrintCharA(a = '?');
1424   FB73 3E 3F       	ld a, 63
1425   FB75 CD E2 FC    	call printchara
1426   FB78             ; 928     Monitor2();
1427   FB78 C3 75 F8    	jp monitor2
1428   FB7B             ; 929 }
1429   FB7B             ; 930 
1430   FB7B             ; 931 // Функция для пользовательской программы.
1431   FB7B             ; 932 // Загрузить файл с магнитной ленты.
1432   FB7B             ; 933 // Параметры: hl - смещение загрузки. Результат: bc - прочитанная КС, hl - адрес загрузки
1433   FB7B             ; 934 
1434   FB7B             ; 935 void ReadTapeFile(...) {
1435   FB7B             readtapefile: 
1436   FB7B             ; 936     ReadTapeWord(a = READ_TAPE_FIRST_BYTE);
1437   FB7B 3E FF       	ld a, 255
1438   FB7D CD 9B FB    	call readtapeword
1439   FB80             ; 937     push_pop(hl) {
1440   FB80 E5          	push hl
1441   FB81             ; 938         hl += bc;
1442   FB81 09          	add hl, bc
1443   FB82             ; 939         swap(hl, de);
1444   FB82 EB          	ex hl, de
1445   FB83             ; 940         ReadTapeWordNext();
1446   FB83 CD 99 FB    	call readtapewordnext
1447   FB86 E1          	pop hl
1448   FB87             ; 941     }
1449   FB87             ; 942     hl += bc;
1450   FB87 09          	add hl, bc
1451   FB88             ; 943     swap(hl, de);
1452   FB88 EB          	ex hl, de
1453   FB89             ; 944 
1454   FB89             ; 945     a = in(PORT_KEYBOARD_MODS);
1455   FB89 DB 05       	in a, (5)
1456   FB8B             ; 946     a &= KEYBOARD_SHIFT_MOD;
1457   FB8B E6 04       	and 4
1458   FB8D             ; 947     if (flag_z)
1459   FB8D             ; 948         return;
1460   FB8D C8          	ret z
1461   FB8E             ; 949 
1462   FB8E             ; 950     push_pop(hl) {
1463   FB8E E5          	push hl
1464   FB8F             ; 951         ReadTapeBlock();
1465   FB8F CD A6 FB    	call readtapeblock
1466   FB92             ; 952         ReadTapeWord(a = READ_TAPE_FIRST_BYTE);
1467   FB92 3E FF       	ld a, 255
1468   FB94 CD 9B FB    	call readtapeword
1469   FB97 E1          	pop hl
1470   FB98 C9          	ret
1471   FB99             ; 953     }
1472   FB99             ; 954 }
1473   FB99             ; 955 
1474   FB99             ; 956 void ReadTapeWordNext() {
1475   FB99             readtapewordnext: 
1476   FB99             ; 957     ReadTapeWord(a = READ_TAPE_NEXT_BYTE);
1477   FB99 3E 08       	ld a, 8
1478   FB9B             ; 958 }
1479   FB9B             ; 959 
1480   FB9B             ; 960 void ReadTapeWord(...) {
1481   FB9B             readtapeword: 
1482   FB9B             ; 961     ReadTapeByte(a);
1483   FB9B CD 34 FC    	call readtapebyte
1484   FB9E             ; 962     b = a;
1485   FB9E 47          	ld b, a
1486   FB9F             ; 963     ReadTapeByte(a = READ_TAPE_NEXT_BYTE);
1487   FB9F 3E 08       	ld a, 8
1488   FBA1 CD 34 FC    	call readtapebyte
1489   FBA4             ; 964     c = a;
1490   FBA4 4F          	ld c, a
1491   FBA5 C9          	ret
1492   FBA6             ; 965 }
1493   FBA6             ; 966 
1494   FBA6             ; 967 void ReadTapeBlock(...) {
1495   FBA6             readtapeblock: 
1496   FBA6             ; 968     for (;;) {
1497   FBA6             l_76: 
1498   FBA6             ; 969         ReadTapeByte(a = READ_TAPE_NEXT_BYTE);
1499   FBA6 3E 08       	ld a, 8
1500   FBA8 CD 34 FC    	call readtapebyte
1501   FBAB             ; 970         *hl = a;
1502   FBAB 77          	ld (hl), a
1503   FBAC             ; 971         Loop();
1504   FBAC CD 96 F9    	call loop
1505   FBAF C3 A6 FB    	jp l_76
1506   FBB2             ; 972     }
1507   FBB2             ; 973 }
1508   FBB2             ; 974 
1509   FBB2             ; 975 // Функция для пользовательской программы.
1510   FBB2             ; 976 // Вычистить 16-битную сумму всех байт по адресам hl..de.
1511   FBB2             ; 977 // Параметры: hl - начальный адрес, de - конечный адрес. Результат: bc - сумма. Сохраяет: de.
1512   FBB2             ; 978 
1513   FBB2             ; 979 void CalculateCheckSum(...) {
1514   FBB2             calculatechecksum: 
1515   FBB2             ; 980     bc = 0;
1516   FBB2 01 00 00    	ld bc, 0
1517   FBB5             ; 981     for (;;) {
1518   FBB5             l_79: 
1519   FBB5             ; 982         c = ((a = *hl) += c);
1520   FBB5 7E          	ld a, (hl)
1521   FBB6 81          	add c
1522   FBB7 4F          	ld c, a
1523   FBB8             ; 983         push_pop(a) {
1524   FBB8 F5          	push af
1525   FBB9             ; 984             CompareHlDe(hl, de);
1526   FBB9 CD 8D F9    	call comparehlde
1527   FBBC             ; 985             if (flag_z)
1528   FBBC             ; 986                 return PopRet();
1529   FBBC CA 9C F9    	jp z, popret
1530   FBBF F1          	pop af
1531   FBC0             ; 987         }
1532   FBC0             ; 988         a = b;
1533   FBC0 78          	ld a, b
1534   FBC1             ; 989         carry_add(a, *hl);
1535   FBC1 8E          	adc (hl)
1536   FBC2             ; 990         b = a;
1537   FBC2 47          	ld b, a
1538   FBC3             ; 991         Loop();
1539   FBC3 CD 96 F9    	call loop
1540   FBC6 C3 B5 FB    	jp l_79
1541   FBC9             ; 992     }
1542   FBC9             ; 993 }
1543   FBC9             ; 994 
1544   FBC9             ; 995 // Команда O <начальный адрес> <конечный адрес> <скорость>
1545   FBC9             ; 996 // Сохранить блок данных на магнитную ленту
1546   FBC9             ; 997 
1547   FBC9             ; 998 void CmdO(...) {
1548   FBC9             cmdo: 
1549   FBC9             ; 999     if ((a = c) != 0)
1550   FBC9 79          	ld a, c
1551   FBCA B7          	or a
1552   FBCB             ; 1000         tapeWriteSpeed = a;
1553   FBCB CA D1 FB    	jp z, l_81
1554   FBCE 32 5D F7    	ld (tapewritespeed), a
1555   FBD1             l_81: 
1556   FBD1             ; 1001     push_pop(hl) {
1557   FBD1 E5          	push hl
1558   FBD2             ; 1002         CalculateCheckSum(hl, de);
1559   FBD2 CD B2 FB    	call calculatechecksum
1560   FBD5 E1          	pop hl
1561   FBD6             ; 1003     }
1562   FBD6             ; 1004     PrintCrLfTabHexWordSpace(hl);
1563   FBD6 CD E8 FB    	call printcrlftabhexwordspace
1564   FBD9             ; 1005     swap(hl, de);
1565   FBD9 EB          	ex hl, de
1566   FBDA             ; 1006     PrintCrLfTabHexWordSpace(hl);
1567   FBDA CD E8 FB    	call printcrlftabhexwordspace
1568   FBDD             ; 1007     swap(hl, de);
1569   FBDD EB          	ex hl, de
1570   FBDE             ; 1008     push_pop(hl) {
1571   FBDE E5          	push hl
1572   FBDF             ; 1009         h = b;
1573   FBDF 60          	ld h, b
1574   FBE0             ; 1010         l = c;
1575   FBE0 69          	ld l, c
1576   FBE1             ; 1011         PrintCrLfTabHexWordSpace(hl);
1577   FBE1 CD E8 FB    	call printcrlftabhexwordspace
1578   FBE4 E1          	pop hl
1579   FBE5             ; 1012     }
1580   FBE5             ; 1013     WriteTapeFile(hl, de);
1581   FBE5 C3 03 FC    	jp writetapefile
1582   FBE8             ; 1014 }
1583   FBE8             ; 1015 
1584   FBE8             ; 1016 void PrintCrLfTabHexWordSpace(...) {
1585   FBE8             printcrlftabhexwordspace: 
1586   FBE8             ; 1017     push_pop(bc) {
1587   FBE8 C5          	push bc
1588   FBE9             ; 1018         PrintCrLfTab();
1589   FBE9 CD AA F9    	call printcrlftab
1590   FBEC             ; 1019         PrintHexWordSpace(hl);
1591   FBEC CD F1 FB    	call printhexwordspace
1592   FBEF C1          	pop bc
1593   FBF0 C9          	ret
1594   FBF1             ; 1020     }
1595   FBF1             ; 1021 }
1596   FBF1             ; 1022 
1597   FBF1             ; 1023 void PrintHexWordSpace(...) {
1598   FBF1             printhexwordspace: 
1599   FBF1             ; 1024     PrintHexByte(a = h);
1600   FBF1 7C          	ld a, h
1601   FBF2 CD CE FC    	call printhexbyte
1602   FBF5             ; 1025     PrintHexByteSpace(a = l);
1603   FBF5 7D          	ld a, l
1604   FBF6 C3 B4 F9    	jp printhexbytespace
1605   FBF9             ; 1026 }
1606   FBF9             ; 1027 
1607   FBF9             ; 1028 void WriteTapeBlock(...) {
1608   FBF9             writetapeblock: 
1609   FBF9             ; 1029     for (;;) {
1610   FBF9             l_84: 
1611   FBF9             ; 1030         WriteTapeByte(c = *hl);
1612   FBF9 4E          	ld c, (hl)
1613   FBFA CD 9D FC    	call writetapebyte
1614   FBFD             ; 1031         Loop();
1615   FBFD CD 96 F9    	call loop
1616   FC00 C3 F9 FB    	jp l_84
1617   FC03             ; 1032     }
1618   FC03             ; 1033 }
1619   FC03             ; 1034 
1620   FC03             ; 1035 // Функция для пользовательской программы.
1621   FC03             ; 1036 // Запись файла на магнитную ленту.
1622   FC03             ; 1037 // Параметры: de - начальный адрес, hl - конечный адрес, bc - контрольная сумма. Результат: нет.
1623   FC03             ; 1038 
1624   FC03             ; 1039 void WriteTapeFile(...) {
1625   FC03             writetapefile: 
1626   FC03             ; 1040     push(bc);
1627   FC03 C5          	push bc
1628   FC04             ; 1041     bc = 0;
1629   FC04 01 00 00    	ld bc, 0
1630   FC07             ; 1042     do {
1631   FC07             l_86: 
1632   FC07             ; 1043         WriteTapeByte(c);
1633   FC07 CD 9D FC    	call writetapebyte
1634   FC0A             ; 1044         b--;
1635   FC0A 05          	dec b
1636   FC0B             ; 1045         swap(hl, *sp);
1637   FC0B E3          	ex (sp), hl
1638   FC0C             ; 1046         swap(hl, *sp);
1639   FC0C E3          	ex (sp), hl
1640   FC0D             l_87: 
1641   FC0D C2 07 FC    	jp nz, l_86
1642   FC10             ; 1047     } while (flag_nz);
1643   FC10             ; 1048     WriteTapeByte(c = TAPE_START);
1644   FC10 0E E6       	ld c, 230
1645   FC12 CD 9D FC    	call writetapebyte
1646   FC15             ; 1049     WriteTapeWord(hl);
1647   FC15 CD 2C FC    	call writetapeword
1648   FC18             ; 1050     swap(hl, de);
1649   FC18 EB          	ex hl, de
1650   FC19             ; 1051     WriteTapeWord(hl);
1651   FC19 CD 2C FC    	call writetapeword
1652   FC1C             ; 1052     swap(hl, de);
1653   FC1C EB          	ex hl, de
1654   FC1D             ; 1053     WriteTapeBlock(hl, de);
1655   FC1D CD F9 FB    	call writetapeblock
1656   FC20             ; 1054     WriteTapeWord(hl = 0);
1657   FC20 21 00 00    	ld hl, 0
1658   FC23 CD 2C FC    	call writetapeword
1659   FC26             ; 1055     WriteTapeByte(c = TAPE_START);
1660   FC26 0E E6       	ld c, 230
1661   FC28 CD 9D FC    	call writetapebyte
1662   FC2B             ; 1056     pop(hl);
1663   FC2B E1          	pop hl
1664   FC2C             ; 1057     WriteTapeWord(hl);
1665   FC2C             ; 1058 }
1666   FC2C             ; 1059 
1667   FC2C             ; 1060 void WriteTapeWord(...) {
1668   FC2C             writetapeword: 
1669   FC2C             ; 1061     WriteTapeByte(c = h);
1670   FC2C 4C          	ld c, h
1671   FC2D CD 9D FC    	call writetapebyte
1672   FC30             ; 1062     WriteTapeByte(c = l);
1673   FC30 4D          	ld c, l
1674   FC31 C3 9D FC    	jp writetapebyte
1675   FC34             ; 1063 }
1676   FC34             ; 1064 
1677   FC34             ; 1065 // Загрузка байта с магнитной ленты.
1678   FC34             ; 1066 // Параметры: a = 0xFF с синхронизацией, = 8 без синхронизации.
1679   FC34             ; 1067 // Результат: a = прочитанный байт.
1680   FC34             ; 1068 
1681   FC34             ; 1069 void ReadTapeByte(...) {
1682   FC34             readtapebyte: 
1683   FC34             ; 1070     push(hl, bc, de);
1684   FC34 E5          	push hl
1685   FC35 C5          	push bc
1686   FC36 D5          	push de
1687   FC37             ; 1071     d = a;
1688   FC37 57          	ld d, a
1689   FC38             ; 1072     ReadTapeByteInternal(d);
1690   FC38             ; 1073 }
1691   FC38             ; 1074 
1692   FC38             ; 1075 void ReadTapeByteInternal(...) {
1693   FC38             readtapebyteinternal: 
1694   FC38             ; 1076     c = 0;
1695   FC38 0E 00       	ld c, 0
1696   FC3A             ; 1077     e = ((a = in(PORT_TAPE)) &= PORT_TAPE_BIT);
1697   FC3A DB 01       	in a, (1)
1698   FC3C E6 01       	and 1
1699   FC3E 5F          	ld e, a
1700   FC3F             ; 1078     do {
1701   FC3F             l_89: 
1702   FC3F             ; 1079 retry:  // Сдвиг результата
1703   FC3F             retry: 
1704   FC3F             ; 1080         (a = c) &= 0x7F;
1705   FC3F 79          	ld a, c
1706   FC40 E6 7F       	and 127
1707   FC42             ; 1081         cyclic_rotate_left(a, 1);
1708   FC42 07          	rlca
1709   FC43             ; 1082         c = a;
1710   FC43 4F          	ld c, a
1711   FC44             ; 1083 
1712   FC44             ; 1084         // Ожидание изменения бита
1713   FC44             ; 1085         h = 0;
1714   FC44 26 00       	ld h, 0
1715   FC46             ; 1086         do {
1716   FC46             l_92: 
1717   FC46             ; 1087             h--;
1718   FC46 25          	dec h
1719   FC47             ; 1088             if (flag_z)
1720   FC47             ; 1089                 return ReadTapeByteTimeout(d);
1721   FC47 CA 92 FC    	jp z, readtapebytetimeout
1722   FC4A             l_93: 
1723   FC4A             ; 1090         } while (((a = in(PORT_TAPE)) &= PORT_TAPE_BIT) == e);
1724   FC4A DB 01       	in a, (1)
1725   FC4C E6 01       	and 1
1726   FC4E BB          	cp e
1727   FC4F CA 46 FC    	jp z, l_92
1728   FC52             ; 1091 
1729   FC52             ; 1092         // Сохранение бита
1730   FC52             ; 1093         c = (a |= c);
1731   FC52 B1          	or c
1732   FC53 4F          	ld c, a
1733   FC54             ; 1094 
1734   FC54             ; 1095         // Задержка
1735   FC54             ; 1096         d--;
1736   FC54 15          	dec d
1737   FC55             ; 1097         a = tapeReadSpeed;
1738   FC55 3A 5C F7    	ld a, (tapereadspeed)
1739   FC58             ; 1098         if (flag_z)
1740   FC58             ; 1099             a -= 18;
1741   FC58 C2 5D FC    	jp nz, l_95
1742   FC5B D6 12       	sub 18
1743   FC5D             l_95: 
1744   FC5D             ; 1100         b = a;
1745   FC5D 47          	ld b, a
1746   FC5E             ; 1101         do {
1747   FC5E             l_97: 
1748   FC5E             l_98: 
1749   FC5E             ; 1102         } while (flag_nz(b--));
1750   FC5E 05          	dec b
1751   FC5F C2 5E FC    	jp nz, l_97
1752   FC62             ; 1103         d++;
1753   FC62 14          	inc d
1754   FC63             ; 1104 
1755   FC63             ; 1105         // Новое значение бита
1756   FC63             ; 1106         e = ((a = in(PORT_TAPE)) &= PORT_TAPE_BIT);
1757   FC63 DB 01       	in a, (1)
1758   FC65 E6 01       	and 1
1759   FC67 5F          	ld e, a
1760   FC68             ; 1107 
1761   FC68             ; 1108         // Режим поиска синхробайта
1762   FC68             ; 1109         if (flag_m((a = d) |= a)) {
1763   FC68 7A          	ld a, d
1764   FC69 B7          	or a
1765   FC6A F2 86 FC    	jp p, l_100
1766   FC6D             ; 1110             if ((a = c) == TAPE_START) {
1767   FC6D 79          	ld a, c
1768   FC6E FE E6       	cp 230
1769   FC70 C2 7A FC    	jp nz, l_102
1770   FC73             ; 1111                 tapePolarity = (a ^= a);
1771   FC73 AF          	xor a
1772   FC74 32 7C F7    	ld (tapepolarity), a
1773   FC77 C3 84 FC    	jp l_103
1774   FC7A             l_102: 
1775   FC7A             ; 1112             } else {
1776   FC7A             ; 1113                 if (a != ~TAPE_START)
1777   FC7A FE 19       	cp 65305
1778   FC7C             ; 1114                     goto retry;
1779   FC7C C2 3F FC    	jp nz, retry
1780   FC7F             ; 1115                 tapePolarity = a = 255;
1781   FC7F 3E FF       	ld a, 255
1782   FC81 32 7C F7    	ld (tapepolarity), a
1783   FC84             l_103: 
1784   FC84             ; 1116             }
1785   FC84             ; 1117             d = 8 + 1;
1786   FC84 16 09       	ld d, 9
1787   FC86             l_100: 
1788   FC86             l_90: 
1789   FC86             ; 1118         }
1790   FC86             ; 1119     } while (flag_nz(d--));
1791   FC86 15          	dec d
1792   FC87 C2 3F FC    	jp nz, l_89
1793   FC8A             ; 1120     (a = tapePolarity) ^= c;
1794   FC8A 3A 7C F7    	ld a, (tapepolarity)
1795   FC8D A9          	xor c
1796   FC8E             ; 1121     pop(hl, bc, de);
1797   FC8E D1          	pop de
1798   FC8F C1          	pop bc
1799   FC90 E1          	pop hl
1800   FC91 C9          	ret
1801   FC92             ; 1122 }
1802   FC92             ; 1123 
1803   FC92             ; 1124 void ReadTapeByteTimeout(...) {
1804   FC92             readtapebytetimeout: 
1805   FC92             ; 1125     if (flag_p((a = d) |= a))
1806   FC92 7A          	ld a, d
1807   FC93 B7          	or a
1808   FC94             ; 1126         return MonitorError();
1809   FC94 F2 73 FB    	jp p, monitorerror
1810   FC97             ; 1127     CtrlC();
1811   FC97 CD A1 F9    	call ctrlc
1812   FC9A             ; 1128     ReadTapeByteInternal();
1813   FC9A C3 38 FC    	jp readtapebyteinternal
1814   FC9D             ; 1129 }
1815   FC9D             ; 1130 
1816   FC9D             ; 1131 // Функция для пользовательской программы.
1817   FC9D             ; 1132 // Запись байта на магнитную ленту.
1818   FC9D             ; 1133 // Параметры: c = байт. Результат: нет. Сохрнаяет: a, bc, de, hl.
1819   FC9D             ; 1134 
1820   FC9D             ; 1135 void WriteTapeByte(...) {
1821   FC9D             writetapebyte: 
1822   FC9D             ; 1136     push_pop(bc, de, a) {
1823   FC9D C5          	push bc
1824   FC9E D5          	push de
1825   FC9F F5          	push af
1826   FCA0             ; 1137         d = 8;
1827   FCA0 16 08       	ld d, 8
1828   FCA2             ; 1138         do {
1829   FCA2             l_104: 
1830   FCA2             ; 1139             // Сдвиг исходного байта
1831   FCA2             ; 1140             a = c;
1832   FCA2 79          	ld a, c
1833   FCA3             ; 1141             cyclic_rotate_left(a, 1);
1834   FCA3 07          	rlca
1835   FCA4             ; 1142             c = a;
1836   FCA4 4F          	ld c, a
1837   FCA5             ; 1143 
1838   FCA5             ; 1144             // Вывод
1839   FCA5             ; 1145             (a = PORT_TAPE_BIT) ^= c;
1840   FCA5 3E 01       	ld a, 1
1841   FCA7 A9          	xor c
1842   FCA8             ; 1146             out(PORT_TAPE, a);
1843   FCA8 D3 01       	out (1), a
1844   FCAA             ; 1147 
1845   FCAA             ; 1148             // Задержка
1846   FCAA             ; 1149             b = a = tapeWriteSpeed;
1847   FCAA 3A 5D F7    	ld a, (tapewritespeed)
1848   FCAD 47          	ld b, a
1849   FCAE             ; 1150             do {
1850   FCAE             l_107: 
1851   FCAE             ; 1151                 b--;
1852   FCAE 05          	dec b
1853   FCAF             l_108: 
1854   FCAF C2 AE FC    	jp nz, l_107
1855   FCB2             ; 1152             } while (flag_nz);
1856   FCB2             ; 1153 
1857   FCB2             ; 1154             // Вывод
1858   FCB2             ; 1155             (a = 0) ^= c;
1859   FCB2 3E 00       	ld a, 0
1860   FCB4 A9          	xor c
1861   FCB5             ; 1156             out(PORT_TAPE, a);
1862   FCB5 D3 01       	out (1), a
1863   FCB7             ; 1157 
1864   FCB7             ; 1158             // Задержка
1865   FCB7             ; 1159             d--;
1866   FCB7 15          	dec d
1867   FCB8             ; 1160             a = tapeWriteSpeed;
1868   FCB8 3A 5D F7    	ld a, (tapewritespeed)
1869   FCBB             ; 1161             if (flag_z)
1870   FCBB             ; 1162                 a -= 14;
1871   FCBB C2 C0 FC    	jp nz, l_110
1872   FCBE D6 0E       	sub 14
1873   FCC0             l_110: 
1874   FCC0             ; 1163             b = a;
1875   FCC0 47          	ld b, a
1876   FCC1             ; 1164             do {
1877   FCC1             l_112: 
1878   FCC1             ; 1165                 b--;
1879   FCC1 05          	dec b
1880   FCC2             l_113: 
1881   FCC2 C2 C1 FC    	jp nz, l_112
1882   FCC5             ; 1166             } while (flag_nz);
1883   FCC5             ; 1167             d++;
1884   FCC5 14          	inc d
1885   FCC6             l_105: 
1886   FCC6             ; 1168         } while (flag_nz(d--));
1887   FCC6 15          	dec d
1888   FCC7 C2 A2 FC    	jp nz, l_104
1889   FCCA F1          	pop af
1890   FCCB D1          	pop de
1891   FCCC C1          	pop bc
1892   FCCD C9          	ret
1893   FCCE             ; 1169     }
1894   FCCE             ; 1170 }
1895   FCCE             ; 1171 
1896   FCCE             ; 1172 // Функция для пользовательской программы.
1897   FCCE             ; 1173 // Вывод 8 битного числа на экран.
1898   FCCE             ; 1174 // Параметры: а - число. Результат: нет. Сохраняет: bc, de, hl.
1899   FCCE             ; 1175 
1900   FCCE             ; 1176 void PrintHexByte(...) {
1901   FCCE             printhexbyte: 
1902   FCCE             ; 1177     push_pop(a) {
1903   FCCE F5          	push af
1904   FCCF             ; 1178         cyclic_rotate_right(a, 4);
1905   FCCF 0F          	rrca
1906   FCD0 0F          	rrca
1907   FCD1 0F          	rrca
1908   FCD2 0F          	rrca
1909   FCD3             ; 1179         PrintHexNibble(a);
1910   FCD3 CD D7 FC    	call printhexnibble
1911   FCD6 F1          	pop af
1912   FCD7             ; 1180     }
1913   FCD7             ; 1181     PrintHexNibble(a);
1914   FCD7             ; 1182 }
1915   FCD7             ; 1183 
1916   FCD7             ; 1184 void PrintHexNibble(...) {
1917   FCD7             printhexnibble: 
1918   FCD7             ; 1185     a &= 0x0F;
1919   FCD7 E6 0F       	and 15
1920   FCD9             ; 1186     if (flag_p(compare(a, 10)))
1921   FCD9 FE 0A       	cp 10
1922   FCDB             ; 1187         a += 'A' - '0' - 10;
1923   FCDB FA E0 FC    	jp m, l_115
1924   FCDE C6 07       	add 7
1925   FCE0             l_115: 
1926   FCE0             ; 1188     a += '0';
1927   FCE0 C6 30       	add 48
1928   FCE2             ; 1189     PrintCharA(a);
1929   FCE2             ; 1190 }
1930   FCE2             ; 1191 
1931   FCE2             ; 1192 // Вывод символа на экран.
1932   FCE2             ; 1193 // Параметры: а - символ. Результат: a и c - символ. Сохраняет: a, b, de, hl.
1933   FCE2             ; 1194 
1934   FCE2             ; 1195 void PrintCharA(...) {
1935   FCE2             printchara: 
1936   FCE2             ; 1196     PrintChar(c = a);
1937   FCE2 4F          	ld c, a
1938   FCE3             ; 1197 }
1939   FCE3             ; 1198 
1940   FCE3             ; 1199 // Функция для пользовательской программы.
1941   FCE3             ; 1200 // Вывод символа на экран.
1942   FCE3             ; 1201 // Параметры: c - символ. Результат: нет. Сохраняет: a, b, de, hl.
1943   FCE3             ; 1202 
1944   FCE3             ; 1203 void PrintChar(...) {
1945   FCE3             printchar: 
1946   FCE3             ; 1204     push(a, bc, de, hl);
1947   FCE3 F5          	push af
1948   FCE4 C5          	push bc
1949   FCE5 D5          	push de
1950   FCE6 E5          	push hl
1951   FCE7             ; 1205     hl = cursor;
1952   FCE7 2A 5A F7    	ld hl, (cursor)
1953   FCEA             ; 1206     DrawCursor(hl);
1954   FCEA CD 30 FD    	call drawcursor
1955   FCED             ; 1207     a = escState;
1956   FCED 3A 5F F7    	ld a, (escstate)
1957   FCF0             ; 1208     a--;
1958   FCF0 3D          	dec a
1959   FCF1             ; 1209     if (flag_m)
1960   FCF1             ; 1210         return PrintCharNoEsc();
1961   FCF1 FA 79 FD    	jp m, printcharnoesc
1962   FCF4             ; 1211     if (flag_z)
1963   FCF4             ; 1212         return PrintCharEsc();
1964   FCF4 CA 5A FD    	jp z, printcharesc
1965   FCF7             ; 1213     a--;
1966   FCF7 3D          	dec a
1967   FCF8             ; 1214     if (flag_nz)
1968   FCF8             ; 1215         return PrintCharEscY2();
1969   FCF8 C2 3F FD    	jp nz, printcharescy2
1970   FCFB             ; 1216 
1971   FCFB             ; 1217     // Первый параметр ESC Y
1972   FCFB             ; 1218     a = c;
1973   FCFB 79          	ld a, c
1974   FCFC             ; 1219     a -= ' ';
1975   FCFC D6 20       	sub 32
1976   FCFE             ; 1220     if (flag_m) {
1977   FCFE F2 05 FD    	jp p, l_117
1978   FD01             ; 1221         a ^= a;
1979   FD01 AF          	xor a
1980   FD02 C3 0C FD    	jp l_118
1981   FD05             l_117: 
1982   FD05             ; 1222     } else {
1983   FD05             ; 1223         if (flag_p(compare(a, SCREEN_HEIGHT)))
1984   FD05 FE 19       	cp 25
1985   FD07             ; 1224             a = SCREEN_HEIGHT - 1;
1986   FD07 FA 0C FD    	jp m, l_119
1987   FD0A 3E 18       	ld a, 24
1988   FD0C             l_119: 
1989   FD0C             l_118: 
1990   FD0C             ; 1225     }
1991   FD0C             ; 1226     cyclic_rotate_right(a, 2);
1992   FD0C 0F          	rrca
1993   FD0D 0F          	rrca
1994   FD0E             ; 1227     c = a;
1995   FD0E 4F          	ld c, a
1996   FD0F             ; 1228     b = (a &= 192);
1997   FD0F E6 C0       	and 192
1998   FD11 47          	ld b, a
1999   FD12             ; 1229     l = (((a = l) &= 63) |= b);
2000   FD12 7D          	ld a, l
2001   FD13 E6 3F       	and 63
2002   FD15 B0          	or b
2003   FD16 6F          	ld l, a
2004   FD17             ; 1230     b = ((a = c) &= 7);
2005   FD17 79          	ld a, c
2006   FD18 E6 07       	and 7
2007   FD1A 47          	ld b, a
2008   FD1B             ; 1231     h = (((a = h) &= 248) |= b);
2009   FD1B 7C          	ld a, h
2010   FD1C E6 F8       	and 248
2011   FD1E B0          	or b
2012   FD1F 67          	ld h, a
2013   FD20             ; 1232     PrintCharSetEscState(hl, a = 3);
2014   FD20 3E 03       	ld a, 3
2015   FD22             ; 1233 }
2016   FD22             ; 1234 
2017   FD22             ; 1235 void PrintCharSetEscState(...) {
2018   FD22             printcharsetescstate: 
2019   FD22             ; 1236     escState = a;
2020   FD22 32 5F F7    	ld (escstate), a
2021   FD25             ; 1237     PrintCharSaveCursor(hl);
2022   FD25             ; 1238 }
2023   FD25             ; 1239 
2024   FD25             ; 1240 void PrintCharSaveCursor(...) {
2025   FD25             printcharsavecursor: 
2026   FD25             ; 1241     cursor = hl;
2027   FD25 22 5A F7    	ld (cursor), hl
2028   FD28             ; 1242     PrintCharExit();
2029   FD28             ; 1243 }
2030   FD28             ; 1244 
2031   FD28             ; 1245 void PrintCharExit(...) {
2032   FD28             printcharexit: 
2033   FD28             ; 1246     DrawCursor(hl);
2034   FD28 CD 30 FD    	call drawcursor
2035   FD2B             ; 1247     pop(a, bc, de, hl);
2036   FD2B E1          	pop hl
2037   FD2C D1          	pop de
2038   FD2D C1          	pop bc
2039   FD2E F1          	pop af
2040   FD2F C9          	ret
2041   FD30             ; 1248 }
2042   FD30             ; 1249 
2043   FD30             ; 1250 void DrawCursor(...) {
2044   FD30             drawcursor: 
2045   FD30             ; 1251     if ((a = cursorVisible) == 0)
2046   FD30 3A 5E F7    	ld a, (cursorvisible)
2047   FD33 B7          	or a
2048   FD34             ; 1252         return;
2049   FD34 C8          	ret z
2050   FD35             ; 1253     d = ((a = h) -= (SCREEN_SIZE >> 8));
2051   FD35 7C          	ld a, h
2052   FD36 D6 08       	sub 8
2053   FD38 57          	ld d, a
2054   FD39             ; 1254     e = l;
2055   FD39 5D          	ld e, l
2056   FD3A             ; 1255     a = *de;
2057   FD3A 1A          	ld a, (de)
2058   FD3B             ; 1256     a ^= SCREEN_ATTRIB_UNDERLINE;
2059   FD3B EE 80       	xor 128
2060   FD3D             ; 1257     *de = a;
2061   FD3D 12          	ld (de), a
2062   FD3E C9          	ret
2063   FD3F             ; 1258 }
2064   FD3F             ; 1259 
2065   FD3F             ; 1260 void PrintCharEscY2(...) {
2066   FD3F             printcharescy2: 
2067   FD3F             ; 1261     a = c;
2068   FD3F 79          	ld a, c
2069   FD40             ; 1262     a -= ' ';
2070   FD40 D6 20       	sub 32
2071   FD42             ; 1263     if (flag_m) {
2072   FD42 F2 49 FD    	jp p, l_121
2073   FD45             ; 1264         a ^= a;
2074   FD45 AF          	xor a
2075   FD46 C3 50 FD    	jp l_122
2076   FD49             l_121: 
2077   FD49             ; 1265     } else {
2078   FD49             ; 1266         if (flag_p(compare(a, SCREEN_WIDTH)))
2079   FD49 FE 40       	cp 64
2080   FD4B             ; 1267             a = SCREEN_WIDTH - 1;
2081   FD4B FA 50 FD    	jp m, l_123
2082   FD4E 3E 3F       	ld a, 63
2083   FD50             l_123: 
2084   FD50             l_122: 
2085   FD50             ; 1268     }
2086   FD50             ; 1269     b = a;
2087   FD50 47          	ld b, a
2088   FD51             ; 1270     l = (((a = l) &= 192) |= b);
2089   FD51 7D          	ld a, l
2090   FD52 E6 C0       	and 192
2091   FD54 B0          	or b
2092   FD55 6F          	ld l, a
2093   FD56             ; 1271     PrintCharResetEscState();
2094   FD56             ; 1272 }
2095   FD56             ; 1273 
2096   FD56             ; 1274 void PrintCharResetEscState(...) {
2097   FD56             printcharresetescstate: 
2098   FD56             ; 1275     a ^= a;
2099   FD56 AF          	xor a
2100   FD57             ; 1276     PrintCharSetEscState();
2101   FD57 C3 22 FD    	jp printcharsetescstate
2102   FD5A             ; 1277 }
2103   FD5A             ; 1278 
2104   FD5A             ; 1279 void PrintCharEsc(...) {
2105   FD5A             printcharesc: 
2106   FD5A             ; 1280     a = c;
2107   FD5A 79          	ld a, c
2108   FD5B             ; 1281     if (a == 'Y') {
2109   FD5B FE 59       	cp 89
2110   FD5D C2 65 FD    	jp nz, l_125
2111   FD60             ; 1282         a = 2;
2112   FD60 3E 02       	ld a, 2
2113   FD62             ; 1283         return PrintCharSetEscState();
2114   FD62 C3 22 FD    	jp printcharsetescstate
2115   FD65             l_125: 
2116   FD65             ; 1284     }
2117   FD65             ; 1285     if (a == 97) {
2118   FD65 FE 61       	cp 97
2119   FD67 C2 6E FD    	jp nz, l_127
2120   FD6A             ; 1286         a ^= a;
2121   FD6A AF          	xor a
2122   FD6B             ; 1287         return SetCursorVisible();
2123   FD6B C3 73 FD    	jp setcursorvisible
2124   FD6E             l_127: 
2125   FD6E             ; 1288     }
2126   FD6E             ; 1289     if (a != 98)
2127   FD6E FE 62       	cp 98
2128   FD70             ; 1290         return PrintCharResetEscState();
2129   FD70 C2 56 FD    	jp nz, printcharresetescstate
2130   FD73             ; 1291     SetCursorVisible();
2131   FD73             ; 1292 }
2132   FD73             ; 1293 
2133   FD73             ; 1294 void SetCursorVisible(...) {
2134   FD73             setcursorvisible: 
2135   FD73             ; 1295     cursorVisible = a;
2136   FD73 32 5E F7    	ld (cursorvisible), a
2137   FD76             ; 1296     PrintCharResetEscState();
2138   FD76 C3 56 FD    	jp printcharresetescstate
2139   FD79             ; 1297 }
2140   FD79             ; 1298 
2141   FD79             ; 1299 void PrintCharNoEsc(...) {
2142   FD79             printcharnoesc: 
2143   FD79             ; 1300     // Остановка вывода нажатием УС + Шифт
2144   FD79             ; 1301     do {
2145   FD79             l_129: 
2146   FD79             ; 1302         a = in(PORT_KEYBOARD_MODS);
2147   FD79 DB 05       	in a, (5)
2148   FD7B             l_130: 
2149   FD7B             ; 1303     } while (flag_z(a &= (KEYBOARD_US_MOD | KEYBOARD_SHIFT_MOD)));
2150   FD7B E6 06       	and 6
2151   FD7D CA 79 FD    	jp z, l_129
2152   FD80             ; 1304 
2153   FD80             ; 1305 #ifdef CMD_A_ENABLED
2154   FD80             ; 1306     compare(a = 16, c);
2155   FD80             ; 1307     a = translateCodeEnabled;
2156   FD80             ; 1308     if (flag_z) {
2157   FD80             ; 1309         invert(a);
2158   FD80             ; 1310         translateCodeEnabled = a;
2159   FD80             ; 1311         return PrintCharSaveCursor();
2160   FD80             ; 1312     }
2161   FD80             ; 1313     if (a != 0)
2162   FD80             ; 1314         TranslateCodePage(c);
2163   FD80             ; 1315 #endif
2164   FD80             ; 1316     a = c;
2165   FD80 79          	ld a, c
2166   FD81             ; 1317     if (a == 31)
2167   FD81 FE 1F       	cp 31
2168   FD83             ; 1318         return ClearScreen();
2169   FD83 CA A5 FD    	jp z, clearscreen
2170   FD86             ; 1319     if (flag_m)
2171   FD86             ; 1320         return PrintChar3(a);
2172   FD86 FA C5 FD    	jp m, printchar3
2173   FD89             ; 1321     PrintChar4(a);
2174   FD89             ; 1322 }
2175   FD89             ; 1323 
2176   FD89             ; 1324 void PrintChar4(...) {
2177   FD89             printchar4: 
2178   FD89             ; 1325     *hl = a;
2179   FD89 77          	ld (hl), a
2180   FD8A             ; 1326     d = ((a = h) -= (SCREEN_SIZE >> 8));
2181   FD8A 7C          	ld a, h
2182   FD8B D6 08       	sub 8
2183   FD8D 57          	ld d, a
2184   FD8E             ; 1327     e = l;
2185   FD8E 5D          	ld e, l
2186   FD8F             ; 1328     *de = a = color;
2187   FD8F 3A 59 F7    	ld a, (color)
2188   FD92 12          	ld (de), a
2189   FD93             ; 1329     hl++;
2190   FD93 23          	inc hl
2191   FD94             ; 1330     TryScrollUp(hl);
2192   FD94 C3 3D FE    	jp tryscrollup
2193   FD97             ; 1331 }
2194   FD97             ; 1332 
2195   FD97             ; 1333 void ClearScreenInt(...) {
2196   FD97             clearscreenint: 
2197   FD97             ; 1334     do {
2198   FD97             l_132: 
2199   FD97             ; 1335         do {
2200   FD97             l_135: 
2201   FD97             ; 1336             *hl = 0;
2202   FD97 36 00       	ld (hl), 0
2203   FD99             ; 1337             hl++;
2204   FD99 23          	inc hl
2205   FD9A             ; 1338             *de = a;
2206   FD9A 12          	ld (de), a
2207   FD9B             ; 1339             de++;
2208   FD9B 13          	inc de
2209   FD9C             l_136: 
2210   FD9C             ; 1340         } while (flag_nz(c--));
2211   FD9C 0D          	dec c
2212   FD9D C2 97 FD    	jp nz, l_135
2213   FDA0             l_133: 
2214   FDA0             ; 1341     } while (flag_nz(b--));
2215   FDA0 05          	dec b
2216   FDA1 C2 97 FD    	jp nz, l_132
2217   FDA4 C9          	ret
2218   FDA5             ; 1342 }
2219   FDA5             ; 1343 
2220   FDA5             ; 1344 void ClearScreen() {
2221   FDA5             clearscreen: 
2222   FDA5             ; 1345     hl = SCREEN_BEGIN;
2223   FDA5 21 00 E8    	ld hl, 59392
2224   FDA8             ; 1346     de = SCREEN_ATTRIB_BEGIN;
2225   FDA8 11 00 E0    	ld de, 57344
2226   FDAB             ; 1347     bc = 25 * SCREEN_WIDTH + 0x100;  // 25 строк
2227   FDAB 01 40 07    	ld bc, 1856
2228   FDAE             ; 1348     a = color;
2229   FDAE 3A 59 F7    	ld a, (color)
2230   FDB1             ; 1349     ClearScreenInt();
2231   FDB1 CD 97 FD    	call clearscreenint
2232   FDB4             ; 1350     a = SCREEN_ATTRIB_BLANK;
2233   FDB4 3E 07       	ld a, 7
2234   FDB6             ; 1351     bc = 7 * SCREEN_WIDTH + 0x100;  // 7 строк
2235   FDB6 01 C0 02    	ld bc, 704
2236   FDB9             ; 1352     ClearScreenInt();
2237   FDB9 CD 97 FD    	call clearscreenint
2238   FDBC             ; 1353     PrintKeyStatus();
2239   FDBC CD CD FF    	call printkeystatus
2240   FDBF             ; 1354     MoveCursorHome();
2241   FDBF             ; 1355 }
2242   FDBF             ; 1356 
2243   FDBF             ; 1357 void MoveCursorHome(...) {
2244   FDBF             movecursorhome: 
2245   FDBF             ; 1358     PrintCharSaveCursor(hl = SCREEN_BEGIN);
2246   FDBF 21 00 E8    	ld hl, 59392
2247   FDC2 C3 25 FD    	jp printcharsavecursor
2248   FDC5             ; 1359 }
2249   FDC5             ; 1360 
2250   FDC5             ; 1361 void PrintChar3(...) {
2251   FDC5             printchar3: 
2252   FDC5             ; 1362     if (a == 12)
2253   FDC5 FE 0C       	cp 12
2254   FDC7             ; 1363         return MoveCursorHome();
2255   FDC7 CA BF FD    	jp z, movecursorhome
2256   FDCA             ; 1364     if (a == 13)
2257   FDCA FE 0D       	cp 13
2258   FDCC             ; 1365         return MoveCursorCr(hl);
2259   FDCC CA 13 FE    	jp z, movecursorcr
2260   FDCF             ; 1366     if (a == 10)
2261   FDCF FE 0A       	cp 10
2262   FDD1             ; 1367         return MoveCursorLf(hl);
2263   FDD1 CA 39 FE    	jp z, movecursorlf
2264   FDD4             ; 1368     if (a == 8)
2265   FDD4 FE 08       	cp 8
2266   FDD6             ; 1369         return MoveCursorLeft(hl);
2267   FDD6 CA 35 FE    	jp z, movecursorleft
2268   FDD9             ; 1370     if (a == 24)
2269   FDD9 FE 18       	cp 24
2270   FDDB             ; 1371         return MoveCursorRight(hl);
2271   FDDB CA 1A FE    	jp z, movecursorright
2272   FDDE             ; 1372     if (a == 25)
2273   FDDE FE 19       	cp 25
2274   FDE0             ; 1373         return MoveCursorUp(hl);
2275   FDE0 CA 70 FE    	jp z, movecursorup
2276   FDE3             ; 1374     if (a == 7)
2277   FDE3 FE 07       	cp 7
2278   FDE5             ; 1375 #ifdef BEEP_ENABLED
2279   FDE5             ; 1376         return PrintCharBeep();
2280   FDE5 CA F7 FD    	jp z, printcharbeep
2281   FDE8             ; 1377 #else
2282   FDE8             ; 1378         return PrintCharExit();
2283   FDE8             ; 1379 #endif
2284   FDE8             ; 1380     if (a == 26)
2285   FDE8 FE 1A       	cp 26
2286   FDEA             ; 1381         return MoveCursorDown();
2287   FDEA CA 77 FE    	jp z, movecursordown
2288   FDED             ; 1382     if (a != 27)
2289   FDED FE 1B       	cp 27
2290   FDEF             ; 1383         return PrintChar4(hl, a);
2291   FDEF C2 89 FD    	jp nz, printchar4
2292   FDF2             ; 1384     a = 1;
2293   FDF2 3E 01       	ld a, 1
2294   FDF4             ; 1385     PrintCharSetEscState();
2295   FDF4 C3 22 FD    	jp printcharsetescstate
2296   FDF7             ; 1386 }
2297   FDF7             ; 1387 
2298   FDF7             ; 1388 #ifdef BEEP_ENABLED
2299   FDF7             ; 1389 void PrintCharBeep(...) {
2300   FDF7             printcharbeep: 
2301   FDF7             ; 1390     bc = (32 << 8) | 128; // Частота, Длительность
2302   FDF7 01 80 20    	ld bc, 8320
2303   FDFA             ; 1391     do {
2304   FDFA             l_138: 
2305   FDFA             ; 1392         e = b;
2306   FDFA 58          	ld e, b
2307   FDFB             ; 1393         do {
2308   FDFB             l_141: 
2309   FDFB             ; 1394             out(PORT_KEYBOARD_MODE, a = 1 | (7 << 1));
2310   FDFB 3E 0F       	ld a, 15
2311   FDFD D3 04       	out (4), a
2312   FDFF             l_142: 
2313   FDFF             ; 1395         } while (flag_nz(e--));
2314   FDFF 1D          	dec e
2315   FE00 C2 FB FD    	jp nz, l_141
2316   FE03             ; 1396         e = b;
2317   FE03 58          	ld e, b
2318   FE04             ; 1397         do {
2319   FE04             l_144: 
2320   FE04             ; 1398             out(PORT_KEYBOARD_MODE, a = (7 << 1));
2321   FE04 3E 0E       	ld a, 14
2322   FE06 D3 04       	out (4), a
2323   FE08             l_145: 
2324   FE08             ; 1399         } while (flag_nz(e--));
2325   FE08 1D          	dec e
2326   FE09 C2 04 FE    	jp nz, l_144
2327   FE0C             l_139: 
2328   FE0C             ; 1400     } while (flag_nz(c--));
2329   FE0C 0D          	dec c
2330   FE0D C2 FA FD    	jp nz, l_138
2331   FE10             ; 1401 
2332   FE10             ; 1402     PrintCharExit();
2333   FE10 C3 28 FD    	jp printcharexit
2334   FE13             ; 1403 }
2335   FE13             ; 1404 #endif
2336   FE13             ; 1405 
2337   FE13             ; 1406 void MoveCursorCr(...) {
2338   FE13             movecursorcr: 
2339   FE13             ; 1407     l = ((a = l) &= ~(SCREEN_WIDTH - 1));
2340   FE13 7D          	ld a, l
2341   FE14 E6 C0       	and 192
2342   FE16 6F          	ld l, a
2343   FE17             ; 1408     PrintCharSaveCursor(hl);
2344   FE17 C3 25 FD    	jp printcharsavecursor
2345   FE1A             ; 1409 }
2346   FE1A             ; 1410 
2347   FE1A             ; 1411 void MoveCursorRight(...) {
2348   FE1A             movecursorright: 
2349   FE1A             ; 1412     hl++;
2350   FE1A 23          	inc hl
2351   FE1B             ; 1413     MoveCursorBoundary(hl);
2352   FE1B             ; 1414 }
2353   FE1B             ; 1415 
2354   FE1B             ; 1416 const int ZERO_LINE = (SCREEN_BEGIN >> 6) & 0xFF;
2355   FE1B             ; 1417 
2356   FE1B             ; 1418 void MoveCursorBoundary(...) {
2357   FE1B             movecursorboundary: 
2358   FE1B             ; 1419     push_pop(hl) {
2359   FE1B E5          	push hl
2360   FE1C             ; 1420         hl += hl;
2361   FE1C 29          	add hl, hl
2362   FE1D             ; 1421         hl += hl;
2363   FE1D 29          	add hl, hl
2364   FE1E             ; 1422         a = h;
2365   FE1E 7C          	ld a, h
2366   FE1F E1          	pop hl
2367   FE20             ; 1423     }
2368   FE20             ; 1424 
2369   FE20             ; 1425     if (a < ZERO_LINE)
2370   FE20 FE A0       	cp 160
2371   FE22             ; 1426         hl += (de = SCREEN_WIDTH * SCREEN_HEIGHT);
2372   FE22 D2 29 FE    	jp nc, l_147
2373   FE25 11 40 06    	ld de, 1600
2374   FE28 19          	add hl, de
2375   FE29             l_147: 
2376   FE29             ; 1427 
2377   FE29             ; 1428     if (a >= SCREEN_HEIGHT + ZERO_LINE)
2378   FE29 FE B9       	cp 185
2379   FE2B             ; 1429         hl += (de = -SCREEN_WIDTH * SCREEN_HEIGHT);
2380   FE2B DA 32 FE    	jp c, l_149
2381   FE2E 11 C0 F9    	ld de, 63936
2382   FE31 19          	add hl, de
2383   FE32             l_149: 
2384   FE32             ; 1430 
2385   FE32             ; 1431     PrintCharSaveCursor(hl);
2386   FE32 C3 25 FD    	jp printcharsavecursor
2387   FE35             ; 1432 }
2388   FE35             ; 1433 
2389   FE35             ; 1434 void MoveCursorLeft(...) {
2390   FE35             movecursorleft: 
2391   FE35             ; 1435     hl--;
2392   FE35 2B          	dec hl
2393   FE36             ; 1436     MoveCursorBoundary(hl);
2394   FE36 C3 1B FE    	jp movecursorboundary
2395   FE39             ; 1437 }
2396   FE39             ; 1438 
2397   FE39             ; 1439 void MoveCursorLf(...) {
2398   FE39             movecursorlf: 
2399   FE39             ; 1440     hl += (bc = SCREEN_WIDTH);
2400   FE39 01 40 00    	ld bc, 64
2401   FE3C 09          	add hl, bc
2402   FE3D             ; 1441     TryScrollUp(hl);
2403   FE3D             ; 1442 }
2404   FE3D             ; 1443 
2405   FE3D             ; 1444 void TryScrollUp(...) {
2406   FE3D             tryscrollup: 
2407   FE3D             ; 1445     swap(hl, de);
2408   FE3D EB          	ex hl, de
2409   FE3E             ; 1446     hl = -(SCREEN_BEGIN + SCREEN_WIDTH * SCREEN_HEIGHT);
2410   FE3E 21 C0 11    	ld hl, 4544
2411   FE41             ; 1447     hl += de;
2412   FE41 19          	add hl, de
2413   FE42             ; 1448     swap(hl, de);
2414   FE42 EB          	ex hl, de
2415   FE43             ; 1449     if (flag_nc)
2416   FE43             ; 1450         return PrintCharSaveCursor(hl);
2417   FE43 D2 25 FD    	jp nc, printcharsavecursor
2418   FE46             ; 1451 
2419   FE46             ; 1452     push_pop(hl) {
2420   FE46 E5          	push hl
2421   FE47             ; 1453         hl = SCREEN_BEGIN + SCREEN_WIDTH * SCREEN_HEIGHT - 1;
2422   FE47 21 3F EE    	ld hl, 60991
2423   FE4A             ; 1454         c = SCREEN_WIDTH;
2424   FE4A 0E 40       	ld c, 64
2425   FE4C             ; 1455         do {
2426   FE4C             l_151: 
2427   FE4C             ; 1456             push_pop(hl) {
2428   FE4C E5          	push hl
2429   FE4D             ; 1457                 de = SCREEN_SIZE - SCREEN_WIDTH;
2430   FE4D 11 C0 07    	ld de, 1984
2431   FE50             ; 1458                 b = 0;
2432   FE50 06 00       	ld b, 0
2433   FE52             ; 1459                 c = a = color;
2434   FE52 3A 59 F7    	ld a, (color)
2435   FE55 4F          	ld c, a
2436   FE56             ; 1460                 do {
2437   FE56             l_154: 
2438   FE56             ; 1461                     a = b;
2439   FE56 78          	ld a, b
2440   FE57             ; 1462                     b = *hl;
2441   FE57 46          	ld b, (hl)
2442   FE58             ; 1463                     *hl = a;
2443   FE58 77          	ld (hl), a
2444   FE59             ; 1464                     h = ((a = h) -= (SCREEN_SIZE >> 8));
2445   FE59 7C          	ld a, h
2446   FE5A D6 08       	sub 8
2447   FE5C 67          	ld h, a
2448   FE5D             ; 1465                     a = c;
2449   FE5D 79          	ld a, c
2450   FE5E             ; 1466                     c = *hl;
2451   FE5E 4E          	ld c, (hl)
2452   FE5F             ; 1467                     *hl = a;
2453   FE5F 77          	ld (hl), a
2454   FE60             ; 1468                     hl += de;
2455   FE60 19          	add hl, de
2456   FE61             l_155: 
2457   FE61             ; 1469                 } while ((a = h) != (SCREEN_BEGIN >> 8) - 1);
2458   FE61 7C          	ld a, h
2459   FE62 FE E7       	cp 65511
2460   FE64 C2 56 FE    	jp nz, l_154
2461   FE67 E1          	pop hl
2462   FE68             ; 1470             }
2463   FE68             ; 1471             l--;
2464   FE68 2D          	dec l
2465   FE69             l_152: 
2466   FE69             ; 1472         } while ((a = l) != SCREEN_BEGIN + SCREEN_WIDTH * SCREEN_HEIGHT - 1 - SCREEN_WIDTH);
2467   FE69 7D          	ld a, l
2468   FE6A FE FF       	cp 60927
2469   FE6C C2 4C FE    	jp nz, l_151
2470   FE6F E1          	pop hl
2471   FE70             ; 1473     }
2472   FE70             ; 1474     MoveCursorUp();
2473   FE70             ; 1475 }
2474   FE70             ; 1476 
2475   FE70             ; 1477 void MoveCursorUp(...) {
2476   FE70             movecursorup: 
2477   FE70             ; 1478     MoveCursor(hl, bc = -SCREEN_WIDTH);
2478   FE70 01 C0 FF    	ld bc, 65472
2479   FE73             ; 1479 }
2480   FE73             ; 1480 
2481   FE73             ; 1481 void MoveCursor(...) {
2482   FE73             movecursor: 
2483   FE73             ; 1482     hl += bc;
2484   FE73 09          	add hl, bc
2485   FE74             ; 1483     MoveCursorBoundary(hl);
2486   FE74 C3 1B FE    	jp movecursorboundary
2487   FE77             ; 1484 }
2488   FE77             ; 1485 
2489   FE77             ; 1486 void MoveCursorDown(...) {
2490   FE77             movecursordown: 
2491   FE77             ; 1487     MoveCursor(hl, bc = SCREEN_WIDTH);
2492   FE77 01 40 00    	ld bc, 64
2493   FE7A C3 73 FE    	jp movecursor
2494   FE7D             ; 1488 }
2495   FE7D             ; 1489 
2496   FE7D             ; 1490 // Функция для пользовательской программы.
2497   FE7D             ; 1491 // Нажата ли хотя бы одна клавиша на клавиатуре?
2498   FE7D             ; 1492 // Параметры: нет. Результат:  a - 0xFF если клавиша нажата, 0 если нет. Сохраняет: bc, de, hl.
2499   FE7D             ; 1493 
2500   FE7D             ; 1494 void IsAnyKeyPressed() {
2501   FE7D             isanykeypressed: 
2502   FE7D             ; 1495     out(PORT_KEYBOARD_COLUMN, a ^= a);
2503   FE7D AF          	xor a
2504   FE7E D3 07       	out (7), a
2505   FE80             ; 1496     a = in(PORT_KEYBOARD_ROW);
2506   FE80 DB 06       	in a, (6)
2507   FE82             ; 1497     invert(a);
2508   FE82 2F          	cpl
2509   FE83             ; 1498     a += a;
2510   FE83 87          	add a
2511   FE84             ; 1499     if (flag_z)
2512   FE84             ; 1500         return;
2513   FE84 C8          	ret z
2514   FE85             ; 1501     a = 0xFF;
2515   FE85 3E FF       	ld a, 255
2516   FE87 C9          	ret
2517   FE88             ; 1502 }
2518   FE88             ; 1503 
2519   FE88             ; 1504 // Функция для пользовательской программы.
2520   FE88             ; 1505 // Получить код нажатой клавиши на клавиатуре.
2521   FE88             ; 1506 // В отличии от функции ScanKey, в этой функции есть задержка повтора.
2522   FE88             ; 1507 // Параметры: нет. Результат: a. Сохраняет: bc, de, hl.
2523   FE88             ; 1508 
2524   FE88             ; 1509 void ReadKey() {
2525   FE88             readkey: 
2526   FE88             ; 1510     push_pop(bc, de, hl) {
2527   FE88 C5          	push bc
2528   FE89 D5          	push de
2529   FE8A E5          	push hl
2530   FE8B             ; 1511 retry:
2531   FE8B             retry_1804289383: 
2532   FE8B             ; 1512         hl = keyDelay;
2533   FE8B 2A 60 F7    	ld hl, (keydelay)
2534   FE8E             ; 1513         ReadKeyInternal(hl);
2535   FE8E CD C6 FE    	call readkeyinternal
2536   FE91             ; 1514         l = 32;         // Задержка повтора нажатия клавиши
2537   FE91 2E 20       	ld l, 32
2538   FE93             ; 1515         if (flag_nz) {  // Не таймаут
2539   FE93 CA A5 FE    	jp z, l_157
2540   FE96             ; 1516             do {
2541   FE96             l_159: 
2542   FE96             ; 1517                 do {
2543   FE96             l_162: 
2544   FE96             ; 1518                     l = 2;
2545   FE96 2E 02       	ld l, 2
2546   FE98             ; 1519                     ReadKeyInternal(hl);
2547   FE98 CD C6 FE    	call readkeyinternal
2548   FE9B             l_163: 
2549   FE9B C2 96 FE    	jp nz, l_162
2550   FE9E             l_160: 
2551   FE9E             ; 1520                 } while (flag_nz);  // Цикл длится, пока не наступит таймаут
2552   FE9E             ; 1521             } while (a == 255);     // Цикл длится, пока не нажата клавиша
2553   FE9E FE FF       	cp 255
2554   FEA0 CA 96 FE    	jp z, l_159
2555   FEA3             ; 1522             l = 128;                // Задержка повтора первого нажатия клавиши
2556   FEA3 2E 80       	ld l, 128
2557   FEA5             l_157: 
2558   FEA5             ; 1523         }
2559   FEA5             ; 1524         keyDelay = hl;
2560   FEA5 22 60 F7    	ld (keydelay), hl
2561   FEA8             ; 1525 
2562   FEA8             ; 1526         if (a == SCAN_RUS) {
2563   FEA8 FE 36       	cp 54
2564   FEAA C2 C1 FE    	jp nz, l_165
2565   FEAD             ; 1527             a = in(PORT_KEYBOARD_MODS);
2566   FEAD DB 05       	in a, (5)
2567   FEAF             ; 1528             carry_rotate_right(a, 3); // Shift
2568   FEAF 1F          	rra
2569   FEB0 1F          	rra
2570   FEB1 1F          	rra
2571   FEB2             ; 1529             a = KEYBOARD_MODE_CAP;
2572   FEB2 3E 02       	ld a, 2
2573   FEB4             ; 1530             carry_sub(a, 0); // KEYBOARD_MODE_CAP -> KEYBOARD_MODE_RUS
2574   FEB4 DE 00       	sbc 0
2575   FEB6             ; 1531             hl = &keyboardMode;
2576   FEB6 21 58 F7    	ld hl, 0FFFFh & (keyboardmode)
2577   FEB9             ; 1532             a ^= *hl;
2578   FEB9 AE          	xor (hl)
2579   FEBA             ; 1533             *hl = a;
2580   FEBA 77          	ld (hl), a
2581   FEBB             ; 1534             PrintKeyStatus();
2582   FEBB CD CD FF    	call printkeystatus
2583   FEBE             ; 1535             goto retry;
2584   FEBE C3 8B FE    	jp retry_1804289383
2585   FEC1             l_165: 
2586   FEC1             ; 1536         }
2587   FEC1             ; 1537         a = c;
2588   FEC1 79          	ld a, c
2589   FEC2 E1          	pop hl
2590   FEC3 D1          	pop de
2591   FEC4 C1          	pop bc
2592   FEC5 C9          	ret
2593   FEC6             ; 1538     }
2594   FEC6             ; 1539 }
2595   FEC6             ; 1540 
2596   FEC6             ; 1541 void ReadKeyInternal(...) {
2597   FEC6             readkeyinternal: 
2598   FEC6             ; 1542     do {
2599   FEC6             l_167: 
2600   FEC6             ; 1543         ScanKey();
2601   FEC6 CD DF FE    	call scankey
2602   FEC9             ; 1544         c = a;
2603   FEC9 4F          	ld c, a
2604   FECA             ; 1545         a = keyCode;
2605   FECA 3A 57 F7    	ld a, (keycode)
2606   FECD             ; 1546         if (a != h)
2607   FECD BC          	cp h
2608   FECE             ; 1547             break;
2609   FECE C2 DD FE    	jp nz, l_169
2610   FED1             ; 1548 
2611   FED1             ; 1549         // Задержка
2612   FED1             ; 1550         a ^= a;
2613   FED1 AF          	xor a
2614   FED2             ; 1551         do {
2615   FED2             l_170: 
2616   FED2             ; 1552             swap(hl, de);
2617   FED2 EB          	ex hl, de
2618   FED3             ; 1553             swap(hl, de);
2619   FED3 EB          	ex hl, de
2620   FED4             l_171: 
2621   FED4             ; 1554         } while (flag_nz(a--));
2622   FED4 3D          	dec a
2623   FED5 C2 D2 FE    	jp nz, l_170
2624   FED8             ; 1555         a = h;
2625   FED8 7C          	ld a, h
2626   FED9             l_168: 
2627   FED9             ; 1556     } while (flag_nz(l--));
2628   FED9 2D          	dec l
2629   FEDA C2 C6 FE    	jp nz, l_167
2630   FEDD             l_169: 
2631   FEDD             ; 1557     h = a;
2632   FEDD 67          	ld h, a
2633   FEDE C9          	ret
2634   FEDF             ; 1558 }
2635   FEDF             ; 1559 
2636   FEDF             ; 1560 // Функция для пользовательской программы.
2637   FEDF             ; 1561 // Получить код нажатой клавиши на клавиатуре.
2638   FEDF             ; 1562 // Параметры: нет. Результат: a. Сохраняет: bc, de, hl.
2639   FEDF             ; 1563 
2640   FEDF             ; 1564 void ScanKey() {
2641   FEDF             scankey: 
2642   FEDF             ; 1565     push(bc, de, hl);
2643   FEDF C5          	push bc
2644   FEE0 D5          	push de
2645   FEE1 E5          	push hl
2646   FEE2             ; 1566 
2647   FEE2             ; 1567     bc = 0xFEFE;
2648   FEE2 01 FE FE    	ld bc, 65278
2649   FEE5             ; 1568     do {
2650   FEE5             l_173: 
2651   FEE5             ; 1569         a = c;
2652   FEE5 79          	ld a, c
2653   FEE6             ; 1570         out(PORT_KEYBOARD_COLUMN, a);
2654   FEE6 D3 07       	out (7), a
2655   FEE8             ; 1571         a = in(PORT_KEYBOARD_ROW);
2656   FEE8 DB 06       	in a, (6)
2657   FEEA             ; 1572         invert(a);
2658   FEEA 2F          	cpl
2659   FEEB             ; 1573         a += a;
2660   FEEB 87          	add a
2661   FEEC             ; 1574         if (flag_nz)
2662   FEEC             ; 1575             return ScanKey2(a);
2663   FEEC C2 09 FF    	jp nz, scankey2
2664   FEEF             ; 1576         b = ((a = b) += KEYBOARD_ROW_COUNT);
2665   FEEF 78          	ld a, b
2666   FEF0 C6 07       	add 7
2667   FEF2 47          	ld b, a
2668   FEF3             ; 1577         a = c;
2669   FEF3 79          	ld a, c
2670   FEF4             ; 1578         cyclic_rotate_left(a, 1);
2671   FEF4 07          	rlca
2672   FEF5             ; 1579         c = a;
2673   FEF5 4F          	ld c, a
2674   FEF6             l_174: 
2675   FEF6 DA E5 FE    	jp c, l_173
2676   FEF9             ; 1580     } while (flag_c);
2677   FEF9             ; 1581 
2678   FEF9             ; 1582     a = in(PORT_KEYBOARD_MODS);
2679   FEF9 DB 05       	in a, (5)
2680   FEFB             ; 1583     carry_rotate_right(a, 1);
2681   FEFB 1F          	rra
2682   FEFC             ; 1584     b++;
2683   FEFC 04          	inc b
2684   FEFD             ; 1585     b++;
2685   FEFD 04          	inc b
2686   FEFE             ; 1586     if (flag_nc)
2687   FEFE             ; 1587         return ScanKey3(b);
2688   FEFE D2 0E FF    	jp nc, scankey3
2689   FF01             ; 1588     keyCode = a = 0xFF;
2690   FF01 3E FF       	ld a, 255
2691   FF03 32 57 F7    	ld (keycode), a
2692   FF06             ; 1589     ScanKeyExit(a);
2693   FF06 C3 64 FF    	jp scankeyexit
2694   FF09             ; 1590 }
2695   FF09             ; 1591 
2696   FF09             ; 1592 void ScanKey2(...) {
2697   FF09             scankey2: 
2698   FF09             ; 1593     do {
2699   FF09             l_176: 
2700   FF09             ; 1594         b++;
2701   FF09 04          	inc b
2702   FF0A             ; 1595         carry_rotate_right(a, 1);
2703   FF0A 1F          	rra
2704   FF0B             l_177: 
2705   FF0B D2 09 FF    	jp nc, l_176
2706   FF0E             ; 1596     } while (flag_nc);
2707   FF0E             ; 1597     ScanKey3(b);
2708   FF0E             ; 1598 }
2709   FF0E             ; 1599 
2710   FF0E             ; 1600 void ScanKey3(...) {
2711   FF0E             scankey3: 
2712   FF0E             ; 1601     // b - key number
2713   FF0E             ; 1602 
2714   FF0E             ; 1603     //  0    0    1 !   2 "   3 #   4 $   5 %   6 &   7 ,
2715   FF0E             ; 1604     //  8   8 (   9 )   : *   ; +   , <   - =   . >   / ?
2716   FF0E             ; 1605     // 16   @ Ю   A А   B Б   C Ц   D Д   E Е   F Ф   G Г
2717   FF0E             ; 1606     // 24   H Х   I И   J Й   K К   L Л   M М   N Н   O О
2718   FF0E             ; 1607     // 32   P П   Q Я   R Р   S С   T Т   U У   V Ж   W В
2719   FF0E             ; 1608     // 40   X Ь   Y Ы   Z З   [ Ш   \ Э   ] Щ   ^ Ч    _
2720   FF0E             ; 1609     // 48   Space Right Left  Up    Down  Vk    Str   Home
2721   FF0E             ; 1610 
2722   FF0E             ; 1611     a = b;
2723   FF0E 78          	ld a, b
2724   FF0F             ; 1612     keyCode = a;
2725   FF0F 32 57 F7    	ld (keycode), a
2726   FF12             ; 1613     if (a >= 48)
2727   FF12 FE 30       	cp 48
2728   FF14             ; 1614         return ScanKeySpecial(a);
2729   FF14 D2 6E FF    	jp nc, scankeyspecial
2730   FF17             ; 1615     a += 48;
2731   FF17 C6 30       	add 48
2732   FF19             ; 1616     if (a >= 60)
2733   FF19 FE 3C       	cp 60
2734   FF1B             ; 1617         if (a < 64)
2735   FF1B DA 25 FF    	jp c, l_179
2736   FF1E FE 40       	cp 64
2737   FF20             ; 1618             a &= 47;
2738   FF20 D2 25 FF    	jp nc, l_181
2739   FF23 E6 2F       	and 47
2740   FF25             l_181: 
2741   FF25             l_179: 
2742   FF25             ; 1619 
2743   FF25             ; 1620     c = a;
2744   FF25 4F          	ld c, a
2745   FF26             ; 1621 
2746   FF26             ; 1622     a = keyboardMode;
2747   FF26 3A 58 F7    	ld a, (keyboardmode)
2748   FF29             ; 1623     carry_rotate_right(a, 1);
2749   FF29 1F          	rra
2750   FF2A             ; 1624     d = a;
2751   FF2A 57          	ld d, a
2752   FF2B             ; 1625     if (flag_c) { // KEYBOARD_MODE_RUS
2753   FF2B D2 32 FF    	jp nc, l_183
2754   FF2E             ; 1626         a = c;
2755   FF2E 79          	ld a, c
2756   FF2F             ; 1627         a |= 0x20;
2757   FF2F F6 20       	or 32
2758   FF31             ; 1628         c = a;
2759   FF31 4F          	ld c, a
2760   FF32             l_183: 
2761   FF32             ; 1629     }
2762   FF32             ; 1630 
2763   FF32             ; 1631     a = in(PORT_KEYBOARD_MODS);
2764   FF32 DB 05       	in a, (5)
2765   FF34             ; 1632     carry_rotate_right(a, 2);
2766   FF34 1F          	rra
2767   FF35 1F          	rra
2768   FF36             ; 1633     if (flag_nc)
2769   FF36             ; 1634         return ScanKeyControl(c);
2770   FF36 D2 68 FF    	jp nc, scankeycontrol
2771   FF39             ; 1635     carry_rotate_right(a, 1);
2772   FF39 1F          	rra
2773   FF3A             ; 1636     a = c;
2774   FF3A 79          	ld a, c
2775   FF3B             ; 1637     if (flag_nc) {
2776   FF3B DA 47 FF    	jp c, l_185
2777   FF3E             ; 1638         a ^= 0x10;
2778   FF3E EE 10       	xor 16
2779   FF40             ; 1639         if (a >= 64)
2780   FF40 FE 40       	cp 64
2781   FF42             ; 1640             a ^= 0x80 | 0x10;
2782   FF42 DA 47 FF    	jp c, l_187
2783   FF45 EE 90       	xor 144
2784   FF47             l_187: 
2785   FF47             l_185: 
2786   FF47             ; 1641     }
2787   FF47             ; 1642     c = a;
2788   FF47 4F          	ld c, a
2789   FF48             ; 1643     a = d;
2790   FF48 7A          	ld a, d
2791   FF49             ; 1644     carry_rotate_right(a, 1);
2792   FF49 1F          	rra
2793   FF4A             ; 1645     if (flag_c) { // KEYBOARD_MODE_CAP
2794   FF4A D2 63 FF    	jp nc, l_189
2795   FF4D             ; 1646         a = c;
2796   FF4D 79          	ld a, c
2797   FF4E             ; 1647         a &= 0x7F;
2798   FF4E E6 7F       	and 127
2799   FF50             ; 1648         if (a >= 0x60)  // Кириллица
2800   FF50 FE 60       	cp 96
2801   FF52             ; 1649             goto convert;
2802   FF52 D2 5F FF    	jp nc, convert
2803   FF55             ; 1650         if (a >= 'A') {
2804   FF55 FE 41       	cp 65
2805   FF57 DA 63 FF    	jp c, l_191
2806   FF5A             ; 1651             if (a < 'Z' + 1) {
2807   FF5A FE 5B       	cp 91
2808   FF5C D2 63 FF    	jp nc, l_193
2809   FF5F             ; 1652 convert:        a = c;
2810   FF5F             convert: 
2811   FF5F 79          	ld a, c
2812   FF60             ; 1653                 a ^= 0x80;
2813   FF60 EE 80       	xor 128
2814   FF62             ; 1654                 c = a;
2815   FF62 4F          	ld c, a
2816   FF63             l_193: 
2817   FF63             l_191: 
2818   FF63             l_189: 
2819   FF63             ; 1655             }
2820   FF63             ; 1656         }
2821   FF63             ; 1657     }
2822   FF63             ; 1658     a = c;
2823   FF63 79          	ld a, c
2824   FF64             ; 1659     ScanKeyExit(a);
2825   FF64             ; 1660 }
2826   FF64             ; 1661 
2827   FF64             ; 1662 void ScanKeyExit(...) {
2828   FF64             scankeyexit: 
2829   FF64             ; 1663     pop(bc, de, hl);
2830   FF64 E1          	pop hl
2831   FF65 D1          	pop de
2832   FF66 C1          	pop bc
2833   FF67 C9          	ret
2834   FF68             ; 1664 }
2835   FF68             ; 1665 
2836   FF68             ; 1666 void ScanKeyControl(...) {
2837   FF68             scankeycontrol: 
2838   FF68             ; 1667     a = c;
2839   FF68 79          	ld a, c
2840   FF69             ; 1668     a &= 0x1F;
2841   FF69 E6 1F       	and 31
2842   FF6B             ; 1669     ScanKeyExit(a);
2843   FF6B C3 64 FF    	jp scankeyexit
2844   FF6E             ; 1670 }
2845   FF6E             ; 1671 
2846   FF6E             ; 1672 void ScanKeySpecial(...) {
2847   FF6E             scankeyspecial: 
2848   FF6E             ; 1673     h = (uintptr_t)specialKeyTable >> 8;
2849   FF6E 26 FF       	ld h, 0FFh & ((0FFFFh & (0FFFFh & (specialkeytable))) >> (8))
2850   FF70             ; 1674     l = (a += (uintptr_t)specialKeyTable - 48);
2851   FF70 C6 47       	add 0FFh & ((0FFFFh & (0FFFFh & (specialkeytable))) - (48))
2852   FF72 6F          	ld l, a
2853   FF73             ; 1675     a = *hl;
2854   FF73 7E          	ld a, (hl)
2855   FF74             ; 1676     ScanKeyExit(a);
2856   FF74 C3 64 FF    	jp scankeyexit
2857   FF77             ; 1677 }
2858   FF77             ; 1678 
2859   FF77             ; 1679 uint8_t specialKeyTable[] = {
2860   FF77             specialkeytable: 
2861   FF77 20          	db 32
2862   FF78 18          	db 24
2863   FF79 08          	db 8
2864   FF7A 19          	db 25
2865   FF7B 1A          	db 26
2866   FF7C 0D          	db 13
2867   FF7D 1F          	db 31
2868   FF7E 0C          	db 12
2869   FF7F 7F          	db 127
2870   FF80             ; 1691  aPrompt[] = "\r\n-->";
2871   FF80             aprompt: 
2872   FF80 0D          	db 13
2873   FF81 0A          	db 10
2874   FF82 2D          	db 45
2875   FF83 2D          	db 45
2876   FF84 3E          	db 62
2877   FF85 00          	ds 1
2878   FF86             ; 1692  aCrLfTab[] = "\r\n\x18\x18\x18";
2879   FF86             acrlftab: 
2880   FF86 0D          	db 13
2881   FF87 0A          	db 10
2882   FF88 18          	db 24
2883   FF89 18          	db 24
2884   FF8A 18          	db 24
2885   FF8B 00          	ds 1
2886   FF8C             ; 1693  aRegisters[] = "\r\nPC-\r\nHL-\r\nBC-\r\nDE-\r\nSP-\r\nAF-\x19\x19\x19\x19\x19\x19";
2887   FF8C             aregisters: 
2888   FF8C 0D          	db 13
2889   FF8D 0A          	db 10
2890   FF8E 50          	db 80
2891   FF8F 43          	db 67
2892   FF90 2D          	db 45
2893   FF91 0D          	db 13
2894   FF92 0A          	db 10
2895   FF93 48          	db 72
2896   FF94 4C          	db 76
2897   FF95 2D          	db 45
2898   FF96 0D          	db 13
2899   FF97 0A          	db 10
2900   FF98 42          	db 66
2901   FF99 43          	db 67
2902   FF9A 2D          	db 45
2903   FF9B 0D          	db 13
2904   FF9C 0A          	db 10
2905   FF9D 44          	db 68
2906   FF9E 45          	db 69
2907   FF9F 2D          	db 45
2908   FFA0 0D          	db 13
2909   FFA1 0A          	db 10
2910   FFA2 53          	db 83
2911   FFA3 50          	db 80
2912   FFA4 2D          	db 45
2913   FFA5 0D          	db 13
2914   FFA6 0A          	db 10
2915   FFA7 41          	db 65
2916   FFA8 46          	db 70
2917   FFA9 2D          	db 45
2918   FFAA 19          	db 25
2919   FFAB 19          	db 25
2920   FFAC 19          	db 25
2921   FFAD 19          	db 25
2922   FFAE 19          	db 25
2923   FFAF 19          	db 25
2924   FFB0 00          	ds 1
2925   FFB1             ; 1694  aBackspace[] = "\x08 \x08";
2926   FFB1             abackspace: 
2927   FFB1 08          	db 8
2928   FFB2 20          	db 32
2929   FFB3 08          	db 8
2930   FFB4 00          	ds 1
2931   FFB5             ; 1695  aHello[] = "\x1FМИКРО 80\x1BБ";
2932   FFB5             ahello: 
2933   FFB5 1F          	db 31
2934   FFB6 6D          	db 109
2935   FFB7 69          	db 105
2936   FFB8 6B          	db 107
2937   FFB9 72          	db 114
2938   FFBA 6F          	db 111
2939   FFBB 20          	db 32
2940   FFBC 38          	db 56
2941   FFBD 30          	db 48
2942   FFBE 1B          	db 27
2943   FFBF 62          	db 98
2944   FFC0 00          	ds 1
2945   FFC1             ; 1702  aZag[3] = "Заг";
2946   FFC1             azag: 
2947   FFC1 7A          	db 122
2948   FFC2 E1          	db 225
2949   FFC3 E7          	db 231
2950   FFC4             ; 1703  aStr[3] = "Стр";
2951   FFC4             astr: 
2952   FFC4 73          	db 115
2953   FFC5 F4          	db 244
2954   FFC6 F2          	db 242
2955   FFC7             ; 1704  aLat[3] = "Лат";
2956   FFC7             alat: 
2957   FFC7 6C          	db 108
2958   FFC8 E1          	db 225
2959   FFC9 F4          	db 244
2960   FFCA             ; 1705  aRus[3] = "Рус";
2961   FFCA             arus: 
2962   FFCA 72          	db 114
2963   FFCB F5          	db 245
2964   FFCC F3          	db 243
2965   FFCD             ; 1707  PrintKeyStatus() {
2966   FFCD             printkeystatus: 
2967   FFCD             ; 1708     bc = SCREEN_BEGIN + 56 + 31 * SCREEN_WIDTH;
2968   FFCD 01 F8 EF    	ld bc, 61432
2969   FFD0             ; 1709     a = keyboardMode;
2970   FFD0 3A 58 F7    	ld a, (keyboardmode)
2971   FFD3             ; 1710     hl = aLat;
2972   FFD3 21 C7 FF    	ld hl, 0FFFFh & (alat)
2973   FFD6             ; 1711     PrintKeyStatusInt(a, bc, hl);
2974   FFD6 CD DC FF    	call printkeystatusint
2975   FFD9             ; 1712     bc++;
2976   FFD9 03          	inc bc
2977   FFDA             ; 1713     l = aZag;
2978   FFDA 2E C1       	ld l, 0FFh & (azag)
2979   FFDC             ; 1714     PrintKeyStatusInt(a, bc, hl);
2980   FFDC             ; 1715 }
2981   FFDC             ; 1716 
2982   FFDC             ; 1717 void PrintKeyStatusInt(...) {
2983   FFDC             printkeystatusint: 
2984   FFDC             ; 1718     de = sizeof(aZag);
2985   FFDC 11 03 00    	ld de, 3
2986   FFDF             ; 1719     cyclic_rotate_right(a, 1);
2987   FFDF 0F          	rrca
2988   FFE0             ; 1720     if (flag_c)
2989   FFE0             ; 1721         hl += de;
2990   FFE0 D2 E4 FF    	jp nc, l_195
2991   FFE3 19          	add hl, de
2992   FFE4             l_195: 
2993   FFE4             ; 1722     d = a;
2994   FFE4 57          	ld d, a
2995   FFE5             ; 1723     do {
2996   FFE5             l_197: 
2997   FFE5             ; 1724         *bc = a = *hl;
2998   FFE5 7E          	ld a, (hl)
2999   FFE6 02          	ld (bc), a
3000   FFE7             ; 1725         bc++;
3001   FFE7 03          	inc bc
3002   FFE8             ; 1726         hl++;
3003   FFE8 23          	inc hl
3004   FFE9             l_198: 
3005   FFE9             ; 1727     } while (flag_nz(e--));
3006   FFE9 1D          	dec e
3007   FFEA C2 E5 FF    	jp nz, l_197
3008   FFED             ; 1728     a = d;
3009   FFED 7A          	ld a, d
3010   FFEE C9          	ret
3011   FFEF              savebin "micro80.bin", 0xF800, 0x10000
3012   FFEF             
