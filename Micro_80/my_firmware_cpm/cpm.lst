0001   0000             ; Micro 80 CP/M BIOS
0002   0000             ; Copyright (c) 2025 Aleksey Morozov aleksey.f.morozov@gmail.com aleksey.f.morozov@yandex.ru
0003   0000             ;
0004   0000             ; ONLY THIS FILE!
0005   0000             ;
0006   0000             ; Licensed under the Apache License, Version 2.0 (the "License");
0007   0000             ; you may not use this file except in compliance with the License.
0008   0000             ; You may obtain a copy of the License at
0009   0000             ;
0010   0000             ;     http://www.apache.org/licenses/LICENSE-2.0
0011   0000             ;
0012   0000             ; Unless required by applicable law or agreed to in writing, software
0013   0000             ; distributed under the License is distributed on an "AS IS" BASIS,
0014   0000             ; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0015   0000             ; See the License for the specific language governing permissions and
0016   0000             ; limitations under the License.
0017   0000             
0018   0000             BIOS_INIT = 0F836h
0019   0000             BIOS_INIT_SP = 0F800h
0020   0000             BIOS_REBOOT = 0F800h
0021   0000             BIOS_READ_KEY = 0F803h
0022   0000             BIOS_CHECK_KEY = 0F812h
0023   0000             BIOS_PRINT_CHAR = 0F809h
0024   0000             
0025   0000             PORT_ROM = 0FFh
0026   0000             PORT_ROM__ENABLE_ROM = 0
0027   0000             PORT_ROM__FLOPPY_B = 1 << 0
0028   0000             PORT_ROM__FLOPPY_SIDE = 1 << 1
0029   0000             PORT_ROM__ENABLE_RAM = 1 << 2
0030   0000             PORT_ROM__ROM_A15 = 1 << 3
0031   0000             
0032   0000             ;----------------------------------------------------------------------------
0033   0000             
0034   0000                 .org 0
0035   0000             
0036   0000             cold_boot:
0037   0000                 ; Инициализация BIOS
0038   0000 F3              di
0039   0001 31 00 F8        ld   sp, BIOS_INIT_SP
0040   0004 CD 36 F8        call BIOS_INIT
0041   0007             
0042   0007                 ; По умолчанию накопитель A:
0043   0007 0E 00           ld   c, 0
0044   0009             
0045   0009             warm_boot:
0046   0009                 ; Копирование CP/M из ПЗУ в ОЗУ
0047   0009 11 1C 00        ld   de, cpm_in_rom
0048   000C 21 00 C4        ld   hl, begin
0049   000F             copy_loop:
0050   000F 1A              ld   a, (de)
0051   0010 13              inc  de
0052   0011 77              ld   (hl), a
0053   0012 23              inc  hl
0054   0013 7C              ld   a, h
0055   0014 FE E0           cp   (end >> 8) + 1
0056   0016 DA 0F 00        jp   c, copy_loop
0057   0019             
0058   0019                 ; Продолжение запуска в ОЗУ
0059   0019 C3 A5 DE        jp   boot
0060   001C             
0061   001C             cpm_in_rom:
0062   001C             
0063   001C             ;----------------------------------------------------------------------------
0064   001C             
0065   C400                 .org 0C400h
0066   C400             begin:
0067   C400             
0068   C400             STORAGE_COUNT = 1
0069   C400             
0070   C400             ROM_STORAGE_ADDRESS = 1C00h
0071   C400             ROM_STORAGE_SIZE = 10000h - ROM_STORAGE_ADDRESS
0072   C400             
0073   C400             A_BLOCK_SIZE = 1024
0074   C400             A_DIRECTORY_BLOCKS = 1
0075   C400             A_BLOCK_COUNT = ROM_STORAGE_SIZE / A_BLOCK_SIZE
0076   C400             
0077   C400                 .include "cpm22.inc"
0001+  C400             ;**************************************************************
0002+  C400             ;*
0003+  C400             ;*             C P / M   version   2 . 2
0004+  C400             ;*
0005+  C400             ;*   Reconstructed from memory image on February 27, 1981
0006+  C400             ;*
0007+  C400             ;*                by Clark A. Calkins
0008+  C400             ;*
0009+  C400             ;**************************************************************
0010+  C400             ;
0011+  C400             ;   Set memory limit here. This is the amount of contigeous
0012+  C400             ; ram starting from 0000. CP/M will reside at the end of this space.
0013+  C400             ;
0014+  C400             
0015+  C400             IOBYTE	.EQU	3		;i/o definition byte.
0016+  C400             TDRIVE	.EQU	4		;current drive name and user number.
0017+  C400             ENTRY	.EQU	5		;entry point for the cp/m bdos.
0018+  C400             TFCB	.EQU	5CH		;default file control block.
0019+  C400             TBUFF	.EQU	80H		;i/o buffer and command line storage.
0020+  C400             TBASE	.EQU	100H		;transiant program storage area.
0021+  C400             ;
0022+  C400             ;   Set control character equates.
0023+  C400             ;
0024+  C400             CNTRLC	.EQU	3		;control-c
0025+  C400             CNTRLE	.EQU	05H		;control-e
0026+  C400             BS	.EQU	08H		;backspace
0027+  C400             TAB	.EQU	09H		;tab
0028+  C400             LF	.EQU	0AH		;line feed
0029+  C400             FF	.EQU	0CH		;form feed
0030+  C400             CR	.EQU	0DH		;carriage return
0031+  C400             CNTRLP	.EQU	10H		;control-p
0032+  C400             CNTRLR	.EQU	12H		;control-r
0033+  C400             CNTRLS	.EQU	13H		;control-s
0034+  C400             CNTRLU	.EQU	15H		;control-u
0035+  C400             CNTRLX	.EQU	18H		;control-x
0036+  C400             CNTRLZ	.EQU	1AH		;control-z (end-of-file mark)
0037+  C400             DEL	.EQU	7FH		;rubout
0038+  C400             
0039+  C400             ;
0040+  C400 C3 5C C7    CBASE:	JP	COMMAND		;execute command processor (ccp).
0041+  C403 C3 58 C7        JP	CLEARBUF	;entry to empty input buffer before starting ccp.
0042+  C406             
0043+  C406             ;
0044+  C406             ;   Standard cp/m ccp input buffer. Format is (max length),
0045+  C406             ; (actual length), (char #1), (char #2), (char #3), etc.
0046+  C406             ;
0047+  C406 7F          INBUFF:	.DB	127		;length of input buffer.
0048+  C407 00              .DB	0		;current length of contents.
0049+  C408 43 6F 70 79     .DB	"Copyright"
0049+  C40C 72 69 67 68 
0049+  C410 74 
0050+  C411 20 31 39 37     .DB	" 1979 (c) by Digital Research      "
0050+  C415 39 20 28 63 
0050+  C419 29 20 62 79 
0050+  C41D 20 44 69 67 
0050+  C421 69 74 61 6C 
0050+  C425 20 52 65 73 
0050+  C429 65 61 72 63 
0050+  C42D 68 20 20 20 
0050+  C431 20 20 20 
0051+  C434 00 00 00 00     .DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0051+  C438 00 00 00 00 
0051+  C43C 00 00 00 00 
0051+  C440 00 00 00 00 
0051+  C444 00 00 00 00 
0051+  C448 00 00 00 
0052+  C44B 00 00 00 00     .DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0052+  C44F 00 00 00 00 
0052+  C453 00 00 00 00 
0052+  C457 00 00 00 00 
0052+  C45B 00 00 00 00 
0052+  C45F 00 00 00 
0053+  C462 00 00 00 00     .DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0053+  C466 00 00 00 00 
0053+  C46A 00 00 00 00 
0053+  C46E 00 00 00 00 
0053+  C472 00 00 00 00 
0053+  C476 00 00 00 
0054+  C479 00 00 00 00     .DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0054+  C47D 00 00 00 00 
0054+  C481 00 00 00 00 
0054+  C485 00 00 00 
0055+  C488 08 C4       INPOINT:.DW	INBUFF+2	;input line pointer
0056+  C48A 00 00       NAMEPNT:.DW	0		;input line pointer used for error message. Points to
0057+  C48C             ;			;start of name in error.
0058+  C48C             ;
0059+  C48C             ;   Routine to print (A) on the console. All registers used.
0060+  C48C             ;
0061+  C48C 5F          PRINT:	LD	E,A		;setup bdos call.
0062+  C48D 0E 02           LD	C,2
0063+  C48F C3 05 00        JP	ENTRY
0064+  C492             ;
0065+  C492             ;   Routine to print (A) on the console and to save (BC).
0066+  C492             ;
0067+  C492 C5          PRINTB:	PUSH	BC
0068+  C493 CD 8C C4        CALL	PRINT
0069+  C496 C1              POP	BC
0070+  C497 C9              RET
0071+  C498             ;
0072+  C498             ;   Routine to send a carriage return, line feed combination
0073+  C498             ; to the console.
0074+  C498             ;
0075+  C498 3E 0D       CRLF:	LD	A,CR
0076+  C49A CD 92 C4        CALL	PRINTB
0077+  C49D 3E 0A           LD	A,LF
0078+  C49F C3 92 C4        JP	PRINTB
0079+  C4A2             ;
0080+  C4A2             ;   Routine to send one space to the console and save (BC).
0081+  C4A2             ;
0082+  C4A2 3E 20       SPACE:	LD	A,' '
0083+  C4A4 C3 92 C4        JP	PRINTB
0084+  C4A7             ;
0085+  C4A7             ;   Routine to print character string pointed to be (BC) on the
0086+  C4A7             ; console. It must terminate with a null byte.
0087+  C4A7             ;
0088+  C4A7 C5          PLINE:	PUSH	BC
0089+  C4A8 CD 98 C4        CALL	CRLF
0090+  C4AB E1              POP	HL
0091+  C4AC 7E          PLINE2:	LD	A,(HL)
0092+  C4AD B7              OR	A
0093+  C4AE C8              RET	Z
0094+  C4AF 23              INC	HL
0095+  C4B0 E5              PUSH	HL
0096+  C4B1 CD 8C C4        CALL	PRINT
0097+  C4B4 E1              POP	HL
0098+  C4B5 C3 AC C4        JP	PLINE2
0099+  C4B8             ;
0100+  C4B8             ;   Routine to reset the disk system.
0101+  C4B8             ;
0102+  C4B8 0E 0D       RESDSK:	LD	C,13
0103+  C4BA C3 05 00        JP	ENTRY
0104+  C4BD             ;
0105+  C4BD             ;   Routine to select disk (A).
0106+  C4BD             ;
0107+  C4BD 5F          DSKSEL:	LD	E,A
0108+  C4BE 0E 0E           LD	C,14
0109+  C4C0 C3 05 00        JP	ENTRY
0110+  C4C3             ;
0111+  C4C3             ;   Routine to call bdos and save the return code. The zero
0112+  C4C3             ; flag is set on a return of 0ffh.
0113+  C4C3             ;
0114+  C4C3 CD 05 00    ENTRY1:	CALL	ENTRY
0115+  C4C6 32 EE CB        LD	(RTNCODE),A	;save return code.
0116+  C4C9 3C              INC	A		;set zero if 0ffh returned.
0117+  C4CA C9              RET
0118+  C4CB             ;
0119+  C4CB             ;   Routine to open a file. (DE) must point to the FCB.
0120+  C4CB             ;
0121+  C4CB 0E 0F       OPEN:	LD	C,15
0122+  C4CD C3 C3 C4        JP	ENTRY1
0123+  C4D0             ;
0124+  C4D0             ;   Routine to open file at (FCB).
0125+  C4D0             ;
0126+  C4D0 AF          OPENFCB:XOR	A		;clear the record number byte at fcb+32
0127+  C4D1 32 ED CB        LD	(FCB+32),A
0128+  C4D4 11 CD CB        LD	DE,FCB
0129+  C4D7 C3 CB C4        JP	OPEN
0130+  C4DA             ;
0131+  C4DA             ;   Routine to close a file. (DE) points to FCB.
0132+  C4DA             ;
0133+  C4DA 0E 10       CLOSE:	LD	C,16
0134+  C4DC C3 C3 C4        JP	ENTRY1
0135+  C4DF             ;
0136+  C4DF             ;   Routine to search for the first file with ambigueous name
0137+  C4DF             ; (DE).
0138+  C4DF             ;
0139+  C4DF 0E 11       SRCHFST:LD	C,17
0140+  C4E1 C3 C3 C4        JP	ENTRY1
0141+  C4E4             ;
0142+  C4E4             ;   Search for the next ambigeous file name.
0143+  C4E4             ;
0144+  C4E4 0E 12       SRCHNXT:LD	C,18
0145+  C4E6 C3 C3 C4        JP	ENTRY1
0146+  C4E9             ;
0147+  C4E9             ;   Search for file at (FCB).
0148+  C4E9             ;
0149+  C4E9 11 CD CB    SRCHFCB:LD	DE,FCB
0150+  C4EC C3 DF C4        JP	SRCHFST
0151+  C4EF             ;
0152+  C4EF             ;   Routine to delete a file pointed to by (DE).
0153+  C4EF             ;
0154+  C4EF 0E 13       DELETE:	LD	C,19
0155+  C4F1 C3 05 00        JP	ENTRY
0156+  C4F4             ;
0157+  C4F4             ;   Routine to call the bdos and set the zero flag if a zero
0158+  C4F4             ; status is returned.
0159+  C4F4             ;
0160+  C4F4 CD 05 00    ENTRY2:	CALL	ENTRY
0161+  C4F7 B7              OR	A		;set zero flag if appropriate.
0162+  C4F8 C9              RET
0163+  C4F9             ;
0164+  C4F9             ;   Routine to read the next record from a sequential file.
0165+  C4F9             ; (DE) points to the FCB.
0166+  C4F9             ;
0167+  C4F9 0E 14       RDREC:	LD	C,20
0168+  C4FB C3 F4 C4        JP	ENTRY2
0169+  C4FE             ;
0170+  C4FE             ;   Routine to read file at (FCB).
0171+  C4FE             ;
0172+  C4FE 11 CD CB    READFCB:LD	DE,FCB
0173+  C501 C3 F9 C4        JP	RDREC
0174+  C504             ;
0175+  C504             ;   Routine to write the next record of a sequential file.
0176+  C504             ; (DE) points to the FCB.
0177+  C504             ;
0178+  C504 0E 15       WRTREC:	LD	C,21
0179+  C506 C3 F4 C4        JP	ENTRY2
0180+  C509             ;
0181+  C509             ;   Routine to create the file pointed to by (DE).
0182+  C509             ;
0183+  C509 0E 16       CREATE:	LD	C,22
0184+  C50B C3 C3 C4        JP	ENTRY1
0185+  C50E             ;
0186+  C50E             ;   Routine to rename the file pointed to by (DE). Note that
0187+  C50E             ; the new name starts at (DE+16).
0188+  C50E             ;
0189+  C50E 0E 17       RENAM:	LD	C,23
0190+  C510 C3 05 00        JP	ENTRY
0191+  C513             ;
0192+  C513             ;   Get the current user code.
0193+  C513             ;
0194+  C513 1E FF       GETUSR:	LD	E,0FFH
0195+  C515             ;
0196+  C515             ;   Routne to get or set the current user code.
0197+  C515             ; If (E) is FF then this is a GET, else it is a SET.
0198+  C515             ;
0199+  C515 0E 20       GETSETUC: LD	C,32
0200+  C517 C3 05 00        JP	ENTRY
0201+  C51A             ;
0202+  C51A             ;   Routine to set the current drive byte at (TDRIVE).
0203+  C51A             ;
0204+  C51A CD 13 C5    SETCDRV:CALL	GETUSR		;get user number
0205+  C51D 87              ADD	A		;and shift into the upper 4 bits.
0206+  C51E 87              ADD	A
0207+  C51F 87              ADD	A
0208+  C520 87              ADD	A
0209+  C521 21 EF CB        LD	HL,CDRIVE	;now add in the current drive number.
0210+  C524 B6              OR	(HL)
0211+  C525 32 04 00        LD	(TDRIVE),A	;and save.
0212+  C528 C9              RET
0213+  C529             ;
0214+  C529             ;   Move currently active drive down to (TDRIVE).
0215+  C529             ;
0216+  C529 3A EF CB    MOVECD:	LD	A,(CDRIVE)
0217+  C52C 32 04 00        LD	(TDRIVE),A
0218+  C52F C9              RET
0219+  C530             ;
0220+  C530             ;   Routine to convert (A) into upper case ascii. Only letters
0221+  C530             ; are affected.
0222+  C530             ;
0223+  C530 FE 61       UPPER:	CP	'a'		;check for letters in the range of 'a' to 'z'.
0224+  C532 D8              RET	C
0225+  C533 FE 7B           CP	'{'
0226+  C535 D0              RET	NC
0227+  C536 E6 5F           AND	5FH		;convert it if found.
0228+  C538 C9              RET
0229+  C539             ;
0230+  C539             ;   Routine to get a line of input. We must check to see if the
0231+  C539             ; user is in (BATCH) mode. If so, then read the input from file
0232+  C539             ; ($$$.SUB). At the end, reset to console input.
0233+  C539             ;
0234+  C539 3A AB CB    GETINP:	LD	A,(BATCH)	;if =0, then use console input.
0235+  C53C B7              OR	A
0236+  C53D CA 96 C5        JP	Z,GETINP1
0237+  C540             ;
0238+  C540             ;   Use the submit file ($$$.sub) which is prepared by a
0239+  C540             ; SUBMIT run. It must be on drive (A) and it will be deleted
0240+  C540             ; if and error occures (like eof).
0241+  C540             ;
0242+  C540 3A EF CB        LD	A,(CDRIVE)	;select drive 0 if need be.
0243+  C543 B7              OR	A
0244+  C544 3E 00           LD	A,0		;always use drive A for submit.
0245+  C546 C4 BD C4        CALL	NZ,DSKSEL	;select it if required.
0246+  C549 11 AC CB        LD	DE,BATCHFCB
0247+  C54C CD CB C4        CALL	OPEN		;look for it.
0248+  C54F CA 96 C5        JP	Z,GETINP1	;if not there, use normal input.
0249+  C552 3A BB CB        LD	A,(BATCHFCB+15)	;get last record number+1.
0250+  C555 3D              DEC	A
0251+  C556 32 CC CB        LD	(BATCHFCB+32),A
0252+  C559 11 AC CB        LD	DE,BATCHFCB
0253+  C55C CD F9 C4        CALL	RDREC		;read last record.
0254+  C55F C2 96 C5        JP	NZ,GETINP1	;quit on end of file.
0255+  C562             ;
0256+  C562             ;   Move this record into input buffer.
0257+  C562             ;
0258+  C562 11 07 C4        LD	DE,INBUFF+1
0259+  C565 21 80 00        LD	HL,TBUFF	;data was read into buffer here.
0260+  C568 06 80           LD	B,128		;all 128 characters may be used.
0261+  C56A CD 42 C8        CALL	HL2DE		;(HL) to (DE), (B) bytes.
0262+  C56D 21 BA CB        LD	HL,BATCHFCB+14
0263+  C570 36 00           LD	(HL),0		;zero out the 's2' byte.
0264+  C572 23              INC	HL		;and decrement the record count.
0265+  C573 35              DEC	(HL)
0266+  C574 11 AC CB        LD	DE,BATCHFCB	;close the batch file now.
0267+  C577 CD DA C4        CALL	CLOSE
0268+  C57A CA 96 C5        JP	Z,GETINP1	;quit on an error.
0269+  C57D 3A EF CB        LD	A,(CDRIVE)	;re-select previous drive if need be.
0270+  C580 B7              OR	A
0271+  C581 C4 BD C4        CALL	NZ,DSKSEL	;don't do needless selects.
0272+  C584             ;
0273+  C584             ;   Print line just read on console.
0274+  C584             ;
0275+  C584 21 08 C4        LD	HL,INBUFF+2
0276+  C587 CD AC C4        CALL	PLINE2
0277+  C58A CD C2 C5        CALL	CHKCON		;check console, quit on a key.
0278+  C58D CA A7 C5        JP	Z,GETINP2	;jump if no key is pressed.
0279+  C590             ;
0280+  C590             ;   Terminate the submit job on any keyboard input. Delete this
0281+  C590             ; file such that it is not re-started and jump to normal keyboard
0282+  C590             ; input section.
0283+  C590             ;
0284+  C590 CD DD C5        CALL	DELBATCH	;delete the batch file.
0285+  C593 C3 82 C7        JP	CMMND1		;and restart command input.
0286+  C596             ;
0287+  C596             ;   Get here for normal keyboard input. Delete the submit file
0288+  C596             ; incase there was one.
0289+  C596             ;
0290+  C596 CD DD C5    GETINP1:CALL	DELBATCH	;delete file ($$$.sub).
0291+  C599 CD 1A C5        CALL	SETCDRV		;reset active disk.
0292+  C59C 0E 0A           LD	C,10		;get line from console device.
0293+  C59E 11 06 C4        LD	DE,INBUFF
0294+  C5A1 CD 05 00        CALL	ENTRY
0295+  C5A4 CD 29 C5        CALL	MOVECD		;reset current drive (again).
0296+  C5A7             ;
0297+  C5A7             ;   Convert input line to upper case.
0298+  C5A7             ;
0299+  C5A7 21 07 C4    GETINP2:LD	HL,INBUFF+1
0300+  C5AA 46              LD	B,(HL)		;(B)=character counter.
0301+  C5AB 23          GETINP3:INC	HL
0302+  C5AC 78              LD	A,B		;end of the line?
0303+  C5AD B7              OR	A
0304+  C5AE CA BA C5        JP	Z,GETINP4
0305+  C5B1 7E              LD	A,(HL)		;convert to upper case.
0306+  C5B2 CD 30 C5        CALL	UPPER
0307+  C5B5 77              LD	(HL),A
0308+  C5B6 05              DEC	B		;adjust character count.
0309+  C5B7 C3 AB C5        JP	GETINP3
0310+  C5BA 77          GETINP4:LD	(HL),A		;add trailing null.
0311+  C5BB 21 08 C4        LD	HL,INBUFF+2
0312+  C5BE 22 88 C4        LD	(INPOINT),HL	;reset input line pointer.
0313+  C5C1 C9              RET
0314+  C5C2             ;
0315+  C5C2             ;   Routine to check the console for a key pressed. The zero
0316+  C5C2             ; flag is set is none, else the character is returned in (A).
0317+  C5C2             ;
0318+  C5C2 0E 0B       CHKCON:	LD	C,11		;check console.
0319+  C5C4 CD 05 00        CALL	ENTRY
0320+  C5C7 B7              OR	A
0321+  C5C8 C8              RET	Z		;return if nothing.
0322+  C5C9 0E 01           LD	C,1		;else get character.
0323+  C5CB CD 05 00        CALL	ENTRY
0324+  C5CE B7              OR	A		;clear zero flag and return.
0325+  C5CF C9              RET
0326+  C5D0             ;
0327+  C5D0             ;   Routine to get the currently active drive number.
0328+  C5D0             ;
0329+  C5D0 0E 19       GETDSK:	LD	C,25
0330+  C5D2 C3 05 00        JP	ENTRY
0331+  C5D5             ;
0332+  C5D5             ;   Set the stabdard dma address.
0333+  C5D5             ;
0334+  C5D5 11 80 00    STDDMA:	LD	DE,TBUFF
0335+  C5D8             ;
0336+  C5D8             ;   Routine to set the dma address to (DE).
0337+  C5D8             ;
0338+  C5D8 0E 1A       DMASET:	LD	C,26
0339+  C5DA C3 05 00        JP	ENTRY
0340+  C5DD             ;
0341+  C5DD             ;  Delete the batch file created by SUBMIT.
0342+  C5DD             ;
0343+  C5DD 21 AB CB    DELBATCH: LD	HL,BATCH	;is batch active?
0344+  C5E0 7E              LD	A,(HL)
0345+  C5E1 B7              OR	A
0346+  C5E2 C8              RET	Z
0347+  C5E3 36 00           LD	(HL),0		;yes, de-activate it.
0348+  C5E5 AF              XOR	A
0349+  C5E6 CD BD C4        CALL	DSKSEL		;select drive 0 for sure.
0350+  C5E9 11 AC CB        LD	DE,BATCHFCB	;and delete this file.
0351+  C5EC CD EF C4        CALL	DELETE
0352+  C5EF 3A EF CB        LD	A,(CDRIVE)	;reset current drive.
0353+  C5F2 C3 BD C4        JP	DSKSEL
0354+  C5F5             ;
0355+  C5F5             ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
0356+  C5F5             ; the same or we halt....
0357+  C5F5             ;
0358+  C5F5 11 28 C7    VERIFY:	LD	DE,PATTRN1	;these are the serial number bytes.
0359+  C5F8 21 00 CC        LD	HL,PATTRN2	;ditto, but how could they be different?
0360+  C5FB 06 06           LD	B,6		;6 bytes each.
0361+  C5FD 1A          VERIFY1:LD	A,(DE)
0362+  C5FE BE              CP	(HL)
0363+  C5FF C2 CF C7        JP	NZ,HALTP	;jump to halt routine.
0364+  C602 13              INC	DE
0365+  C603 23              INC	HL
0366+  C604 05              DEC	B
0367+  C605 C2 FD C5        JP	NZ,VERIFY1
0368+  C608 C9              RET
0369+  C609             ;
0370+  C609             ;   Print back file name with a '?' to indicate a syntax error.
0371+  C609             ;
0372+  C609 CD 98 C4    SYNERR:	CALL	CRLF		;end current line.
0373+  C60C 2A 8A C4        LD	HL,(NAMEPNT)	;this points to name in error.
0374+  C60F 7E          SYNERR1:LD	A,(HL)		;print it until a space or null is found.
0375+  C610 FE 20           CP	' '
0376+  C612 CA 22 C6        JP	Z,SYNERR2
0377+  C615 B7              OR	A
0378+  C616 CA 22 C6        JP	Z,SYNERR2
0379+  C619 E5              PUSH	HL
0380+  C61A CD 8C C4        CALL	PRINT
0381+  C61D E1              POP	HL
0382+  C61E 23              INC	HL
0383+  C61F C3 0F C6        JP	SYNERR1
0384+  C622 3E 3F       SYNERR2:LD	A,'?'		;add trailing '?'.
0385+  C624 CD 8C C4        CALL	PRINT
0386+  C627 CD 98 C4        CALL	CRLF
0387+  C62A CD DD C5        CALL	DELBATCH	;delete any batch file.
0388+  C62D C3 82 C7        JP	CMMND1		;and restart from console input.
0389+  C630             ;
0390+  C630             ;   Check character at (DE) for legal command input. Note that the
0391+  C630             ; zero flag is set if the character is a delimiter.
0392+  C630             ;
0393+  C630 1A          CHECK:	LD	A,(DE)
0394+  C631 B7              OR	A
0395+  C632 C8              RET	Z
0396+  C633 FE 20           CP	' '		;control characters are not legal here.
0397+  C635 DA 09 C6        JP	C,SYNERR
0398+  C638 C8              RET	Z		;check for valid delimiter.
0399+  C639 FE 3D           CP	'='
0400+  C63B C8              RET	Z
0401+  C63C FE 5F           CP	'_'
0402+  C63E C8              RET	Z
0403+  C63F FE 2E           CP	'.'
0404+  C641 C8              RET	Z
0405+  C642 FE 3A           CP	':'
0406+  C644 C8              RET	Z
0407+  C645 FE 3B           CP	03BH ; ';'
0408+  C647 C8              RET	Z
0409+  C648 FE 3C           CP	'<'
0410+  C64A C8              RET	Z
0411+  C64B FE 3E           CP	'>'
0412+  C64D C8              RET	Z
0413+  C64E C9              RET
0414+  C64F             ;
0415+  C64F             ;   Get the next non-blank character from (DE).
0416+  C64F             ;
0417+  C64F 1A          NONBLANK: LD	A,(DE)
0418+  C650 B7              OR	A		;string ends with a null.
0419+  C651 C8              RET	Z
0420+  C652 FE 20           CP	' '
0421+  C654 C0              RET	NZ
0422+  C655 13              INC	DE
0423+  C656 C3 4F C6        JP	NONBLANK
0424+  C659             ;
0425+  C659             ;   Add (HL)=(HL)+(A)
0426+  C659             ;
0427+  C659 85          ADDHL:	ADD	L
0428+  C65A 6F              LD	L,A
0429+  C65B D0              RET	NC		;take care of any carry.
0430+  C65C 24              INC	H
0431+  C65D C9              RET
0432+  C65E             ;
0433+  C65E             ;   Convert the first name in (FCB).
0434+  C65E             ;
0435+  C65E 3E 00       CONVFST:LD	A,0
0436+  C660             ;
0437+  C660             ;   Format a file name (convert * to '?', etc.). On return,
0438+  C660             ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
0439+  C660             ; the position within the fcb for the name (either 0 or 16).
0440+  C660             ;
0441+  C660 21 CD CB    CONVERT:LD	HL,FCB
0442+  C663 CD 59 C6        CALL	ADDHL
0443+  C666 E5              PUSH	HL
0444+  C667 E5              PUSH	HL
0445+  C668 AF              XOR	A
0446+  C669 32 F0 CB        LD	(CHGDRV),A	;initialize drive change flag.
0447+  C66C 2A 88 C4        LD	HL,(INPOINT)	;set (HL) as pointer into input line.
0448+  C66F EB              EX	DE,HL
0449+  C670 CD 4F C6        CALL	NONBLANK	;get next non-blank character.
0450+  C673 EB              EX	DE,HL
0451+  C674 22 8A C4        LD	(NAMEPNT),HL	;save pointer here for any error message.
0452+  C677 EB              EX	DE,HL
0453+  C678 E1              POP	HL
0454+  C679 1A              LD	A,(DE)		;get first character.
0455+  C67A B7              OR	A
0456+  C67B CA 89 C6        JP	Z,CONVRT1
0457+  C67E DE 40           SBC	'A'-1		;might be a drive name, convert to binary.
0458+  C680 47              LD	B,A		;and save.
0459+  C681 13              INC	DE		;check next character for a ':'.
0460+  C682 1A              LD	A,(DE)
0461+  C683 FE 3A           CP	':'
0462+  C685 CA 90 C6        JP	Z,CONVRT2
0463+  C688 1B              DEC	DE		;nope, move pointer back to the start of the line.
0464+  C689 3A EF CB    CONVRT1:LD	A,(CDRIVE)
0465+  C68C 77              LD	(HL),A
0466+  C68D C3 96 C6        JP	CONVRT3
0467+  C690 78          CONVRT2:LD	A,B
0468+  C691 32 F0 CB        LD	(CHGDRV),A	;set change in drives flag.
0469+  C694 70              LD	(HL),B
0470+  C695 13              INC	DE
0471+  C696             ;
0472+  C696             ;   Convert the basic file name.
0473+  C696             ;
0474+  C696 06 08       CONVRT3:LD	B,08H
0475+  C698 CD 30 C6    CONVRT4:CALL	CHECK
0476+  C69B CA B9 C6        JP	Z,CONVRT8
0477+  C69E 23              INC	HL
0478+  C69F FE 2A           CP	'*'		;note that an '*' will fill the remaining
0479+  C6A1 C2 A9 C6        JP	NZ,CONVRT5	;field with '?'.
0480+  C6A4 36 3F           LD	(HL),'?'
0481+  C6A6 C3 AB C6        JP	CONVRT6
0482+  C6A9 77          CONVRT5:LD	(HL),A
0483+  C6AA 13              INC	DE
0484+  C6AB 05          CONVRT6:DEC	B
0485+  C6AC C2 98 C6        JP	NZ,CONVRT4
0486+  C6AF CD 30 C6    CONVRT7:CALL	CHECK		;get next delimiter.
0487+  C6B2 CA C0 C6        JP	Z,GETEXT
0488+  C6B5 13              INC	DE
0489+  C6B6 C3 AF C6        JP	CONVRT7
0490+  C6B9 23          CONVRT8:INC	HL		;blank fill the file name.
0491+  C6BA 36 20           LD	(HL),' '
0492+  C6BC 05              DEC	B
0493+  C6BD C2 B9 C6        JP	NZ,CONVRT8
0494+  C6C0             ;
0495+  C6C0             ;   Get the extension and convert it.
0496+  C6C0             ;
0497+  C6C0 06 03       GETEXT:	LD	B,03H
0498+  C6C2 FE 2E           CP	'.'
0499+  C6C4 C2 E9 C6        JP	NZ,GETEXT5
0500+  C6C7 13              INC	DE
0501+  C6C8 CD 30 C6    GETEXT1:CALL	CHECK
0502+  C6CB CA E9 C6        JP	Z,GETEXT5
0503+  C6CE 23              INC	HL
0504+  C6CF FE 2A           CP	'*'
0505+  C6D1 C2 D9 C6        JP	NZ,GETEXT2
0506+  C6D4 36 3F           LD	(HL),'?'
0507+  C6D6 C3 DB C6        JP	GETEXT3
0508+  C6D9 77          GETEXT2:LD	(HL),A
0509+  C6DA 13              INC	DE
0510+  C6DB 05          GETEXT3:DEC	B
0511+  C6DC C2 C8 C6        JP	NZ,GETEXT1
0512+  C6DF CD 30 C6    GETEXT4:CALL	CHECK
0513+  C6E2 CA F0 C6        JP	Z,GETEXT6
0514+  C6E5 13              INC	DE
0515+  C6E6 C3 DF C6        JP	GETEXT4
0516+  C6E9 23          GETEXT5:INC	HL
0517+  C6EA 36 20           LD	(HL),' '
0518+  C6EC 05              DEC	B
0519+  C6ED C2 E9 C6        JP	NZ,GETEXT5
0520+  C6F0 06 03       GETEXT6:LD	B,3
0521+  C6F2 23          GETEXT7:INC	HL
0522+  C6F3 36 00           LD	(HL),0
0523+  C6F5 05              DEC	B
0524+  C6F6 C2 F2 C6        JP	NZ,GETEXT7
0525+  C6F9 EB              EX	DE,HL
0526+  C6FA 22 88 C4        LD	(INPOINT),HL	;save input line pointer.
0527+  C6FD E1              POP	HL
0528+  C6FE             ;
0529+  C6FE             ;   Check to see if this is an ambigeous file name specification.
0530+  C6FE             ; Set the (A) register to non zero if it is.
0531+  C6FE             ;
0532+  C6FE 01 0B 00        LD	BC,11		;set name length.
0533+  C701 23          GETEXT8:INC	HL
0534+  C702 7E              LD	A,(HL)
0535+  C703 FE 3F           CP	'?'		;any question marks?
0536+  C705 C2 09 C7        JP	NZ,GETEXT9
0537+  C708 04              INC	B		;count them.
0538+  C709 0D          GETEXT9:DEC	C
0539+  C70A C2 01 C7        JP	NZ,GETEXT8
0540+  C70D 78              LD	A,B
0541+  C70E B7              OR	A
0542+  C70F C9              RET
0543+  C710             ;
0544+  C710             ;   CP/M command table. Note commands can be either 3 or 4 characters long.
0545+  C710             ;
0546+  C710             NUMCMDS .EQU	6		;number of commands
0547+  C710 44 49 52 20 CMDTBL:	.DB	"DIR "
0548+  C714 45 52 41 20     .DB	"ERA "
0549+  C718 54 59 50 45     .DB	"TYPE"
0550+  C71C 53 41 56 45     .DB	"SAVE"
0551+  C720 52 45 4E 20     .DB	"REN "
0552+  C724 55 53 45 52     .DB	"USER"
0553+  C728             ;
0554+  C728             ;   The following six bytes must agree with those at (PATTRN2)
0555+  C728             ; or cp/m will HALT. Why?
0556+  C728             ;
0557+  C728 00 16 00 00 PATTRN1:.DB	0,22,0,0,0,0	;(* serial number bytes *).
0557+  C72C 00 00 
0558+  C72E             ;
0559+  C72E             ;   Search the command table for a match with what has just
0560+  C72E             ; been entered. If a match is found, then we jump to the
0561+  C72E             ; proper section. Else jump to (UNKNOWN).
0562+  C72E             ; On return, the (C) register is set to the command number
0563+  C72E             ; that matched (or NUMCMDS+1 if no match).
0564+  C72E             ;
0565+  C72E 21 10 C7    SEARCH:	LD	HL,CMDTBL
0566+  C731 0E 00           LD	C,0
0567+  C733 79          SEARCH1:LD	A,C
0568+  C734 FE 06           CP	NUMCMDS		;this commands exists.
0569+  C736 D0              RET	NC
0570+  C737 11 CE CB        LD	DE,FCB+1	;check this one.
0571+  C73A 06 04           LD	B,4		;max command length.
0572+  C73C 1A          SEARCH2:LD	A,(DE)
0573+  C73D BE              CP	(HL)
0574+  C73E C2 4F C7        JP	NZ,SEARCH3	;not a match.
0575+  C741 13              INC	DE
0576+  C742 23              INC	HL
0577+  C743 05              DEC	B
0578+  C744 C2 3C C7        JP	NZ,SEARCH2
0579+  C747 1A              LD	A,(DE)		;allow a 3 character command to match.
0580+  C748 FE 20           CP	' '
0581+  C74A C2 54 C7        JP	NZ,SEARCH4
0582+  C74D 79              LD	A,C		;set return register for this command.
0583+  C74E C9              RET
0584+  C74F 23          SEARCH3:INC	HL
0585+  C750 05              DEC	B
0586+  C751 C2 4F C7        JP	NZ,SEARCH3
0587+  C754 0C          SEARCH4:INC	C
0588+  C755 C3 33 C7        JP	SEARCH1
0589+  C758             ;
0590+  C758             ;   Set the input buffer to empty and then start the command
0591+  C758             ; processor (ccp).
0592+  C758             ;
0593+  C758 AF          CLEARBUF: XOR	A
0594+  C759 32 07 C4        LD	(INBUFF+1),A	;second byte is actual length.
0595+  C75C             ;
0596+  C75C             ;**************************************************************
0597+  C75C             ;*
0598+  C75C             ;*
0599+  C75C             ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
0600+  C75C             ;*
0601+  C75C             ;**************************************************************
0602+  C75C             ;*
0603+  C75C 31 AB CB    COMMAND:LD	SP,CCPSTACK	;setup stack area.
0604+  C75F C5              PUSH	BC		;note that (C) should be equal to:
0605+  C760 79              LD	A,C		;(uuuudddd) where 'uuuu' is the user number
0606+  C761 1F              RRA			;and 'dddd' is the drive number.
0607+  C762 1F              RRA
0608+  C763 1F              RRA
0609+  C764 1F              RRA
0610+  C765 E6 0F           AND	0FH		;isolate the user number.
0611+  C767 5F              LD	E,A
0612+  C768 CD 15 C5        CALL	GETSETUC	;and set it.
0613+  C76B CD B8 C4        CALL	RESDSK		;reset the disk system.
0614+  C76E 32 AB CB        LD	(BATCH),A	;clear batch mode flag.
0615+  C771 C1              POP	BC
0616+  C772 79              LD	A,C
0617+  C773 E6 0F           AND	0FH		;isolate the drive number.
0618+  C775 32 EF CB        LD	(CDRIVE),A	;and save.
0619+  C778 CD BD C4        CALL	DSKSEL		;...and select.
0620+  C77B 3A 07 C4        LD	A,(INBUFF+1)
0621+  C77E B7              OR	A		;anything in input buffer already?
0622+  C77F C2 98 C7        JP	NZ,CMMND2	;yes, we just process it.
0623+  C782             ;
0624+  C782             ;   Entry point to get a command line from the console.
0625+  C782             ;
0626+  C782 31 AB CB    CMMND1:	LD	SP,CCPSTACK	;set stack straight.
0627+  C785 CD 98 C4        CALL	CRLF		;start a new line on the screen.
0628+  C788 CD D0 C5        CALL	GETDSK		;get current drive.
0629+  C78B C6 41           ADD	'A'
0630+  C78D CD 8C C4        CALL	PRINT		;print current drive.
0631+  C790 3E 3E           LD	A,'>'
0632+  C792 CD 8C C4        CALL	PRINT		;and add prompt.
0633+  C795 CD 39 C5        CALL	GETINP		;get line from user.
0634+  C798             ;
0635+  C798             ;   Process command line here.
0636+  C798             ;
0637+  C798 11 80 00    CMMND2:	LD	DE,TBUFF
0638+  C79B CD D8 C5        CALL	DMASET		;set standard dma address.
0639+  C79E CD D0 C5        CALL	GETDSK
0640+  C7A1 32 EF CB        LD	(CDRIVE),A	;set current drive.
0641+  C7A4 CD 5E C6        CALL	CONVFST		;convert name typed in.
0642+  C7A7 C4 09 C6        CALL	NZ,SYNERR	;wild cards are not allowed.
0643+  C7AA 3A F0 CB        LD	A,(CHGDRV)	;if a change in drives was indicated,
0644+  C7AD B7              OR	A		;then treat this as an unknown command
0645+  C7AE C2 A5 CA        JP	NZ,UNKNOWN	;which gets executed.
0646+  C7B1 CD 2E C7        CALL	SEARCH		;else search command table for a match.
0647+  C7B4             ;
0648+  C7B4             ;   Note that an unknown command returns
0649+  C7B4             ; with (A) pointing to the last address
0650+  C7B4             ; in our table which is (UNKNOWN).
0651+  C7B4             ;
0652+  C7B4 21 C1 C7        LD	HL,CMDADR	;now, look thru our address table for command (A).
0653+  C7B7 5F              LD	E,A		;set (DE) to command number.
0654+  C7B8 16 00           LD	D,0
0655+  C7BA 19              ADD	HL,DE
0656+  C7BB 19              ADD	HL,DE		;(HL)=(CMDADR)+2*(command number).
0657+  C7BC 7E              LD	A,(HL)		;now pick out this address.
0658+  C7BD 23              INC	HL
0659+  C7BE 66              LD	H,(HL)
0660+  C7BF 6F              LD	L,A
0661+  C7C0 E9              JP	(HL)		;now execute it.
0662+  C7C1             ;
0663+  C7C1             ;   CP/M command address table.
0664+  C7C1             ;
0665+  C7C1 77 C8 1F C9 CMDADR:	.DW	DIRECT,ERASE,TYPE,SAVE
0665+  C7C5 5D C9 AD C9 
0666+  C7C9 10 CA 8E CA     .DW	RENAME,USER,UNKNOWN
0666+  C7CD A5 CA 
0667+  C7CF             ;
0668+  C7CF             ;   Halt the system. Reason for this is unknown at present.
0669+  C7CF             ;
0670+  C7CF 21 F3 76    HALTP:	LD	HL,76F3H	;'DI HLT' instructions.
0671+  C7D2 22 00 C4        LD	(CBASE),HL
0672+  C7D5 21 00 C4        LD	HL,CBASE
0673+  C7D8 E9              JP	(HL)
0674+  C7D9             ;
0675+  C7D9             ;   Read error while TYPEing a file.
0676+  C7D9             ;
0677+  C7D9 01 DF C7    RDERROR:LD	BC,RDERR
0678+  C7DC C3 A7 C4        JP	PLINE
0679+  C7DF 52 65 61 64 RDERR:	.DB	"Read error"
0679+  C7E3 20 65 72 72 
0679+  C7E7 6F 72 
0680+  C7E9 00              .DB	0
0681+  C7EA             ;
0682+  C7EA             ;   Required file was not located.
0683+  C7EA             ;
0684+  C7EA 01 F0 C7    NONE:	LD	BC,NOFILE
0685+  C7ED C3 A7 C4        JP	PLINE
0686+  C7F0 4E 6F 20 66 NOFILE:	.DB	"No file"
0686+  C7F4 69 6C 65 
0687+  C7F7 00              .DB	0
0688+  C7F8             ;
0689+  C7F8             ;   Decode a command of the form 'A>filename number{ filename}.
0690+  C7F8             ; Note that a drive specifier is not allowed on the first file
0691+  C7F8             ; name. On return, the number is in register (A). Any error
0692+  C7F8             ; causes 'filename?' to be printed and the command is aborted.
0693+  C7F8             ;
0694+  C7F8 CD 5E C6    DECODE:	CALL	CONVFST		;convert filename.
0695+  C7FB 3A F0 CB        LD	A,(CHGDRV)	;do not allow a drive to be specified.
0696+  C7FE B7              OR	A
0697+  C7FF C2 09 C6        JP	NZ,SYNERR
0698+  C802 21 CE CB        LD	HL,FCB+1	;convert number now.
0699+  C805 01 0B 00        LD	BC,11		;(B)=sum register, (C)=max digit count.
0700+  C808 7E          DECODE1:LD	A,(HL)
0701+  C809 FE 20           CP	' '		;a space terminates the numeral.
0702+  C80B CA 33 C8        JP	Z,DECODE3
0703+  C80E 23              INC	HL
0704+  C80F D6 30           SUB	'0'		;make binary from ascii.
0705+  C811 FE 0A           CP	10		;legal digit?
0706+  C813 D2 09 C6        JP	NC,SYNERR
0707+  C816 57              LD	D,A		;yes, save it in (D).
0708+  C817 78              LD	A,B		;compute (B)=(B)*10 and check for overflow.
0709+  C818 E6 E0           AND	0E0H
0710+  C81A C2 09 C6        JP	NZ,SYNERR
0711+  C81D 78              LD	A,B
0712+  C81E 07              RLCA
0713+  C81F 07              RLCA
0714+  C820 07              RLCA			;(A)=(B)*8
0715+  C821 80              ADD	B		;.......*9
0716+  C822 DA 09 C6        JP	C,SYNERR
0717+  C825 80              ADD	B		;.......*10
0718+  C826 DA 09 C6        JP	C,SYNERR
0719+  C829 82              ADD	D		;add in new digit now.
0720+  C82A DA 09 C6    DECODE2:JP	C,SYNERR
0721+  C82D 47              LD	B,A		;and save result.
0722+  C82E 0D              DEC	C		;only look at 11 digits.
0723+  C82F C2 08 C8        JP	NZ,DECODE1
0724+  C832 C9              RET
0725+  C833 7E          DECODE3:LD	A,(HL)		;spaces must follow (why?).
0726+  C834 FE 20           CP	' '
0727+  C836 C2 09 C6        JP	NZ,SYNERR
0728+  C839 23              INC	HL
0729+  C83A 0D          DECODE4:DEC	C
0730+  C83B C2 33 C8        JP	NZ,DECODE3
0731+  C83E 78              LD	A,B		;set (A)=the numeric value entered.
0732+  C83F C9              RET
0733+  C840             ;
0734+  C840             ;   Move 3 bytes from (HL) to (DE). Note that there is only
0735+  C840             ; one reference to this at (A2D5h).
0736+  C840             ;
0737+  C840 06 03       MOVE3:	LD	B,3
0738+  C842             ;
0739+  C842             ;   Move (B) bytes from (HL) to (DE).
0740+  C842             ;
0741+  C842 7E          HL2DE:	LD	A,(HL)
0742+  C843 12              LD	(DE),A
0743+  C844 23              INC	HL
0744+  C845 13              INC	DE
0745+  C846 05              DEC	B
0746+  C847 C2 42 C8        JP	NZ,HL2DE
0747+  C84A C9              RET
0748+  C84B             ;
0749+  C84B             ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
0750+  C84B             ;
0751+  C84B 21 80 00    EXTRACT:LD	HL,TBUFF
0752+  C84E 81              ADD	C
0753+  C84F CD 59 C6        CALL	ADDHL
0754+  C852 7E              LD	A,(HL)
0755+  C853 C9              RET
0756+  C854             ;
0757+  C854             ;  Check drive specified. If it means a change, then the new
0758+  C854             ; drive will be selected. In any case, the drive byte of the
0759+  C854             ; fcb will be set to null (means use current drive).
0760+  C854             ;
0761+  C854 AF          DSELECT:XOR	A		;null out first byte of fcb.
0762+  C855 32 CD CB        LD	(FCB),A
0763+  C858 3A F0 CB        LD	A,(CHGDRV)	;a drive change indicated?
0764+  C85B B7              OR	A
0765+  C85C C8              RET	Z
0766+  C85D 3D              DEC	A		;yes, is it the same as the current drive?
0767+  C85E 21 EF CB        LD	HL,CDRIVE
0768+  C861 BE              CP	(HL)
0769+  C862 C8              RET	Z
0770+  C863 C3 BD C4        JP	DSKSEL		;no. Select it then.
0771+  C866             ;
0772+  C866             ;   Check the drive selection and reset it to the previous
0773+  C866             ; drive if it was changed for the preceeding command.
0774+  C866             ;
0775+  C866 3A F0 CB    RESETDR:LD	A,(CHGDRV)	;drive change indicated?
0776+  C869 B7              OR	A
0777+  C86A C8              RET	Z
0778+  C86B 3D              DEC	A		;yes, was it a different drive?
0779+  C86C 21 EF CB        LD	HL,CDRIVE
0780+  C86F BE              CP	(HL)
0781+  C870 C8              RET	Z
0782+  C871 3A EF CB        LD	A,(CDRIVE)	;yes, re-select our old drive.
0783+  C874 C3 BD C4        JP	DSKSEL
0784+  C877             ;
0785+  C877             ;**************************************************************
0786+  C877             ;*
0787+  C877             ;*           D I R E C T O R Y   C O M M A N D
0788+  C877             ;*
0789+  C877             ;**************************************************************
0790+  C877             ;
0791+  C877 CD 5E C6    DIRECT:	CALL	CONVFST		;convert file name.
0792+  C87A CD 54 C8        CALL	DSELECT		;select indicated drive.
0793+  C87D 21 CE CB        LD	HL,FCB+1	;was any file indicated?
0794+  C880 7E              LD	A,(HL)
0795+  C881 FE 20           CP	' '
0796+  C883 C2 8F C8        JP	NZ,DIRECT2
0797+  C886 06 0B           LD	B,11		;no. Fill field with '?' - same as *.*.
0798+  C888 36 3F       DIRECT1:LD	(HL),'?'
0799+  C88A 23              INC	HL
0800+  C88B 05              DEC	B
0801+  C88C C2 88 C8        JP	NZ,DIRECT1
0802+  C88F 1E 00       DIRECT2:LD	E,0		;set initial cursor position.
0803+  C891 D5              PUSH	DE
0804+  C892 CD E9 C4        CALL	SRCHFCB		;get first file name.
0805+  C895 CC EA C7        CALL	Z,NONE		;none found at all?
0806+  C898 CA 1B C9    DIRECT3:JP	Z,DIRECT9	;terminate if no more names.
0807+  C89B 3A EE CB        LD	A,(RTNCODE)	;get file's position in segment (0-3).
0808+  C89E 0F              RRCA
0809+  C89F 0F              RRCA
0810+  C8A0 0F              RRCA
0811+  C8A1 E6 60           AND	60H		;(A)=position*32
0812+  C8A3 4F              LD	C,A
0813+  C8A4 3E 0A           LD	A,10
0814+  C8A6 CD 4B C8        CALL	EXTRACT		;extract the tenth entry in fcb.
0815+  C8A9 17              RLA			;check system file status bit.
0816+  C8AA DA 0F C9        JP	C,DIRECT8	;we don't list them.
0817+  C8AD D1              POP	DE
0818+  C8AE 7B              LD	A,E		;bump name count.
0819+  C8AF 1C              INC	E
0820+  C8B0 D5              PUSH	DE
0821+  C8B1 E6 03           AND	03H		;at end of line?
0822+  C8B3 F5              PUSH	AF
0823+  C8B4 C2 CC C8        JP	NZ,DIRECT4
0824+  C8B7 CD 98 C4        CALL	CRLF		;yes, end this line and start another.
0825+  C8BA C5              PUSH	BC
0826+  C8BB CD D0 C5        CALL	GETDSK		;start line with ('A:').
0827+  C8BE C1              POP	BC
0828+  C8BF C6 41           ADD	'A'
0829+  C8C1 CD 92 C4        CALL	PRINTB
0830+  C8C4 3E 3A           LD	A,':'
0831+  C8C6 CD 92 C4        CALL	PRINTB
0832+  C8C9 C3 D4 C8        JP	DIRECT5
0833+  C8CC CD A2 C4    DIRECT4:CALL	SPACE		;add seperator between file names.
0834+  C8CF 3E 3A           LD	A,':'
0835+  C8D1 CD 92 C4        CALL	PRINTB
0836+  C8D4 CD A2 C4    DIRECT5:CALL	SPACE
0837+  C8D7 06 01           LD	B,1		;'extract' each file name character at a time.
0838+  C8D9 78          DIRECT6:LD	A,B
0839+  C8DA CD 4B C8        CALL	EXTRACT
0840+  C8DD E6 7F           AND	7FH		;strip bit 7 (status bit).
0841+  C8DF FE 20           CP	' '		;are we at the end of the name?
0842+  C8E1 C2 F9 C8        JP	NZ,DRECT65
0843+  C8E4 F1              POP	AF		;yes, don't print spaces at the end of a line.
0844+  C8E5 F5              PUSH	AF
0845+  C8E6 FE 03           CP	3
0846+  C8E8 C2 F7 C8        JP	NZ,DRECT63
0847+  C8EB 3E 09           LD	A,9		;first check for no extension.
0848+  C8ED CD 4B C8        CALL	EXTRACT
0849+  C8F0 E6 7F           AND	7FH
0850+  C8F2 FE 20           CP	' '
0851+  C8F4 CA 0E C9        JP	Z,DIRECT7	;don't print spaces.
0852+  C8F7 3E 20       DRECT63:LD	A,' '		;else print them.
0853+  C8F9 CD 92 C4    DRECT65:CALL	PRINTB
0854+  C8FC 04              INC	B		;bump to next character psoition.
0855+  C8FD 78              LD	A,B
0856+  C8FE FE 0C           CP	12		;end of the name?
0857+  C900 D2 0E C9        JP	NC,DIRECT7
0858+  C903 FE 09           CP	9		;nope, starting extension?
0859+  C905 C2 D9 C8        JP	NZ,DIRECT6
0860+  C908 CD A2 C4        CALL	SPACE		;yes, add seperating space.
0861+  C90B C3 D9 C8        JP	DIRECT6
0862+  C90E F1          DIRECT7:POP	AF		;get the next file name.
0863+  C90F CD C2 C5    DIRECT8:CALL	CHKCON		;first check console, quit on anything.
0864+  C912 C2 1B C9        JP	NZ,DIRECT9
0865+  C915 CD E4 C4        CALL	SRCHNXT		;get next name.
0866+  C918 C3 98 C8        JP	DIRECT3		;and continue with our list.
0867+  C91B D1          DIRECT9:POP	DE		;restore the stack and return to command level.
0868+  C91C C3 86 CB        JP	GETBACK
0869+  C91F             ;
0870+  C91F             ;**************************************************************
0871+  C91F             ;*
0872+  C91F             ;*                E R A S E   C O M M A N D
0873+  C91F             ;*
0874+  C91F             ;**************************************************************
0875+  C91F             ;
0876+  C91F CD 5E C6    ERASE:	CALL	CONVFST		;convert file name.
0877+  C922 FE 0B           CP	11		;was '*.*' entered?
0878+  C924 C2 42 C9        JP	NZ,ERASE1
0879+  C927 01 52 C9        LD	BC,YESNO	;yes, ask for confirmation.
0880+  C92A CD A7 C4        CALL	PLINE
0881+  C92D CD 39 C5        CALL	GETINP
0882+  C930 21 07 C4        LD	HL,INBUFF+1
0883+  C933 35              DEC	(HL)		;must be exactly 'y'.
0884+  C934 C2 82 C7        JP	NZ,CMMND1
0885+  C937 23              INC	HL
0886+  C938 7E              LD	A,(HL)
0887+  C939 FE 59           CP	'Y'
0888+  C93B C2 82 C7        JP	NZ,CMMND1
0889+  C93E 23              INC	HL
0890+  C93F 22 88 C4        LD	(INPOINT),HL	;save input line pointer.
0891+  C942 CD 54 C8    ERASE1:	CALL	DSELECT		;select desired disk.
0892+  C945 11 CD CB        LD	DE,FCB
0893+  C948 CD EF C4        CALL	DELETE		;delete the file.
0894+  C94B 3C              INC	A
0895+  C94C CC EA C7        CALL	Z,NONE		;not there?
0896+  C94F C3 86 CB        JP	GETBACK		;return to command level now.
0897+  C952 41 6C 6C 20 YESNO:	.DB	"All (y/n)?"
0897+  C956 28 79 2F 6E 
0897+  C95A 29 3F 
0898+  C95C 00              .DB	0
0899+  C95D             ;
0900+  C95D             ;**************************************************************
0901+  C95D             ;*
0902+  C95D             ;*            T Y P E   C O M M A N D
0903+  C95D             ;*
0904+  C95D             ;**************************************************************
0905+  C95D             ;
0906+  C95D CD 5E C6    TYPE:	CALL	CONVFST		;convert file name.
0907+  C960 C2 09 C6        JP	NZ,SYNERR	;wild cards not allowed.
0908+  C963 CD 54 C8        CALL	DSELECT		;select indicated drive.
0909+  C966 CD D0 C4        CALL	OPENFCB		;open the file.
0910+  C969 CA A7 C9        JP	Z,TYPE5		;not there?
0911+  C96C CD 98 C4        CALL	CRLF		;ok, start a new line on the screen.
0912+  C96F 21 F1 CB        LD	HL,NBYTES	;initialize byte counter.
0913+  C972 36 FF           LD	(HL),0FFH	;set to read first sector.
0914+  C974 21 F1 CB    TYPE1:	LD	HL,NBYTES
0915+  C977 7E          TYPE2:	LD	A,(HL)		;have we written the entire sector?
0916+  C978 FE 80           CP	128
0917+  C97A DA 87 C9        JP	C,TYPE3
0918+  C97D E5              PUSH	HL		;yes, read in the next one.
0919+  C97E CD FE C4        CALL	READFCB
0920+  C981 E1              POP	HL
0921+  C982 C2 A0 C9        JP	NZ,TYPE4	;end or error?
0922+  C985 AF              XOR	A		;ok, clear byte counter.
0923+  C986 77              LD	(HL),A
0924+  C987 34          TYPE3:	INC	(HL)		;count this byte.
0925+  C988 21 80 00        LD	HL,TBUFF	;and get the (A)th one from the buffer (TBUFF).
0926+  C98B CD 59 C6        CALL	ADDHL
0927+  C98E 7E              LD	A,(HL)
0928+  C98F FE 1A           CP	CNTRLZ		;end of file mark?
0929+  C991 CA 86 CB        JP	Z,GETBACK
0930+  C994 CD 8C C4        CALL	PRINT		;no, print it.
0931+  C997 CD C2 C5        CALL	CHKCON		;check console, quit if anything ready.
0932+  C99A C2 86 CB        JP	NZ,GETBACK
0933+  C99D C3 74 C9        JP	TYPE1
0934+  C9A0             ;
0935+  C9A0             ;   Get here on an end of file or read error.
0936+  C9A0             ;
0937+  C9A0 3D          TYPE4:	DEC	A		;read error?
0938+  C9A1 CA 86 CB        JP	Z,GETBACK
0939+  C9A4 CD D9 C7        CALL	RDERROR		;yes, print message.
0940+  C9A7 CD 66 C8    TYPE5:	CALL	RESETDR		;and reset proper drive
0941+  C9AA C3 09 C6        JP	SYNERR		;now print file name with problem.
0942+  C9AD             ;
0943+  C9AD             ;**************************************************************
0944+  C9AD             ;*
0945+  C9AD             ;*            S A V E   C O M M A N D
0946+  C9AD             ;*
0947+  C9AD             ;**************************************************************
0948+  C9AD             ;
0949+  C9AD CD F8 C7    SAVE:	CALL	DECODE		;get numeric number that follows SAVE.
0950+  C9B0 F5              PUSH	AF		;save number of pages to write.
0951+  C9B1 CD 5E C6        CALL	CONVFST		;convert file name.
0952+  C9B4 C2 09 C6        JP	NZ,SYNERR	;wild cards not allowed.
0953+  C9B7 CD 54 C8        CALL	DSELECT		;select specified drive.
0954+  C9BA 11 CD CB        LD	DE,FCB		;now delete this file.
0955+  C9BD D5              PUSH	DE
0956+  C9BE CD EF C4        CALL	DELETE
0957+  C9C1 D1              POP	DE
0958+  C9C2 CD 09 C5        CALL	CREATE		;and create it again.
0959+  C9C5 CA FB C9        JP	Z,SAVE3		;can't create?
0960+  C9C8 AF              XOR	A		;clear record number byte.
0961+  C9C9 32 ED CB        LD	(FCB+32),A
0962+  C9CC F1              POP	AF		;convert pages to sectors.
0963+  C9CD 6F              LD	L,A
0964+  C9CE 26 00           LD	H,0
0965+  C9D0 29              ADD	HL,HL		;(HL)=number of sectors to write.
0966+  C9D1 11 00 01        LD	DE,TBASE	;and we start from here.
0967+  C9D4 7C          SAVE1:	LD	A,H		;done yet?
0968+  C9D5 B5              OR	L
0969+  C9D6 CA F1 C9        JP	Z,SAVE2
0970+  C9D9 2B              DEC	HL		;nope, count this and compute the start
0971+  C9DA E5              PUSH	HL		;of the next 128 byte sector.
0972+  C9DB 21 80 00        LD	HL,128
0973+  C9DE 19              ADD	HL,DE
0974+  C9DF E5              PUSH	HL		;save it and set the transfer address.
0975+  C9E0 CD D8 C5        CALL	DMASET
0976+  C9E3 11 CD CB        LD	DE,FCB		;write out this sector now.
0977+  C9E6 CD 04 C5        CALL	WRTREC
0978+  C9E9 D1              POP	DE		;reset (DE) to the start of the last sector.
0979+  C9EA E1              POP	HL		;restore sector count.
0980+  C9EB C2 FB C9        JP	NZ,SAVE3	;write error?
0981+  C9EE C3 D4 C9        JP	SAVE1
0982+  C9F1             ;
0983+  C9F1             ;   Get here after writing all of the file.
0984+  C9F1             ;
0985+  C9F1 11 CD CB    SAVE2:	LD	DE,FCB		;now close the file.
0986+  C9F4 CD DA C4        CALL	CLOSE
0987+  C9F7 3C              INC	A		;did it close ok?
0988+  C9F8 C2 01 CA        JP	NZ,SAVE4
0989+  C9FB             ;
0990+  C9FB             ;   Print out error message (no space).
0991+  C9FB             ;
0992+  C9FB 01 07 CA    SAVE3:	LD	BC,NOSPACE
0993+  C9FE CD A7 C4        CALL	PLINE
0994+  CA01 CD D5 C5    SAVE4:	CALL	STDDMA		;reset the standard dma address.
0995+  CA04 C3 86 CB        JP	GETBACK
0996+  CA07 4E 6F 20 73 NOSPACE:.DB	"No space"
0996+  CA0B 70 61 63 65 
0997+  CA0F 00              .DB	0
0998+  CA10             ;
0999+  CA10             ;**************************************************************
1000+  CA10             ;*
1001+  CA10             ;*           R E N A M E   C O M M A N D
1002+  CA10             ;*
1003+  CA10             ;**************************************************************
1004+  CA10             ;
1005+  CA10 CD 5E C6    RENAME:	CALL	CONVFST		;convert first file name.
1006+  CA13 C2 09 C6        JP	NZ,SYNERR	;wild cards not allowed.
1007+  CA16 3A F0 CB        LD	A,(CHGDRV)	;remember any change in drives specified.
1008+  CA19 F5              PUSH	AF
1009+  CA1A CD 54 C8        CALL	DSELECT		;and select this drive.
1010+  CA1D CD E9 C4        CALL	SRCHFCB		;is this file present?
1011+  CA20 C2 79 CA        JP	NZ,RENAME6	;yes, print error message.
1012+  CA23 21 CD CB        LD	HL,FCB		;yes, move this name into second slot.
1013+  CA26 11 DD CB        LD	DE,FCB+16
1014+  CA29 06 10           LD	B,16
1015+  CA2B CD 42 C8        CALL	HL2DE
1016+  CA2E 2A 88 C4        LD	HL,(INPOINT)	;get input pointer.
1017+  CA31 EB              EX	DE,HL
1018+  CA32 CD 4F C6        CALL	NONBLANK	;get next non blank character.
1019+  CA35 FE 3D           CP	'='		;only allow an '=' or '_' seperator.
1020+  CA37 CA 3F CA        JP	Z,RENAME1
1021+  CA3A FE 5F           CP	'_'
1022+  CA3C C2 73 CA        JP	NZ,RENAME5
1023+  CA3F EB          RENAME1:EX	DE,HL
1024+  CA40 23              INC	HL		;ok, skip seperator.
1025+  CA41 22 88 C4        LD	(INPOINT),HL	;save input line pointer.
1026+  CA44 CD 5E C6        CALL	CONVFST		;convert this second file name now.
1027+  CA47 C2 73 CA        JP	NZ,RENAME5	;again, no wild cards.
1028+  CA4A F1              POP	AF		;if a drive was specified, then it
1029+  CA4B 47              LD	B,A		;must be the same as before.
1030+  CA4C 21 F0 CB        LD	HL,CHGDRV
1031+  CA4F 7E              LD	A,(HL)
1032+  CA50 B7              OR	A
1033+  CA51 CA 59 CA        JP	Z,RENAME2
1034+  CA54 B8              CP	B
1035+  CA55 70              LD	(HL),B
1036+  CA56 C2 73 CA        JP	NZ,RENAME5	;they were different, error.
1037+  CA59 70          RENAME2:LD	(HL),B		;	reset as per the first file specification.
1038+  CA5A AF              XOR	A
1039+  CA5B 32 CD CB        LD	(FCB),A		;clear the drive byte of the fcb.
1040+  CA5E CD E9 C4    RENAME3:CALL	SRCHFCB		;and go look for second file.
1041+  CA61 CA 6D CA        JP	Z,RENAME4	;doesn't exist?
1042+  CA64 11 CD CB        LD	DE,FCB
1043+  CA67 CD 0E C5        CALL	RENAM		;ok, rename the file.
1044+  CA6A C3 86 CB        JP	GETBACK
1045+  CA6D             ;
1046+  CA6D             ;   Process rename errors here.
1047+  CA6D             ;
1048+  CA6D CD EA C7    RENAME4:CALL	NONE		;file not there.
1049+  CA70 C3 86 CB        JP	GETBACK
1050+  CA73 CD 66 C8    RENAME5:CALL	RESETDR		;bad command format.
1051+  CA76 C3 09 C6        JP	SYNERR
1052+  CA79 01 82 CA    RENAME6:LD	BC,EXISTS	;destination file already exists.
1053+  CA7C CD A7 C4        CALL	PLINE
1054+  CA7F C3 86 CB        JP	GETBACK
1055+  CA82 46 69 6C 65 EXISTS:	.DB	"File exists"
1055+  CA86 20 65 78 69 
1055+  CA8A 73 74 73 
1056+  CA8D 00              .DB	0
1057+  CA8E             ;
1058+  CA8E             ;**************************************************************
1059+  CA8E             ;*
1060+  CA8E             ;*             U S E R   C O M M A N D
1061+  CA8E             ;*
1062+  CA8E             ;**************************************************************
1063+  CA8E             ;
1064+  CA8E CD F8 C7    USER:	CALL	DECODE		;get numeric value following command.
1065+  CA91 FE 10           CP	16		;legal user number?
1066+  CA93 D2 09 C6        JP	NC,SYNERR
1067+  CA96 5F              LD	E,A		;yes but is there anything else?
1068+  CA97 3A CE CB        LD	A,(FCB+1)
1069+  CA9A FE 20           CP	' '
1070+  CA9C CA 09 C6        JP	Z,SYNERR	;yes, that is not allowed.
1071+  CA9F CD 15 C5        CALL	GETSETUC	;ok, set user code.
1072+  CAA2 C3 89 CB        JP	GETBACK1
1073+  CAA5             ;
1074+  CAA5             ;**************************************************************
1075+  CAA5             ;*
1076+  CAA5             ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
1077+  CAA5             ;*
1078+  CAA5             ;**************************************************************
1079+  CAA5             ;
1080+  CAA5 CD F5 C5    UNKNOWN:CALL	VERIFY		;check for valid system (why?).
1081+  CAA8 3A CE CB        LD	A,(FCB+1)	;anything to execute?
1082+  CAAB FE 20           CP	' '
1083+  CAAD C2 C4 CA        JP	NZ,UNKWN1
1084+  CAB0 3A F0 CB        LD	A,(CHGDRV)	;nope, only a drive change?
1085+  CAB3 B7              OR	A
1086+  CAB4 CA 89 CB        JP	Z,GETBACK1	;neither???
1087+  CAB7 3D              DEC	A
1088+  CAB8 32 EF CB        LD	(CDRIVE),A	;ok, store new drive.
1089+  CABB CD 29 C5        CALL	MOVECD		;set (TDRIVE) also.
1090+  CABE CD BD C4        CALL	DSKSEL		;and select this drive.
1091+  CAC1 C3 89 CB        JP	GETBACK1	;then return.
1092+  CAC4             ;
1093+  CAC4             ;   Here a file name was typed. Prepare to execute it.
1094+  CAC4             ;
1095+  CAC4 11 D6 CB    UNKWN1:	LD	DE,FCB+9	;an extension specified?
1096+  CAC7 1A              LD	A,(DE)
1097+  CAC8 FE 20           CP	' '
1098+  CACA C2 09 C6        JP	NZ,SYNERR	;yes, not allowed.
1099+  CACD D5          UNKWN2:	PUSH	DE
1100+  CACE CD 54 C8        CALL	DSELECT		;select specified drive.
1101+  CAD1 D1              POP	DE
1102+  CAD2 21 83 CB        LD	HL,COMFILE	;set the extension to 'COM'.
1103+  CAD5 CD 40 C8        CALL	MOVE3
1104+  CAD8 CD D0 C4        CALL	OPENFCB		;and open this file.
1105+  CADB CA 6B CB        JP	Z,UNKWN9	;not present?
1106+  CADE             ;
1107+  CADE             ;   Load in the program.
1108+  CADE             ;
1109+  CADE 21 00 01        LD	HL,TBASE	;store the program starting here.
1110+  CAE1 E5          UNKWN3:	PUSH	HL
1111+  CAE2 EB              EX	DE,HL
1112+  CAE3 CD D8 C5        CALL	DMASET		;set transfer address.
1113+  CAE6 11 CD CB        LD	DE,FCB		;and read the next record.
1114+  CAE9 CD F9 C4        CALL	RDREC
1115+  CAEC C2 01 CB        JP	NZ,UNKWN4	;end of file or read error?
1116+  CAEF E1              POP	HL		;nope, bump pointer for next sector.
1117+  CAF0 11 80 00        LD	DE,128
1118+  CAF3 19              ADD	HL,DE
1119+  CAF4 11 00 C4        LD	DE,CBASE	;enough room for the whole file?
1120+  CAF7 7D              LD	A,L
1121+  CAF8 93              SUB	E
1122+  CAF9 7C              LD	A,H
1123+  CAFA 9A              SBC	D
1124+  CAFB D2 71 CB        JP	NC,UNKWN0	;no, it can't fit.
1125+  CAFE C3 E1 CA        JP	UNKWN3
1126+  CB01             ;
1127+  CB01             ;   Get here after finished reading.
1128+  CB01             ;
1129+  CB01 E1          UNKWN4:	POP	HL
1130+  CB02 3D              DEC	A		;normal end of file?
1131+  CB03 C2 71 CB        JP	NZ,UNKWN0
1132+  CB06 CD 66 C8        CALL	RESETDR		;yes, reset previous drive.
1133+  CB09 CD 5E C6        CALL	CONVFST		;convert the first file name that follows
1134+  CB0C 21 F0 CB        LD	HL,CHGDRV	;command name.
1135+  CB0F E5              PUSH	HL
1136+  CB10 7E              LD	A,(HL)		;set drive code in default fcb.
1137+  CB11 32 CD CB        LD	(FCB),A
1138+  CB14 3E 10           LD	A,16		;put second name 16 bytes later.
1139+  CB16 CD 60 C6        CALL	CONVERT		;convert second file name.
1140+  CB19 E1              POP	HL
1141+  CB1A 7E              LD	A,(HL)		;and set the drive for this second file.
1142+  CB1B 32 DD CB        LD	(FCB+16),A
1143+  CB1E AF              XOR	A		;clear record byte in fcb.
1144+  CB1F 32 ED CB        LD	(FCB+32),A
1145+  CB22 11 5C 00        LD	DE,TFCB		;move it into place at(005Ch).
1146+  CB25 21 CD CB        LD	HL,FCB
1147+  CB28 06 21           LD	B,33
1148+  CB2A CD 42 C8        CALL	HL2DE
1149+  CB2D 21 08 C4        LD	HL,INBUFF+2	;now move the remainder of the input
1150+  CB30 7E          UNKWN5:	LD	A,(HL)		;line down to (0080h). Look for a non blank.
1151+  CB31 B7              OR	A		;or a null.
1152+  CB32 CA 3E CB        JP	Z,UNKWN6
1153+  CB35 FE 20           CP	' '
1154+  CB37 CA 3E CB        JP	Z,UNKWN6
1155+  CB3A 23              INC	HL
1156+  CB3B C3 30 CB        JP	UNKWN5
1157+  CB3E             ;
1158+  CB3E             ;   Do the line move now. It ends in a null byte.
1159+  CB3E             ;
1160+  CB3E 06 00       UNKWN6:	LD	B,0		;keep a character count.
1161+  CB40 11 81 00        LD	DE,TBUFF+1	;data gets put here.
1162+  CB43 7E          UNKWN7:	LD	A,(HL)		;move it now.
1163+  CB44 12              LD	(DE),A
1164+  CB45 B7              OR	A
1165+  CB46 CA 4F CB        JP	Z,UNKWN8
1166+  CB49 04              INC	B
1167+  CB4A 23              INC	HL
1168+  CB4B 13              INC	DE
1169+  CB4C C3 43 CB        JP	UNKWN7
1170+  CB4F 78          UNKWN8:	LD	A,B		;now store the character count.
1171+  CB50 32 80 00        LD	(TBUFF),A
1172+  CB53 CD 98 C4        CALL	CRLF		;clean up the screen.
1173+  CB56 CD D5 C5        CALL	STDDMA		;set standard transfer address.
1174+  CB59 CD 1A C5        CALL	SETCDRV		;reset current drive.
1175+  CB5C CD 00 01        CALL	TBASE		;and execute the program.
1176+  CB5F             ;
1177+  CB5F             ;   Transiant programs return here (or reboot).
1178+  CB5F             ;
1179+  CB5F 31 AB CB        LD	SP,BATCH	;set stack first off.
1180+  CB62 CD 29 C5        CALL	MOVECD		;move current drive into place (TDRIVE).
1181+  CB65 CD BD C4        CALL	DSKSEL		;and reselect it.
1182+  CB68 C3 82 C7        JP	CMMND1		;back to comand mode.
1183+  CB6B             ;
1184+  CB6B             ;   Get here if some error occured.
1185+  CB6B             ;
1186+  CB6B CD 66 C8    UNKWN9:	CALL	RESETDR		;inproper format.
1187+  CB6E C3 09 C6        JP	SYNERR
1188+  CB71 01 7A CB    UNKWN0:	LD	BC,BADLOAD	;read error or won't fit.
1189+  CB74 CD A7 C4        CALL	PLINE
1190+  CB77 C3 86 CB        JP	GETBACK
1191+  CB7A 42 61 64 20 BADLOAD:.DB	"Bad load"
1191+  CB7E 6C 6F 61 64 
1192+  CB82 00              .DB	0
1193+  CB83 43 4F 4D    COMFILE:.DB	"COM"		;command file extension.
1194+  CB86             ;
1195+  CB86             ;   Get here to return to command level. We will reset the
1196+  CB86             ; previous active drive and then either return to command
1197+  CB86             ; level directly or print error message and then return.
1198+  CB86             ;
1199+  CB86 CD 66 C8    GETBACK:CALL	RESETDR		;reset previous drive.
1200+  CB89 CD 5E C6    GETBACK1: CALL	CONVFST		;convert first name in (FCB).
1201+  CB8C 3A CE CB        LD	A,(FCB+1)	;if this was just a drive change request,
1202+  CB8F D6 20           SUB	' '		;make sure it was valid.
1203+  CB91 21 F0 CB        LD	HL,CHGDRV
1204+  CB94 B6              OR	(HL)
1205+  CB95 C2 09 C6        JP	NZ,SYNERR
1206+  CB98 C3 82 C7        JP	CMMND1		;ok, return to command level.
1207+  CB9B             ;
1208+  CB9B             ;   ccp stack area.
1209+  CB9B             ;
1210+  CB9B 00 00 00 00     .DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1210+  CB9F 00 00 00 00 
1210+  CBA3 00 00 00 00 
1210+  CBA7 00 00 00 00 
1211+  CBAB             CCPSTACK .EQU	$	;end of ccp stack area.
1212+  CBAB             ;
1213+  CBAB             ;   Batch (or SUBMIT) processing information storage.
1214+  CBAB             ;
1215+  CBAB 00          BATCH:	.DB	0		;batch mode flag (0=not active).
1216+  CBAC 00          BATCHFCB: .DB	0
1217+  CBAD 24 24 24 20     .DB "$$$     SUB"
1217+  CBB1 20 20 20 20 
1217+  CBB5 53 55 42 
1218+  CBB8 00 00 00 00     .DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1218+  CBBC 00 00 00 00 
1218+  CBC0 00 00 00 00 
1218+  CBC4 00 00 00 00 
1218+  CBC8 00 00 00 00 
1218+  CBCC 00 
1219+  CBCD             ;
1220+  CBCD             ;   File control block setup by the CCP.
1221+  CBCD             ;
1222+  CBCD 00          FCB:	.DB	0
1223+  CBCE 20 20 20 20     .DB	"           "
1223+  CBD2 20 20 20 20 
1223+  CBD6 20 20 20 
1224+  CBD9 00 00 00 00     .DB	0,0,0,0,0
1224+  CBDD 00 
1225+  CBDE 20 20 20 20     .DB	"           "
1225+  CBE2 20 20 20 20 
1225+  CBE6 20 20 20 
1226+  CBE9 00 00 00 00     .DB	0,0,0,0,0
1226+  CBED 00 
1227+  CBEE 00          RTNCODE:.DB	0		;status returned from bdos call.
1228+  CBEF 00          CDRIVE:	.DB	0		;currently active drive.
1229+  CBF0 00          CHGDRV:	.DB	0		;change in drives flag (0=no change).
1230+  CBF1 00 00       NBYTES:	.DW	0		;byte counter used by TYPE.
1231+  CBF3             ;
1232+  CBF3             ;   Room for expansion?
1233+  CBF3             ;
1234+  CBF3 00 00 00 00     .DB	0,0,0,0,0,0,0,0,0,0,0,0,0
1234+  CBF7 00 00 00 00 
1234+  CBFB 00 00 00 00 
1234+  CBFF 00 
1235+  CC00             ;
1236+  CC00             ;   Note that the following six bytes must match those at
1237+  CC00             ; (PATTRN1) or cp/m will HALT. Why?
1238+  CC00             ;
1239+  CC00 00 16 00 00 PATTRN2:.DB	0,22,0,0,0,0	;(* serial number bytes *).
1239+  CC04 00 00 
1240+  CC06             ;
1241+  CC06             ;**************************************************************
1242+  CC06             ;*
1243+  CC06             ;*                    B D O S   E N T R Y
1244+  CC06             ;*
1245+  CC06             ;**************************************************************
1246+  CC06             ;
1247+  CC06 C3 11 CC    FBASE:	JP	FBASE1
1248+  CC09             ;
1249+  CC09             ;   Bdos error table.
1250+  CC09             ;
1251+  CC09 99 CC       BADSCTR:.DW	ERROR1		;bad sector on read or write.
1252+  CC0B A5 CC       BADSLCT:.DW	ERROR2		;bad disk select.
1253+  CC0D AB CC       RODISK:	.DW	ERROR3		;disk is read only.
1254+  CC0F B1 CC       ROFILE:	.DW	ERROR4		;file is read only.
1255+  CC11             ;
1256+  CC11             ;   Entry into bdos. (DE) or (E) are the parameters passed. The
1257+  CC11             ; function number desired is in register (C).
1258+  CC11             ;
1259+  CC11 EB          FBASE1:	EX	DE,HL		;save the (DE) parameters.
1260+  CC12 22 43 CF        LD	(PARAMS),HL
1261+  CC15 EB              EX	DE,HL
1262+  CC16 7B              LD	A,E		;and save register (E) in particular.
1263+  CC17 32 D6 D9        LD	(EPARAM),A
1264+  CC1A 21 00 00        LD	HL,0
1265+  CC1D 22 45 CF        LD	(STATUS),HL	;clear return status.
1266+  CC20 39              ADD	HL,SP
1267+  CC21 22 0F CF        LD	(USRSTACK),HL	;save users stack pointer.
1268+  CC24 31 41 CF        LD	SP,STKAREA	;and set our own.
1269+  CC27 AF              XOR	A		;clear auto select storage space.
1270+  CC28 32 E0 D9        LD	(AUTOFLAG),A
1271+  CC2B 32 DE D9        LD	(AUTO),A
1272+  CC2E 21 74 D9        LD	HL,GOBACK	;set return address.
1273+  CC31 E5              PUSH	HL
1274+  CC32 79              LD	A,C		;get function number.
1275+  CC33 FE 29           CP	NFUNCTS		;valid function number?
1276+  CC35 D0              RET	NC
1277+  CC36 4B              LD	C,E		;keep single register function here.
1278+  CC37 21 47 CC        LD	HL,FUNCTNS	;now look thru the function table.
1279+  CC3A 5F              LD	E,A
1280+  CC3B 16 00           LD	D,0		;(DE)=function number.
1281+  CC3D 19              ADD	HL,DE
1282+  CC3E 19              ADD	HL,DE		;(HL)=(start of table)+2*(function number).
1283+  CC3F 5E              LD	E,(HL)
1284+  CC40 23              INC	HL
1285+  CC41 56              LD	D,(HL)		;now (DE)=address for this function.
1286+  CC42 2A 43 CF        LD	HL,(PARAMS)	;retrieve parameters.
1287+  CC45 EB              EX	DE,HL		;now (DE) has the original parameters.
1288+  CC46 E9              JP	(HL)		;execute desired function.
1289+  CC47             ;
1290+  CC47             ;   BDOS function jump table.
1291+  CC47             ;
1292+  CC47             NFUNCTS .EQU	41		;number of functions in followin table.
1293+  CC47             ;
1294+  CC47 03 DA C8 CE FUNCTNS:.DW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
1294+  CC4B 90 CD CE CE 
1294+  CC4F 12 DA 0F DA 
1294+  CC53 D4 CE ED CE 
1295+  CC57 F3 CE F8 CE     .DW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
1295+  CC5B E1 CD FE CE 
1295+  CC5F 7E D8 83 D8 
1295+  CC63 45 D8 9C D8 
1296+  CC67 A5 D8 AB D8     .DW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
1296+  CC6B C8 D8 D7 D8 
1296+  CC6F E0 D8 E6 D8 
1296+  CC73 EC D8 
1297+  CC75 F5 D8 FE D8     .DW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
1297+  CC79 04 D9 0A D9 
1297+  CC7D 11 D9 2C D1 
1297+  CC81 17 D9 1D D9 
1298+  CC85 26 D9 2D D9     .DW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
1298+  CC89 41 D9 47 D9 
1298+  CC8D 4D D9 0E D8 
1298+  CC91 53 D9 04 CF 
1299+  CC95 04 CF 9B D9     .DW	RTN,WTSPECL
1300+  CC99             ;
1301+  CC99             ;   Bdos error message section.
1302+  CC99             ;
1303+  CC99 21 CA CC    ERROR1:	LD	HL,BADSEC	;bad sector message.
1304+  CC9C CD E5 CC        CALL	PRTERR		;print it and get a 1 char responce.
1305+  CC9F FE 03           CP	CNTRLC		;re-boot request (control-c)?
1306+  CCA1 CA 00 00        JP	Z,0		;yes.
1307+  CCA4 C9              RET			;no, return to retry i/o function.
1308+  CCA5             ;
1309+  CCA5 21 D5 CC    ERROR2:	LD	HL,BADSEL	;bad drive selected.
1310+  CCA8 C3 B4 CC        JP	ERROR5
1311+  CCAB             ;
1312+  CCAB 21 E1 CC    ERROR3:	LD	HL,DISKRO	;disk is read only.
1313+  CCAE C3 B4 CC        JP	ERROR5
1314+  CCB1             ;
1315+  CCB1 21 DC CC    ERROR4:	LD	HL,FILERO	;file is read only.
1316+  CCB4             ;
1317+  CCB4 CD E5 CC    ERROR5:	CALL	PRTERR
1318+  CCB7 C3 00 00        JP	0		;always reboot on these errors.
1319+  CCBA             ;
1320+  CCBA 42 64 6F 73 BDOSERR:.DB	"Bdos Err On "
1320+  CCBE 20 45 72 72 
1320+  CCC2 20 4F 6E 20 
1321+  CCC6 20 3A 20 24 BDOSDRV:.DB	" : $"
1322+  CCCA 42 61 64 20 BADSEC:	.DB	"Bad Sector$"
1322+  CCCE 53 65 63 74 
1322+  CCD2 6F 72 24 
1323+  CCD5 53 65 6C 65 BADSEL:	.DB	"Select$"
1323+  CCD9 63 74 24 
1324+  CCDC 46 69 6C 65 FILERO:	.DB	"File "
1324+  CCE0 20 
1325+  CCE1 52 2F 4F 24 DISKRO:	.DB	"R/O$"
1326+  CCE5             ;
1327+  CCE5             ;   Print bdos error message.
1328+  CCE5             ;
1329+  CCE5 E5          PRTERR:	PUSH	HL		;save second message pointer.
1330+  CCE6 CD C9 CD        CALL	OUTCRLF		;send (cr)(lf).
1331+  CCE9 3A 42 CF        LD	A,(ACTIVE)	;get active drive.
1332+  CCEC C6 41           ADD	'A'		;make ascii.
1333+  CCEE 32 C6 CC        LD	(BDOSDRV),A	;and put in message.
1334+  CCF1 01 BA CC        LD	BC,BDOSERR	;and print it.
1335+  CCF4 CD D3 CD        CALL	PRTMESG
1336+  CCF7 C1              POP	BC		;print second message line now.
1337+  CCF8 CD D3 CD        CALL	PRTMESG
1338+  CCFB             ;
1339+  CCFB             ;   Get an input character. We will check our 1 character
1340+  CCFB             ; buffer first. This may be set by the console status routine.
1341+  CCFB             ;
1342+  CCFB 21 0E CF    GETCHAR:LD	HL,CHARBUF	;check character buffer.
1343+  CCFE 7E              LD	A,(HL)		;anything present already?
1344+  CCFF 36 00           LD	(HL),0		;...either case clear it.
1345+  CD01 B7              OR	A
1346+  CD02 C0              RET	NZ		;yes, use it.
1347+  CD03 C3 09 DA        JP	CONIN		;nope, go get a character responce.
1348+  CD06             ;
1349+  CD06             ;   Input and echo a character.
1350+  CD06             ;
1351+  CD06 CD FB CC    GETECHO:CALL	GETCHAR		;input a character.
1352+  CD09 CD 14 CD        CALL	CHKCHAR		;carriage control?
1353+  CD0C D8              RET	C		;no, a regular control char so don't echo.
1354+  CD0D F5              PUSH	AF		;ok, save character now.
1355+  CD0E 4F              LD	C,A
1356+  CD0F CD 90 CD        CALL	OUTCON		;and echo it.
1357+  CD12 F1              POP	AF		;get character and return.
1358+  CD13 C9              RET
1359+  CD14             ;
1360+  CD14             ;   Check character in (A). Set the zero flag on a carriage
1361+  CD14             ; control character and the carry flag on any other control
1362+  CD14             ; character.
1363+  CD14             ;
1364+  CD14 FE 0D       CHKCHAR:CP	CR		;check for carriage return, line feed, backspace,
1365+  CD16 C8              RET	Z		;or a tab.
1366+  CD17 FE 0A           CP	LF
1367+  CD19 C8              RET	Z
1368+  CD1A FE 09           CP	TAB
1369+  CD1C C8              RET	Z
1370+  CD1D FE 08           CP	BS
1371+  CD1F C8              RET	Z
1372+  CD20 FE 20           CP	' '		;other control char? Set carry flag.
1373+  CD22 C9              RET
1374+  CD23             ;
1375+  CD23             ;   Check the console during output. Halt on a control-s, then
1376+  CD23             ; reboot on a control-c. If anything else is ready, clear the
1377+  CD23             ; zero flag and return (the calling routine may want to do
1378+  CD23             ; something).
1379+  CD23             ;
1380+  CD23 3A 0E CF    CKCONSOL: LD	A,(CHARBUF)	;check buffer.
1381+  CD26 B7              OR	A		;if anything, just return without checking.
1382+  CD27 C2 45 CD        JP	NZ,CKCON2
1383+  CD2A CD 06 DA        CALL	CONST		;nothing in buffer. Check console.
1384+  CD2D E6 01           AND	01H		;look at bit 0.
1385+  CD2F C8              RET	Z		;return if nothing.
1386+  CD30 CD 09 DA        CALL	CONIN		;ok, get it.
1387+  CD33 FE 13           CP	CNTRLS		;if not control-s, return with zero cleared.
1388+  CD35 C2 42 CD        JP	NZ,CKCON1
1389+  CD38 CD 09 DA        CALL	CONIN		;halt processing until another char
1390+  CD3B FE 03           CP	CNTRLC		;is typed. Control-c?
1391+  CD3D CA 00 00        JP	Z,0		;yes, reboot now.
1392+  CD40 AF              XOR	A		;no, just pretend nothing was ever ready.
1393+  CD41 C9              RET
1394+  CD42 32 0E CF    CKCON1:	LD	(CHARBUF),A	;save character in buffer for later processing.
1395+  CD45 3E 01       CKCON2:	LD	A,1		;set (A) to non zero to mean something is ready.
1396+  CD47 C9              RET
1397+  CD48             ;
1398+  CD48             ;   Output (C) to the screen. If the printer flip-flop flag
1399+  CD48             ; is set, we will send character to printer also. The console
1400+  CD48             ; will be checked in the process.
1401+  CD48             ;
1402+  CD48 3A 0A CF    OUTCHAR:LD	A,(OUTFLAG)	;check output flag.
1403+  CD4B B7              OR	A		;anything and we won't generate output.
1404+  CD4C C2 62 CD        JP	NZ,OUTCHR1
1405+  CD4F C5              PUSH	BC
1406+  CD50 CD 23 CD        CALL	CKCONSOL	;check console (we don't care whats there).
1407+  CD53 C1              POP	BC
1408+  CD54 C5              PUSH	BC
1409+  CD55 CD 0C DA        CALL	CONOUT		;output (C) to the screen.
1410+  CD58 C1              POP	BC
1411+  CD59 C5              PUSH	BC
1412+  CD5A 3A 0D CF        LD	A,(PRTFLAG)	;check printer flip-flop flag.
1413+  CD5D B7              OR	A
1414+  CD5E C4 0F DA        CALL	NZ,LIST		;print it also if non-zero.
1415+  CD61 C1              POP	BC
1416+  CD62 79          OUTCHR1:LD	A,C		;update cursors position.
1417+  CD63 21 0C CF        LD	HL,CURPOS
1418+  CD66 FE 7F           CP	DEL		;rubouts don't do anything here.
1419+  CD68 C8              RET	Z
1420+  CD69 34              INC	(HL)		;bump line pointer.
1421+  CD6A FE 20           CP	' '		;and return if a normal character.
1422+  CD6C D0              RET	NC
1423+  CD6D 35              DEC	(HL)		;restore and check for the start of the line.
1424+  CD6E 7E              LD	A,(HL)
1425+  CD6F B7              OR	A
1426+  CD70 C8              RET	Z		;ingnore control characters at the start of the line.
1427+  CD71 79              LD	A,C
1428+  CD72 FE 08           CP	BS		;is it a backspace?
1429+  CD74 C2 79 CD        JP	NZ,OUTCHR2
1430+  CD77 35              DEC	(HL)		;yes, backup pointer.
1431+  CD78 C9              RET
1432+  CD79 FE 0A       OUTCHR2:CP	LF		;is it a line feed?
1433+  CD7B C0              RET	NZ		;ignore anything else.
1434+  CD7C 36 00           LD	(HL),0		;reset pointer to start of line.
1435+  CD7E C9              RET
1436+  CD7F             ;
1437+  CD7F             ;   Output (A) to the screen. If it is a control character
1438+  CD7F             ; (other than carriage control), use ^x format.
1439+  CD7F             ;
1440+  CD7F 79          SHOWIT:	LD	A,C
1441+  CD80 CD 14 CD        CALL	CHKCHAR		;check character.
1442+  CD83 D2 90 CD        JP	NC,OUTCON	;not a control, use normal output.
1443+  CD86 F5              PUSH	AF
1444+  CD87 0E 5E           LD	C,'^'		;for a control character, preceed it with '^'.
1445+  CD89 CD 48 CD        CALL	OUTCHAR
1446+  CD8C F1              POP	AF
1447+  CD8D F6 40           OR	'@'		;and then use the letter equivelant.
1448+  CD8F 4F              LD	C,A
1449+  CD90             ;
1450+  CD90             ;   Function to output (C) to the console device and expand tabs
1451+  CD90             ; if necessary.
1452+  CD90             ;
1453+  CD90 79          OUTCON:	LD	A,C
1454+  CD91 FE 09           CP	TAB		;is it a tab?
1455+  CD93 C2 48 CD        JP	NZ,OUTCHAR	;use regular output.
1456+  CD96 0E 20       OUTCON1:LD	C,' '		;yes it is, use spaces instead.
1457+  CD98 CD 48 CD        CALL	OUTCHAR
1458+  CD9B 3A 0C CF        LD	A,(CURPOS)	;go until the cursor is at a multiple of 8
1459+  CD9E             
1460+  CD9E E6 07           AND	07H		;position.
1461+  CDA0 C2 96 CD        JP	NZ,OUTCON1
1462+  CDA3 C9              RET
1463+  CDA4             ;
1464+  CDA4             ;   Echo a backspace character. Erase the prevoius character
1465+  CDA4             ; on the screen.
1466+  CDA4             ;
1467+  CDA4 CD AC CD    BACKUP:	CALL	BACKUP1		;backup the screen 1 place.
1468+  CDA7 0E 20           LD	C,' '		;then blank that character.
1469+  CDA9 CD 0C DA        CALL	CONOUT
1470+  CDAC 0E 08       BACKUP1:LD	C,BS		;then back space once more.
1471+  CDAE C3 0C DA        JP	CONOUT
1472+  CDB1             ;
1473+  CDB1             ;   Signal a deleted line. Print a '#' at the end and start
1474+  CDB1             ; over.
1475+  CDB1             ;
1476+  CDB1 0E 23       NEWLINE:LD	C,'#'
1477+  CDB3 CD 48 CD        CALL	OUTCHAR		;print this.
1478+  CDB6 CD C9 CD        CALL	OUTCRLF		;start new line.
1479+  CDB9 3A 0C CF    NEWLN1:	LD	A,(CURPOS)	;move the cursor to the starting position.
1480+  CDBC 21 0B CF        LD	HL,STARTING
1481+  CDBF BE              CP	(HL)
1482+  CDC0 D0              RET	NC		;there yet?
1483+  CDC1 0E 20           LD	C,' '
1484+  CDC3 CD 48 CD        CALL	OUTCHAR		;nope, keep going.
1485+  CDC6 C3 B9 CD        JP	NEWLN1
1486+  CDC9             ;
1487+  CDC9             ;   Output a (cr) (lf) to the console device (screen).
1488+  CDC9             ;
1489+  CDC9 0E 0D       OUTCRLF:LD	C,CR
1490+  CDCB CD 48 CD        CALL	OUTCHAR
1491+  CDCE 0E 0A           LD	C,LF
1492+  CDD0 C3 48 CD        JP	OUTCHAR
1493+  CDD3             ;
1494+  CDD3             ;   Print message pointed to by (BC). It will end with a '$'.
1495+  CDD3             ;
1496+  CDD3 0A          PRTMESG:LD	A,(BC)		;check for terminating character.
1497+  CDD4 FE 24           CP	'$'
1498+  CDD6 C8              RET	Z
1499+  CDD7 03              INC	BC
1500+  CDD8 C5              PUSH	BC		;otherwise, bump pointer and print it.
1501+  CDD9 4F              LD	C,A
1502+  CDDA CD 90 CD        CALL	OUTCON
1503+  CDDD C1              POP	BC
1504+  CDDE C3 D3 CD        JP	PRTMESG
1505+  CDE1             ;
1506+  CDE1             ;   Function to execute a buffered read.
1507+  CDE1             ;
1508+  CDE1 3A 0C CF    RDBUFF:	LD	A,(CURPOS)	;use present location as starting one.
1509+  CDE4 32 0B CF        LD	(STARTING),A
1510+  CDE7 2A 43 CF        LD	HL,(PARAMS)	;get the maximum buffer space.
1511+  CDEA 4E              LD	C,(HL)
1512+  CDEB 23              INC	HL		;point to first available space.
1513+  CDEC E5              PUSH	HL		;and save.
1514+  CDED 06 00           LD	B,0		;keep a character count.
1515+  CDEF C5          RDBUF1:	PUSH	BC
1516+  CDF0 E5              PUSH	HL
1517+  CDF1 CD FB CC    RDBUF2:	CALL	GETCHAR		;get the next input character.
1518+  CDF4 00              NOP ; AND	7FH		;strip bit 7.
1519+  CDF5 00              NOP ;
1520+  CDF6 E1              POP	HL		;reset registers.
1521+  CDF7 C1              POP	BC
1522+  CDF8 FE 0D           CP	CR		;en of the line?
1523+  CDFA CA C1 CE        JP	Z,RDBUF17
1524+  CDFD FE 0A           CP	LF
1525+  CDFF CA C1 CE        JP	Z,RDBUF17
1526+  CE02 FE 08           CP	BS		;how about a backspace?
1527+  CE04 C2 16 CE        JP	NZ,RDBUF3
1528+  CE07 78              LD	A,B		;yes, but ignore at the beginning of the line.
1529+  CE08 B7              OR	A
1530+  CE09 CA EF CD        JP	Z,RDBUF1
1531+  CE0C 05              DEC	B		;ok, update counter.
1532+  CE0D 3A 0C CF        LD	A,(CURPOS)	;if we backspace to the start of the line,
1533+  CE10 32 0A CF        LD	(OUTFLAG),A	;treat as a cancel (control-x).
1534+  CE13 C3 70 CE        JP	RDBUF10
1535+  CE16 FE 7F       RDBUF3:	CP	DEL		;user typed a rubout?
1536+  CE18 C2 26 CE        JP	NZ,RDBUF4
1537+  CE1B 78              LD	A,B		;ignore at the start of the line.
1538+  CE1C B7              OR	A
1539+  CE1D CA EF CD        JP	Z,RDBUF1
1540+  CE20 7E              LD	A,(HL)		;ok, echo the prevoius character.
1541+  CE21 05              DEC	B		;and reset pointers (counters).
1542+  CE22 2B              DEC	HL
1543+  CE23 C3 A9 CE        JP	RDBUF15
1544+  CE26 FE 05       RDBUF4:	CP	CNTRLE		;physical end of line?
1545+  CE28 C2 37 CE        JP	NZ,RDBUF5
1546+  CE2B C5              PUSH	BC		;yes, do it.
1547+  CE2C E5              PUSH	HL
1548+  CE2D CD C9 CD        CALL	OUTCRLF
1549+  CE30 AF              XOR	A		;and update starting position.
1550+  CE31 32 0B CF        LD	(STARTING),A
1551+  CE34 C3 F1 CD        JP	RDBUF2
1552+  CE37 FE 10       RDBUF5:	CP	CNTRLP		;control-p?
1553+  CE39 C2 48 CE        JP	NZ,RDBUF6
1554+  CE3C E5              PUSH	HL		;yes, flip the print flag filp-flop byte.
1555+  CE3D 21 0D CF        LD	HL,PRTFLAG
1556+  CE40 3E 01           LD	A,1		;PRTFLAG=1-PRTFLAG
1557+  CE42 96              SUB	(HL)
1558+  CE43 77              LD	(HL),A
1559+  CE44 E1              POP	HL
1560+  CE45 C3 EF CD        JP	RDBUF1
1561+  CE48 FE 18       RDBUF6:	CP	CNTRLX		;control-x (cancel)?
1562+  CE4A C2 5F CE        JP	NZ,RDBUF8
1563+  CE4D E1              POP	HL
1564+  CE4E 3A 0B CF    RDBUF7:	LD	A,(STARTING)	;yes, backup the cursor to here.
1565+  CE51 21 0C CF        LD	HL,CURPOS
1566+  CE54 BE              CP	(HL)
1567+  CE55 D2 E1 CD        JP	NC,RDBUFF	;done yet?
1568+  CE58 35              DEC	(HL)		;no, decrement pointer and output back up one space.
1569+  CE59 CD A4 CD        CALL	BACKUP
1570+  CE5C C3 4E CE        JP	RDBUF7
1571+  CE5F FE 15       RDBUF8:	CP	CNTRLU		;cntrol-u (cancel line)?
1572+  CE61 C2 6B CE        JP	NZ,RDBUF9
1573+  CE64 CD B1 CD        CALL	NEWLINE		;start a new line.
1574+  CE67 E1              POP	HL
1575+  CE68 C3 E1 CD        JP	RDBUFF
1576+  CE6B FE 12       RDBUF9:	CP	CNTRLR		;control-r?
1577+  CE6D C2 A6 CE        JP	NZ,RDBUF14
1578+  CE70 C5          RDBUF10:PUSH	BC		;yes, start a new line and retype the old one.
1579+  CE71 CD B1 CD        CALL	NEWLINE
1580+  CE74 C1              POP	BC
1581+  CE75 E1              POP	HL
1582+  CE76 E5              PUSH	HL
1583+  CE77 C5              PUSH	BC
1584+  CE78 78          RDBUF11:LD	A,B		;done whole line yet?
1585+  CE79 B7              OR	A
1586+  CE7A CA 8A CE        JP	Z,RDBUF12
1587+  CE7D 23              INC	HL		;nope, get next character.
1588+  CE7E 4E              LD	C,(HL)
1589+  CE7F 05              DEC	B		;count it.
1590+  CE80 C5              PUSH	BC
1591+  CE81 E5              PUSH	HL
1592+  CE82 CD 7F CD        CALL	SHOWIT		;and display it.
1593+  CE85 E1              POP	HL
1594+  CE86 C1              POP	BC
1595+  CE87 C3 78 CE        JP	RDBUF11
1596+  CE8A E5          RDBUF12:PUSH	HL		;done with line. If we were displaying
1597+  CE8B 3A 0A CF        LD	A,(OUTFLAG)	;then update cursor position.
1598+  CE8E B7              OR	A
1599+  CE8F CA F1 CD        JP	Z,RDBUF2
1600+  CE92 21 0C CF        LD	HL,CURPOS	;because this line is shorter, we must
1601+  CE95 96              SUB	(HL)		;back up the cursor (not the screen however)
1602+  CE96 32 0A CF        LD	(OUTFLAG),A	;some number of positions.
1603+  CE99 CD A4 CD    RDBUF13:CALL	BACKUP		;note that as long as (OUTFLAG) is non
1604+  CE9C 21 0A CF        LD	HL,OUTFLAG	;zero, the screen will not be changed.
1605+  CE9F 35              DEC	(HL)
1606+  CEA0 C2 99 CE        JP	NZ,RDBUF13
1607+  CEA3 C3 F1 CD        JP	RDBUF2		;now just get the next character.
1608+  CEA6             ;
1609+  CEA6             ;   Just a normal character, put this in our buffer and echo.
1610+  CEA6             ;
1611+  CEA6 23          RDBUF14:INC	HL
1612+  CEA7 77              LD	(HL),A		;store character.
1613+  CEA8 04              INC	B		;and count it.
1614+  CEA9 C5          RDBUF15:PUSH	BC
1615+  CEAA E5              PUSH	HL
1616+  CEAB 4F              LD	C,A		;echo it now.
1617+  CEAC CD 7F CD        CALL	SHOWIT
1618+  CEAF E1              POP	HL
1619+  CEB0 C1              POP	BC
1620+  CEB1 7E              LD	A,(HL)		;was it an abort request?
1621+  CEB2 FE 03           CP	CNTRLC		;control-c abort?
1622+  CEB4 78              LD	A,B
1623+  CEB5 C2 BD CE        JP	NZ,RDBUF16
1624+  CEB8 FE 01           CP	1		;only if at start of line.
1625+  CEBA CA 00 00        JP	Z,0
1626+  CEBD B9          RDBUF16:CP	C		;nope, have we filled the buffer?
1627+  CEBE DA EF CD        JP	C,RDBUF1
1628+  CEC1 E1          RDBUF17:POP	HL		;yes end the line and return.
1629+  CEC2 70              LD	(HL),B
1630+  CEC3 0E 0D           LD	C,CR
1631+  CEC5 C3 48 CD        JP	OUTCHAR		;output (cr) and return.
1632+  CEC8             ;
1633+  CEC8             ;   Function to get a character from the console device.
1634+  CEC8             ;
1635+  CEC8 CD 06 CD    GETCON:	CALL	GETECHO		;get and echo.
1636+  CECB C3 01 CF        JP	SETSTAT		;save status and return.
1637+  CECE             ;
1638+  CECE             ;   Function to get a character from the tape reader device.
1639+  CECE             ;
1640+  CECE CD 15 DA    GETRDR:	CALL	READER		;get a character from reader, set status and return.
1641+  CED1 C3 01 CF        JP	SETSTAT
1642+  CED4             ;
1643+  CED4             ;  Function to perform direct console i/o. If (C) contains (FF)
1644+  CED4             ; then this is an input request. If (C) contains (FE) then
1645+  CED4             ; this is a status request. Otherwise we are to output (C).
1646+  CED4             ;
1647+  CED4             
1648+  CED4 79          DIRCIO:	LD	A,C		;test for (FF).
1649+  CED5 3C              INC	A
1650+  CED6 CA E0 CE        JP	Z,DIRC1
1651+  CED9 3C              INC	A		;test for (FE).
1652+  CEDA CA 06 DA        JP	Z,CONST
1653+  CEDD C3 0C DA        JP	CONOUT		;just output (C).
1654+  CEE0 CD 06 DA    DIRC1:	CALL	CONST		;this is an input request.
1655+  CEE3 B7              OR	A
1656+  CEE4 CA 91 D9        JP	Z,GOBACK1	;not ready? Just return (directly).
1657+  CEE7 CD 09 DA        CALL	CONIN		;yes, get character.
1658+  CEEA C3 01 CF        JP	SETSTAT		;set status and return.
1659+  CEED             ;
1660+  CEED             ;   Function to return the i/o byte.
1661+  CEED             ;
1662+  CEED 3A 03 00    GETIOB:	LD	A,(IOBYTE)
1663+  CEF0 C3 01 CF        JP	SETSTAT
1664+  CEF3             ;
1665+  CEF3             ;   Function to set the i/o byte.
1666+  CEF3             ;
1667+  CEF3 21 03 00    SETIOB:	LD	HL,IOBYTE
1668+  CEF6 71              LD	(HL),C
1669+  CEF7 C9              RET
1670+  CEF8             ;
1671+  CEF8             ;   Function to print the character string pointed to by (DE)
1672+  CEF8             ; on the console device. The string ends with a '$'.
1673+  CEF8             ;
1674+  CEF8 EB          PRTSTR:	EX	DE,HL
1675+  CEF9 4D              LD	C,L
1676+  CEFA 44              LD	B,H		;now (BC) points to it.
1677+  CEFB C3 D3 CD        JP	PRTMESG
1678+  CEFE             ;
1679+  CEFE             ;   Function to interigate the console device.
1680+  CEFE             ;
1681+  CEFE CD 23 CD    GETCSTS:CALL	CKCONSOL
1682+  CF01             ;
1683+  CF01             ;   Get here to set the status and return to the cleanup
1684+  CF01             ; section. Then back to the user.
1685+  CF01             ;
1686+  CF01 32 45 CF    SETSTAT:LD	(STATUS),A
1687+  CF04 C9          RTN:	RET
1688+  CF05             ;
1689+  CF05             ;   Set the status to 1 (read or write error code).
1690+  CF05             ;
1691+  CF05 3E 01       IOERR1:	LD	A,1
1692+  CF07 C3 01 CF        JP	SETSTAT
1693+  CF0A             ;
1694+  CF0A 00          OUTFLAG:.DB	0		;output flag (non zero means no output).
1695+  CF0B 02          STARTING: .DB	2		;starting position for cursor.
1696+  CF0C 00          CURPOS:	.DB	0		;cursor position (0=start of line).
1697+  CF0D 00          PRTFLAG:.DB	0		;printer flag (control-p toggle). List if non zero.
1698+  CF0E 00          CHARBUF:.DB	0		;single input character buffer.
1699+  CF0F             ;
1700+  CF0F             ;   Stack area for BDOS calls.
1701+  CF0F             ;
1702+  CF0F 00 00       USRSTACK: .DW	0		;save users stack pointer here.
1703+  CF11             ;
1704+  CF11 00 00 00 00     .DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1704+  CF15 00 00 00 00 
1704+  CF19 00 00 00 00 
1704+  CF1D 00 00 00 00 
1704+  CF21 00 00 00 00 
1704+  CF25 00 00 00 00 
1705+  CF29 00 00 00 00     .DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1705+  CF2D 00 00 00 00 
1705+  CF31 00 00 00 00 
1705+  CF35 00 00 00 00 
1705+  CF39 00 00 00 00 
1705+  CF3D 00 00 00 00 
1706+  CF41             STKAREA .EQU	$		;end of stack area.
1707+  CF41             ;
1708+  CF41 00          USERNO:	.DB	0		;current user number.
1709+  CF42 00          ACTIVE:	.DB	0		;currently active drive.
1710+  CF43 00 00       PARAMS:	.DW	0		;save (DE) parameters here on entry.
1711+  CF45 00 00       STATUS:	.DW	0		;status returned from bdos function.
1712+  CF47             ;
1713+  CF47             ;   Select error occured, jump to error routine.
1714+  CF47             ;
1715+  CF47 21 0B CC    SLCTERR:LD	HL,BADSLCT
1716+  CF4A             ;
1717+  CF4A             ;   Jump to (HL) indirectly.
1718+  CF4A             ;
1719+  CF4A 5E          JUMPHL:	LD	E,(HL)
1720+  CF4B 23              INC	HL
1721+  CF4C 56              LD	D,(HL)		;now (DE) contain the desired address.
1722+  CF4D EB              EX	DE,HL
1723+  CF4E E9              JP	(HL)
1724+  CF4F             ;
1725+  CF4F             ;   Block move. (DE) to (HL), (C) bytes total.
1726+  CF4F             ;
1727+  CF4F 0C          DE2HL:	INC	C		;is count down to zero?
1728+  CF50 0D          DE2HL1:	DEC	C
1729+  CF51 C8              RET	Z		;yes, we are done.
1730+  CF52 1A              LD	A,(DE)		;no, move one more byte.
1731+  CF53 77              LD	(HL),A
1732+  CF54 13              INC	DE
1733+  CF55 23              INC	HL
1734+  CF56 C3 50 CF        JP	DE2HL1		;and repeat.
1735+  CF59             ;
1736+  CF59             ;   Select the desired drive.
1737+  CF59             ;
1738+  CF59 3A 42 CF    SELECT:	LD	A,(ACTIVE)	;get active disk.
1739+  CF5C 4F              LD	C,A
1740+  CF5D CD 1B DA        CALL	SELDSK		;select it.
1741+  CF60 7C              LD	A,H		;valid drive?
1742+  CF61 B5              OR	L		;valid drive?
1743+  CF62 C8              RET	Z		;return if not.
1744+  CF63             ;
1745+  CF63             ;   Here, the BIOS returned the address of the parameter block
1746+  CF63             ; in (HL). We will extract the necessary pointers and save them.
1747+  CF63             ;
1748+  CF63 5E              LD	E,(HL)		;yes, get address of translation table into (DE).
1749+  CF64 23              INC	HL
1750+  CF65 56              LD	D,(HL)
1751+  CF66 23              INC	HL
1752+  CF67 22 B3 D9        LD	(SCRATCH1),HL	;save pointers to scratch areas.
1753+  CF6A 23              INC	HL
1754+  CF6B 23              INC	HL
1755+  CF6C 22 B5 D9        LD	(SCRATCH2),HL	;ditto.
1756+  CF6F 23              INC	HL
1757+  CF70 23              INC	HL
1758+  CF71 22 B7 D9        LD	(SCRATCH3),HL	;ditto.
1759+  CF74 23              INC	HL
1760+  CF75 23              INC	HL
1761+  CF76 EB              EX	DE,HL		;now save the translation table address.
1762+  CF77 22 D0 D9        LD	(XLATE),HL
1763+  CF7A 21 B9 D9        LD	HL,DIRBUF	;put the next 8 bytes here.
1764+  CF7D 0E 08           LD	C,8		;they consist of the directory buffer
1765+  CF7F CD 4F CF        CALL	DE2HL		;pointer, parameter block pointer,
1766+  CF82 2A BB D9        LD	HL,(DISKPB)	;check and allocation vectors.
1767+  CF85 EB              EX	DE,HL
1768+  CF86 21 C1 D9        LD	HL,SECTORS	;move parameter block into our ram.
1769+  CF89 0E 0F           LD	C,15		;it is 15 bytes long.
1770+  CF8B CD 4F CF        CALL	DE2HL
1771+  CF8E 2A C6 D9        LD	HL,(DSKSIZE)	;check disk size.
1772+  CF91 7C              LD	A,H		;more than 256 blocks on this?
1773+  CF92 21 DD D9        LD	HL,BIGDISK
1774+  CF95 36 FF           LD	(HL),0FFH	;set to samll.
1775+  CF97 B7              OR	A
1776+  CF98 CA 9D CF        JP	Z,SELECT1
1777+  CF9B 36 00           LD	(HL),0		;wrong, set to large.
1778+  CF9D 3E FF       SELECT1:LD	A,0FFH		;clear the zero flag.
1779+  CF9F B7              OR	A
1780+  CFA0 C9              RET
1781+  CFA1             ;
1782+  CFA1             ;   Routine to home the disk track head and clear pointers.
1783+  CFA1             ;
1784+  CFA1 CD 18 DA    HOMEDRV:CALL	HOME		;home the head.
1785+  CFA4 AF              XOR	A
1786+  CFA5 2A B5 D9        LD	HL,(SCRATCH2)	;set our track pointer also.
1787+  CFA8 77              LD	(HL),A
1788+  CFA9 23              INC	HL
1789+  CFAA 77              LD	(HL),A
1790+  CFAB 2A B7 D9        LD	HL,(SCRATCH3)	;and our sector pointer.
1791+  CFAE 77              LD	(HL),A
1792+  CFAF 23              INC	HL
1793+  CFB0 77              LD	(HL),A
1794+  CFB1 C9              RET
1795+  CFB2             ;
1796+  CFB2             ;   Do the actual disk read and check the error return status.
1797+  CFB2             ;
1798+  CFB2 CD 27 DA    DOREAD:	CALL	READ
1799+  CFB5 C3 BB CF        JP	IORET
1800+  CFB8             ;
1801+  CFB8             ;   Do the actual disk write and handle any bios error.
1802+  CFB8             ;
1803+  CFB8 CD 2A DA    DOWRITE:CALL	WRITE
1804+  CFBB B7          IORET:	OR	A
1805+  CFBC C8              RET	Z		;return unless an error occured.
1806+  CFBD 21 09 CC        LD	HL,BADSCTR	;bad read/write on this sector.
1807+  CFC0 C3 4A CF        JP	JUMPHL
1808+  CFC3             ;
1809+  CFC3             ;   Routine to select the track and sector that the desired
1810+  CFC3             ; block number falls in.
1811+  CFC3             ;
1812+  CFC3 2A EA D9    TRKSEC:	LD	HL,(FILEPOS)	;get position of last accessed file
1813+  CFC6 0E 02           LD	C,2		;in directory and compute sector #.
1814+  CFC8 CD EA D0        CALL	SHIFTR		;sector #=file-position/4.
1815+  CFCB 22 E5 D9        LD	(BLKNMBR),HL	;save this as the block number of interest.
1816+  CFCE 22 EC D9        LD	(CKSUMTBL),HL	;what's it doing here too?
1817+  CFD1             ;
1818+  CFD1             ;   if the sector number has already been set (BLKNMBR), enter
1819+  CFD1             ; at this point.
1820+  CFD1             ;
1821+  CFD1 21 E5 D9    TRKSEC1:LD	HL,BLKNMBR
1822+  CFD4 4E              LD	C,(HL)		;move sector number into (BC).
1823+  CFD5 23              INC	HL
1824+  CFD6 46              LD	B,(HL)
1825+  CFD7 2A B7 D9        LD	HL,(SCRATCH3)	;get current sector number and
1826+  CFDA 5E              LD	E,(HL)		;move this into (DE).
1827+  CFDB 23              INC	HL
1828+  CFDC 56              LD	D,(HL)
1829+  CFDD 2A B5 D9        LD	HL,(SCRATCH2)	;get current track number.
1830+  CFE0 7E              LD	A,(HL)		;and this into (HL).
1831+  CFE1 23              INC	HL
1832+  CFE2 66              LD	H,(HL)
1833+  CFE3 6F              LD	L,A
1834+  CFE4 79          TRKSEC2:LD	A,C		;is desired sector before current one?
1835+  CFE5 93              SUB	E
1836+  CFE6 78              LD	A,B
1837+  CFE7 9A              SBC	D
1838+  CFE8 D2 FA CF        JP	NC,TRKSEC3
1839+  CFEB E5              PUSH	HL		;yes, decrement sectors by one track.
1840+  CFEC 2A C1 D9        LD	HL,(SECTORS)	;get sectors per track.
1841+  CFEF 7B              LD	A,E
1842+  CFF0 95              SUB	L
1843+  CFF1 5F              LD	E,A
1844+  CFF2 7A              LD	A,D
1845+  CFF3 9C              SBC	H
1846+  CFF4 57              LD	D,A		;now we have backed up one full track.
1847+  CFF5 E1              POP	HL
1848+  CFF6 2B              DEC	HL		;adjust track counter.
1849+  CFF7 C3 E4 CF        JP	TRKSEC2
1850+  CFFA E5          TRKSEC3:PUSH	HL		;desired sector is after current one.
1851+  CFFB 2A C1 D9        LD	HL,(SECTORS)	;get sectors per track.
1852+  CFFE 19              ADD	HL,DE		;bump sector pointer to next track.
1853+  CFFF DA 0F D0        JP	C,TRKSEC4
1854+  D002 79              LD	A,C		;is desired sector now before current one?
1855+  D003 95              SUB	L
1856+  D004 78              LD	A,B
1857+  D005 9C              SBC	H
1858+  D006 DA 0F D0        JP	C,TRKSEC4
1859+  D009 EB              EX	DE,HL		;not yes, increment track counter
1860+  D00A E1              POP	HL		;and continue until it is.
1861+  D00B 23              INC	HL
1862+  D00C C3 FA CF        JP	TRKSEC3
1863+  D00F             ;
1864+  D00F             ;   here we have determined the track number that contains the
1865+  D00F             ; desired sector.
1866+  D00F             ;
1867+  D00F E1          TRKSEC4:POP	HL		;get track number (HL).
1868+  D010 C5              PUSH	BC
1869+  D011 D5              PUSH	DE
1870+  D012 E5              PUSH	HL
1871+  D013 EB              EX	DE,HL
1872+  D014 2A CE D9        LD	HL,(OFFSET)	;adjust for first track offset.
1873+  D017 19              ADD	HL,DE
1874+  D018 44              LD	B,H
1875+  D019 4D              LD	C,L
1876+  D01A CD 1E DA        CALL	SETTRK		;select this track.
1877+  D01D D1              POP	DE		;reset current track pointer.
1878+  D01E 2A B5 D9        LD	HL,(SCRATCH2)
1879+  D021 73              LD	(HL),E
1880+  D022 23              INC	HL
1881+  D023 72              LD	(HL),D
1882+  D024 D1              POP	DE
1883+  D025 2A B7 D9        LD	HL,(SCRATCH3)	;reset the first sector on this track.
1884+  D028 73              LD	(HL),E
1885+  D029 23              INC	HL
1886+  D02A 72              LD	(HL),D
1887+  D02B C1              POP	BC
1888+  D02C 79              LD	A,C		;now subtract the desired one.
1889+  D02D 93              SUB	E		;to make it relative (1-# sectors/track).
1890+  D02E 4F              LD	C,A
1891+  D02F 78              LD	A,B
1892+  D030 9A              SBC	D
1893+  D031 47              LD	B,A
1894+  D032 2A D0 D9        LD	HL,(XLATE)	;translate this sector according to this table.
1895+  D035 EB              EX	DE,HL
1896+  D036 CD 30 DA        CALL	SECTRN		;let the bios translate it.
1897+  D039 4D              LD	C,L
1898+  D03A 44              LD	B,H
1899+  D03B C3 21 DA        JP	SETSEC		;and select it.
1900+  D03E             ;
1901+  D03E             ;   Compute block number from record number (SAVNREC) and
1902+  D03E             ; extent number (SAVEXT).
1903+  D03E             ;
1904+  D03E 21 C3 D9    GETBLOCK: LD	HL,BLKSHFT	;get logical to physical conversion.
1905+  D041 4E              LD	C,(HL)		;note that this is base 2 log of ratio.
1906+  D042 3A E3 D9        LD	A,(SAVNREC)	;get record number.
1907+  D045 B7          GETBLK1:OR	A		;compute (A)=(A)/2^BLKSHFT.
1908+  D046 1F              RRA
1909+  D047 0D              DEC	C
1910+  D048 C2 45 D0        JP	NZ,GETBLK1
1911+  D04B 47              LD	B,A		;save result in (B).
1912+  D04C 3E 08           LD	A,8
1913+  D04E 96              SUB	(HL)
1914+  D04F 4F              LD	C,A		;compute (C)=8-BLKSHFT.
1915+  D050 3A E2 D9        LD	A,(SAVEXT)
1916+  D053 0D          GETBLK2:DEC	C		;compute (A)=SAVEXT*2^(8-BLKSHFT).
1917+  D054 CA 5C D0        JP	Z,GETBLK3
1918+  D057 B7              OR	A
1919+  D058 17              RLA
1920+  D059 C3 53 D0        JP	GETBLK2
1921+  D05C 80          GETBLK3:ADD	B
1922+  D05D C9              RET
1923+  D05E             ;
1924+  D05E             ;   Routine to extract the (BC) block byte from the fcb pointed
1925+  D05E             ; to by (PARAMS). If this is a big-disk, then these are 16 bit
1926+  D05E             ; block numbers, else they are 8 bit numbers.
1927+  D05E             ; Number is returned in (HL).
1928+  D05E             ;
1929+  D05E 2A 43 CF    EXTBLK:	LD	HL,(PARAMS)	;get fcb address.
1930+  D061 11 10 00        LD	DE,16		;block numbers start 16 bytes into fcb.
1931+  D064 19              ADD	HL,DE
1932+  D065 09              ADD	HL,BC
1933+  D066 3A DD D9        LD	A,(BIGDISK)	;are we using a big-disk?
1934+  D069 B7              OR	A
1935+  D06A CA 71 D0        JP	Z,EXTBLK1
1936+  D06D 6E              LD	L,(HL)		;no, extract an 8 bit number from the fcb.
1937+  D06E 26 00           LD	H,0
1938+  D070 C9              RET
1939+  D071 09          EXTBLK1:ADD	HL,BC		;yes, extract a 16 bit number.
1940+  D072 5E              LD	E,(HL)
1941+  D073 23              INC	HL
1942+  D074 56              LD	D,(HL)
1943+  D075 EB              EX	DE,HL		;return in (HL).
1944+  D076 C9              RET
1945+  D077             ;
1946+  D077             ;   Compute block number.
1947+  D077             ;
1948+  D077 CD 3E D0    COMBLK:	CALL	GETBLOCK
1949+  D07A 4F              LD	C,A
1950+  D07B 06 00           LD	B,0
1951+  D07D CD 5E D0        CALL	EXTBLK
1952+  D080 22 E5 D9        LD	(BLKNMBR),HL
1953+  D083 C9              RET
1954+  D084             ;
1955+  D084             ;   Check for a zero block number (unused).
1956+  D084             ;
1957+  D084 2A E5 D9    CHKBLK:	LD	HL,(BLKNMBR)
1958+  D087 7D              LD	A,L		;is it zero?
1959+  D088 B4              OR	H
1960+  D089 C9              RET
1961+  D08A             ;
1962+  D08A             ;   Adjust physical block (BLKNMBR) and convert to logical
1963+  D08A             ; sector (LOGSECT). This is the starting sector of this block.
1964+  D08A             ; The actual sector of interest is then added to this and the
1965+  D08A             ; resulting sector number is stored back in (BLKNMBR). This
1966+  D08A             ; will still have to be adjusted for the track number.
1967+  D08A             ;
1968+  D08A 3A C3 D9    LOGICAL:LD	A,(BLKSHFT)	;get log2(physical/logical sectors).
1969+  D08D 2A E5 D9        LD	HL,(BLKNMBR)	;get physical sector desired.
1970+  D090 29          LOGICL1:ADD	HL,HL		;compute logical sector number.
1971+  D091 3D              DEC	A		;note logical sectors are 128 bytes long.
1972+  D092 C2 90 D0        JP	NZ,LOGICL1
1973+  D095 22 E7 D9        LD	(LOGSECT),HL	;save logical sector.
1974+  D098 3A C4 D9        LD	A,(BLKMASK)	;get block mask.
1975+  D09B 4F              LD	C,A
1976+  D09C 3A E3 D9        LD	A,(SAVNREC)	;get next sector to access.
1977+  D09F A1              AND	C		;extract the relative position within physical block.
1978+  D0A0 B5              OR	L		;and add it too logical sector.
1979+  D0A1 6F              LD	L,A
1980+  D0A2 22 E5 D9        LD	(BLKNMBR),HL	;and store.
1981+  D0A5 C9              RET
1982+  D0A6             ;
1983+  D0A6             ;   Set (HL) to point to extent byte in fcb.
1984+  D0A6             ;
1985+  D0A6 2A 43 CF    SETEXT:	LD	HL,(PARAMS)
1986+  D0A9 11 0C 00        LD	DE,12		;it is the twelth byte.
1987+  D0AC 19              ADD	HL,DE
1988+  D0AD C9              RET
1989+  D0AE             ;
1990+  D0AE             ;   Set (HL) to point to record count byte in fcb and (DE) to
1991+  D0AE             ; next record number byte.
1992+  D0AE             ;
1993+  D0AE 2A 43 CF    SETHLDE:LD	HL,(PARAMS)
1994+  D0B1 11 0F 00        LD	DE,15		;record count byte (#15).
1995+  D0B4 19              ADD	HL,DE
1996+  D0B5 EB              EX	DE,HL
1997+  D0B6 21 11 00        LD	HL,17		;next record number (#32).
1998+  D0B9 19              ADD	HL,DE
1999+  D0BA C9              RET
2000+  D0BB             ;
2001+  D0BB             ;   Save current file data from fcb.
2002+  D0BB             ;
2003+  D0BB CD AE D0    STRDATA:CALL	SETHLDE
2004+  D0BE 7E              LD	A,(HL)		;get and store record count byte.
2005+  D0BF 32 E3 D9        LD	(SAVNREC),A
2006+  D0C2 EB              EX	DE,HL
2007+  D0C3 7E              LD	A,(HL)		;get and store next record number byte.
2008+  D0C4 32 E1 D9        LD	(SAVNXT),A
2009+  D0C7 CD A6 D0        CALL	SETEXT		;point to extent byte.
2010+  D0CA 3A C5 D9        LD	A,(EXTMASK)	;get extent mask.
2011+  D0CD A6              AND	(HL)
2012+  D0CE 32 E2 D9        LD	(SAVEXT),A	;and save extent here.
2013+  D0D1 C9              RET
2014+  D0D2             ;
2015+  D0D2             ;   Set the next record to access. If (MODE) is set to 2, then
2016+  D0D2             ; the last record byte (SAVNREC) has the correct number to access.
2017+  D0D2             ; For sequential access, (MODE) will be equal to 1.
2018+  D0D2             ;
2019+  D0D2 CD AE D0    SETNREC:CALL	SETHLDE
2020+  D0D5 3A D5 D9        LD	A,(MODE)	;get sequential flag (=1).
2021+  D0D8 FE 02           CP	2		;a 2 indicates that no adder is needed.
2022+  D0DA C2 DE D0        JP	NZ,STNREC1
2023+  D0DD AF              XOR	A		;clear adder (random access?).
2024+  D0DE 4F          STNREC1:LD	C,A
2025+  D0DF 3A E3 D9        LD	A,(SAVNREC)	;get last record number.
2026+  D0E2 81              ADD	C		;increment record count.
2027+  D0E3 77              LD	(HL),A		;and set fcb's next record byte.
2028+  D0E4 EB              EX	DE,HL
2029+  D0E5 3A E1 D9        LD	A,(SAVNXT)	;get next record byte from storage.
2030+  D0E8 77              LD	(HL),A		;and put this into fcb as number of records used.
2031+  D0E9 C9              RET
2032+  D0EA             ;
2033+  D0EA             ;   Shift (HL) right (C) bits.
2034+  D0EA             ;
2035+  D0EA 0C          SHIFTR:	INC	C
2036+  D0EB 0D          SHIFTR1:DEC	C
2037+  D0EC C8              RET	Z
2038+  D0ED 7C              LD	A,H
2039+  D0EE B7              OR	A
2040+  D0EF 1F              RRA
2041+  D0F0 67              LD	H,A
2042+  D0F1 7D              LD	A,L
2043+  D0F2 1F              RRA
2044+  D0F3 6F              LD	L,A
2045+  D0F4 C3 EB D0        JP	SHIFTR1
2046+  D0F7             ;
2047+  D0F7             ;   Compute the check-sum for the directory buffer. Return
2048+  D0F7             ; integer sum in (A).
2049+  D0F7             ;
2050+  D0F7 0E 80       CHECKSUM: LD	C,128		;length of buffer.
2051+  D0F9 2A B9 D9        LD	HL,(DIRBUF)	;get its location.
2052+  D0FC AF              XOR	A		;clear summation byte.
2053+  D0FD 86          CHKSUM1:ADD	(HL)		;and compute sum ignoring carries.
2054+  D0FE 23              INC	HL
2055+  D0FF 0D              DEC	C
2056+  D100 C2 FD D0        JP	NZ,CHKSUM1
2057+  D103 C9              RET
2058+  D104             ;
2059+  D104             ;   Shift (HL) left (C) bits.
2060+  D104             ;
2061+  D104 0C          SHIFTL:	INC	C
2062+  D105 0D          SHIFTL1:DEC	C
2063+  D106 C8              RET	Z
2064+  D107 29              ADD	HL,HL		;shift left 1 bit.
2065+  D108 C3 05 D1        JP	SHIFTL1
2066+  D10B             ;
2067+  D10B             ;   Routine to set a bit in a 16 bit value contained in (BC).
2068+  D10B             ; The bit set depends on the current drive selection.
2069+  D10B             ;
2070+  D10B C5          SETBIT:	PUSH	BC		;save 16 bit word.
2071+  D10C 3A 42 CF        LD	A,(ACTIVE)	;get active drive.
2072+  D10F 4F              LD	C,A
2073+  D110 21 01 00        LD	HL,1
2074+  D113 CD 04 D1        CALL	SHIFTL		;shift bit 0 into place.
2075+  D116 C1              POP	BC		;now 'or' this with the original word.
2076+  D117 79              LD	A,C
2077+  D118 B5              OR	L
2078+  D119 6F              LD	L,A		;low byte done, do high byte.
2079+  D11A 78              LD	A,B
2080+  D11B B4              OR	H
2081+  D11C 67              LD	H,A
2082+  D11D C9              RET
2083+  D11E             ;
2084+  D11E             ;   Extract the write protect status bit for the current drive.
2085+  D11E             ; The result is returned in (A), bit 0.
2086+  D11E             ;
2087+  D11E 2A AD D9    GETWPRT:LD	HL,(WRTPRT)	;get status bytes.
2088+  D121 3A 42 CF        LD	A,(ACTIVE)	;which drive is current?
2089+  D124 4F              LD	C,A
2090+  D125 CD EA D0        CALL	SHIFTR		;shift status such that bit 0 is the
2091+  D128 7D              LD	A,L		;one of interest for this drive.
2092+  D129 E6 01           AND	01H		;and isolate it.
2093+  D12B C9              RET
2094+  D12C             ;
2095+  D12C             ;   Function to write protect the current disk.
2096+  D12C             ;
2097+  D12C 21 AD D9    WRTPRTD:LD	HL,WRTPRT	;point to status word.
2098+  D12F 4E              LD	C,(HL)		;set (BC) equal to the status.
2099+  D130 23              INC	HL
2100+  D131 46              LD	B,(HL)
2101+  D132 CD 0B D1        CALL	SETBIT		;and set this bit according to current drive.
2102+  D135 22 AD D9        LD	(WRTPRT),HL	;then save.
2103+  D138 2A C8 D9        LD	HL,(DIRSIZE)	;now save directory size limit.
2104+  D13B 23              INC	HL		;remember the last one.
2105+  D13C EB              EX	DE,HL
2106+  D13D 2A B3 D9        LD	HL,(SCRATCH1)	;and store it here.
2107+  D140 73              LD	(HL),E		;put low byte.
2108+  D141 23              INC	HL
2109+  D142 72              LD	(HL),D		;then high byte.
2110+  D143 C9              RET
2111+  D144             ;
2112+  D144             ;   Check for a read only file.
2113+  D144             ;
2114+  D144 CD 5E D1    CHKROFL:CALL	FCB2HL		;set (HL) to file entry in directory buffer.
2115+  D147 11 09 00    CKROF1:	LD	DE,9		;look at bit 7 of the ninth byte.
2116+  D14A 19              ADD	HL,DE
2117+  D14B 7E              LD	A,(HL)
2118+  D14C 17              RLA
2119+  D14D D0              RET	NC		;return if ok.
2120+  D14E 21 0F CC        LD	HL,ROFILE	;else, print error message and terminate.
2121+  D151 C3 4A CF        JP	JUMPHL
2122+  D154             ;
2123+  D154             ;   Check the write protect status of the active disk.
2124+  D154             ;
2125+  D154 CD 1E D1    CHKWPRT:CALL	GETWPRT
2126+  D157 C8              RET	Z		;return if ok.
2127+  D158 21 0D CC        LD	HL,RODISK	;else print message and terminate.
2128+  D15B C3 4A CF        JP	JUMPHL
2129+  D15E             ;
2130+  D15E             ;   Routine to set (HL) pointing to the proper entry in the
2131+  D15E             ; directory buffer.
2132+  D15E             ;
2133+  D15E 2A B9 D9    FCB2HL:	LD	HL,(DIRBUF)	;get address of buffer.
2134+  D161 3A E9 D9        LD	A,(FCBPOS)	;relative position of file.
2135+  D164             ;
2136+  D164             ;   Routine to add (A) to (HL).
2137+  D164             ;
2138+  D164 85          ADDA2HL:ADD	L
2139+  D165 6F              LD	L,A
2140+  D166 D0              RET	NC
2141+  D167 24              INC	H		;take care of any carry.
2142+  D168 C9              RET
2143+  D169             ;
2144+  D169             ;   Routine to get the 's2' byte from the fcb supplied in
2145+  D169             ; the initial parameter specification.
2146+  D169             ;
2147+  D169 2A 43 CF    GETS2:	LD	HL,(PARAMS)	;get address of fcb.
2148+  D16C 11 0E 00        LD	DE,14		;relative position of 's2'.
2149+  D16F 19              ADD	HL,DE
2150+  D170 7E              LD	A,(HL)		;extract this byte.
2151+  D171 C9              RET
2152+  D172             ;
2153+  D172             ;   Clear the 's2' byte in the fcb.
2154+  D172             ;
2155+  D172 CD 69 D1    CLEARS2:CALL	GETS2		;this sets (HL) pointing to it.
2156+  D175 36 00           LD	(HL),0		;now clear it.
2157+  D177 C9              RET
2158+  D178             ;
2159+  D178             ;   Set bit 7 in the 's2' byte of the fcb.
2160+  D178             ;
2161+  D178 CD 69 D1    SETS2B7:CALL	GETS2		;get the byte.
2162+  D17B F6 80           OR	80H		;and set bit 7.
2163+  D17D 77              LD	(HL),A		;then store.
2164+  D17E C9              RET
2165+  D17F             ;
2166+  D17F             ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
2167+  D17F             ; the difference. This checks to see if there are more file
2168+  D17F             ; names in the directory. We are at (FILEPOS) and there are
2169+  D17F             ; (SCRATCH1) of them to check.
2170+  D17F             ;
2171+  D17F 2A EA D9    MOREFLS:LD	HL,(FILEPOS)	;we are here.
2172+  D182 EB              EX	DE,HL
2173+  D183 2A B3 D9        LD	HL,(SCRATCH1)	;and don't go past here.
2174+  D186 7B              LD	A,E		;compute difference but don't keep.
2175+  D187 96              SUB	(HL)
2176+  D188 23              INC	HL
2177+  D189 7A              LD	A,D
2178+  D18A 9E              SBC	(HL)		;set carry if no more names.
2179+  D18B C9              RET
2180+  D18C             ;
2181+  D18C             ;   Call this routine to prevent (SCRATCH1) from being greater
2182+  D18C             ; than (FILEPOS).
2183+  D18C             ;
2184+  D18C CD 7F D1    CHKNMBR:CALL	MOREFLS		;SCRATCH1 too big?
2185+  D18F D8              RET	C
2186+  D190 13              INC	DE		;yes, reset it to (FILEPOS).
2187+  D191 72              LD	(HL),D
2188+  D192 2B              DEC	HL
2189+  D193 73              LD	(HL),E
2190+  D194 C9              RET
2191+  D195             ;
2192+  D195             ;   Compute (HL)=(DE)-(HL)
2193+  D195             ;
2194+  D195 7B          SUBHL:	LD	A,E		;compute difference.
2195+  D196 95              SUB	L
2196+  D197 6F              LD	L,A		;store low byte.
2197+  D198 7A              LD	A,D
2198+  D199 9C              SBC	H
2199+  D19A 67              LD	H,A		;and then high byte.
2200+  D19B C9              RET
2201+  D19C             ;
2202+  D19C             ;   Set the directory checksum byte.
2203+  D19C             ;
2204+  D19C 0E FF       SETDIR:	LD	C,0FFH
2205+  D19E             ;
2206+  D19E             ;   Routine to set or compare the directory checksum byte. If
2207+  D19E             ; (C)=0ffh, then this will set the checksum byte. Else the byte
2208+  D19E             ; will be checked. If the check fails (the disk has been changed),
2209+  D19E             ; then this disk will be write protected.
2210+  D19E             ;
2211+  D19E 2A EC D9    CHECKDIR: LD	HL,(CKSUMTBL)
2212+  D1A1 EB              EX	DE,HL
2213+  D1A2 2A CC D9        LD	HL,(ALLOC1)
2214+  D1A5 CD 95 D1        CALL	SUBHL
2215+  D1A8 D0              RET	NC		;ok if (CKSUMTBL) > (ALLOC1), so return.
2216+  D1A9 C5              PUSH	BC
2217+  D1AA CD F7 D0        CALL	CHECKSUM	;else compute checksum.
2218+  D1AD 2A BD D9        LD	HL,(CHKVECT)	;get address of checksum table.
2219+  D1B0 EB              EX	DE,HL
2220+  D1B1 2A EC D9        LD	HL,(CKSUMTBL)
2221+  D1B4 19              ADD	HL,DE		;set (HL) to point to byte for this drive.
2222+  D1B5 C1              POP	BC
2223+  D1B6 0C              INC	C		;set or check ?
2224+  D1B7 CA C4 D1        JP	Z,CHKDIR1
2225+  D1BA BE              CP	(HL)		;check them.
2226+  D1BB C8              RET	Z		;return if they are the same.
2227+  D1BC CD 7F D1        CALL	MOREFLS		;not the same, do we care?
2228+  D1BF D0              RET	NC
2229+  D1C0 CD 2C D1        CALL	WRTPRTD		;yes, mark this as write protected.
2230+  D1C3 C9              RET
2231+  D1C4 77          CHKDIR1:LD	(HL),A		;just set the byte.
2232+  D1C5 C9              RET
2233+  D1C6             ;
2234+  D1C6             ;   Do a write to the directory of the current disk.
2235+  D1C6             ;
2236+  D1C6 CD 9C D1    DIRWRITE: CALL	SETDIR		;set checksum byte.
2237+  D1C9 CD E0 D1        CALL	DIRDMA		;set directory dma address.
2238+  D1CC 0E 01           LD	C,1		;tell the bios to actually write.
2239+  D1CE CD B8 CF        CALL	DOWRITE		;then do the write.
2240+  D1D1 C3 DA D1        JP	DEFDMA
2241+  D1D4             ;
2242+  D1D4             ;   Read from the directory.
2243+  D1D4             ;
2244+  D1D4 CD E0 D1    DIRREAD:CALL	DIRDMA		;set the directory dma address.
2245+  D1D7 CD B2 CF        CALL	DOREAD		;and read it.
2246+  D1DA             ;
2247+  D1DA             ;   Routine to set the dma address to the users choice.
2248+  D1DA             ;
2249+  D1DA 21 B1 D9    DEFDMA:	LD	HL,USERDMA	;reset the default dma address and return.
2250+  D1DD C3 E3 D1        JP	DIRDMA1
2251+  D1E0             ;
2252+  D1E0             ;   Routine to set the dma address for directory work.
2253+  D1E0             ;
2254+  D1E0 21 B9 D9    DIRDMA:	LD	HL,DIRBUF
2255+  D1E3             ;
2256+  D1E3             ;   Set the dma address. On entry, (HL) points to
2257+  D1E3             ; word containing the desired dma address.
2258+  D1E3             ;
2259+  D1E3 4E          DIRDMA1:LD	C,(HL)
2260+  D1E4 23              INC	HL
2261+  D1E5 46              LD	B,(HL)		;setup (BC) and go to the bios to set it.
2262+  D1E6 C3 24 DA        JP	SETDMA
2263+  D1E9             ;
2264+  D1E9             ;   Move the directory buffer into user's dma space.
2265+  D1E9             ;
2266+  D1E9 2A B9 D9    MOVEDIR:LD	HL,(DIRBUF)	;buffer is located here, and
2267+  D1EC EB              EX	DE,HL
2268+  D1ED 2A B1 D9        LD	HL,(USERDMA)	; put it here.
2269+  D1F0 0E 80           LD	C,128		;this is its length.
2270+  D1F2 C3 4F CF        JP	DE2HL		;move it now and return.
2271+  D1F5             ;
2272+  D1F5             ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
2273+  D1F5             ;
2274+  D1F5 21 EA D9    CKFILPOS: LD	HL,FILEPOS
2275+  D1F8 7E              LD	A,(HL)
2276+  D1F9 23              INC	HL
2277+  D1FA BE              CP	(HL)		;are both bytes the same?
2278+  D1FB C0              RET	NZ
2279+  D1FC 3C              INC	A		;yes, but are they each 0ffh?
2280+  D1FD C9              RET
2281+  D1FE             ;
2282+  D1FE             ;   Set location (FILEPOS) to 0ffffh.
2283+  D1FE             ;
2284+  D1FE 21 FF FF    STFILPOS: LD	HL,0FFFFH
2285+  D201 22 EA D9        LD	(FILEPOS),HL
2286+  D204 C9              RET
2287+  D205             ;
2288+  D205             ;   Move on to the next file position within the current
2289+  D205             ; directory buffer. If no more exist, set pointer to 0ffffh
2290+  D205             ; and the calling routine will check for this. Enter with (C)
2291+  D205             ; equal to 0ffh to cause the checksum byte to be set, else we
2292+  D205             ; will check this disk and set write protect if checksums are
2293+  D205             ; not the same (applies only if another directory sector must
2294+  D205             ; be read).
2295+  D205             ;
2296+  D205 2A C8 D9    NXENTRY:LD	HL,(DIRSIZE)	;get directory entry size limit.
2297+  D208 EB              EX	DE,HL
2298+  D209 2A EA D9        LD	HL,(FILEPOS)	;get current count.
2299+  D20C 23              INC	HL		;go on to the next one.
2300+  D20D 22 EA D9        LD	(FILEPOS),HL
2301+  D210 CD 95 D1        CALL	SUBHL		;(HL)=(DIRSIZE)-(FILEPOS)
2302+  D213 D2 19 D2        JP	NC,NXENT1	;is there more room left?
2303+  D216 C3 FE D1        JP	STFILPOS	;no. Set this flag and return.
2304+  D219 3A EA D9    NXENT1:	LD	A,(FILEPOS)	;get file position within directory.
2305+  D21C E6 03           AND	03H		;only look within this sector (only 4 entries fit).
2306+  D21E 06 05           LD	B,5		;convert to relative position (32 bytes each).
2307+  D220 87          NXENT2:	ADD	A		;note that this is not efficient code.
2308+  D221 05              DEC	B		;5 'ADD A's would be better.
2309+  D222 C2 20 D2        JP	NZ,NXENT2
2310+  D225 32 E9 D9        LD	(FCBPOS),A	;save it as position of fcb.
2311+  D228 B7              OR	A
2312+  D229 C0              RET	NZ		;return if we are within buffer.
2313+  D22A C5              PUSH	BC
2314+  D22B CD C3 CF        CALL	TRKSEC		;we need the next directory sector.
2315+  D22E CD D4 D1        CALL	DIRREAD
2316+  D231 C1              POP	BC
2317+  D232 C3 9E D1        JP	CHECKDIR
2318+  D235             ;
2319+  D235             ;   Routine to to get a bit from the disk space allocation
2320+  D235             ; map. It is returned in (A), bit position 0. On entry to here,
2321+  D235             ; set (BC) to the block number on the disk to check.
2322+  D235             ; On return, (D) will contain the original bit position for
2323+  D235             ; this block number and (HL) will point to the address for it.
2324+  D235             ;
2325+  D235 79          CKBITMAP: LD	A,C		;determine bit number of interest.
2326+  D236 E6 07           AND	07H		;compute (D)=(E)=(C and 7)+1.
2327+  D238 3C              INC	A
2328+  D239 5F              LD	E,A		;save particular bit number.
2329+  D23A 57              LD	D,A
2330+  D23B             ;
2331+  D23B             ;   compute (BC)=(BC)/8.
2332+  D23B             ;
2333+  D23B 79              LD	A,C
2334+  D23C 0F              RRCA			;now shift right 3 bits.
2335+  D23D 0F              RRCA
2336+  D23E 0F              RRCA
2337+  D23F E6 1F           AND	1FH		;and clear bits 7,6,5.
2338+  D241 4F              LD	C,A
2339+  D242 78              LD	A,B
2340+  D243 87              ADD	A		;now shift (B) into bits 7,6,5.
2341+  D244 87              ADD	A
2342+  D245 87              ADD	A
2343+  D246 87              ADD	A
2344+  D247 87              ADD	A
2345+  D248 B1              OR	C		;and add in (C).
2346+  D249 4F              LD	C,A		;ok, (C) ha been completed.
2347+  D24A 78              LD	A,B		;is there a better way of doing this?
2348+  D24B 0F              RRCA
2349+  D24C 0F              RRCA
2350+  D24D 0F              RRCA
2351+  D24E E6 1F           AND	1FH
2352+  D250 47              LD	B,A		;and now (B) is completed.
2353+  D251             ;
2354+  D251             ;   use this as an offset into the disk space allocation
2355+  D251             ; table.
2356+  D251             ;
2357+  D251 2A BF D9        LD	HL,(ALOCVECT)
2358+  D254 09              ADD	HL,BC
2359+  D255 7E              LD	A,(HL)		;now get correct byte.
2360+  D256 07          CKBMAP1:RLCA			;get correct bit into position 0.
2361+  D257 1D              DEC	E
2362+  D258 C2 56 D2        JP	NZ,CKBMAP1
2363+  D25B C9              RET
2364+  D25C             ;
2365+  D25C             ;   Set or clear the bit map such that block number (BC) will be marked
2366+  D25C             ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
2367+  D25C             ; 1 then it will be set (don't use anyother values).
2368+  D25C             ;
2369+  D25C D5          STBITMAP: PUSH	DE
2370+  D25D CD 35 D2        CALL	CKBITMAP	;get the byte of interest.
2371+  D260 E6 FE           AND	0FEH		;clear the affected bit.
2372+  D262 C1              POP	BC
2373+  D263 B1              OR	C		;and now set it acording to (C).
2374+  D264             ;
2375+  D264             ;  entry to restore the original bit position and then store
2376+  D264             ; in table. (A) contains the value, (D) contains the bit
2377+  D264             ; position (1-8), and (HL) points to the address within the
2378+  D264             ; space allocation table for this byte.
2379+  D264             ;
2380+  D264 0F          STBMAP1:RRCA			;restore original bit position.
2381+  D265 15              DEC	D
2382+  D266 C2 64 D2        JP	NZ,STBMAP1
2383+  D269 77              LD	(HL),A		;and stor byte in table.
2384+  D26A C9              RET
2385+  D26B             ;
2386+  D26B             ;   Set/clear space used bits in allocation map for this file.
2387+  D26B             ; On entry, (C)=1 to set the map and (C)=0 to clear it.
2388+  D26B             ;
2389+  D26B CD 5E D1    SETFILE:CALL	FCB2HL		;get address of fcb
2390+  D26E 11 10 00        LD	DE,16
2391+  D271 19              ADD	HL,DE		;get to block number bytes.
2392+  D272 C5              PUSH	BC
2393+  D273 0E 11           LD	C,17		;check all 17 bytes (max) of table.
2394+  D275 D1          SETFL1:	POP	DE
2395+  D276 0D              DEC	C		;done all bytes yet?
2396+  D277 C8              RET	Z
2397+  D278 D5              PUSH	DE
2398+  D279 3A DD D9        LD	A,(BIGDISK)	;check disk size for 16 bit block numbers.
2399+  D27C B7              OR	A
2400+  D27D CA 88 D2        JP	Z,SETFL2
2401+  D280 C5              PUSH	BC		;only 8 bit numbers. set (BC) to this one.
2402+  D281 E5              PUSH	HL
2403+  D282 4E              LD	C,(HL)		;get low byte from table, always
2404+  D283 06 00           LD	B,0		;set high byte to zero.
2405+  D285 C3 8E D2        JP	SETFL3
2406+  D288 0D          SETFL2:	DEC	C		;for 16 bit block numbers, adjust counter.
2407+  D289 C5              PUSH	BC
2408+  D28A 4E              LD	C,(HL)		;now get both the low and high bytes.
2409+  D28B 23              INC	HL
2410+  D28C 46              LD	B,(HL)
2411+  D28D E5              PUSH	HL
2412+  D28E 79          SETFL3:	LD	A,C		;block used?
2413+  D28F B0              OR	B
2414+  D290 CA 9D D2        JP	Z,SETFL4
2415+  D293 2A C6 D9        LD	HL,(DSKSIZE)	;is this block number within the
2416+  D296 7D              LD	A,L		;space on the disk?
2417+  D297 91              SUB	C
2418+  D298 7C              LD	A,H
2419+  D299 98              SBC	B
2420+  D29A D4 5C D2        CALL	NC,STBITMAP	;yes, set the proper bit.
2421+  D29D E1          SETFL4:	POP	HL		;point to next block number in fcb.
2422+  D29E 23              INC	HL
2423+  D29F C1              POP	BC
2424+  D2A0 C3 75 D2        JP	SETFL1
2425+  D2A3             ;
2426+  D2A3             ;   Construct the space used allocation bit map for the active
2427+  D2A3             ; drive. If a file name starts with '$' and it is under the
2428+  D2A3             ; current user number, then (STATUS) is set to minus 1. Otherwise
2429+  D2A3             ; it is not set at all.
2430+  D2A3             ;
2431+  D2A3 2A C6 D9    BITMAP:	LD	HL,(DSKSIZE)	;compute size of allocation table.
2432+  D2A6 0E 03           LD	C,3
2433+  D2A8 CD EA D0        CALL	SHIFTR		;(HL)=(HL)/8.
2434+  D2AB 23              INC	HL		;at lease 1 byte.
2435+  D2AC 44              LD	B,H
2436+  D2AD 4D              LD	C,L		;set (BC) to the allocation table length.
2437+  D2AE             ;
2438+  D2AE             ;   Initialize the bitmap for this drive. Right now, the first
2439+  D2AE             ; two bytes are specified by the disk parameter block. However
2440+  D2AE             ; a patch could be entered here if it were necessary to setup
2441+  D2AE             ; this table in a special mannor. For example, the bios could
2442+  D2AE             ; determine locations of 'bad blocks' and set them as already
2443+  D2AE             ; 'used' in the map.
2444+  D2AE             ;
2445+  D2AE 2A BF D9        LD	HL,(ALOCVECT)	;now zero out the table now.
2446+  D2B1 36 00       BITMAP1:LD	(HL),0
2447+  D2B3 23              INC	HL
2448+  D2B4 0B              DEC	BC
2449+  D2B5 78              LD	A,B
2450+  D2B6 B1              OR	C
2451+  D2B7 C2 B1 D2        JP	NZ,BITMAP1
2452+  D2BA 2A CA D9        LD	HL,(ALLOC0)	;get initial space used by directory.
2453+  D2BD EB              EX	DE,HL
2454+  D2BE 2A BF D9        LD	HL,(ALOCVECT)	;and put this into map.
2455+  D2C1 73              LD	(HL),E
2456+  D2C2 23              INC	HL
2457+  D2C3 72              LD	(HL),D
2458+  D2C4             ;
2459+  D2C4             ;   End of initialization portion.
2460+  D2C4             ;
2461+  D2C4 CD A1 CF        CALL	HOMEDRV		;now home the drive.
2462+  D2C7 2A B3 D9        LD	HL,(SCRATCH1)
2463+  D2CA 36 03           LD	(HL),3		;force next directory request to read
2464+  D2CC 23              INC	HL		;in a sector.
2465+  D2CD 36 00           LD	(HL),0
2466+  D2CF CD FE D1        CALL	STFILPOS	;clear initial file position also.
2467+  D2D2 0E FF       BITMAP2:LD	C,0FFH		;read next file name in directory
2468+  D2D4 CD 05 D2        CALL	NXENTRY		;and set checksum byte.
2469+  D2D7 CD F5 D1        CALL	CKFILPOS	;is there another file?
2470+  D2DA C8              RET	Z
2471+  D2DB CD 5E D1        CALL	FCB2HL		;yes, get its address.
2472+  D2DE 3E E5           LD	A,0E5H
2473+  D2E0 BE              CP	(HL)		;empty file entry?
2474+  D2E1 CA D2 D2        JP	Z,BITMAP2
2475+  D2E4 3A 41 CF        LD	A,(USERNO)	;no, correct user number?
2476+  D2E7 BE              CP	(HL)
2477+  D2E8 C2 F6 D2        JP	NZ,BITMAP3
2478+  D2EB 23              INC	HL
2479+  D2EC 7E              LD	A,(HL)		;yes, does name start with a '$'?
2480+  D2ED D6 24           SUB	'$'
2481+  D2EF C2 F6 D2        JP	NZ,BITMAP3
2482+  D2F2 3D              DEC	A		;yes, set atatus to minus one.
2483+  D2F3 32 45 CF        LD	(STATUS),A
2484+  D2F6 0E 01       BITMAP3:LD	C,1		;now set this file's space as used in bit map.
2485+  D2F8 CD 6B D2        CALL	SETFILE
2486+  D2FB CD 8C D1        CALL	CHKNMBR		;keep (SCRATCH1) in bounds.
2487+  D2FE C3 D2 D2        JP	BITMAP2
2488+  D301             ;
2489+  D301             ;   Set the status (STATUS) and return.
2490+  D301             ;
2491+  D301 3A D4 D9    STSTATUS: LD	A,(FNDSTAT)
2492+  D304 C3 01 CF        JP	SETSTAT
2493+  D307             ;
2494+  D307             ;   Check extents in (A) and (C). Set the zero flag if they
2495+  D307             ; are the same. The number of 16k chunks of disk space that
2496+  D307             ; the directory extent covers is expressad is (EXTMASK+1).
2497+  D307             ; No registers are modified.
2498+  D307             ;
2499+  D307 C5          SAMEXT:	PUSH	BC
2500+  D308 F5              PUSH	AF
2501+  D309 3A C5 D9        LD	A,(EXTMASK)	;get extent mask and use it to
2502+  D30C 2F              CPL			;to compare both extent numbers.
2503+  D30D 47              LD	B,A		;save resulting mask here.
2504+  D30E 79              LD	A,C		;mask first extent and save in (C).
2505+  D30F A0              AND	B
2506+  D310 4F              LD	C,A
2507+  D311 F1              POP	AF		;now mask second extent and compare
2508+  D312 A0              AND	B		;with the first one.
2509+  D313 91              SUB	C
2510+  D314 E6 1F           AND	1FH		;(* only check buts 0-4 *)
2511+  D316 C1              POP	BC		;the zero flag is set if they are the same.
2512+  D317 C9              RET			;restore (BC) and return.
2513+  D318             ;
2514+  D318             ;   Search for the first occurence of a file name. On entry,
2515+  D318             ; register (C) should contain the number of bytes of the fcb
2516+  D318             ; that must match.
2517+  D318             ;
2518+  D318 3E FF       FINDFST:LD	A,0FFH
2519+  D31A 32 D4 D9        LD	(FNDSTAT),A
2520+  D31D 21 D8 D9        LD	HL,COUNTER	;save character count.
2521+  D320 71              LD	(HL),C
2522+  D321 2A 43 CF        LD	HL,(PARAMS)	;get filename to match.
2523+  D324 22 D9 D9        LD	(SAVEFCB),HL	;and save.
2524+  D327 CD FE D1        CALL	STFILPOS	;clear initial file position (set to 0ffffh).
2525+  D32A CD A1 CF        CALL	HOMEDRV		;home the drive.
2526+  D32D             ;
2527+  D32D             ;   Entry to locate the next occurence of a filename within the
2528+  D32D             ; directory. The disk is not expected to have been changed. If
2529+  D32D             ; it was, then it will be write protected.
2530+  D32D             ;
2531+  D32D 0E 00       FINDNXT:LD	C,0		;write protect the disk if changed.
2532+  D32F CD 05 D2        CALL	NXENTRY		;get next filename entry in directory.
2533+  D332 CD F5 D1        CALL	CKFILPOS	;is file position = 0ffffh?
2534+  D335 CA 94 D3        JP	Z,FNDNXT6	;yes, exit now then.
2535+  D338 2A D9 D9        LD	HL,(SAVEFCB)	;set (DE) pointing to filename to match.
2536+  D33B EB              EX	DE,HL
2537+  D33C 1A              LD	A,(DE)
2538+  D33D FE E5           CP	0E5H		;empty directory entry?
2539+  D33F CA 4A D3        JP	Z,FNDNXT1	;(* are we trying to reserect erased entries? *)
2540+  D342 D5              PUSH	DE
2541+  D343 CD 7F D1        CALL	MOREFLS		;more files in directory?
2542+  D346 D1              POP	DE
2543+  D347 D2 94 D3        JP	NC,FNDNXT6	;no more. Exit now.
2544+  D34A CD 5E D1    FNDNXT1:CALL	FCB2HL		;get address of this fcb in directory.
2545+  D34D 3A D8 D9        LD	A,(COUNTER)	;get number of bytes (characters) to check.
2546+  D350 4F              LD	C,A
2547+  D351 06 00           LD	B,0		;initialize byte position counter.
2548+  D353 79          FNDNXT2:LD	A,C		;are we done with the compare?
2549+  D354 B7              OR	A
2550+  D355 CA 83 D3        JP	Z,FNDNXT5
2551+  D358 1A              LD	A,(DE)		;no, check next byte.
2552+  D359 FE 3F           CP	'?'		;don't care about this character?
2553+  D35B CA 7C D3        JP	Z,FNDNXT4
2554+  D35E 78              LD	A,B		;get bytes position in fcb.
2555+  D35F FE 0D           CP	13		;don't care about the thirteenth byte either.
2556+  D361 CA 7C D3        JP	Z,FNDNXT4
2557+  D364 FE 0C           CP	12		;extent byte?
2558+  D366 1A              LD	A,(DE)
2559+  D367 CA 73 D3        JP	Z,FNDNXT3
2560+  D36A 96              SUB	(HL)		;otherwise compare characters.
2561+  D36B E6 7F           AND	7FH
2562+  D36D C2 2D D3        JP	NZ,FINDNXT	;not the same, check next entry.
2563+  D370 C3 7C D3        JP	FNDNXT4		;so far so good, keep checking.
2564+  D373 C5          FNDNXT3:PUSH	BC		;check the extent byte here.
2565+  D374 4E              LD	C,(HL)
2566+  D375 CD 07 D3        CALL	SAMEXT
2567+  D378 C1              POP	BC
2568+  D379 C2 2D D3        JP	NZ,FINDNXT	;not the same, look some more.
2569+  D37C             ;
2570+  D37C             ;   So far the names compare. Bump pointers to the next byte
2571+  D37C             ; and continue until all (C) characters have been checked.
2572+  D37C             ;
2573+  D37C 13          FNDNXT4:INC	DE		;bump pointers.
2574+  D37D 23              INC	HL
2575+  D37E 04              INC	B
2576+  D37F 0D              DEC	C		;adjust character counter.
2577+  D380 C3 53 D3        JP	FNDNXT2
2578+  D383 3A EA D9    FNDNXT5:LD	A,(FILEPOS)	;return the position of this entry.
2579+  D386 E6 03           AND	03H
2580+  D388 32 45 CF        LD	(STATUS),A
2581+  D38B 21 D4 D9        LD	HL,FNDSTAT
2582+  D38E 7E              LD	A,(HL)
2583+  D38F 17              RLA
2584+  D390 D0              RET	NC
2585+  D391 AF              XOR	A
2586+  D392 77              LD	(HL),A
2587+  D393 C9              RET
2588+  D394             ;
2589+  D394             ;   Filename was not found. Set appropriate status.
2590+  D394             ;
2591+  D394 CD FE D1    FNDNXT6:CALL	STFILPOS	;set (FILEPOS) to 0ffffh.
2592+  D397 3E FF           LD	A,0FFH		;say not located.
2593+  D399 C3 01 CF        JP	SETSTAT
2594+  D39C             ;
2595+  D39C             ;   Erase files from the directory. Only the first byte of the
2596+  D39C             ; fcb will be affected. It is set to (E5).
2597+  D39C             ;
2598+  D39C CD 54 D1    ERAFILE:CALL	CHKWPRT		;is disk write protected?
2599+  D39F 0E 0C           LD	C,12		;only compare file names.
2600+  D3A1 CD 18 D3        CALL	FINDFST		;get first file name.
2601+  D3A4 CD F5 D1    ERAFIL1:CALL	CKFILPOS	;any found?
2602+  D3A7 C8              RET	Z		;nope, we must be done.
2603+  D3A8 CD 44 D1        CALL	CHKROFL		;is file read only?
2604+  D3AB CD 5E D1        CALL	FCB2HL		;nope, get address of fcb and
2605+  D3AE 36 E5           LD	(HL),0E5H	;set first byte to 'empty'.
2606+  D3B0 0E 00           LD	C,0		;clear the space from the bit map.
2607+  D3B2 CD 6B D2        CALL	SETFILE
2608+  D3B5 CD C6 D1        CALL	DIRWRITE	;now write the directory sector back out.
2609+  D3B8 CD 2D D3        CALL	FINDNXT		;find the next file name.
2610+  D3BB C3 A4 D3        JP	ERAFIL1		;and repeat process.
2611+  D3BE             ;
2612+  D3BE             ;   Look through the space allocation map (bit map) for the
2613+  D3BE             ; next available block. Start searching at block number (BC-1).
2614+  D3BE             ; The search procedure is to look for an empty block that is
2615+  D3BE             ; before the starting block. If not empty, look at a later
2616+  D3BE             ; block number. In this way, we return the closest empty block
2617+  D3BE             ; on either side of the 'target' block number. This will speed
2618+  D3BE             ; access on random devices. For serial devices, this should be
2619+  D3BE             ; changed to look in the forward direction first and then start
2620+  D3BE             ; at the front and search some more.
2621+  D3BE             ;
2622+  D3BE             ;   On return, (DE)= block number that is empty and (HL) =0
2623+  D3BE             ; if no empry block was found.
2624+  D3BE             ;
2625+  D3BE 50          FNDSPACE: LD	D,B		;set (DE) as the block that is checked.
2626+  D3BF 59              LD	E,C
2627+  D3C0             ;
2628+  D3C0             ;   Look before target block. Registers (BC) are used as the lower
2629+  D3C0             ; pointer and (DE) as the upper pointer.
2630+  D3C0             ;
2631+  D3C0 79          FNDSPA1:LD	A,C		;is block 0 specified?
2632+  D3C1 B0              OR	B
2633+  D3C2 CA D1 D3        JP	Z,FNDSPA2
2634+  D3C5 0B              DEC	BC		;nope, check previous block.
2635+  D3C6 D5              PUSH	DE
2636+  D3C7 C5              PUSH	BC
2637+  D3C8 CD 35 D2        CALL	CKBITMAP
2638+  D3CB 1F              RRA			;is this block empty?
2639+  D3CC D2 EC D3        JP	NC,FNDSPA3	;yes. use this.
2640+  D3CF             ;
2641+  D3CF             ;   Note that the above logic gets the first block that it finds
2642+  D3CF             ; that is empty. Thus a file could be written 'backward' making
2643+  D3CF             ; it very slow to access. This could be changed to look for the
2644+  D3CF             ; first empty block and then continue until the start of this
2645+  D3CF             ; empty space is located and then used that starting block.
2646+  D3CF             ; This should help speed up access to some files especially on
2647+  D3CF             ; a well used disk with lots of fairly small 'holes'.
2648+  D3CF             ;
2649+  D3CF C1              POP	BC		;nope, check some more.
2650+  D3D0 D1              POP	DE
2651+  D3D1             ;
2652+  D3D1             ;   Now look after target block.
2653+  D3D1             ;
2654+  D3D1 2A C6 D9    FNDSPA2:LD	HL,(DSKSIZE)	;is block (DE) within disk limits?
2655+  D3D4 7B              LD	A,E
2656+  D3D5 95              SUB	L
2657+  D3D6 7A              LD	A,D
2658+  D3D7 9C              SBC	H
2659+  D3D8 D2 F4 D3        JP	NC,FNDSPA4
2660+  D3DB 13              INC	DE		;yes, move on to next one.
2661+  D3DC C5              PUSH	BC
2662+  D3DD D5              PUSH	DE
2663+  D3DE 42              LD	B,D
2664+  D3DF 4B              LD	C,E
2665+  D3E0 CD 35 D2        CALL	CKBITMAP	;check it.
2666+  D3E3 1F              RRA			;empty?
2667+  D3E4 D2 EC D3        JP	NC,FNDSPA3
2668+  D3E7 D1              POP	DE		;nope, continue searching.
2669+  D3E8 C1              POP	BC
2670+  D3E9 C3 C0 D3        JP	FNDSPA1
2671+  D3EC             ;
2672+  D3EC             ;   Empty block found. Set it as used and return with (HL)
2673+  D3EC             ; pointing to it (true?).
2674+  D3EC             ;
2675+  D3EC 17          FNDSPA3:RLA			;reset byte.
2676+  D3ED 3C              INC	A		;and set bit 0.
2677+  D3EE CD 64 D2        CALL	STBMAP1		;update bit map.
2678+  D3F1 E1              POP	HL		;set return registers.
2679+  D3F2 D1              POP	DE
2680+  D3F3 C9              RET
2681+  D3F4             ;
2682+  D3F4             ;   Free block was not found. If (BC) is not zero, then we have
2683+  D3F4             ; not checked all of the disk space.
2684+  D3F4             ;
2685+  D3F4 79          FNDSPA4:LD	A,C
2686+  D3F5 B0              OR	B
2687+  D3F6 C2 C0 D3        JP	NZ,FNDSPA1
2688+  D3F9 21 00 00        LD	HL,0		;set 'not found' status.
2689+  D3FC C9              RET
2690+  D3FD             ;
2691+  D3FD             ;   Move a complete fcb entry into the directory and write it.
2692+  D3FD             ;
2693+  D3FD 0E 00       FCBSET:	LD	C,0
2694+  D3FF 1E 20           LD	E,32		;length of each entry.
2695+  D401             ;
2696+  D401             ;   Move (E) bytes from the fcb pointed to by (PARAMS) into
2697+  D401             ; fcb in directory starting at relative byte (C). This updated
2698+  D401             ; directory buffer is then written to the disk.
2699+  D401             ;
2700+  D401 D5          UPDATE:	PUSH	DE
2701+  D402 06 00           LD	B,0		;set (BC) to relative byte position.
2702+  D404 2A 43 CF        LD	HL,(PARAMS)	;get address of fcb.
2703+  D407 09              ADD	HL,BC		;compute starting byte.
2704+  D408 EB              EX	DE,HL
2705+  D409 CD 5E D1        CALL	FCB2HL		;get address of fcb to update in directory.
2706+  D40C C1              POP	BC		;set (C) to number of bytes to change.
2707+  D40D CD 4F CF        CALL	DE2HL
2708+  D410 CD C3 CF    UPDATE1:CALL	TRKSEC		;determine the track and sector affected.
2709+  D413 C3 C6 D1        JP	DIRWRITE	;then write this sector out.
2710+  D416             ;
2711+  D416             ;   Routine to change the name of all files on the disk with a
2712+  D416             ; specified name. The fcb contains the current name as the
2713+  D416             ; first 12 characters and the new name 16 bytes into the fcb.
2714+  D416             ;
2715+  D416 CD 54 D1    CHGNAMES: CALL	CHKWPRT		;check for a write protected disk.
2716+  D419 0E 0C           LD	C,12		;match first 12 bytes of fcb only.
2717+  D41B CD 18 D3        CALL	FINDFST		;get first name.
2718+  D41E 2A 43 CF        LD	HL,(PARAMS)	;get address of fcb.
2719+  D421 7E              LD	A,(HL)		;get user number.
2720+  D422 11 10 00        LD	DE,16		;move over to desired name.
2721+  D425 19              ADD	HL,DE
2722+  D426 77              LD	(HL),A		;keep same user number.
2723+  D427 CD F5 D1    CHGNAM1:CALL	CKFILPOS	;any matching file found?
2724+  D42A C8              RET	Z		;no, we must be done.
2725+  D42B CD 44 D1        CALL	CHKROFL		;check for read only file.
2726+  D42E 0E 10           LD	C,16		;start 16 bytes into fcb.
2727+  D430 1E 0C           LD	E,12		;and update the first 12 bytes of directory.
2728+  D432 CD 01 D4        CALL	UPDATE
2729+  D435 CD 2D D3        CALL	FINDNXT		;get te next file name.
2730+  D438 C3 27 D4        JP	CHGNAM1		;and continue.
2731+  D43B             ;
2732+  D43B             ;   Update a files attributes. The procedure is to search for
2733+  D43B             ; every file with the same name as shown in fcb (ignoring bit 7)
2734+  D43B             ; and then to update it (which includes bit 7). No other changes
2735+  D43B             ; are made.
2736+  D43B             ;
2737+  D43B 0E 0C       SAVEATTR: LD	C,12		;match first 12 bytes.
2738+  D43D CD 18 D3        CALL	FINDFST		;look for first filename.
2739+  D440 CD F5 D1    SAVATR1:CALL	CKFILPOS	;was one found?
2740+  D443 C8              RET	Z		;nope, we must be done.
2741+  D444 0E 00           LD	C,0		;yes, update the first 12 bytes now.
2742+  D446 1E 0C           LD	E,12
2743+  D448 CD 01 D4        CALL	UPDATE		;update filename and write directory.
2744+  D44B CD 2D D3        CALL	FINDNXT		;and get the next file.
2745+  D44E C3 40 D4        JP	SAVATR1		;then continue until done.
2746+  D451             ;
2747+  D451             ;  Open a file (name specified in fcb).
2748+  D451             ;
2749+  D451 0E 0F       OPENIT:	LD	C,15		;compare the first 15 bytes.
2750+  D453 CD 18 D3        CALL	FINDFST		;get the first one in directory.
2751+  D456 CD F5 D1        CALL	CKFILPOS	;any at all?
2752+  D459 C8              RET	Z
2753+  D45A CD A6 D0    OPENIT1:CALL	SETEXT		;point to extent byte within users fcb.
2754+  D45D 7E              LD	A,(HL)		;and get it.
2755+  D45E F5              PUSH	AF		;save it and address.
2756+  D45F E5              PUSH	HL
2757+  D460 CD 5E D1        CALL	FCB2HL		;point to fcb in directory.
2758+  D463 EB              EX	DE,HL
2759+  D464 2A 43 CF        LD	HL,(PARAMS)	;this is the users copy.
2760+  D467 0E 20           LD	C,32		;move it into users space.
2761+  D469 D5              PUSH	DE
2762+  D46A CD 4F CF        CALL	DE2HL
2763+  D46D CD 78 D1        CALL	SETS2B7		;set bit 7 in 's2' byte (unmodified).
2764+  D470 D1              POP	DE		;now get the extent byte from this fcb.
2765+  D471 21 0C 00        LD	HL,12
2766+  D474 19              ADD	HL,DE
2767+  D475 4E              LD	C,(HL)		;into (C).
2768+  D476 21 0F 00        LD	HL,15		;now get the record count byte into (B).
2769+  D479 19              ADD	HL,DE
2770+  D47A 46              LD	B,(HL)
2771+  D47B E1              POP	HL		;keep the same extent as the user had originally.
2772+  D47C F1              POP	AF
2773+  D47D 77              LD	(HL),A
2774+  D47E 79              LD	A,C		;is it the same as in the directory fcb?
2775+  D47F BE              CP	(HL)
2776+  D480 78              LD	A,B		;if yes, then use the same record count.
2777+  D481 CA 8B D4        JP	Z,OPENIT2
2778+  D484 3E 00           LD	A,0		;if the user specified an extent greater than
2779+  D486 DA 8B D4        JP	C,OPENIT2	;the one in the directory, then set record count to 0.
2780+  D489 3E 80           LD	A,128		;otherwise set to maximum.
2781+  D48B 2A 43 CF    OPENIT2:LD	HL,(PARAMS)	;set record count in users fcb to (A).
2782+  D48E 11 0F 00        LD	DE,15
2783+  D491 19              ADD	HL,DE		;compute relative position.
2784+  D492 77              LD	(HL),A		;and set the record count.
2785+  D493 C9              RET
2786+  D494             ;
2787+  D494             ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
2788+  D494             ; point to a zero value (16 bit).
2789+  D494             ;   Return with zero flag set it (DE) was moved. Registers (DE)
2790+  D494             ; and (HL) are not changed. However (A) is.
2791+  D494             ;
2792+  D494 7E          MOVEWORD: LD	A,(HL)		;check for a zero word.
2793+  D495 23              INC	HL
2794+  D496 B6              OR	(HL)		;both bytes zero?
2795+  D497 2B              DEC	HL
2796+  D498 C0              RET	NZ		;nope, just return.
2797+  D499 1A              LD	A,(DE)		;yes, move two bytes from (DE) into
2798+  D49A 77              LD	(HL),A		;this zero space.
2799+  D49B 13              INC	DE
2800+  D49C 23              INC	HL
2801+  D49D 1A              LD	A,(DE)
2802+  D49E 77              LD	(HL),A
2803+  D49F 1B              DEC	DE		;don't disturb these registers.
2804+  D4A0 2B              DEC	HL
2805+  D4A1 C9              RET
2806+  D4A2             ;
2807+  D4A2             ;   Get here to close a file specified by (fcb).
2808+  D4A2             ;
2809+  D4A2 AF          CLOSEIT:XOR	A		;clear status and file position bytes.
2810+  D4A3 32 45 CF        LD	(STATUS),A
2811+  D4A6 32 EA D9        LD	(FILEPOS),A
2812+  D4A9 32 EB D9        LD	(FILEPOS+1),A
2813+  D4AC CD 1E D1        CALL	GETWPRT		;get write protect bit for this drive.
2814+  D4AF C0              RET	NZ		;just return if it is set.
2815+  D4B0 CD 69 D1        CALL	GETS2		;else get the 's2' byte.
2816+  D4B3 E6 80           AND	80H		;and look at bit 7 (file unmodified?).
2817+  D4B5 C0              RET	NZ		;just return if set.
2818+  D4B6 0E 0F           LD	C,15		;else look up this file in directory.
2819+  D4B8 CD 18 D3        CALL	FINDFST
2820+  D4BB CD F5 D1        CALL	CKFILPOS	;was it found?
2821+  D4BE C8              RET	Z		;just return if not.
2822+  D4BF 01 10 00        LD	BC,16		;set (HL) pointing to records used section.
2823+  D4C2 CD 5E D1        CALL	FCB2HL
2824+  D4C5 09              ADD	HL,BC
2825+  D4C6 EB              EX	DE,HL
2826+  D4C7 2A 43 CF        LD	HL,(PARAMS)	;do the same for users specified fcb.
2827+  D4CA 09              ADD	HL,BC
2828+  D4CB 0E 10           LD	C,16		;this many bytes are present in this extent.
2829+  D4CD 3A DD D9    CLOSEIT1: LD	A,(BIGDISK)	;8 or 16 bit record numbers?
2830+  D4D0 B7              OR	A
2831+  D4D1 CA E8 D4        JP	Z,CLOSEIT4
2832+  D4D4 7E              LD	A,(HL)		;just 8 bit. Get one from users fcb.
2833+  D4D5 B7              OR	A
2834+  D4D6 1A              LD	A,(DE)		;now get one from directory fcb.
2835+  D4D7 C2 DB D4        JP	NZ,CLOSEIT2
2836+  D4DA 77              LD	(HL),A		;users byte was zero. Update from directory.
2837+  D4DB B7          CLOSEIT2: OR	A
2838+  D4DC C2 E1 D4        JP	NZ,CLOSEIT3
2839+  D4DF 7E              LD	A,(HL)		;directories byte was zero, update from users fcb.
2840+  D4E0 12              LD	(DE),A
2841+  D4E1 BE          CLOSEIT3: CP	(HL)		;if neither one of these bytes were zero,
2842+  D4E2 C2 1F D5        JP	NZ,CLOSEIT7	;then close error if they are not the same.
2843+  D4E5 C3 FD D4        JP	CLOSEIT5	;ok so far, get to next byte in fcbs.
2844+  D4E8 CD 94 D4    CLOSEIT4: CALL	MOVEWORD	;update users fcb if it is zero.
2845+  D4EB EB              EX	DE,HL
2846+  D4EC CD 94 D4        CALL	MOVEWORD	;update directories fcb if it is zero.
2847+  D4EF EB              EX	DE,HL
2848+  D4F0 1A              LD	A,(DE)		;if these two values are no different,
2849+  D4F1 BE              CP	(HL)		;then a close error occured.
2850+  D4F2 C2 1F D5        JP	NZ,CLOSEIT7
2851+  D4F5 13              INC	DE		;check second byte.
2852+  D4F6 23              INC	HL
2853+  D4F7 1A              LD	A,(DE)
2854+  D4F8 BE              CP	(HL)
2855+  D4F9 C2 1F D5        JP	NZ,CLOSEIT7
2856+  D4FC 0D              DEC	C		;remember 16 bit values.
2857+  D4FD 13          CLOSEIT5: INC	DE		;bump to next item in table.
2858+  D4FE 23              INC	HL
2859+  D4FF 0D              DEC	C		;there are 16 entries only.
2860+  D500 C2 CD D4        JP	NZ,CLOSEIT1	;continue if more to do.
2861+  D503 01 EC FF        LD	BC,0FFECH	;backup 20 places (extent byte).
2862+  D506 09              ADD	HL,BC
2863+  D507 EB              EX	DE,HL
2864+  D508 09              ADD	HL,BC
2865+  D509 1A              LD	A,(DE)
2866+  D50A BE              CP	(HL)		;directory's extent already greater than the
2867+  D50B DA 17 D5        JP	C,CLOSEIT6	;users extent?
2868+  D50E 77              LD	(HL),A		;no, update directory extent.
2869+  D50F 01 03 00        LD	BC,3		;and update the record count byte in
2870+  D512 09              ADD	HL,BC		;directories fcb.
2871+  D513 EB              EX	DE,HL
2872+  D514 09              ADD	HL,BC
2873+  D515 7E              LD	A,(HL)		;get from user.
2874+  D516 12              LD	(DE),A		;and put in directory.
2875+  D517 3E FF       CLOSEIT6: LD	A,0FFH		;set 'was open and is now closed' byte.
2876+  D519 32 D2 D9        LD	(CLOSEFLG),A
2877+  D51C C3 10 D4        JP	UPDATE1		;update the directory now.
2878+  D51F 21 45 CF    CLOSEIT7: LD	HL,STATUS	;set return status and then return.
2879+  D522 35              DEC	(HL)
2880+  D523 C9              RET
2881+  D524             ;
2882+  D524             ;   Routine to get the next empty space in the directory. It
2883+  D524             ; will then be cleared for use.
2884+  D524             ;
2885+  D524 CD 54 D1    GETEMPTY: CALL	CHKWPRT		;make sure disk is not write protected.
2886+  D527 2A 43 CF        LD	HL,(PARAMS)	;save current parameters (fcb).
2887+  D52A E5              PUSH	HL
2888+  D52B 21 AC D9        LD	HL,EMPTYFCB	;use special one for empty space.
2889+  D52E 22 43 CF        LD	(PARAMS),HL
2890+  D531 0E 01           LD	C,1		;search for first empty spot in directory.
2891+  D533 CD 18 D3        CALL	FINDFST		;(* only check first byte *)
2892+  D536 CD F5 D1        CALL	CKFILPOS	;none?
2893+  D539 E1              POP	HL
2894+  D53A 22 43 CF        LD	(PARAMS),HL	;restore original fcb address.
2895+  D53D C8              RET	Z		;return if no more space.
2896+  D53E EB              EX	DE,HL
2897+  D53F 21 0F 00        LD	HL,15		;point to number of records for this file.
2898+  D542 19              ADD	HL,DE
2899+  D543 0E 11           LD	C,17		;and clear all of this space.
2900+  D545 AF              XOR	A
2901+  D546 77          GETMT1:	LD	(HL),A
2902+  D547 23              INC	HL
2903+  D548 0D              DEC	C
2904+  D549 C2 46 D5        JP	NZ,GETMT1
2905+  D54C 21 0D 00        LD	HL,13		;clear the 's1' byte also.
2906+  D54F 19              ADD	HL,DE
2907+  D550 77              LD	(HL),A
2908+  D551 CD 8C D1        CALL	CHKNMBR		;keep (SCRATCH1) within bounds.
2909+  D554 CD FD D3        CALL	FCBSET		;write out this fcb entry to directory.
2910+  D557 C3 78 D1        JP	SETS2B7		;set 's2' byte bit 7 (unmodified at present).
2911+  D55A             ;
2912+  D55A             ;   Routine to close the current extent and open the next one
2913+  D55A             ; for reading.
2914+  D55A             ;
2915+  D55A AF          GETNEXT:XOR	A
2916+  D55B 32 D2 D9        LD	(CLOSEFLG),A	;clear close flag.
2917+  D55E CD A2 D4        CALL	CLOSEIT		;close this extent.
2918+  D561 CD F5 D1        CALL	CKFILPOS
2919+  D564 C8              RET	Z		;not there???
2920+  D565 2A 43 CF        LD	HL,(PARAMS)	;get extent byte.
2921+  D568 01 0C 00        LD	BC,12
2922+  D56B 09              ADD	HL,BC
2923+  D56C 7E              LD	A,(HL)		;and increment it.
2924+  D56D 3C              INC	A
2925+  D56E E6 1F           AND	1FH		;keep within range 0-31.
2926+  D570 77              LD	(HL),A
2927+  D571 CA 83 D5        JP	Z,GTNEXT1	;overflow?
2928+  D574 47              LD	B,A		;mask extent byte.
2929+  D575 3A C5 D9        LD	A,(EXTMASK)
2930+  D578 A0              AND	B
2931+  D579 21 D2 D9        LD	HL,CLOSEFLG	;check close flag (0ffh is ok).
2932+  D57C A6              AND	(HL)
2933+  D57D CA 8E D5        JP	Z,GTNEXT2	;if zero, we must read in next extent.
2934+  D580 C3 AC D5        JP	GTNEXT3		;else, it is already in memory.
2935+  D583 01 02 00    GTNEXT1:LD	BC,2		;Point to the 's2' byte.
2936+  D586 09              ADD	HL,BC
2937+  D587 34              INC	(HL)		;and bump it.
2938+  D588 7E              LD	A,(HL)		;too many extents?
2939+  D589 E6 0F           AND	0FH
2940+  D58B CA B6 D5        JP	Z,GTNEXT5	;yes, set error code.
2941+  D58E             ;
2942+  D58E             ;   Get here to open the next extent.
2943+  D58E             ;
2944+  D58E 0E 0F       GTNEXT2:LD	C,15		;set to check first 15 bytes of fcb.
2945+  D590 CD 18 D3        CALL	FINDFST		;find the first one.
2946+  D593 CD F5 D1        CALL	CKFILPOS	;none available?
2947+  D596 C2 AC D5        JP	NZ,GTNEXT3
2948+  D599 3A D3 D9        LD	A,(RDWRTFLG)	;no extent present. Can we open an empty one?
2949+  D59C 3C              INC	A		;0ffh means reading (so not possible).
2950+  D59D CA B6 D5        JP	Z,GTNEXT5	;or an error.
2951+  D5A0 CD 24 D5        CALL	GETEMPTY	;we are writing, get an empty entry.
2952+  D5A3 CD F5 D1        CALL	CKFILPOS	;none?
2953+  D5A6 CA B6 D5        JP	Z,GTNEXT5	;error if true.
2954+  D5A9 C3 AF D5        JP	GTNEXT4		;else we are almost done.
2955+  D5AC CD 5A D4    GTNEXT3:CALL	OPENIT1		;open this extent.
2956+  D5AF CD BB D0    GTNEXT4:CALL	STRDATA		;move in updated data (rec #, extent #, etc.)
2957+  D5B2 AF              XOR	A		;clear status and return.
2958+  D5B3 C3 01 CF        JP	SETSTAT
2959+  D5B6             ;
2960+  D5B6             ;   Error in extending the file. Too many extents were needed
2961+  D5B6             ; or not enough space on the disk.
2962+  D5B6             ;
2963+  D5B6 CD 05 CF    GTNEXT5:CALL	IOERR1		;set error code, clear bit 7 of 's2'
2964+  D5B9 C3 78 D1        JP	SETS2B7		;so this is not written on a close.
2965+  D5BC             ;
2966+  D5BC             ;   Read a sequential file.
2967+  D5BC             ;
2968+  D5BC 3E 01       RDSEQ:	LD	A,1		;set sequential access mode.
2969+  D5BE 32 D5 D9        LD	(MODE),A
2970+  D5C1 3E FF       RDSEQ1:	LD	A,0FFH		;don't allow reading unwritten space.
2971+  D5C3 32 D3 D9        LD	(RDWRTFLG),A
2972+  D5C6 CD BB D0        CALL	STRDATA		;put rec# and ext# into fcb.
2973+  D5C9 3A E3 D9        LD	A,(SAVNREC)	;get next record to read.
2974+  D5CC 21 E1 D9        LD	HL,SAVNXT	;get number of records in extent.
2975+  D5CF BE              CP	(HL)		;within this extent?
2976+  D5D0 DA E6 D5        JP	C,RDSEQ2
2977+  D5D3 FE 80           CP	128		;no. Is this extent fully used?
2978+  D5D5 C2 FB D5        JP	NZ,RDSEQ3	;no. End-of-file.
2979+  D5D8 CD 5A D5        CALL	GETNEXT		;yes, open the next one.
2980+  D5DB AF              XOR	A		;reset next record to read.
2981+  D5DC 32 E3 D9        LD	(SAVNREC),A
2982+  D5DF 3A 45 CF        LD	A,(STATUS)	;check on open, successful?
2983+  D5E2 B7              OR	A
2984+  D5E3 C2 FB D5        JP	NZ,RDSEQ3	;no, error.
2985+  D5E6 CD 77 D0    RDSEQ2:	CALL	COMBLK		;ok. compute block number to read.
2986+  D5E9 CD 84 D0        CALL	CHKBLK		;check it. Within bounds?
2987+  D5EC CA FB D5        JP	Z,RDSEQ3	;no, error.
2988+  D5EF CD 8A D0        CALL	LOGICAL		;convert (BLKNMBR) to logical sector (128 byte).
2989+  D5F2 CD D1 CF        CALL	TRKSEC1		;set the track and sector for this block #.
2990+  D5F5 CD B2 CF        CALL	DOREAD		;and read it.
2991+  D5F8 C3 D2 D0        JP	SETNREC		;and set the next record to be accessed.
2992+  D5FB             ;
2993+  D5FB             ;   Read error occured. Set status and return.
2994+  D5FB             ;
2995+  D5FB C3 05 CF    RDSEQ3:	JP	IOERR1
2996+  D5FE             ;
2997+  D5FE             ;   Write the next sequential record.
2998+  D5FE             ;
2999+  D5FE 3E 01       WTSEQ:	LD	A,1		;set sequential access mode.
3000+  D600 32 D5 D9        LD	(MODE),A
3001+  D603 3E 00       WTSEQ1:	LD	A,0		;allow an addition empty extent to be opened.
3002+  D605 32 D3 D9        LD	(RDWRTFLG),A
3003+  D608 CD 54 D1        CALL	CHKWPRT		;check write protect status.
3004+  D60B 2A 43 CF        LD	HL,(PARAMS)
3005+  D60E CD 47 D1        CALL	CKROF1		;check for read only file, (HL) already set to fcb.
3006+  D611 CD BB D0        CALL	STRDATA		;put updated data into fcb.
3007+  D614 3A E3 D9        LD	A,(SAVNREC)	;get record number to write.
3008+  D617 FE 80           CP	128		;within range?
3009+  D619 D2 05 CF        JP	NC,IOERR1	;no, error(?).
3010+  D61C CD 77 D0        CALL	COMBLK		;compute block number.
3011+  D61F CD 84 D0        CALL	CHKBLK		;check number.
3012+  D622 0E 00           LD	C,0		;is there one to write to?
3013+  D624 C2 6E D6        JP	NZ,WTSEQ6	;yes, go do it.
3014+  D627 CD 3E D0        CALL	GETBLOCK	;get next block number within fcb to use.
3015+  D62A 32 D7 D9        LD	(RELBLOCK),A	;and save.
3016+  D62D 01 00 00        LD	BC,0		;start looking for space from the start
3017+  D630 B7              OR	A		;if none allocated as yet.
3018+  D631 CA 3B D6        JP	Z,WTSEQ2
3019+  D634 4F              LD	C,A		;extract previous block number from fcb
3020+  D635 0B              DEC	BC		;so we can be closest to it.
3021+  D636 CD 5E D0        CALL	EXTBLK
3022+  D639 44              LD	B,H
3023+  D63A 4D              LD	C,L
3024+  D63B CD BE D3    WTSEQ2:	CALL	FNDSPACE	;find the next empty block nearest number (BC).
3025+  D63E 7D              LD	A,L		;check for a zero number.
3026+  D63F B4              OR	H
3027+  D640 C2 48 D6        JP	NZ,WTSEQ3
3028+  D643 3E 02           LD	A,2		;no more space?
3029+  D645 C3 01 CF        JP	SETSTAT
3030+  D648 22 E5 D9    WTSEQ3:	LD	(BLKNMBR),HL	;save block number to access.
3031+  D64B EB              EX	DE,HL		;put block number into (DE).
3032+  D64C 2A 43 CF        LD	HL,(PARAMS)	;now we must update the fcb for this
3033+  D64F 01 10 00        LD	BC,16		;newly allocated block.
3034+  D652 09              ADD	HL,BC
3035+  D653 3A DD D9        LD	A,(BIGDISK)	;8 or 16 bit block numbers?
3036+  D656 B7              OR	A
3037+  D657 3A D7 D9        LD	A,(RELBLOCK)	;(* update this entry *)
3038+  D65A CA 64 D6        JP	Z,WTSEQ4	;zero means 16 bit ones.
3039+  D65D CD 64 D1        CALL	ADDA2HL		;(HL)=(HL)+(A)
3040+  D660 73              LD	(HL),E		;store new block number.
3041+  D661 C3 6C D6        JP	WTSEQ5
3042+  D664 4F          WTSEQ4:	LD	C,A		;compute spot in this 16 bit table.
3043+  D665 06 00           LD	B,0
3044+  D667 09              ADD	HL,BC
3045+  D668 09              ADD	HL,BC
3046+  D669 73              LD	(HL),E		;stuff block number (DE) there.
3047+  D66A 23              INC	HL
3048+  D66B 72              LD	(HL),D
3049+  D66C 0E 02       WTSEQ5:	LD	C,2		;set (C) to indicate writing to un-used disk space.
3050+  D66E 3A 45 CF    WTSEQ6:	LD	A,(STATUS)	;are we ok so far?
3051+  D671 B7              OR	A
3052+  D672 C0              RET	NZ
3053+  D673 C5              PUSH	BC		;yes, save write flag for bios (register C).
3054+  D674 CD 8A D0        CALL	LOGICAL		;convert (BLKNMBR) over to loical sectors.
3055+  D677 3A D5 D9        LD	A,(MODE)	;get access mode flag (1=sequential,
3056+  D67A 3D              DEC	A		;0=random, 2=special?).
3057+  D67B 3D              DEC	A
3058+  D67C C2 BB D6        JP	NZ,WTSEQ9
3059+  D67F             ;
3060+  D67F             ;   Special random i/o from function #40. Maybe for M/PM, but the
3061+  D67F             ; current block, if it has not been written to, will be zeroed
3062+  D67F             ; out and then written (reason?).
3063+  D67F             ;
3064+  D67F C1              POP	BC
3065+  D680 C5              PUSH	BC
3066+  D681 79              LD	A,C		;get write status flag (2=writing unused space).
3067+  D682 3D              DEC	A
3068+  D683 3D              DEC	A
3069+  D684 C2 BB D6        JP	NZ,WTSEQ9
3070+  D687 E5              PUSH	HL
3071+  D688 2A B9 D9        LD	HL,(DIRBUF)	;zero out the directory buffer.
3072+  D68B 57              LD	D,A		;note that (A) is zero here.
3073+  D68C 77          WTSEQ7:	LD	(HL),A
3074+  D68D 23              INC	HL
3075+  D68E 14              INC	D		;do 128 bytes.
3076+  D68F F2 8C D6        JP	P,WTSEQ7
3077+  D692 CD E0 D1        CALL	DIRDMA		;tell the bios the dma address for directory access.
3078+  D695 2A E7 D9        LD	HL,(LOGSECT)	;get sector that starts current block.
3079+  D698 0E 02           LD	C,2		;set 'writing to unused space' flag.
3080+  D69A 22 E5 D9    WTSEQ8:	LD	(BLKNMBR),HL	;save sector to write.
3081+  D69D C5              PUSH	BC
3082+  D69E CD D1 CF        CALL	TRKSEC1		;determine its track and sector numbers.
3083+  D6A1 C1              POP	BC
3084+  D6A2 CD B8 CF        CALL	DOWRITE		;now write out 128 bytes of zeros.
3085+  D6A5 2A E5 D9        LD	HL,(BLKNMBR)	;get sector number.
3086+  D6A8 0E 00           LD	C,0		;set normal write flag.
3087+  D6AA 3A C4 D9        LD	A,(BLKMASK)	;determine if we have written the entire
3088+  D6AD 47              LD	B,A		;physical block.
3089+  D6AE A5              AND	L
3090+  D6AF B8              CP	B
3091+  D6B0 23              INC	HL		;prepare for the next one.
3092+  D6B1 C2 9A D6        JP	NZ,WTSEQ8	;continue until (BLKMASK+1) sectors written.
3093+  D6B4 E1              POP	HL		;reset next sector number.
3094+  D6B5 22 E5 D9        LD	(BLKNMBR),HL
3095+  D6B8 CD DA D1        CALL	DEFDMA		;and reset dma address.
3096+  D6BB             ;
3097+  D6BB             ;   Normal disk write. Set the desired track and sector then
3098+  D6BB             ; do the actual write.
3099+  D6BB             ;
3100+  D6BB CD D1 CF    WTSEQ9:	CALL	TRKSEC1		;determine track and sector for this write.
3101+  D6BE C1              POP	BC		;get write status flag.
3102+  D6BF C5              PUSH	BC
3103+  D6C0 CD B8 CF        CALL	DOWRITE		;and write this out.
3104+  D6C3 C1              POP	BC
3105+  D6C4 3A E3 D9        LD	A,(SAVNREC)	;get number of records in file.
3106+  D6C7 21 E1 D9        LD	HL,SAVNXT	;get last record written.
3107+  D6CA BE              CP	(HL)
3108+  D6CB DA D2 D6        JP	C,WTSEQ10
3109+  D6CE 77              LD	(HL),A		;we have to update record count.
3110+  D6CF 34              INC	(HL)
3111+  D6D0 0E 02           LD	C,2
3112+  D6D2             ;
3113+  D6D2             ;*   This area has been patched to correct disk update problem
3114+  D6D2             ;* when using blocking and de-blocking in the BIOS.
3115+  D6D2             ;
3116+  D6D2 00          WTSEQ10:NOP			;was 'dcr c'
3117+  D6D3 00              NOP			;was 'dcr c'
3118+  D6D4 21 00 00        LD	HL,0		;was 'jnz wtseq99'
3119+  D6D7             ;
3120+  D6D7             ; *   End of patch.
3121+  D6D7             ;
3122+  D6D7 F5              PUSH	AF
3123+  D6D8 CD 69 D1        CALL	GETS2		;set 'extent written to' flag.
3124+  D6DB E6 7F           AND	7FH		;(* clear bit 7 *)
3125+  D6DD 77              LD	(HL),A
3126+  D6DE F1              POP	AF		;get record count for this extent.
3127+  D6DF FE 7F       WTSEQ99:CP	127		;is it full?
3128+  D6E1 C2 00 D7        JP	NZ,WTSEQ12
3129+  D6E4 3A D5 D9        LD	A,(MODE)	;yes, are we in sequential mode?
3130+  D6E7 FE 01           CP	1
3131+  D6E9 C2 00 D7        JP	NZ,WTSEQ12
3132+  D6EC CD D2 D0        CALL	SETNREC		;yes, set next record number.
3133+  D6EF CD 5A D5        CALL	GETNEXT		;and get next empty space in directory.
3134+  D6F2 21 45 CF        LD	HL,STATUS	;ok?
3135+  D6F5 7E              LD	A,(HL)
3136+  D6F6 B7              OR	A
3137+  D6F7 C2 FE D6        JP	NZ,WTSEQ11
3138+  D6FA 3D              DEC	A		;yes, set record count to -1.
3139+  D6FB 32 E3 D9        LD	(SAVNREC),A
3140+  D6FE 36 00       WTSEQ11:LD	(HL),0		;clear status.
3141+  D700 C3 D2 D0    WTSEQ12:JP	SETNREC		;set next record to access.
3142+  D703             ;
3143+  D703             ;   For random i/o, set the fcb for the desired record number
3144+  D703             ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
3145+  D703             ; used as follows:
3146+  D703             ;
3147+  D703             ;       fcb+35            fcb+34            fcb+33
3148+  D703             ;  |     'r-2'      |      'r-1'      |      'r-0'     |
3149+  D703             ;  |7             0 | 7             0 | 7             0|
3150+  D703             ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
3151+  D703             ;  |    overflow   | | extra |  extent   |   record #  |
3152+  D703             ;  | ______________| |_extent|__number___|_____________|
3153+  D703             ;                     also 's2'
3154+  D703             ;
3155+  D703             ;   On entry, register (C) contains 0ffh if this is a read
3156+  D703             ; and thus we can not access unwritten disk space. Otherwise,
3157+  D703             ; another extent will be opened (for writing) if required.
3158+  D703             ;
3159+  D703 AF          POSITION: XOR	A		;set random i/o flag.
3160+  D704 32 D5 D9        LD	(MODE),A
3161+  D707             ;
3162+  D707             ;   Special entry (function #40). M/PM ?
3163+  D707             ;
3164+  D707 C5          POSITN1:PUSH	BC		;save read/write flag.
3165+  D708 2A 43 CF        LD	HL,(PARAMS)	;get address of fcb.
3166+  D70B EB              EX	DE,HL
3167+  D70C 21 21 00        LD	HL,33		;now get byte 'r0'.
3168+  D70F 19              ADD	HL,DE
3169+  D710 7E              LD	A,(HL)
3170+  D711 E6 7F           AND	7FH		;keep bits 0-6 for the record number to access.
3171+  D713 F5              PUSH	AF
3172+  D714 7E              LD	A,(HL)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
3173+  D715 17              RLA
3174+  D716 23              INC	HL
3175+  D717 7E              LD	A,(HL)
3176+  D718 17              RLA
3177+  D719 E6 1F           AND	1FH		;and save this in bits 0-4 of (C).
3178+  D71B 4F              LD	C,A		;this is the extent byte.
3179+  D71C 7E              LD	A,(HL)		;now get the extra extent byte.
3180+  D71D 1F              RRA
3181+  D71E 1F              RRA
3182+  D71F 1F              RRA
3183+  D720 1F              RRA
3184+  D721 E6 0F           AND	0FH
3185+  D723 47              LD	B,A		;and save it in (B).
3186+  D724 F1              POP	AF		;get record number back to (A).
3187+  D725 23              INC	HL		;check overflow byte 'r2'.
3188+  D726 6E              LD	L,(HL)
3189+  D727 2C              INC	L
3190+  D728 2D              DEC	L
3191+  D729 2E 06           LD	L,6		;prepare for error.
3192+  D72B C2 8B D7        JP	NZ,POSITN5	;out of disk space error.
3193+  D72E 21 20 00        LD	HL,32		;store record number into fcb.
3194+  D731 19              ADD	HL,DE
3195+  D732 77              LD	(HL),A
3196+  D733 21 0C 00        LD	HL,12		;and now check the extent byte.
3197+  D736 19              ADD	HL,DE
3198+  D737 79              LD	A,C
3199+  D738 96              SUB	(HL)		;same extent as before?
3200+  D739 C2 47 D7        JP	NZ,POSITN2
3201+  D73C 21 0E 00        LD	HL,14		;yes, check extra extent byte 's2' also.
3202+  D73F 19              ADD	HL,DE
3203+  D740 78              LD	A,B
3204+  D741 96              SUB	(HL)
3205+  D742 E6 7F           AND	7FH
3206+  D744 CA 7F D7        JP	Z,POSITN3	;same, we are almost done then.
3207+  D747             ;
3208+  D747             ;  Get here when another extent is required.
3209+  D747             ;
3210+  D747 C5          POSITN2:PUSH	BC
3211+  D748 D5              PUSH	DE
3212+  D749 CD A2 D4        CALL	CLOSEIT		;close current extent.
3213+  D74C D1              POP	DE
3214+  D74D C1              POP	BC
3215+  D74E 2E 03           LD	L,3		;prepare for error.
3216+  D750 3A 45 CF        LD	A,(STATUS)
3217+  D753 3C              INC	A
3218+  D754 CA 84 D7        JP	Z,POSITN4	;close error.
3219+  D757 21 0C 00        LD	HL,12		;put desired extent into fcb now.
3220+  D75A 19              ADD	HL,DE
3221+  D75B 71              LD	(HL),C
3222+  D75C 21 0E 00        LD	HL,14		;and store extra extent byte 's2'.
3223+  D75F 19              ADD	HL,DE
3224+  D760 70              LD	(HL),B
3225+  D761 CD 51 D4        CALL	OPENIT		;try and get this extent.
3226+  D764 3A 45 CF        LD	A,(STATUS)	;was it there?
3227+  D767 3C              INC	A
3228+  D768 C2 7F D7        JP	NZ,POSITN3
3229+  D76B C1              POP	BC		;no. can we create a new one (writing?).
3230+  D76C C5              PUSH	BC
3231+  D76D 2E 04           LD	L,4		;prepare for error.
3232+  D76F 0C              INC	C
3233+  D770 CA 84 D7        JP	Z,POSITN4	;nope, reading unwritten space error.
3234+  D773 CD 24 D5        CALL	GETEMPTY	;yes we can, try to find space.
3235+  D776 2E 05           LD	L,5		;prepare for error.
3236+  D778 3A 45 CF        LD	A,(STATUS)
3237+  D77B 3C              INC	A
3238+  D77C CA 84 D7        JP	Z,POSITN4	;out of space?
3239+  D77F             ;
3240+  D77F             ;   Normal return location. Clear error code and return.
3241+  D77F             ;
3242+  D77F C1          POSITN3:POP	BC		;restore stack.
3243+  D780 AF              XOR	A		;and clear error code byte.
3244+  D781 C3 01 CF        JP	SETSTAT
3245+  D784             ;
3246+  D784             ;   Error. Set the 's2' byte to indicate this (why?).
3247+  D784             ;
3248+  D784 E5          POSITN4:PUSH	HL
3249+  D785 CD 69 D1        CALL	GETS2
3250+  D788 36 C0           LD	(HL),0C0H
3251+  D78A E1              POP	HL
3252+  D78B             ;
3253+  D78B             ;   Return with error code (presently in L).
3254+  D78B             ;
3255+  D78B C1          POSITN5:POP	BC
3256+  D78C 7D              LD	A,L		;get error code.
3257+  D78D 32 45 CF        LD	(STATUS),A
3258+  D790 C3 78 D1        JP	SETS2B7
3259+  D793             ;
3260+  D793             ;   Read a random record.
3261+  D793             ;
3262+  D793 0E FF       READRAN:LD	C,0FFH		;set 'read' status.
3263+  D795 CD 03 D7        CALL	POSITION	;position the file to proper record.
3264+  D798 CC C1 D5        CALL	Z,RDSEQ1	;and read it as usual (if no errors).
3265+  D79B C9              RET
3266+  D79C             ;
3267+  D79C             ;   Write to a random record.
3268+  D79C             ;
3269+  D79C 0E 00       WRITERAN: LD	C,0		;set 'writing' flag.
3270+  D79E CD 03 D7        CALL	POSITION	;position the file to proper record.
3271+  D7A1 CC 03 D6        CALL	Z,WTSEQ1	;and write as usual (if no errors).
3272+  D7A4 C9              RET
3273+  D7A5             ;
3274+  D7A5             ;   Compute the random record number. Enter with (HL) pointing
3275+  D7A5             ; to a fcb an (DE) contains a relative location of a record
3276+  D7A5             ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
3277+  D7A5             ; byte, and (A) the 'r2' byte.
3278+  D7A5             ;
3279+  D7A5             ;   On return, the zero flag is set if the record is within
3280+  D7A5             ; bounds. Otherwise, an overflow occured.
3281+  D7A5             ;
3282+  D7A5             
3283+  D7A5 EB          COMPRAND: EX	DE,HL		;save fcb pointer in (DE).
3284+  D7A6 19              ADD	HL,DE		;compute relative position of record #.
3285+  D7A7 4E              LD	C,(HL)		;get record number into (BC).
3286+  D7A8 06 00           LD	B,0
3287+  D7AA 21 0C 00        LD	HL,12		;now get extent.
3288+  D7AD 19              ADD	HL,DE
3289+  D7AE 7E              LD	A,(HL)		;compute (BC)=(record #)+(extent)*128.
3290+  D7AF 0F              RRCA			;move lower bit into bit 7.
3291+  D7B0 E6 80           AND	80H		;and ignore all other bits.
3292+  D7B2 81              ADD	C		;add to our record number.
3293+  D7B3 4F              LD	C,A
3294+  D7B4 3E 00           LD	A,0		;take care of any carry.
3295+  D7B6 88              ADC	B
3296+  D7B7 47              LD	B,A
3297+  D7B8 7E              LD	A,(HL)		;now get the upper bits of extent into
3298+  D7B9 0F              RRCA			;bit positions 0-3.
3299+  D7BA E6 0F           AND	0FH		;and ignore all others.
3300+  D7BC 80              ADD	B		;add this in to 'r1' byte.
3301+  D7BD 47              LD	B,A
3302+  D7BE 21 0E 00        LD	HL,14		;get the 's2' byte (extra extent).
3303+  D7C1 19              ADD	HL,DE
3304+  D7C2 7E              LD	A,(HL)
3305+  D7C3 87              ADD	A		;and shift it left 4 bits (bits 4-7).
3306+  D7C4 87              ADD	A
3307+  D7C5 87              ADD	A
3308+  D7C6 87              ADD	A
3309+  D7C7 F5              PUSH	AF		;save carry flag (bit 0 of flag byte).
3310+  D7C8 80              ADD	B		;now add extra extent into 'r1'.
3311+  D7C9 47              LD	B,A
3312+  D7CA F5              PUSH	AF		;and save carry (overflow byte 'r2').
3313+  D7CB E1              POP	HL		;bit 0 of (L) is the overflow indicator.
3314+  D7CC 7D              LD	A,L
3315+  D7CD E1              POP	HL		;and same for first carry flag.
3316+  D7CE B5              OR	L		;either one of these set?
3317+  D7CF E6 01           AND	01H		;only check the carry flags.
3318+  D7D1 C9              RET
3319+  D7D2             ;
3320+  D7D2             ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
3321+  D7D2             ; reflect the last record used for a random (or other) file.
3322+  D7D2             ; This reads the directory and looks at all extents computing
3323+  D7D2             ; the largerst record number for each and keeping the maximum
3324+  D7D2             ; value only. Then 'r0', 'r1', and 'r2' will reflect this
3325+  D7D2             ; maximum record number. This is used to compute the space used
3326+  D7D2             ; by a random file.
3327+  D7D2             ;
3328+  D7D2 0E 0C       RANSIZE:LD	C,12		;look thru directory for first entry with
3329+  D7D4 CD 18 D3        CALL	FINDFST		;this name.
3330+  D7D7 2A 43 CF        LD	HL,(PARAMS)	;zero out the 'r0, r1, r2' bytes.
3331+  D7DA 11 21 00        LD	DE,33
3332+  D7DD 19              ADD	HL,DE
3333+  D7DE E5              PUSH	HL
3334+  D7DF 72              LD	(HL),D		;note that (D)=0.
3335+  D7E0 23              INC	HL
3336+  D7E1 72              LD	(HL),D
3337+  D7E2 23              INC	HL
3338+  D7E3 72              LD	(HL),D
3339+  D7E4 CD F5 D1    RANSIZ1:CALL	CKFILPOS	;is there an extent to process?
3340+  D7E7 CA 0C D8        JP	Z,RANSIZ3	;no, we are done.
3341+  D7EA CD 5E D1        CALL	FCB2HL		;set (HL) pointing to proper fcb in dir.
3342+  D7ED 11 0F 00        LD	DE,15		;point to last record in extent.
3343+  D7F0 CD A5 D7        CALL	COMPRAND	;and compute random parameters.
3344+  D7F3 E1              POP	HL
3345+  D7F4 E5              PUSH	HL		;now check these values against those
3346+  D7F5 5F              LD	E,A		;already in fcb.
3347+  D7F6 79              LD	A,C		;the carry flag will be set if those
3348+  D7F7 96              SUB	(HL)		;in the fcb represent a larger size than
3349+  D7F8 23              INC	HL		;this extent does.
3350+  D7F9 78              LD	A,B
3351+  D7FA 9E              SBC	(HL)
3352+  D7FB 23              INC	HL
3353+  D7FC 7B              LD	A,E
3354+  D7FD 9E              SBC	(HL)
3355+  D7FE DA 06 D8        JP	C,RANSIZ2
3356+  D801 73              LD	(HL),E		;we found a larger (in size) extent.
3357+  D802 2B              DEC	HL		;stuff these values into fcb.
3358+  D803 70              LD	(HL),B
3359+  D804 2B              DEC	HL
3360+  D805 71              LD	(HL),C
3361+  D806 CD 2D D3    RANSIZ2:CALL	FINDNXT		;now get the next extent.
3362+  D809 C3 E4 D7        JP	RANSIZ1		;continue til all done.
3363+  D80C E1          RANSIZ3:POP	HL		;we are done, restore the stack and
3364+  D80D C9              RET			;return.
3365+  D80E             ;
3366+  D80E             ;   Function to return the random record position of a given
3367+  D80E             ; file which has been read in sequential mode up to now.
3368+  D80E             ;
3369+  D80E 2A 43 CF    SETRAN:	LD	HL,(PARAMS)	;point to fcb.
3370+  D811 11 20 00        LD	DE,32		;and to last used record.
3371+  D814 CD A5 D7        CALL	COMPRAND	;compute random position.
3372+  D817 21 21 00        LD	HL,33		;now stuff these values into fcb.
3373+  D81A 19              ADD	HL,DE
3374+  D81B 71              LD	(HL),C		;move 'r0'.
3375+  D81C 23              INC	HL
3376+  D81D 70              LD	(HL),B		;and 'r1'.
3377+  D81E 23              INC	HL
3378+  D81F 77              LD	(HL),A		;and lastly 'r2'.
3379+  D820 C9              RET
3380+  D821             ;
3381+  D821             ;   This routine select the drive specified in (ACTIVE) and
3382+  D821             ; update the login vector and bitmap table if this drive was
3383+  D821             ; not already active.
3384+  D821             ;
3385+  D821 2A AF D9    LOGINDRV: LD	HL,(LOGIN)	;get the login vector.
3386+  D824 3A 42 CF        LD	A,(ACTIVE)	;get the default drive.
3387+  D827 4F              LD	C,A
3388+  D828 CD EA D0        CALL	SHIFTR		;position active bit for this drive
3389+  D82B E5              PUSH	HL		;into bit 0.
3390+  D82C EB              EX	DE,HL
3391+  D82D CD 59 CF        CALL	SELECT		;select this drive.
3392+  D830 E1              POP	HL
3393+  D831 CC 47 CF        CALL	Z,SLCTERR	;valid drive?
3394+  D834 7D              LD	A,L		;is this a newly activated drive?
3395+  D835 1F              RRA
3396+  D836 D8              RET	C
3397+  D837 2A AF D9        LD	HL,(LOGIN)	;yes, update the login vector.
3398+  D83A 4D              LD	C,L
3399+  D83B 44              LD	B,H
3400+  D83C CD 0B D1        CALL	SETBIT
3401+  D83F 22 AF D9        LD	(LOGIN),HL	;and save.
3402+  D842 C3 A3 D2        JP	BITMAP		;now update the bitmap.
3403+  D845             ;
3404+  D845             ;   Function to set the active disk number.
3405+  D845             ;
3406+  D845 3A D6 D9    SETDSK:	LD	A,(EPARAM)	;get parameter passed and see if this
3407+  D848 21 42 CF        LD	HL,ACTIVE	;represents a change in drives.
3408+  D84B BE              CP	(HL)
3409+  D84C C8              RET	Z
3410+  D84D 77              LD	(HL),A		;yes it does, log it in.
3411+  D84E C3 21 D8        JP	LOGINDRV
3412+  D851             ;
3413+  D851             ;   This is the 'auto disk select' routine. The firsst byte
3414+  D851             ; of the fcb is examined for a drive specification. If non
3415+  D851             ; zero then the drive will be selected and loged in.
3416+  D851             ;
3417+  D851 3E FF       AUTOSEL:LD	A,0FFH		;say 'auto-select activated'.
3418+  D853 32 DE D9        LD	(AUTO),A
3419+  D856 2A 43 CF        LD	HL,(PARAMS)	;get drive specified.
3420+  D859 7E              LD	A,(HL)
3421+  D85A E6 1F           AND	1FH		;look at lower 5 bits.
3422+  D85C 3D              DEC	A		;adjust for (1=A, 2=B) etc.
3423+  D85D 32 D6 D9        LD	(EPARAM),A	;and save for the select routine.
3424+  D860 FE 1E           CP	1EH		;check for 'no change' condition.
3425+  D862 D2 75 D8        JP	NC,AUTOSL1	;yes, don't change.
3426+  D865 3A 42 CF        LD	A,(ACTIVE)	;we must change, save currently active
3427+  D868 32 DF D9        LD	(OLDDRV),A	;drive.
3428+  D86B 7E              LD	A,(HL)		;and save first byte of fcb also.
3429+  D86C 32 E0 D9        LD	(AUTOFLAG),A	;this must be non-zero.
3430+  D86F E6 E0           AND	0E0H		;whats this for (bits 6,7 are used for
3431+  D871 77              LD	(HL),A		;something)?
3432+  D872 CD 45 D8        CALL	SETDSK		;select and log in this drive.
3433+  D875 3A 41 CF    AUTOSL1:LD	A,(USERNO)	;move user number into fcb.
3434+  D878 2A 43 CF        LD	HL,(PARAMS)	;(* upper half of first byte *)
3435+  D87B B6              OR	(HL)
3436+  D87C 77              LD	(HL),A
3437+  D87D C9              RET			;and return (all done).
3438+  D87E             ;
3439+  D87E             ;   Function to return the current cp/m version number.
3440+  D87E             ;
3441+  D87E 3E 22       GETVER:	LD	A,022H		;version 2.2
3442+  D880 C3 01 CF        JP	SETSTAT
3443+  D883             ;
3444+  D883             ;   Function to reset the disk system.
3445+  D883             ;
3446+  D883 21 00 00    RSTDSK:	LD	HL,0		;clear write protect status and log
3447+  D886 22 AD D9        LD	(WRTPRT),HL	;in vector.
3448+  D889 22 AF D9        LD	(LOGIN),HL
3449+  D88C AF              XOR	A		;select drive 'A'.
3450+  D88D 32 42 CF        LD	(ACTIVE),A
3451+  D890 21 80 00        LD	HL,TBUFF	;setup default dma address.
3452+  D893 22 B1 D9        LD	(USERDMA),HL
3453+  D896 CD DA D1        CALL	DEFDMA
3454+  D899 C3 21 D8        JP	LOGINDRV	;now log in drive 'A'.
3455+  D89C             ;
3456+  D89C             ;   Function to open a specified file.
3457+  D89C             ;
3458+  D89C CD 72 D1    OPENFIL:CALL	CLEARS2		;clear 's2' byte.
3459+  D89F CD 51 D8        CALL	AUTOSEL		;select proper disk.
3460+  D8A2 C3 51 D4        JP	OPENIT		;and open the file.
3461+  D8A5             ;
3462+  D8A5             ;   Function to close a specified file.
3463+  D8A5             ;
3464+  D8A5 CD 51 D8    CLOSEFIL: CALL	AUTOSEL		;select proper disk.
3465+  D8A8 C3 A2 D4        JP	CLOSEIT		;and close the file.
3466+  D8AB             ;
3467+  D8AB             ;   Function to return the first occurence of a specified file
3468+  D8AB             ; name. If the first byte of the fcb is '?' then the name will
3469+  D8AB             ; not be checked (get the first entry no matter what).
3470+  D8AB             ;
3471+  D8AB 0E 00       GETFST:	LD	C,0		;prepare for special search.
3472+  D8AD EB              EX	DE,HL
3473+  D8AE 7E              LD	A,(HL)		;is first byte a '?'?
3474+  D8AF FE 3F           CP	'?'
3475+  D8B1 CA C2 D8        JP	Z,GETFST1	;yes, just get very first entry (zero length match).
3476+  D8B4 CD A6 D0        CALL	SETEXT		;get the extension byte from fcb.
3477+  D8B7 7E              LD	A,(HL)		;is it '?'? if yes, then we want
3478+  D8B8 FE 3F           CP	'?'		;an entry with a specific 's2' byte.
3479+  D8BA C4 72 D1        CALL	NZ,CLEARS2	;otherwise, look for a zero 's2' byte.
3480+  D8BD CD 51 D8        CALL	AUTOSEL		;select proper drive.
3481+  D8C0 0E 0F           LD	C,15		;compare bytes 0-14 in fcb (12&13 excluded).
3482+  D8C2 CD 18 D3    GETFST1:CALL	FINDFST		;find an entry and then move it into
3483+  D8C5 C3 E9 D1        JP	MOVEDIR		;the users dma space.
3484+  D8C8             ;
3485+  D8C8             ;   Function to return the next occurence of a file name.
3486+  D8C8             ;
3487+  D8C8 2A D9 D9    GETNXT:	LD	HL,(SAVEFCB)	;restore pointers. note that no
3488+  D8CB 22 43 CF        LD	(PARAMS),HL	;other dbos calls are allowed.
3489+  D8CE CD 51 D8        CALL	AUTOSEL		;no error will be returned, but the
3490+  D8D1 CD 2D D3        CALL	FINDNXT		;results will be wrong.
3491+  D8D4 C3 E9 D1        JP	MOVEDIR
3492+  D8D7             ;
3493+  D8D7             ;   Function to delete a file by name.
3494+  D8D7             ;
3495+  D8D7 CD 51 D8    DELFILE:CALL	AUTOSEL		;select proper drive.
3496+  D8DA CD 9C D3        CALL	ERAFILE		;erase the file.
3497+  D8DD C3 01 D3        JP	STSTATUS	;set status and return.
3498+  D8E0             ;
3499+  D8E0             ;   Function to execute a sequential read of the specified
3500+  D8E0             ; record number.
3501+  D8E0             ;
3502+  D8E0 CD 51 D8    READSEQ:CALL	AUTOSEL		;select proper drive then read.
3503+  D8E3 C3 BC D5        JP	RDSEQ
3504+  D8E6             ;
3505+  D8E6             ;   Function to write the net sequential record.
3506+  D8E6             ;
3507+  D8E6 CD 51 D8    WRTSEQ:	CALL	AUTOSEL		;select proper drive then write.
3508+  D8E9 C3 FE D5        JP	WTSEQ
3509+  D8EC             ;
3510+  D8EC             ;   Create a file function.
3511+  D8EC             ;
3512+  D8EC CD 72 D1    FCREATE:CALL	CLEARS2		;clear the 's2' byte on all creates.
3513+  D8EF CD 51 D8        CALL	AUTOSEL		;select proper drive and get the next
3514+  D8F2 C3 24 D5        JP	GETEMPTY	;empty directory space.
3515+  D8F5             ;
3516+  D8F5             ;   Function to rename a file.
3517+  D8F5             ;
3518+  D8F5 CD 51 D8    RENFILE:CALL	AUTOSEL		;select proper drive and then switch
3519+  D8F8 CD 16 D4        CALL	CHGNAMES	;file names.
3520+  D8FB C3 01 D3        JP	STSTATUS
3521+  D8FE             ;
3522+  D8FE             ;   Function to return the login vector.
3523+  D8FE             ;
3524+  D8FE 2A AF D9    GETLOG:	LD	HL,(LOGIN)
3525+  D901 C3 29 D9        JP	GETPRM1
3526+  D904             ;
3527+  D904             ;   Function to return the current disk assignment.
3528+  D904             ;
3529+  D904 3A 42 CF    GETCRNT:LD	A,(ACTIVE)
3530+  D907 C3 01 CF        JP	SETSTAT
3531+  D90A             ;
3532+  D90A             ;   Function to set the dma address.
3533+  D90A             ;
3534+  D90A EB          PUTDMA:	EX	DE,HL
3535+  D90B 22 B1 D9        LD	(USERDMA),HL	;save in our space and then get to
3536+  D90E C3 DA D1        JP	DEFDMA		;the bios with this also.
3537+  D911             ;
3538+  D911             ;   Function to return the allocation vector.
3539+  D911             ;
3540+  D911 2A BF D9    GETALOC:LD	HL,(ALOCVECT)
3541+  D914 C3 29 D9        JP	GETPRM1
3542+  D917             ;
3543+  D917             ;   Function to return the read-only status vector.
3544+  D917             ;
3545+  D917 2A AD D9    GETROV:	LD	HL,(WRTPRT)
3546+  D91A C3 29 D9        JP	GETPRM1
3547+  D91D             ;
3548+  D91D             ;   Function to set the file attributes (read-only, system).
3549+  D91D             ;
3550+  D91D CD 51 D8    SETATTR:CALL	AUTOSEL		;select proper drive then save attributes.
3551+  D920 CD 3B D4        CALL	SAVEATTR
3552+  D923 C3 01 D3        JP	STSTATUS
3553+  D926             ;
3554+  D926             ;   Function to return the address of the disk parameter block
3555+  D926             ; for the current drive.
3556+  D926             ;
3557+  D926 2A BB D9    GETPARM:LD	HL,(DISKPB)
3558+  D929 22 45 CF    GETPRM1:LD	(STATUS),HL
3559+  D92C C9              RET
3560+  D92D             ;
3561+  D92D             ;   Function to get or set the user number. If (E) was (FF)
3562+  D92D             ; then this is a request to return the current user number.
3563+  D92D             ; Else set the user number from (E).
3564+  D92D             ;
3565+  D92D 3A D6 D9    GETUSER:LD	A,(EPARAM)	;get parameter.
3566+  D930 FE FF           CP	0FFH		;get user number?
3567+  D932 C2 3B D9        JP	NZ,SETUSER
3568+  D935 3A 41 CF        LD	A,(USERNO)	;yes, just do it.
3569+  D938 C3 01 CF        JP	SETSTAT
3570+  D93B E6 1F       SETUSER:AND	1FH		;no, we should set it instead. keep low
3571+  D93D 32 41 CF        LD	(USERNO),A	;bits (0-4) only.
3572+  D940 C9              RET
3573+  D941             ;
3574+  D941             ;   Function to read a random record from a file.
3575+  D941             ;
3576+  D941 CD 51 D8    RDRANDOM: CALL	AUTOSEL		;select proper drive and read.
3577+  D944 C3 93 D7        JP	READRAN
3578+  D947             ;
3579+  D947             ;   Function to compute the file size for random files.
3580+  D947             ;
3581+  D947 CD 51 D8    WTRANDOM: CALL	AUTOSEL		;select proper drive and write.
3582+  D94A C3 9C D7        JP	WRITERAN
3583+  D94D             ;
3584+  D94D             ;   Function to compute the size of a random file.
3585+  D94D             ;
3586+  D94D CD 51 D8    FILESIZE: CALL	AUTOSEL		;select proper drive and check file length
3587+  D950 C3 D2 D7        JP	RANSIZE
3588+  D953             ;
3589+  D953             ;   Function #37. This allows a program to log off any drives.
3590+  D953             ; On entry, set (DE) to contain a word with bits set for those
3591+  D953             ; drives that are to be logged off. The log-in vector and the
3592+  D953             ; write protect vector will be updated. This must be a M/PM
3593+  D953             ; special function.
3594+  D953             ;
3595+  D953 2A 43 CF    LOGOFF:	LD	HL,(PARAMS)	;get drives to log off.
3596+  D956 7D              LD	A,L		;for each bit that is set, we want
3597+  D957 2F              CPL			;to clear that bit in (LOGIN)
3598+  D958 5F              LD	E,A		;and (WRTPRT).
3599+  D959 7C              LD	A,H
3600+  D95A 2F              CPL
3601+  D95B 2A AF D9        LD	HL,(LOGIN)	;reset the login vector.
3602+  D95E A4              AND	H
3603+  D95F 57              LD	D,A
3604+  D960 7D              LD	A,L
3605+  D961 A3              AND	E
3606+  D962 5F              LD	E,A
3607+  D963 2A AD D9        LD	HL,(WRTPRT)
3608+  D966 EB              EX	DE,HL
3609+  D967 22 AF D9        LD	(LOGIN),HL	;and save.
3610+  D96A 7D              LD	A,L		;now do the write protect vector.
3611+  D96B A3              AND	E
3612+  D96C 6F              LD	L,A
3613+  D96D 7C              LD	A,H
3614+  D96E A2              AND	D
3615+  D96F 67              LD	H,A
3616+  D970 22 AD D9        LD	(WRTPRT),HL	;and save. all done.
3617+  D973 C9              RET
3618+  D974             ;
3619+  D974             ;   Get here to return to the user.
3620+  D974             ;
3621+  D974 3A DE D9    GOBACK:	LD	A,(AUTO)	;was auto select activated?
3622+  D977 B7              OR	A
3623+  D978 CA 91 D9        JP	Z,GOBACK1
3624+  D97B 2A 43 CF        LD	HL,(PARAMS)	;yes, but was a change made?
3625+  D97E 36 00           LD	(HL),0		;(* reset first byte of fcb *)
3626+  D980 3A E0 D9        LD	A,(AUTOFLAG)
3627+  D983 B7              OR	A
3628+  D984 CA 91 D9        JP	Z,GOBACK1
3629+  D987 77              LD	(HL),A		;yes, reset first byte properly.
3630+  D988 3A DF D9        LD	A,(OLDDRV)	;and get the old drive and select it.
3631+  D98B 32 D6 D9        LD	(EPARAM),A
3632+  D98E CD 45 D8        CALL	SETDSK
3633+  D991 2A 0F CF    GOBACK1:LD	HL,(USRSTACK)	;reset the users stack pointer.
3634+  D994 F9              LD	SP,HL
3635+  D995 2A 45 CF        LD	HL,(STATUS)	;get return status.
3636+  D998 7D              LD	A,L		;force version 1.4 compatability.
3637+  D999 44              LD	B,H
3638+  D99A C9              RET			;and go back to user.
3639+  D99B             ;
3640+  D99B             ;   Function #40. This is a special entry to do random i/o.
3641+  D99B             ; For the case where we are writing to unused disk space, this
3642+  D99B             ; space will be zeroed out first. This must be a M/PM special
3643+  D99B             ; purpose function, because why would any normal program even
3644+  D99B             ; care about the previous contents of a sector about to be
3645+  D99B             ; written over.
3646+  D99B             ;
3647+  D99B CD 51 D8    WTSPECL:CALL	AUTOSEL		;select proper drive.
3648+  D99E 3E 02           LD	A,2		;use special write mode.
3649+  D9A0 32 D5 D9        LD	(MODE),A
3650+  D9A3 0E 00           LD	C,0		;set write indicator.
3651+  D9A5 CD 07 D7        CALL	POSITN1		;position the file.
3652+  D9A8 CC 03 D6        CALL	Z,WTSEQ1	;and write (if no errors).
3653+  D9AB C9              RET
3654+  D9AC             ;
3655+  D9AC             ;**************************************************************
3656+  D9AC             ;*
3657+  D9AC             ;*     BDOS data storage pool.
3658+  D9AC             ;*
3659+  D9AC             ;**************************************************************
3660+  D9AC             ;
3661+  D9AC E5          EMPTYFCB: .DB	0E5H		;empty directory segment indicator.
3662+  D9AD 00 00       WRTPRT:	.DW	0		;write protect status for all 16 drives.
3663+  D9AF 00 00       LOGIN:	.DW	0		;drive active word (1 bit per drive).
3664+  D9B1 80 00       USERDMA:.DW	080H		;user's dma address (defaults to 80h).
3665+  D9B3             ;
3666+  D9B3             ;   Scratch areas from parameter block.
3667+  D9B3             ;
3668+  D9B3 00 00       SCRATCH1: .DW	0		;relative position within dir segment for file (0-3).
3669+  D9B5 00 00       SCRATCH2: .DW	0		;last selected track number.
3670+  D9B7 00 00       SCRATCH3: .DW	0		;last selected sector number.
3671+  D9B9             ;
3672+  D9B9             ;   Disk storage areas from parameter block.
3673+  D9B9             ;
3674+  D9B9 00 00       DIRBUF:	.DW	0		;address of directory buffer to use.
3675+  D9BB 00 00       DISKPB:	.DW	0		;contains address of disk parameter block.
3676+  D9BD 00 00       CHKVECT:.DW	0		;address of check vector.
3677+  D9BF 00 00       ALOCVECT: .DW	0		;address of allocation vector (bit map).
3678+  D9C1             ;
3679+  D9C1             ;   Parameter block returned from the bios.
3680+  D9C1             ;
3681+  D9C1 00 00       SECTORS:.DW	0		;sectors per track from bios.
3682+  D9C3 00          BLKSHFT:.DB	0		;block shift.
3683+  D9C4 00          BLKMASK:.DB	0		;block mask.
3684+  D9C5 00          EXTMASK:.DB	0		;extent mask.
3685+  D9C6 00 00       DSKSIZE:.DW	0		;disk size from bios (number of blocks-1).
3686+  D9C8 00 00       DIRSIZE:.DW	0		;directory size.
3687+  D9CA 00 00       ALLOC0:	.DW	0		;storage for first bytes of bit map (dir space used).
3688+  D9CC 00 00       ALLOC1:	.DW	0
3689+  D9CE 00 00       OFFSET:	.DW	0		;first usable track number.
3690+  D9D0 00 00       XLATE:	.DW	0		;sector translation table address.
3691+  D9D2             ;
3692+  D9D2             ;
3693+  D9D2 00          CLOSEFLG: .DB	0		;close flag (=0ffh is extent written ok).
3694+  D9D3 00          RDWRTFLG: .DB	0		;read/write flag (0ffh=read, 0=write).
3695+  D9D4 00          FNDSTAT:.DB	0		;filename found status (0=found first entry).
3696+  D9D5 00          MODE:	.DB	0		;I/o mode select (0=random, 1=sequential, 2=special random).
3697+  D9D6 00          EPARAM:	.DB	0		;storage for register (E) on entry to bdos.
3698+  D9D7 00          RELBLOCK: .DB	0		;relative position within fcb of block number written.
3699+  D9D8 00          COUNTER:.DB	0		;byte counter for directory name searches.
3700+  D9D9 00 00 00 00 SAVEFCB:.DW	0,0		;save space for address of fcb (for directory searches).
3701+  D9DD 00          BIGDISK:.DB	0		;if =0 then disk is > 256 blocks long.
3702+  D9DE 00          AUTO:	.DB	0		;if non-zero, then auto select activated.
3703+  D9DF 00          OLDDRV:	.DB	0		;on auto select, storage for previous drive.
3704+  D9E0 00          AUTOFLAG: .DB	0		;if non-zero, then auto select changed drives.
3705+  D9E1 00          SAVNXT:	.DB	0		;storage for next record number to access.
3706+  D9E2 00          SAVEXT:	.DB	0		;storage for extent number of file.
3707+  D9E3 00 00       SAVNREC:.DW	0		;storage for number of records in file.
3708+  D9E5 00 00       BLKNMBR:.DW	0		;block number (physical sector) used within a file or logical sect
3709+  D9E7 00 00       LOGSECT:.DW	0		;starting logical (128 byte) sector of block (physical sector).
3710+  D9E9 00          FCBPOS:	.DB	0		;relative position within buffer for fcb of file of interest.
3711+  D9EA 00 00       FILEPOS:.DW	0		;files position within directory (0 to max entries -1).
3712+  D9EC             ;
3713+  D9EC             ;   Disk directory buffer checksum bytes. One for each of the
3714+  D9EC             ; 16 possible drives.
3715+  D9EC             ;
3716+  D9EC 00 00 00 00 CKSUMTBL: .DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
3716+  D9F0 00 00 00 00 
3716+  D9F4 00 00 00 00 
3716+  D9F8 00 00 00 00 
3717+  D9FC             ;
3718+  D9FC             ;   Extra space ?
3719+  D9FC             ;
3720+  D9FC 00 00 00 00     .DB	0,0,0,0
3721+  DA00             ;
3722+  DA00             ;**************************************************************
3723+  DA00             ;*
3724+  DA00             ;*        B I O S   J U M P   T A B L E
3725+  DA00             ;*
3726+  DA00             ;**************************************************************
3727+  DA00             
3728+  DA00 C3 AC DE    BOOT:   JP BIOS_BOOT
3729+  DA03 C3 B4 DE    WBOOT:  JP BIOS_WBOOT
3730+  DA06 C3 C0 DE    CONST:  JP BIOS_CONST
3731+  DA09 C3 CF DE    CONIN:  JP BIOS_CONIN
3732+  DA0C C3 C3 DE    CONOUT: JP BIOS_CONOUT
3733+  DA0F C3 EE DE    LIST:   JP BIOS_LIST
3734+  DA12 C3 EF DE    PUNCH:  JP BIOS_PUNCH
3735+  DA15 C3 F0 DE    READER: JP BIOS_READER
3736+  DA18 C3 20 DD    HOME:   JP BIOS_HOME
3737+  DA1B C3 29 DD    SELDSK: JP BIOS_SELDSK
3738+  DA1E C3 4F DD    SETTRK: JP BIOS_SETTRK
3739+  DA21 C3 57 DD    SETSEC: JP BIOS_SETSEC
3740+  DA24 C3 5F DD    SETDMA: JP BIOS_SETDMA
3741+  DA27 C3 F0 DD    READ:   JP BIOS_READ
3742+  DA2A C3 6A DD    WRITE:  JP BIOS_WRITE
3743+  DA2D C3 EC DE    PRSTAT: JP BIOS_PRSTAT
3744+  DA30 C3 67 DD    SECTRN: JP BIOS_SECTRN
3745+  DA33             
3746+  DA33             ;**************************************************************
3747+  DA33             ;*
3748+  DA33             ;*           Conditional compilation configurable
3749+  DA33             ;*                DPH, DPB and static buffers
3750+  DA33             ;*               Support for 512 byte sectors
3751+  DA33             ;*                  2025 (c) Aleksey Morozov
3752+  DA33             ;*
3753+  DA33             ;**************************************************************
3754+  DA33             
3755+  DA33 00          ARG_SELDSK:	.DB 0
3756+  DA34 00 00       ARG_TRACK:	.DW 0
3757+  DA36 00 00       ARG_SECTOR_128:	.DW 0
3758+  DA38 00 00       ARG_SECTOR_512:	.DW 0
3759+  DA3A 00 00       ARG_DMA:	.DW 0
3760+  DA3C 00 00       ARG_DPB:	.DW 0
3761+  DA3E 00          NEW_COUNT:	.DB 0
3762+  DA3F 00          NEW_DISK:	.DB 0
3763+  DA40 00 00       NEW_TRACK:	.DW 0
3764+  DA42 00 00       NEW_SECTOR:	.DW 0
3765+  DA44 00          WRITE_MODE:	.DB 0
3766+  DA45 FF          BUFFER_DISK:	.DB -1
3767+  DA46 00 00       BUFFER_TRACK:	.DW 0
3768+  DA48 00 00       BUFFER_SECTOR:	.DW 0
3769+  DA4A 00          BUFFER_CHANGED:	.DB 0
3770+  DA4B             BUFFER:	.DS 512
3771+  DC4B             DIRBUF2:	.DS 128
3772+  DCCB             
3773+  DCCB             DPHLIST:
3774+  DCCB                 .DS 8
3775+  DCD3 4B DC           .DW DIRBUF2
3776+  DCD5 DB DC           .DW A_DPB
3777+  DCD7                 .IFNDEF A_FIXED
3778+  DCD7 EA DC           .DW A_CSV
3779+  DCD9~                .ELSE
3780+  DCD9~                .DW 0
3781+  DCD9                 .ENDIF
3782+  DCD9 F2 DC           .DW A_ALV
3783+  DCDB             
3784+  DCDB~                .IF STORAGE_COUNT >= 2
3785+  DCDB~                .DS 8
3786+  DCDB~                .DW DIRBUF2
3787+  DCDB~                .DW B_DPB
3788+  DCDB~                .IFNDEF B_FIXED
3789+  DCDB~                .DW B_CSV
3790+  DCDB~                .ELSE
3791+  DCDB~                .DW 0
3792+  DCDB~                .ENDIF
3793+  DCDB~                .DW B_ALV
3794+  DCDB                 .ENDIF
3795+  DCDB             
3796+  DCDB~                .IF STORAGE_COUNT >= 3
3797+  DCDB~                .DS 8
3798+  DCDB~                .DW DIRBUF2
3799+  DCDB~                .IFNDEF A_FIXED
3800+  DCDB~                .DW C_CSV
3801+  DCDB~                .ELSE
3802+  DCDB~                .DW 0
3803+  DCDB~                .ENDIF
3804+  DCDB~                .DW C_CSV
3805+  DCDB~                .DW C_ALV
3806+  DCDB                 .ENDIF
3807+  DCDB             
3808+  DCDB~                .IF STORAGE_COUNT >= 4
3809+  DCDB~                .DS 8
3810+  DCDB~                .DW DIRBUF2
3811+  DCDB~                .DW D_DPB
3812+  DCDB~                .IFNDEF D_FIXED
3813+  DCDB~                .DW D_CSV
3814+  DCDB~                .ELSE
3815+  DCDB~                .DW 0
3816+  DCDB~                .ENDIF
3817+  DCDB~                .DW D_ALV
3818+  DCDB                 .ENDIF
3819+  DCDB             
3820+  DCDB~                .IF STORAGE_COUNT > 4
3821+  DCDB~                Incorrect STORAGE_COUNT
3822+  DCDB                 .ENDIF
3823+  DCDB             
3824+  DCDB             CPM_ENTRY_SIZE = 32
3825+  DCDB             CPM_SECTOR_SIZE = 128
3826+  DCDB             
3827+  DCDB             A_FILES_COUNT = ((A_BLOCK_SIZE / CPM_ENTRY_SIZE) * A_DIRECTORY_BLOCKS)
3828+  DCDB             
3829+  DCDB             A_DPB:
3830+  DCDB                 ; SPT - Number of 128-byte records per track
3831+  DCDB~                .IFDEF A_SECTOR_PER_TRACK
3832+  DCDB~                .DW A_SECTOR_PER_TRACK
3833+  DCDB                 .ELSE
3834+  DCDB FF FF           .DW 0FFFFh
3835+  DCDD                 .ENDIF
3836+  DCDD                 ; BSH - Block shift. 3 => 1k,4 => 2k,5 => 4k....
3837+  DCDD                 ; BLM - Block mask. 7 => 1k,0Fh => 2k,1Fh => 4k...
3838+  DCDD                 ; ЕХМ - Extent mask
3839+  DCDD                 .IF A_BLOCK_SIZE = 1024
3840+  DCDD 03 07 00        .DB 3,07h,0
3841+  DCE0~                .IF A_BLOCK_COUNT >= 100h
3842+  DCE0~                Incorrect A_BLOCK_COUNT
3843+  DCE0                 .ENDIF
3844+  DCE0~                .ELSE
3845+  DCE0~                .IF A_BLOCK_SIZE = 2048
3846+  DCE0~                .DB 4,0Fh,1 >> (A_BLOCK_COUNT >= 100h)
3847+  DCE0~                .ELSE
3848+  DCE0~                .IF A_BLOCK_SIZE = 4096
3849+  DCE0~                .DB 5,1Fh,3 >> (A_BLOCK_COUNT >= 100h)
3850+  DCE0~                .ELSE
3851+  DCE0~                .IF A_BLOCK_SIZE = 8192
3852+  DCE0~                .DB 6,3Fh,7 >> (A_BLOCK_COUNT >= 100h)
3853+  DCE0~                .ELSE
3854+  DCE0~                .IF A_BLOCK_SIZE = 16384
3855+  DCE0~                .DB 7,7Fh,15 >> (A_BLOCK_COUNT >= 100h)
3856+  DCE0~                .ELSE
3857+  DCE0~                Incorrect A_BLOCK_SIZE
3858+  DCE0~                .ENDIF
3859+  DCE0~                .ENDIF
3860+  DCE0~                .ENDIF
3861+  DCE0~                .ENDIF
3862+  DCE0                 .ENDIF
3863+  DCE0                 ; DSM - (no. of blocks on the disc)-1
3864+  DCE0 38 00           .DW A_BLOCK_COUNT - 1
3865+  DCE2                 ; DRM - (no. of directory entries)-1
3866+  DCE2 1F 00           .DW A_FILES_COUNT - 1
3867+  DCE4                 ; AL - Directory allocation bitmap
3868+  DCE4 80              .DB (0FFFF00h >> A_DIRECTORY_BLOCKS) & 0FFh
3869+  DCE5 00              .DB (0FF0000h >> A_DIRECTORY_BLOCKS) & 0FFh
3870+  DCE6                 ; CKS - Checksum vector size,0 or 8000h for a fixed disc.
3871+  DCE6~                .IFDEF A_FIXED
3872+  DCE6~                .DW 0
3873+  DCE6                 .ELSE
3874+  DCE6 08 00           .DW (A_FILES_COUNT + 3) / 4
3875+  DCE8                 .ENDIF
3876+  DCE8                 ; OFF - Offset,number of reserved tracks
3877+  DCE8 00 00           .DW 0
3878+  DCEA             
3879+  DCEA                 .IFNDEF A_FIXED
3880+  DCEA             A_CSV:	.DS (A_FILES_COUNT + 3) / 4
3881+  DCF2                 .ENDIF
3882+  DCF2             A_ALV:	.DS (A_BLOCK_COUNT + 7) / 8
3883+  DCFA             
3884+  DCFA~                .IF STORAGE_COUNT >= 2
3885+  DCFA~            B_FILES_COUNT = ((B_BLOCK_SIZE / CPM_ENTRY_SIZE) * B_DIRECTORY_BLOCKS)
3886+  DCFA~            
3887+  DCFA~            B_DPB:
3888+  DCFA~                ; SPT - Number of 128-byte records per track
3889+  DCFA~                .IFDEF B_SECTOR_PER_TRACK
3890+  DCFA~                .DW B_SECTOR_PER_TRACK
3891+  DCFA~                .ELSE
3892+  DCFA~                .DW 0FFFFh
3893+  DCFA~                .ENDIF
3894+  DCFA~                ; BSH - Block shift. 3 => 1k,4 => 2k,5 => 4k....
3895+  DCFA~                ; BLM - Block mask. 7 => 1k,0Fh => 2k,1Fh => 4k...
3896+  DCFA~                ; ЕХМ - Extent mask
3897+  DCFA~                .IF B_BLOCK_SIZE = 1024
3898+  DCFA~                .DB 3,07h,0
3899+  DCFA~                .IF B_BLOCK_COUNT >= 100h
3900+  DCFA~                Incorrect B_BLOCK_COUNT
3901+  DCFA~                .ENDIF
3902+  DCFA~                .ELSE
3903+  DCFA~                .IF B_BLOCK_SIZE = 2048
3904+  DCFA~                .DB 4,0Fh,1 >> (B_BLOCK_COUNT >= 100h)
3905+  DCFA~                .ELSE
3906+  DCFA~                .IF B_BLOCK_SIZE = 4096
3907+  DCFA~                .DB 5,1Fh,3 >> (B_BLOCK_COUNT >= 100h)
3908+  DCFA~                .ELSE
3909+  DCFA~                .IF B_BLOCK_SIZE = 8192
3910+  DCFA~                .DB 6,3Fh,7 >> (B_BLOCK_COUNT >= 100h)
3911+  DCFA~                .ELSE
3912+  DCFA~                .IF B_BLOCK_SIZE = 16384
3913+  DCFA~                .DB 7,7Fh,15 >> (B_BLOCK_COUNT >= 100h)
3914+  DCFA~                .ELSE
3915+  DCFA~                Incorrect B_BLOCK_SIZE
3916+  DCFA~                .ENDIF
3917+  DCFA~                .ENDIF
3918+  DCFA~                .ENDIF
3919+  DCFA~                .ENDIF
3920+  DCFA~                .ENDIF
3921+  DCFA~                ; DSM - (no. of blocks on the disc)-1
3922+  DCFA~                .DW B_BLOCK_COUNT - 1
3923+  DCFA~                ; DRM - (no. of directory entries)-1
3924+  DCFA~                .DW B_FILES_COUNT - 1
3925+  DCFA~                ; AL - Directory allocation bitmap
3926+  DCFA~                .DB (0FFFF00h >> B_DIRECTORY_BLOCKS) & 0FFh
3927+  DCFA~                .DB (0FF0000h >> B_DIRECTORY_BLOCKS) & 0FFh
3928+  DCFA~                ; CKS - Checksum vector size,0 or 8000h for a fixed disc.
3929+  DCFA~                .IFDEF B_FIXED
3930+  DCFA~                .DW 0
3931+  DCFA~                .ELSE
3932+  DCFA~                .DW (B_FILES_COUNT + 3) / 4
3933+  DCFA~                .ENDIF
3934+  DCFA~                ; OFF - Offset,number of reserved tracks
3935+  DCFA~                .DW 0
3936+  DCFA~            
3937+  DCFA~                .IFNDEF B_FIXED
3938+  DCFA~            B_CSV:	.DS (B_FILES_COUNT + 3) / 4
3939+  DCFA~                .ENDIF
3940+  DCFA~            B_ALV:	.DS (B_BLOCK_COUNT + 7) / 8
3941+  DCFA                 .ENDIF
3942+  DCFA             
3943+  DCFA~                .IF STORAGE_COUNT >= 3
3944+  DCFA~            ; TODO
3945+  DCFA~                .IFNDEF C_FIXED
3946+  DCFA~            C_CSV:	.DS (C_FILES_COUNT + 3) / 4
3947+  DCFA~                .ENDIF
3948+  DCFA~            C_ALV:	.DS (C_BLOCK_COUNT + 7) / 8
3949+  DCFA                 .ENDIF
3950+  DCFA             
3951+  DCFA~                .IF STORAGE_COUNT >= 4
3952+  DCFA~            ; TODO
3953+  DCFA~                .IFNDEF D_FIXED
3954+  DCFA~            D_CSV:	.DS (D_FILES_COUNT + 3) / 4
3955+  DCFA~                .ENDIF
3956+  DCFA~            D_ALV:	.DS (D_BLOCK_COUNT + 7) / 8
3957+  DCFA                 .ENDIF
3958+  DCFA             
3959+  DCFA             ;**************************************************************
3960+  DCFA             ;*
3961+  DCFA             ;*		B I O S   D E F A U L T   R O U T I N E S
3962+  DCFA             ;*
3963+  DCFA             ;**************************************************************
3964+  DCFA             
3965+  DCFA             RUNCPM:
3966+  DCFA 79              LD	A,C
3967+  DCFB 32 04 00        LD	(TDRIVE),A
3968+  DCFE 3E C3           LD	A,0C3h ; JMP OPCODE
3969+  DD00 32 00 00        LD	(0),A
3970+  DD03 21 03 DA        LD	HL,WBOOT
3971+  DD06 22 01 00        LD	(1),HL
3972+  DD09 32 05 00        LD	(5),A
3973+  DD0C 21 06 CC        LD	HL,FBASE
3974+  DD0F 22 06 00        LD	(6),HL
3975+  DD12 21 80 00        LD	HL,TBUFF
3976+  DD15 22 3A DA        LD	(ARG_DMA),HL
3977+  DD18 3E 81           LD	A,81h
3978+  DD1A 32 03 00        LD	(IOBYTE),a
3979+  DD1D C3 00 C4        JP	CBASE
3980+  DD20             
3981+  DD20             BIOS_HOME:
3982+  DD20 E5              PUSH	HL
3983+  DD21 21 00 00        LD	HL,0
3984+  DD24 22 34 DA        LD	(ARG_TRACK),HL
3985+  DD27 E1              POP	HL
3986+  DD28 C9              RET
3987+  DD29             
3988+  DD29             BIOS_SELDSK:
3989+  DD29 79              LD	A,C		; check device number
3990+  DD2A FE 01           CP	STORAGE_COUNT
3991+  DD2C 21 00 00        LD	HL,0
3992+  DD2F D0              RET	NC
3993+  DD30 32 04 00        LD	(TDRIVE),A	; save current device number
3994+  DD33 32 33 DA        LD	(ARG_SELDSK),A
3995+  DD36 6F              LD	L,A		; calc DPH address
3996+  DD37 29              ADD	HL,HL
3997+  DD38 29              ADD	HL,HL
3998+  DD39 29              ADD	HL,HL
3999+  DD3A 29              ADD	HL,HL
4000+  DD3B D5              PUSH	DE
4001+  DD3C 11 CB DC        LD	DE,DPHLIST
4002+  DD3F 19              ADD	HL,DE
4003+  DD40 E5              PUSH	HL		; save DPB address
4004+  DD41 11 0A 00        LD	DE,10
4005+  DD44 19              ADD	HL,DE
4006+  DD45 5E              LD	E,(HL)
4007+  DD46 23              INC	HL
4008+  DD47 56              LD	D,(HL)
4009+  DD48 EB              EX	HL,DE
4010+  DD49 22 3C DA        LD	(ARG_DPB),HL
4011+  DD4C E1              POP	HL
4012+  DD4D D1              POP	DE
4013+  DD4E C9              RET
4014+  DD4F             
4015+  DD4F             BIOS_SETTRK:
4016+  DD4F E5              PUSH	HL
4017+  DD50 60              LD	H,B
4018+  DD51 69              LD	L,C
4019+  DD52 22 34 DA        LD	(ARG_TRACK),HL
4020+  DD55 E1              POP	HL
4021+  DD56 C9              RET
4022+  DD57             
4023+  DD57             BIOS_SETSEC:
4024+  DD57 E5              PUSH	HL
4025+  DD58 60              LD	H,B
4026+  DD59 69              LD	L,C
4027+  DD5A 22 36 DA        LD	(ARG_SECTOR_128),HL
4028+  DD5D E1              POP	HL
4029+  DD5E C9              RET
4030+  DD5F             
4031+  DD5F             BIOS_SETDMA:
4032+  DD5F E5              PUSH	HL
4033+  DD60 60              LD	H,B
4034+  DD61 69              LD	L,C
4035+  DD62 22 3A DA        LD	(ARG_DMA),HL
4036+  DD65 E1              POP	HL
4037+  DD66 C9              RET
4038+  DD67             
4039+  DD67             BIOS_SECTRN:
4040+  DD67 60              LD	H,B
4041+  DD68 69              LD	L,C
4042+  DD69 C9              RET
4043+  DD6A             
4044+  DD6A             ;
4045+  DD6A             ;**************************************************************
4046+  DD6A             ;*
4047+  DD6A             ;*           F I L E   A P P E N D   O P T I M I Z A T I O N
4048+  DD6A             ;*
4049+  DD6A             ;**************************************************************
4050+  DD6A             ;
4051+  DD6A             
4052+  DD6A             BIOS_WRITE:
4053+  DD6A C5              PUSH	BC
4054+  DD6B D5              PUSH	DE
4055+  DD6C E5              PUSH	HL
4056+  DD6D             
4057+  DD6D                 ; Дополнительная информация от CP/M:
4058+  DD6D                 ; 0 - Запись данных можно отложить
4059+  DD6D                 ; 1 - Нужно записать все данные на дискету сейчас
4060+  DD6D                 ; 2 - Запись в блок файловой системы,который до этого не использовался
4061+  DD6D                 ; Сообщается только о первом 128-секторе 2048 байтного блока.
4062+  DD6D 79              LD	A,C
4063+  DD6E 32 44 DA        LD	(WRITE_MODE),A
4064+  DD71             
4065+  DD71                 ; Если это запись в блок файловой системы, который до этого не
4066+  DD71                 ; использовался, то взводится счетчик блокирующий чтение с дискеты
4067+  DD71 FE 02           CP	2
4068+  DD73 CA C9 DD        JP	Z,BIOS_WRITE_FIRST_NEW
4069+  DD76             
4070+  DD76                 ; Если счетчик равен нулю, то читаем как обычно
4071+  DD76 3A 3E DA        LD	A,(NEW_COUNT)
4072+  DD79 B7              OR	A
4073+  DD7A CA E6 DD        JP	Z,BIOS_WRITE_STOP_NEW
4074+  DD7D             
4075+  DD7D                 ; С каждой записью уменьшается счетчик
4076+  DD7D 3D              DEC	A
4077+  DD7E 32 3E DA        LD	(NEW_COUNT),A
4078+  DD81             
4079+  DD81                 ; Если изменился диск, дорожка или сектор, то счетчик сбрасывается
4080+  DD81 3A 3F DA        LD	A,(NEW_DISK)
4081+  DD84 21 33 DA        LD	HL,ARG_SELDSK
4082+  DD87 BE              CP	(HL)
4083+  DD88 C2 E6 DD        JP	NZ,BIOS_WRITE_STOP_NEW
4084+  DD8B             
4085+  DD8B 2A 40 DA        LD	HL,(NEW_TRACK)
4086+  DD8E 11 34 DA        LD	DE,ARG_TRACK
4087+  DD91 CD 9E DE        CALL	CMP_HL_PDE
4088+  DD94 C2 E6 DD        JP	NZ,BIOS_WRITE_STOP_NEW
4089+  DD97             
4090+  DD97 2A 42 DA        LD	HL,(NEW_SECTOR)
4091+  DD9A 11 36 DA        LD	DE,ARG_SECTOR_128
4092+  DD9D CD 9E DE        CALL	CMP_HL_PDE
4093+  DDA0 C2 E6 DD        JP	NZ,BIOS_WRITE_STOP_NEW
4094+  DDA3             
4095+  DDA3             BIOS_WRITE_NEW:
4096+  DDA3                 ; С каждой записью увеличивается номер сектора
4097+  DDA3 23              INC	HL
4098+  DDA4 22 42 DA        LD	(NEW_SECTOR),HL
4099+  DDA7             
4100+  DDA7                 ; Переход на следующую дорожку
4101+  DDA7 EB              EX	HL,DE
4102+  DDA8 2A 3C DA        LD	HL,(ARG_DPB)
4103+  DDAB EB              EX	HL,DE
4104+  DDAC CD 9E DE        CALL	CMP_HL_PDE
4105+  DDAF C2 BF DD        JP	NZ,BIOS_WRITE_TRACK
4106+  DDB2 21 00 00        LD	HL,0
4107+  DDB5 22 42 DA        LD	(NEW_SECTOR),HL ; TODO: Можно сохранять один раз в конце
4108+  DDB8 2A 40 DA        LD	HL,(NEW_TRACK)
4109+  DDBB 23              INC	HL
4110+  DDBC 22 40 DA        LD	(NEW_TRACK),HL
4111+  DDBF             BIOS_WRITE_TRACK:
4112+  DDBF             
4113+  DDBF 01 00 00        LD	BC,0  ; Режим работы - запись, чтение запрещено
4114+  DDC2             
4115+  DDC2             BIOS_WRITE_END:
4116+  DDC2 CD 06 DE        CALL	BUFFER_WORK
4117+  DDC5             
4118+  DDC5 E1              POP     HL
4119+  DDC6 D1              POP     DE
4120+  DDC7 C1              POP     BC
4121+  DDC8 C9              RET
4122+  DDC9             
4123+  DDC9             BIOS_WRITE_FIRST_NEW:
4124+  DDC9 2A 3C DA        LD	HL,(ARG_DPB)
4125+  DDCC 11 03 00        LD  DE,	3
4126+  DDCF 19              ADD HL, DE
4127+  DDD0 7E              LD	A,(HL)	; Get block mask. 7 => 1k, 0Fh => 2k, 1Fh => 4k...
4128+  DDD1 32 3E DA        LD	(NEW_COUNT),A
4129+  DDD4 3A 33 DA        LD	A,(ARG_SELDSK)
4130+  DDD7 32 3F DA        LD	(NEW_DISK),A
4131+  DDDA 2A 34 DA        LD	HL,(ARG_TRACK)
4132+  DDDD 22 40 DA        LD	(NEW_TRACK),HL
4133+  DDE0 2A 36 DA        LD	HL,(ARG_SECTOR_128)
4134+  DDE3 C3 A3 DD        JP	BIOS_WRITE_NEW
4135+  DDE6             
4136+  DDE6             BIOS_WRITE_STOP_NEW:
4137+  DDE6                 ; Сброс счетчика блокирующего чтение с дискеты
4138+  DDE6 AF              XOR	A
4139+  DDE7 32 3E DA        LD	(NEW_COUNT),A
4140+  DDEA 01 01 00        LD	BC,1  ; Режим работы - обычная запись
4141+  DDED C3 C2 DD        JP	BIOS_WRITE_END
4142+  DDF0             
4143+  DDF0             ;**************************************************************
4144+  DDF0             
4145+  DDF0             BIOS_READ:
4146+  DDF0 C5              PUSH	BC
4147+  DDF1 D5              PUSH	DE
4148+  DDF2 E5              PUSH	HL
4149+  DDF3             
4150+  DDF3                 ; Сброс счетчика блокирующего чтение с дискеты
4151+  DDF3 AF              XOR	A
4152+  DDF4 32 3E DA        LD	(NEW_COUNT),A
4153+  DDF7             
4154+  DDF7 CD FE DD        CALL	BUFFER_READ
4155+  DDFA             
4156+  DDFA E1              POP     HL
4157+  DDFB D1              POP     DE
4158+  DDFC C1              POP     BC
4159+  DDFD C9              RET
4160+  DDFE             
4161+  DDFE             ;
4162+  DDFE             ;**************************************************************
4163+  DDFE             ;*
4164+  DDFE             ;*           5 1 2   B Y T E   S E C T O R S
4165+  DDFE             ;*
4166+  DDFE             ;**************************************************************
4167+  DDFE             ;
4168+  DDFE             
4169+  DDFE             BUFFER_READ:
4170+  DDFE                 ; Режим работы - чтение с дискеты в буфер
4171+  DDFE 3E 02           LD	A,2
4172+  DE00 32 44 DA        LD	(WRITE_MODE),A
4173+  DE03 01 01 01        LD	BC,101h
4174+  DE06             
4175+  DE06             BUFFER_WORK:
4176+  DE06                 ; Вычисление номера реального 512-байтного сектора
4177+  DE06 51              LD  D, C
4178+  DE07 2A 36 DA        LD	HL,(ARG_SECTOR_128)
4179+  DE0A 0E 02           LD  C, 2
4180+  DE0C CD EA D0        CALL	SHIFTR
4181+  DE0F 22 38 DA        LD	(ARG_SECTOR_512),HL
4182+  DE12 4A              LD  C, D
4183+  DE13             
4184+  DE13                 ; Если в буфере нет данных, то переходим на загрузку
4185+  DE13 3A 45 DA        LD	A,(BUFFER_DISK)
4186+  DE16 FE FF           CP	-1
4187+  DE18 CA 43 DE        JP	Z,BUFFER_WORK_3
4188+  DE1B             
4189+  DE1B                 ; Если в буфере не тот диск, дорожка, сектор, то сохраняем буфер
4190+  DE1B                 ; и загружем другой сектор
4191+  DE1B 21 33 DA        LD	HL,ARG_SELDSK
4192+  DE1E BE              CP	(HL)
4193+  DE1F C2 3A DE        JP	NZ,BUFFER_WORK_2
4194+  DE22             
4195+  DE22 2A 34 DA        LD	HL,(ARG_TRACK)
4196+  DE25 11 46 DA        LD	DE,BUFFER_TRACK
4197+  DE28 CD 9E DE        CALL	CMP_HL_PDE
4198+  DE2B C2 3A DE        JP	NZ,BUFFER_WORK_2
4199+  DE2E             
4200+  DE2E 2A 38 DA        LD	HL,(ARG_SECTOR_512)
4201+  DE31 11 48 DA        LD	DE,BUFFER_SECTOR
4202+  DE34 CD 9E DE        CALL	CMP_HL_PDE
4203+  DE37 CA 62 DE        JP	Z,BUFFER_WORK_5
4204+  DE3A             
4205+  DE3A             BUFFER_WORK_2:
4206+  DE3A                 ; Если нужно сохранить буфер, то сохраняем
4207+  DE3A 3A 4A DA        LD	A,(BUFFER_CHANGED)
4208+  DE3D B7              OR	A
4209+  DE3E C4 94 DE        CALL	NZ,BUFFER_WORK_7
4210+  DE41 B7              OR	A
4211+  DE42 C0              RET	NZ
4212+  DE43             
4213+  DE43             BUFFER_WORK_3:
4214+  DE43                 ; Информация о новом секторе
4215+  DE43 AF              XOR	A
4216+  DE44 32 4A DA        LD	(BUFFER_CHANGED),A
4217+  DE47 3A 33 DA        LD	A,(ARG_SELDSK)
4218+  DE4A 32 45 DA        LD	(BUFFER_DISK),A
4219+  DE4D 2A 34 DA        LD	HL,(ARG_TRACK)
4220+  DE50 22 46 DA        LD	(BUFFER_TRACK),HL
4221+  DE53 2A 38 DA        LD	HL,(ARG_SECTOR_512)
4222+  DE56 22 48 DA        LD	(BUFFER_SECTOR),HL
4223+  DE59             
4224+  DE59                 ; Если разрешено загрузить в буфер, то загружаем
4225+  DE59 79              LD	A,C
4226+  DE5A B7              OR	A
4227+  DE5B C5              PUSH	BC
4228+  DE5C C4 F3 DE        CALL	NZ,BIOS_READ_512
4229+  DE5F C1              POP	BC
4230+  DE60 B7              OR	A
4231+  DE61 C0              RET	NZ ; TODO: Очистить буфер
4232+  DE62             
4233+  DE62             BUFFER_WORK_5:
4234+  DE62                 ; Вычисляем адрес 128 байтного сектора в буфере
4235+  DE62 3A 36 DA        LD	A,(ARG_SECTOR_128)
4236+  DE65 E6 03           AND	3
4237+  DE67 67              LD	H,A
4238+  DE68 2E 00           LD	L,0
4239+  DE6A 0E 01           LD  C, 1
4240+  DE6C CD EA D0        CALL	SHIFTR
4241+  DE6F 11 4B DA        LD	DE,BUFFER
4242+  DE72 19              ADD	HL,DE
4243+  DE73 EB              EX	HL,DE
4244+  DE74             
4245+  DE74                 ; Читаем или записываем 128 байтный сектор
4246+  DE74 2A 3A DA        LD	HL,(ARG_DMA)
4247+  DE77 0E 80           LD	C,CPM_SECTOR_SIZE
4248+  DE79 78              LD	A,B ; 0 - запись, 1 - чтение
4249+  DE7A B7              OR	A
4250+  DE7B C2 84 DE        JP	NZ,BUFFER_WORK_6
4251+  DE7E 3E 01           LD	A,1
4252+  DE80 32 4A DA        LD	(BUFFER_CHANGED),A
4253+  DE83 EB              EX	HL,DE
4254+  DE84             BUFFER_WORK_6:
4255+  DE84 1A              LD	A,(DE)
4256+  DE85 13              INC	DE
4257+  DE86 77              LD	(HL),A
4258+  DE87 23              INC	HL
4259+  DE88 0D              DEC	C
4260+  DE89 C2 84 DE        JP	NZ,BUFFER_WORK_6
4261+  DE8C             
4262+  DE8C                 ; Если CP/M не требует сохранить буфер сейчас,то выходим
4263+  DE8C 3A 44 DA        LD	A,(WRITE_MODE) ; Разместить в регистре WRITE_MODE
4264+  DE8F FE 01           CP	1
4265+  DE91 3E 00           LD	A,0
4266+  DE93 C0              RET	NZ
4267+  DE94             
4268+  DE94             BUFFER_WORK_7:
4269+  DE94                 ; Записываем сектор на дискету
4270+  DE94 C5              PUSH	BC
4271+  DE95 AF              XOR	A
4272+  DE96 32 4A DA        LD	(BUFFER_CHANGED),A
4273+  DE99 CD 21 DF        CALL	BIOS_WRITE_512
4274+  DE9C C1              POP	BC
4275+  DE9D C9              RET
4276+  DE9E             
4277+  DE9E             ;
4278+  DE9E             ;**************************************************************
4279+  DE9E             ;*
4280+  DE9E             ;*           M I S C   F U N C T I O N S
4281+  DE9E             ;*
4282+  DE9E             ;**************************************************************
4283+  DE9E             ;
4284+  DE9E             
4285+  DE9E             CMP_HL_PDE:
4286+  DE9E 1A              LD	A,(DE)
4287+  DE9F BD              CP	L
4288+  DEA0 C0              RET	NZ
4289+  DEA1 13              INC	DE
4290+  DEA2 1A              LD	A,(DE)
4291+  DEA3 BC              CP	H
4292+  DEA4 C9              RET
0078   DEA5             
0079   DEA5             ;----------------------------------------------------------------------------
0080   DEA5             
0081   DEA5             boot:
0082   DEA5                 ; Включение ОЗУ
0083   DEA5 3E 04           ld   a, PORT_ROM__ENABLE_RAM
0084   DEA7 D3 FF           out  (PORT_ROM), a
0085   DEA9             
0086   DEA9 C3 FA DC        jp   RUNCPM
0087   DEAC             
0088   DEAC             ;----------------------------------------------------------------------------
0089   DEAC             
0090   DEAC             BIOS_BOOT:
0091   DEAC                 ; Выключение прерываний
0092   DEAC F3              di
0093   DEAD             
0094   DEAD                 ; Включение ПЗУ
0095   DEAD 3E 00           ld   a, PORT_ROM__ENABLE_ROM
0096   DEAF D3 FF           out  (PORT_ROM), a
0097   DEB1             
0098   DEB1                 ; Перезагрузка всего компьютера
0099   DEB1 C3 00 00        jp   cold_boot
0100   DEB4             
0101   DEB4             ;----------------------------------------------------------------------------
0102   DEB4             
0103   DEB4             BIOS_WBOOT:
0104   DEB4                 ; Выключение прерываний
0105   DEB4 F3              di
0106   DEB5             
0107   DEB5                 ; Сохранение выбранного диска
0108   DEB5 3A 04 00        ld   a, (TDRIVE)
0109   DEB8 4F              ld   c, a
0110   DEB9             
0111   DEB9                 ; Включение ПЗУ
0112   DEB9 3E 00           ld   a, PORT_ROM__ENABLE_ROM
0113   DEBB D3 FF           out  (PORT_ROM), a
0114   DEBD             
0115   DEBD                 ; Перезагрузка CP/M
0116   DEBD C3 09 00        jp   warm_boot
0117   DEC0             
0118   DEC0             ;----------------------------------------------------------------------------
0119   DEC0             
0120   DEC0             BIOS_CONST:
0121   DEC0 C3 12 F8        jp   BIOS_CHECK_KEY
0122   DEC3             
0123   DEC3             ;----------------------------------------------------------------------------
0124   DEC3             
0125   DEC3             BIOS_CONOUT:
0126   DEC3                 ; Кодировка ASCII -> Микро80
0127   DEC3 F5              push af
0128   DEC4 79              ld   a, c
0129   DEC5 FE 60           cp   060h
0130   DEC7 D4 D5 DE        call nc, CODEPAGE
0131   DECA 4F              ld   c, a
0132   DECB F1              pop  af
0133   DECC C3 09 F8        jp   BIOS_PRINT_CHAR
0134   DECF             
0135   DECF             ;----------------------------------------------------------------------------
0136   DECF             
0137   DECF             BIOS_CONIN:
0138   DECF CD 03 F8        call BIOS_READ_KEY
0139   DED2             
0140   DED2                 ; Кодировка ASCII -> Микро80
0141   DED2 FE 60           cp   060h
0142   DED4 D8              ret  c
0143   DED5             
0144   DED5             ;----------------------------------------------------------------------------
0145   DED5             
0146   DED5             CODEPAGE:
0147   DED5 FE 7F           cp   7Fh
0148   DED7 CA E9 DE        jp   z, CODEPAGE_2
0149   DEDA D2 E0 DE        jp   nc, CODEPAGE_1
0150   DEDD C6 60           add  060h
0151   DEDF C9              ret
0152   DEE0             CODEPAGE_1:
0153   DEE0 FE C0           cp   0C0h
0154   DEE2 D8              ret  c
0155   DEE3 FE E0           cp   0E0h
0156   DEE5 D0              ret  nc
0157   DEE6 D6 60           sub  060h
0158   DEE8 C9              ret
0159   DEE9             CODEPAGE_2:
0160   DEE9 3E 08           ld   a, 8
0161   DEEB C9              ret
0162   DEEC             
0163   DEEC             ;----------------------------------------------------------------------------
0164   DEEC             
0165   DEEC             BIOS_PRSTAT:
0166   DEEC AF              xor  a ; Принтер не готов
0167   DEED C9              ret
0168   DEEE             
0169   DEEE             ;----------------------------------------------------------------------------
0170   DEEE             
0171   DEEE             BIOS_LIST:
0172   DEEE C9              ret ; Принтер
0173   DEEF             
0174   DEEF             ;----------------------------------------------------------------------------
0175   DEEF             
0176   DEEF             BIOS_PUNCH:
0177   DEEF C9              ret ; RS232
0178   DEF0             
0179   DEF0             ;----------------------------------------------------------------------------
0180   DEF0             
0181   DEF0             BIOS_READER:
0182   DEF0 3E 1A           ld  a, 26
0183   DEF2 C9              ret ; RS232
0184   DEF3             
0185   DEF3             ;----------------------------------------------------------------------------
0186   DEF3             
0187   DEF3             BIOS_READ_512:
0188   DEF3                 ; Вычисление номера сектора
0189   DEF3 2A 48 DA        ld   hl, (BUFFER_SECTOR)
0190   DEF6 11 0E 00        ld   de, ROM_STORAGE_ADDRESS / 512
0191   DEF9 19              add  hl, de
0192   DEFA 45              ld   b, l
0193   DEFB             
0194   DEFB                 ; Выбор страницы ПЗУ
0195   DEFB 29              add  hl, hl
0196   DEFC 29              add  hl, hl
0197   DEFD 7C              ld   a, h
0198   DEFE 87              add  a
0199   DEFF 87              add  a
0200   DF00 87              add  a
0201   DF01 D3 FF           out  (PORT_ROM), a
0202   DF03             
0203   DF03                 ; Вычисление адреса сектора в памяти
0204   DF03 78              ld   a, b
0205   DF04 E6 3F           and  3Fh
0206   DF06 87              add  a
0207   DF07 67              ld   h, a
0208   DF08 2E 00           ld   l, 0
0209   DF0A             
0210   DF0A                 ; Скопировать туда
0211   DF0A 11 4B DA        ld   de, BUFFER
0212   DF0D             
0213   DF0D                 ; Копирование сектора из ПЗУ в ОЗУ
0214   DF0D 0E 00           ld   c, 0
0215   DF0F             BIOS_READ_1:
0216   DF0F 7E              ld   a, (hl)
0217   DF10 12              ld   (de), a
0218   DF11 23              inc  hl
0219   DF12 13              inc  de
0220   DF13 7E              ld   a, (hl)
0221   DF14 12              ld   (de), a
0222   DF15 23              inc  hl
0223   DF16 13              inc  de
0224   DF17 0D              dec  c
0225   DF18 C2 0F DF        jp   nz, BIOS_READ_1
0226   DF1B             
0227   DF1B                 ; Выключение ПЗУ
0228   DF1B 3E 04           ld   a, PORT_ROM__ENABLE_RAM
0229   DF1D D3 FF           out  (PORT_ROM), a
0230   DF1F             
0231   DF1F                 ; Код ошибки - Нет ошибки
0232   DF1F AF              xor  a
0233   DF20 C9              ret
0234   DF21             
0235   DF21             ;----------------------------------------------------------------------------
0236   DF21             
0237   DF21             BIOS_WRITE_512:
0238   DF21                 ; Код ошибки - Все полохо
0239   DF21 3E 01           ld   a, 1
0240   DF23 C9              ret
0241   DF24             
0242   DF24             ;----------------------------------------------------------------------------
0243   DF24             
0244   DF24~                .IF $ >= 0E000h
0245   DF24~                CPM_ADDRESS too big
0246   DF24                 .ENDIF
0247   DF24             
0248   DF24             end:
0249   DF24                 .end
tasm: Number of errors = 0
