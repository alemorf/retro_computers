0001   0000                 device zxspectrum48 ; It has nothing to do with ZX Spectrum 48K, it is needed for the sjasmplus compiler.
0002   0000             rst30opcode equ 48
0003   0000             rst30address equ 49
0004   0000             rst38opcode equ 56
0005   0000             rst38address equ 57
0006   0000             cursor equ 63322
0007   0000             tapereadspeed equ 63324
0008   0000             tapewritespeed equ 63325
0009   0000             cursorvisible equ 63326
0010   0000             escstate equ 63327
0011   0000             keydelay equ 63328
0012   0000             regpc equ 63330
0013   0000             reghl equ 63332
0014   0000             regbc equ 63334
0015   0000             regde equ 63336
0016   0000             regsp equ 63338
0017   0000             regaf equ 63340
0018   0000             breakpointaddress equ 63345
0019   0000             breakpointvalue equ 63347
0020   0000             jmpparam1opcode equ 63348
0021   0000             param1 equ 63349
0022   0000             param2 equ 63351
0023   0000             param3 equ 63353
0024   0000             param2exists equ 63355
0025   0000             tapepolarity equ 63356
0026   0000             translatecodeenabled equ 63357
0027   0000             translatecodepagejump equ 63358
0028   0000             translatecodepageaddress equ 63359
0029   0000             ramtop equ 63361
0030   0000             inputbuffer equ 63363
0031   0000             jmpparam1 equ 63348
0032   0000             translatecodepage equ 63358
0033   0000              .org 0xF800
0034   F800             ; 52  uint8_t rst30Opcode __address(0x30);
0035   F800             ; 53 extern uint16_t rst30Address __address(0x31);
0036   F800             ; 54 extern uint8_t rst38Opcode __address(0x38);
0037   F800             ; 55 extern uint16_t rst38Address __address(0x39);
0038   F800             ; 56 
0039   F800             ; 57 // Прототипы
0040   F800             ; 58 void Reboot(...);
0041   F800             ; 59 void EntryF86C_Monitor(...);
0042   F800             ; 60 void Reboot2(...);
0043   F800             ; 61 void Monitor(...);
0044   F800             ; 62 void Monitor2();
0045   F800             ; 63 void ReadStringBackspace(...);
0046   F800             ; 64 void ReadString(...);
0047   F800             ; 65 void ReadStringBegin(...);
0048   F800             ; 66 void ReadStringLoop(...);
0049   F800             ; 67 void ReadStringExit(...);
0050   F800             ; 68 void PrintString(...);
0051   F800             ; 69 void ParseParams(...);
0052   F800             ; 70 void ParseWord(...);
0053   F800             ; 71 void ParseWordReturnCf(...);
0054   F800             ; 72 void CompareHlDe(...);
0055   F800             ; 73 void LoopWithBreak(...);
0056   F800             ; 74 void Loop(...);
0057   F800             ; 75 void PopRet();
0058   F800             ; 76 void IncHl(...);
0059   F800             ; 77 void CtrlC(...);
0060   F800             ; 78 void PrintCrLfTab();
0061   F800             ; 79 void PrintHexByteFromHlSpace(...);
0062   F800             ; 80 void PrintHexByteSpace(...);
0063   F800             ; 81 void CmdR(...);
0064   F800             ; 82 void GetRamTop(...);
0065   F800             ; 83 void SetRamTop(...);
0066   F800             ; 84 void CmdA(...);
0067   F800             ; 85 void CmdD(...);
0068   F800             ; 86 void PrintSpacesTo(...);
0069   F800             ; 87 void PrintSpace();
0070   F800             ; 88 void CmdC(...);
0071   F800             ; 89 void CmdF(...);
0072   F800             ; 90 void CmdS(...);
0073   F800             ; 91 void CmdW(...);
0074   F800             ; 92 void CmdT(...);
0075   F800             ; 93 void CmdM(...);
0076   F800             ; 94 void CmdG(...);
0077   F800             ; 95 void BreakPointHandler(...);
0078   F800             ; 96 void CmdX(...);
0079   F800             ; 97 void GetCursor();
0080   F800             ; 98 void GetCursorChar();
0081   F800             ; 99 void CmdH(...);
0082   F800             ; 100 void CmdI(...);
0083   F800             ; 101 void MonitorError();
0084   F800             ; 102 void ReadTapeFile(...);
0085   F800             ; 103 void ReadTapeWordNext();
0086   F800             ; 104 void ReadTapeWord(...);
0087   F800             ; 105 void ReadTapeBlock(...);
0088   F800             ; 106 void CalculateCheckSum(...);
0089   F800             ; 107 void CmdO(...);
0090   F800             ; 108 void WriteTapeFile(...);
0091   F800             ; 109 void PrintCrLfTabHexWordSpace(...);
0092   F800             ; 110 void PrintHexWordSpace(...);
0093   F800             ; 111 void WriteTapeBlock(...);
0094   F800             ; 112 void WriteTapeWord(...);
0095   F800             ; 113 void ReadTapeByte(...);
0096   F800             ; 114 void ReadTapeByteInternal(...);
0097   F800             ; 115 void ReadTapeByteTimeout(...);
0098   F800             ; 116 void WriteTapeByte(...);
0099   F800             ; 117 void PrintHexByte(...);
0100   F800             ; 118 void PrintHexNibble(...);
0101   F800             ; 119 void PrintCharA(...);
0102   F800             ; 120 void PrintChar(...);
0103   F800             ; 121 void PrintCharSetEscState(...);
0104   F800             ; 122 void PrintCharSaveCursor(...);
0105   F800             ; 123 void PrintCharExit(...);
0106   F800             ; 124 void DrawCursor(...);
0107   F800             ; 125 void PrintCharEscY2(...);
0108   F800             ; 126 void PrintCharResetEscState(...);
0109   F800             ; 127 void PrintCharEsc(...);
0110   F800             ; 128 void SetCursorVisible(...);
0111   F800             ; 129 void PrintCharNoEsc(...);
0112   F800             ; 130 void PrintChar4(...);
0113   F800             ; 131 void ClearScreen(...);
0114   F800             ; 132 void MoveCursorHome(...);
0115   F800             ; 133 void PrintChar3(...);
0116   F800             ; 134 void PrintCharBeep(...);
0117   F800             ; 135 void MoveCursorCr(...);
0118   F800             ; 136 void MoveCursorRight(...);
0119   F800             ; 137 void MoveCursorBoundary(...);
0120   F800             ; 138 void MoveCursorLeft(...);
0121   F800             ; 139 void MoveCursorLf(...);
0122   F800             ; 140 void MoveCursorUp(...);
0123   F800             ; 141 void MoveCursor(...);
0124   F800             ; 142 void MoveCursorDown(...);
0125   F800             ; 143 void PrintCrLf();
0126   F800             ; 144 void IsAnyKeyPressed();
0127   F800             ; 145 void ReadKey();
0128   F800             ; 146 void ReadKeyInternal(...);
0129   F800             ; 147 void ScanKey();
0130   F800             ; 148 void ScanKey2(...);
0131   F800             ; 149 void ScanKeyExit(...);
0132   F800             ; 150 void ScanKeyControl(...);
0133   F800             ; 151 void ScanKeyShift(...);
0134   F800             ; 152 void ScanKeySpecial(...);
0135   F800             ; 153 void TranslateCodePageDefault(...);
0136   F800             ; 154 
0137   F800             ; 155 // Переменные Монитора
0138   F800             ; 156 
0139   F800             ; 157 extern uint16_t cursor __address(0xF75A);
0140   F800             ; 158 extern uint8_t tapeReadSpeed __address(0xF75C);
0141   F800             ; 159 extern uint8_t tapeWriteSpeed __address(0xF75D);
0142   F800             ; 160 extern uint8_t cursorVisible __address(0xF75E);
0143   F800             ; 161 extern uint8_t escState __address(0xF75F);
0144   F800             ; 162 extern uint16_t keyDelay __address(0xF760);
0145   F800             ; 163 extern uint16_t regPC __address(0xF762);
0146   F800             ; 164 extern uint16_t regHL __address(0xF764);
0147   F800             ; 165 extern uint16_t regBC __address(0xF766);
0148   F800             ; 166 extern uint16_t regDE __address(0xF768);
0149   F800             ; 167 extern uint16_t regSP __address(0xF76A);
0150   F800             ; 168 extern uint16_t regAF __address(0xF76C);
0151   F800             ; 169 extern uint16_t breakPointAddress __address(0xF771);
0152   F800             ; 170 extern uint8_t breakPointValue __address(0xF773);
0153   F800             ; 171 extern uint8_t jmpParam1Opcode __address(0xF774);
0154   F800             ; 172 extern uint16_t param1 __address(0xF775);
0155   F800             ; 173 extern uint16_t param2 __address(0xF777);
0156   F800             ; 174 extern uint16_t param3 __address(0xF779);
0157   F800             ; 175 extern uint8_t param2Exists __address(0xF77B);
0158   F800             ; 176 extern uint8_t tapePolarity __address(0xF77C);
0159   F800             ; 177 extern uint8_t translateCodeEnabled __address(0xF77D);
0160   F800             ; 178 extern uint8_t translateCodePageJump __address(0xF77E);
0161   F800             ; 179 extern uint16_t translateCodePageAddress __address(0xF77F);
0162   F800             ; 180 extern uint16_t ramTop __address(0xF781);
0163   F800             ; 181 extern uint8_t inputBuffer[32] __address(0xF783);
0164   F800             ; 182 
0165   F800             ; 183 #define firstVariableAddress (&tapeWriteSpeed)
0166   F800             ; 184 #define lastVariableAddress (&inputBuffer[sizeof(inputBuffer) - 1])
0167   F800             ; 185 
0168   F800             ; 186 extern uint8_t specialKeyTable[8];
0169   F800             ; 187 extern uint8_t aPrompt[6];
0170   F800             ; 188 extern uint8_t aCrLfTab[6];
0171   F800             ; 189 extern uint8_t aRegisters[37];
0172   F800             ; 190 extern uint8_t aBackspace[4];
0173   F800             ; 191 extern uint8_t aHello[9];
0174   F800             ; 192 
0175   F800             ; 193 // Для удобства
0176   F800             ; 194 
0177   F800             ; 195 void JmpParam1() __address(0xF774);
0178   F800             ; 196 void TranslateCodePage() __address(0xF77E);
0179   F800             ; 197 
0180   F800             ; 198 // Точки входа
0181   F800             ; 199 
0182   F800             ; 200 void EntryF800_Reboot() {
0183   F800             entryf800_reboot: 
0184   F800             ; 201     Reboot();
0185   F800 C3 36 F8    	jp reboot
0186   F803             ; 202 }
0187   F803             ; 203 
0188   F803             ; 204 void EntryF803_ReadKey() {
0189   F803             entryf803_readkey: 
0190   F803             ; 205     ReadKey();
0191   F803 C3 C8 FE    	jp readkey
0192   F806             ; 206 }
0193   F806             ; 207 
0194   F806             ; 208 void EntryF806_ReadTapeByte(...) {
0195   F806             entryf806_readtapebyte: 
0196   F806             ; 209     ReadTapeByte(a);
0197   F806 C3 74 FC    	jp readtapebyte
0198   F809             ; 210 }
0199   F809             ; 211 
0200   F809             ; 212 void EntryF809_PrintChar(...) {
0201   F809             entryf809_printchar: 
0202   F809             ; 213     PrintChar(c);
0203   F809 C3 23 FD    	jp printchar
0204   F80C             ; 214 }
0205   F80C             ; 215 
0206   F80C             ; 216 void EntryF80C_WriteTapeByte(...) {
0207   F80C             entryf80c_writetapebyte: 
0208   F80C             ; 217     WriteTapeByte(c);
0209   F80C C3 DD FC    	jp writetapebyte
0210   F80F             ; 218 }
0211   F80F             ; 219 
0212   F80F             ; 220 void EntryF80F_TranslateCodePage(...) {
0213   F80F             entryf80f_translatecodepage: 
0214   F80F             ; 221     TranslateCodePage(c);
0215   F80F C3 7E F7    	jp translatecodepage
0216   F812             ; 222 }
0217   F812             ; 223 
0218   F812             ; 224 void EntryF812_IsAnyKeyPressed() {
0219   F812             entryf812_isanykeypressed: 
0220   F812             ; 225     IsAnyKeyPressed();
0221   F812 C3 B7 FE    	jp isanykeypressed
0222   F815             ; 226 }
0223   F815             ; 227 
0224   F815             ; 228 void EntryF815_PrintHexByte(...) {
0225   F815             entryf815_printhexbyte: 
0226   F815             ; 229     PrintHexByte(a);
0227   F815 C3 0E FD    	jp printhexbyte
0228   F818             ; 230 }
0229   F818             ; 231 
0230   F818             ; 232 void EntryF818_PrintString(...) {
0231   F818             entryf818_printstring: 
0232   F818             ; 233     PrintString(hl);
0233   F818 C3 48 F9    	jp printstring
0234   F81B             ; 234 }
0235   F81B             ; 235 
0236   F81B             ; 236 void EntryF81B_ScanKey() {
0237   F81B             entryf81b_scankey: 
0238   F81B             ; 237     ScanKey();
0239   F81B C3 FE FE    	jp scankey
0240   F81E             ; 238 }
0241   F81E             ; 239 
0242   F81E             ; 240 void EntryF81E_GetCursor() {
0243   F81E             entryf81e_getcursor: 
0244   F81E             ; 241     GetCursor();
0245   F81E C3 49 FB    	jp getcursor
0246   F821             ; 242 }
0247   F821             ; 243 
0248   F821             ; 244 void EntryF821_GetCursorChar() {
0249   F821             entryf821_getcursorchar: 
0250   F821             ; 245     GetCursorChar();
0251   F821 C3 5E FB    	jp getcursorchar
0252   F824             ; 246 }
0253   F824             ; 247 
0254   F824             ; 248 void EntryF824_ReadTapeFile(...) {
0255   F824             entryf824_readtapefile: 
0256   F824             ; 249     ReadTapeFile(hl);
0257   F824 C3 BA FB    	jp readtapefile
0258   F827             ; 250 }
0259   F827             ; 251 
0260   F827             ; 252 void EntryF827_WriteTapeFile(...) {
0261   F827             entryf827_writetapefile: 
0262   F827             ; 253     WriteTapeFile(bc, de, hl);
0263   F827 C3 24 FC    	jp writetapefile
0264   F82A             ; 254 }
0265   F82A             ; 255 
0266   F82A             ; 256 void EntryF82A_CalculateCheckSum(...) {
0267   F82A             entryf82a_calculatechecksum: 
0268   F82A             ; 257     CalculateCheckSum(hl, de);
0269   F82A C3 F1 FB    	jp calculatechecksum
0270   F82D             ; 258 }
0271   F82D             ; 259 
0272   F82D             ; 260 void EntryF82D_EnableScreen() {
0273   F82D             entryf82d_enablescreen: 
0274   F82D             ; 261     return;
0275   F82D C9          	ret
0276   F82E             ; 262     return;
0277   F82E C9          	ret
0278   F82F             ; 263     return;
0279   F82F C9          	ret
0280   F830             ; 264 }
0281   F830             ; 265 
0282   F830             ; 266 void EntryF830_GetRamTop() {
0283   F830             entryf830_getramtop: 
0284   F830             ; 267     GetRamTop();
0285   F830 C3 FA F9    	jp getramtop
0286   F833             ; 268 }
0287   F833             ; 269 
0288   F833             ; 270 void EntryF833_SetRamTop(...) {
0289   F833             entryf833_setramtop: 
0290   F833             ; 271     SetRamTop(hl);
0291   F833 C3 FE F9    	jp setramtop
0292   F836             ; 272 }
0293   F836             ; 273 
0294   F836             ; 274 // Инициализация. Выполняется после перезагрузки или пользовательской программой.
0295   F836             ; 275 // Параметры: нет. Функция никогда не завершается.
0296   F836             ; 276 
0297   F836             ; 277 void Reboot(...) {
0298   F836             reboot: 
0299   F836             ; 278     sp = STACK_TOP;
0300   F836 31 00 F8    	ld sp, 63488
0301   F839             ; 279 
0302   F839             ; 280     // Очистка памяти
0303   F839             ; 281     hl = firstVariableAddress;
0304   F839 21 5D F7    	ld hl, 0FFFFh & (tapewritespeed)
0305   F83C             ; 282     de = lastVariableAddress;
0306   F83C 11 A2 F7    	ld de, 0FFFFh & ((inputbuffer) + (31))
0307   F83F             ; 283     bc = 0;
0308   F83F 01 00 00    	ld bc, 0
0309   F842             ; 284     CmdF();
0310   F842 CD 82 FA    	call cmdf
0311   F845             ; 285 
0312   F845             ; 286     translateCodePageJump = a = OPCODE_JMP;
0313   F845 3E C3       	ld a, 195
0314   F847 32 7E F7    	ld (translatecodepagejump), a
0315   F84A             ; 287 
0316   F84A             ; 288     PrintString(hl = aHello);
0317   F84A 21 D4 FF    	ld hl, 0FFFFh & (ahello)
0318   F84D CD 48 F9    	call printstring
0319   F850             ; 289 
0320   F850             ; 290     // Проверка ОЗУ
0321   F850             ; 291     hl = 0;
0322   F850 21 00 00    	ld hl, 0
0323   F853             ; 292     for (;;) {
0324   F853             l_1: 
0325   F853             ; 293         c = *hl;
0326   F853 4E          	ld c, (hl)
0327   F854             ; 294         a = 0x55;
0328   F854 3E 55       	ld a, 85
0329   F856             ; 295         *hl = a;
0330   F856 77          	ld (hl), a
0331   F857             ; 296         a ^= *hl;
0332   F857 AE          	xor (hl)
0333   F858             ; 297         b = a;
0334   F858 47          	ld b, a
0335   F859             ; 298         a = 0xAA;
0336   F859 3E AA       	ld a, 170
0337   F85B             ; 299         *hl = a;
0338   F85B 77          	ld (hl), a
0339   F85C             ; 300         a ^= *hl;
0340   F85C AE          	xor (hl)
0341   F85D             ; 301         a |= b;
0342   F85D B0          	or b
0343   F85E             ; 302         if (flag_nz)
0344   F85E             ; 303             return Reboot2();
0345   F85E C2 6F F8    	jp nz, reboot2
0346   F861             ; 304         *hl = c;
0347   F861 71          	ld (hl), c
0348   F862             ; 305         hl++;
0349   F862 23          	inc hl
0350   F863             ; 306         if ((a = h) == SCREEN_ATTRIB_BEGIN >> 8)
0351   F863 7C          	ld a, h
0352   F864 FE E0       	cp 65504
0353   F866             ; 307             return Reboot2();
0354   F866 CA 6F F8    	jp z, reboot2
0355   F869 C3 53 F8    	jp l_1
0356   F86C             ; 308     }
0357   F86C             ; 309 
0358   F86C             ; 310     Reboot2();
0359   F86C C3 6F F8    	jp reboot2
0360   F86F              .org 0xF86C
0361   F86C             ; 311 }
0362   F86C             ; 312 
0363   F86C             ; 313 asm(" .org 0xF86C");
0364   F86C             ; 314 
0365   F86C             ; 315 void EntryF86C_Monitor() {
0366   F86C             entryf86c_monitor: 
0367   F86C             ; 316     Monitor();
0368   F86C C3 88 F8    	jp monitor
0369   F86F             ; 317 }
0370   F86F             ; 318 
0371   F86F             ; 319 void Reboot2(...) {
0372   F86F             reboot2: 
0373   F86F             ; 320     hl--;
0374   F86F 2B          	dec hl
0375   F870             ; 321     ramTop = hl;
0376   F870 22 81 F7    	ld (ramtop), hl
0377   F873             ; 322     PrintHexWordSpace(hl);
0378   F873 CD 5A FC    	call printhexwordspace
0379   F876             ; 323     tapeReadSpeed = hl = TAPE_SPEED;
0380   F876 21 54 38    	ld hl, 14420
0381   F879 22 5C F7    	ld (tapereadspeed), hl
0382   F87C             ; 324     translateCodePageAddress = hl = &TranslateCodePageDefault;
0383   F87C 21 DD FF    	ld hl, 0FFFFh & (translatecodepagedefault)
0384   F87F 22 7F F7    	ld (translatecodepageaddress), hl
0385   F882             ; 325     regSP = hl = 0xF7FE;
0386   F882 21 FE F7    	ld hl, 63486
0387   F885 22 6A F7    	ld (regsp), hl
0388   F888             ; 326     Monitor();
0389   F888             ; 327 }
0390   F888             ; 328 
0391   F888             ; 329 void Monitor() {
0392   F888             monitor: 
0393   F888             ; 330     out(PORT_KEYBOARD_MODE, a = 0x83);
0394   F888 3E 83       	ld a, 131
0395   F88A D3 04       	out (4), a
0396   F88C             ; 331     cursorVisible = a;
0397   F88C 32 5E F7    	ld (cursorvisible), a
0398   F88F             ; 332     jmpParam1Opcode = a = OPCODE_JMP;
0399   F88F 3E C3       	ld a, 195
0400   F891 32 74 F7    	ld (jmpparam1opcode), a
0401   F894             ; 333     Monitor2();
0402   F894             ; 334 }
0403   F894             ; 335 
0404   F894             ; 336 void Monitor2() {
0405   F894             monitor2: 
0406   F894             ; 337     sp = STACK_TOP;
0407   F894 31 00 F8    	ld sp, 63488
0408   F897             ; 338     PrintString(hl = aPrompt);
0409   F897 21 9F FF    	ld hl, 0FFFFh & (aprompt)
0410   F89A CD 48 F9    	call printstring
0411   F89D             ; 339     ReadString();
0412   F89D CD 14 F9    	call readstring
0413   F8A0             ; 340 
0414   F8A0             ; 341     push(hl = &EntryF86C_Monitor);
0415   F8A0 21 6C F8    	ld hl, 0FFFFh & (entryf86c_monitor)
0416   F8A3 E5          	push hl
0417   F8A4             ; 342 
0418   F8A4             ; 343     hl = inputBuffer;
0419   F8A4 21 83 F7    	ld hl, 0FFFFh & (inputbuffer)
0420   F8A7             ; 344     a = *hl;
0421   F8A7 7E          	ld a, (hl)
0422   F8A8             ; 345 
0423   F8A8             ; 346     if (a == 'X')
0424   F8A8 FE 58       	cp 88
0425   F8AA             ; 347         return CmdX();
0426   F8AA CA 1C FB    	jp z, cmdx
0427   F8AD             ; 348 
0428   F8AD             ; 349     push_pop(a) {
0429   F8AD F5          	push af
0430   F8AE             ; 350         ParseParams();
0431   F8AE CD 52 F9    	call parseparams
0432   F8B1             ; 351         hl = param3;
0433   F8B1 2A 79 F7    	ld hl, (param3)
0434   F8B4             ; 352         c = l;
0435   F8B4 4D          	ld c, l
0436   F8B5             ; 353         b = h;
0437   F8B5 44          	ld b, h
0438   F8B6             ; 354         hl = param2;
0439   F8B6 2A 77 F7    	ld hl, (param2)
0440   F8B9             ; 355         swap(hl, de);
0441   F8B9 EB          	ex hl, de
0442   F8BA             ; 356         hl = param1;
0443   F8BA 2A 75 F7    	ld hl, (param1)
0444   F8BD F1          	pop af
0445   F8BE             ; 357     }
0446   F8BE             ; 358 
0447   F8BE             ; 359     if (a == 'D')
0448   F8BE FE 44       	cp 68
0449   F8C0             ; 360         return CmdD();
0450   F8C0 CA 06 FA    	jp z, cmdd
0451   F8C3             ; 361     if (a == 'C')
0452   F8C3 FE 43       	cp 67
0453   F8C5             ; 362         return CmdC();
0454   F8C5 CA 6C FA    	jp z, cmdc
0455   F8C8             ; 363     if (a == 'F')
0456   F8C8 FE 46       	cp 70
0457   F8CA             ; 364         return CmdF();
0458   F8CA CA 82 FA    	jp z, cmdf
0459   F8CD             ; 365     if (a == 'S')
0460   F8CD FE 53       	cp 83
0461   F8CF             ; 366         return CmdS();
0462   F8CF CA 89 FA    	jp z, cmds
0463   F8D2             ; 367     if (a == 'T')
0464   F8D2 FE 54       	cp 84
0465   F8D4             ; 368         return CmdT();
0466   F8D4 CA A6 FA    	jp z, cmdt
0467   F8D7             ; 369     if (a == 'M')
0468   F8D7 FE 4D       	cp 77
0469   F8D9             ; 370         return CmdM();
0470   F8D9 CA AF FA    	jp z, cmdm
0471   F8DC             ; 371     if (a == 'G')
0472   F8DC FE 47       	cp 71
0473   F8DE             ; 372         return CmdG();
0474   F8DE CA C8 FA    	jp z, cmdg
0475   F8E1             ; 373     if (a == 'I')
0476   F8E1 FE 49       	cp 73
0477   F8E3             ; 374         return CmdI();
0478   F8E3 CA 8A FB    	jp z, cmdi
0479   F8E6             ; 375     if (a == 'O')
0480   F8E6 FE 4F       	cp 79
0481   F8E8             ; 376         return CmdO();
0482   F8E8 CA 08 FC    	jp z, cmdo
0483   F8EB             ; 377     if (a == 'W')
0484   F8EB FE 57       	cp 87
0485   F8ED             ; 378         return CmdW();
0486   F8ED CA 94 FA    	jp z, cmdw
0487   F8F0             ; 379     if (a == 'A')
0488   F8F0 FE 41       	cp 65
0489   F8F2             ; 380         return CmdA();
0490   F8F2 CA 02 FA    	jp z, cmda
0491   F8F5             ; 381     if (a == 'H')
0492   F8F5 FE 48       	cp 72
0493   F8F7             ; 382         return CmdH();
0494   F8F7 CA 65 FB    	jp z, cmdh
0495   F8FA             ; 383     if (a == 'R')
0496   F8FA FE 52       	cp 82
0497   F8FC             ; 384         return CmdR();
0498   F8FC CA E6 F9    	jp z, cmdr
0499   F8FF             ; 385     return MonitorError();
0500   F8FF C3 B2 FB    	jp monitorerror
0501   F902             ; 386 }
0502   F902             ; 387 
0503   F902             ; 388 void ReadStringBackspace(...) {
0504   F902             readstringbackspace: 
0505   F902             ; 389     if ((a = inputBuffer) == l)
0506   F902 3E 83       	ld a, 0FFh & (inputbuffer)
0507   F904 BD          	cp l
0508   F905             ; 390         return ReadStringBegin(hl);
0509   F905 CA 17 F9    	jp z, readstringbegin
0510   F908             ; 391     push_pop(hl) {
0511   F908 E5          	push hl
0512   F909             ; 392         PrintString(hl = aBackspace);
0513   F909 21 D0 FF    	ld hl, 0FFFFh & (abackspace)
0514   F90C CD 48 F9    	call printstring
0515   F90F E1          	pop hl
0516   F910             ; 393     }
0517   F910             ; 394     hl--;
0518   F910 2B          	dec hl
0519   F911             ; 395     return ReadStringLoop(b, hl);
0520   F911 C3 19 F9    	jp readstringloop
0521   F914             ; 396 }
0522   F914             ; 397 
0523   F914             ; 398 void ReadString() {
0524   F914             readstring: 
0525   F914             ; 399     hl = inputBuffer;
0526   F914 21 83 F7    	ld hl, 0FFFFh & (inputbuffer)
0527   F917             ; 400     ReadStringBegin(hl);
0528   F917             ; 401 }
0529   F917             ; 402 
0530   F917             ; 403 void ReadStringBegin(...) {
0531   F917             readstringbegin: 
0532   F917             ; 404     b = 0;
0533   F917 06 00       	ld b, 0
0534   F919             ; 405     ReadStringLoop(b, hl);
0535   F919             ; 406 }
0536   F919             ; 407 
0537   F919             ; 408 void ReadStringLoop(...) {
0538   F919             readstringloop: 
0539   F919             ; 409     for (;;) {
0540   F919             l_4: 
0541   F919             ; 410         ReadKey();
0542   F919 CD C8 FE    	call readkey
0543   F91C             ; 411         if (a == 127)
0544   F91C FE 7F       	cp 127
0545   F91E             ; 412             return ReadStringBackspace();
0546   F91E CA 02 F9    	jp z, readstringbackspace
0547   F921             ; 413         if (a == 8)
0548   F921 FE 08       	cp 8
0549   F923             ; 414             return ReadStringBackspace();
0550   F923 CA 02 F9    	jp z, readstringbackspace
0551   F926             ; 415         if (flag_nz)
0552   F926             ; 416             PrintCharA(a);
0553   F926 C4 22 FD    	call nz, printchara
0554   F929             ; 417         *hl = a;
0555   F929 77          	ld (hl), a
0556   F92A             ; 418         if (a == 13)
0557   F92A FE 0D       	cp 13
0558   F92C             ; 419             return ReadStringExit(b);
0559   F92C CA 40 F9    	jp z, readstringexit
0560   F92F             ; 420         if (a == '.')
0561   F92F FE 2E       	cp 46
0562   F931             ; 421             return Monitor2();
0563   F931 CA 94 F8    	jp z, monitor2
0564   F934             ; 422         b = 255;
0565   F934 06 FF       	ld b, 255
0566   F936             ; 423         if ((a = inputBuffer + sizeof(inputBuffer) - 1) == l)
0567   F936 3E A2       	ld a, 0FFh & (((inputbuffer) + (32)) - (1))
0568   F938 BD          	cp l
0569   F939             ; 424             return MonitorError();
0570   F939 CA B2 FB    	jp z, monitorerror
0571   F93C             ; 425         hl++;
0572   F93C 23          	inc hl
0573   F93D C3 19 F9    	jp l_4
0574   F940             ; 426     }
0575   F940             ; 427 }
0576   F940             ; 428 
0577   F940             ; 429 void ReadStringExit(...) {
0578   F940             readstringexit: 
0579   F940             ; 430     a = b;
0580   F940 78          	ld a, b
0581   F941             ; 431     carry_rotate_left(a, 1);
0582   F941 17          	rla
0583   F942             ; 432     de = inputBuffer;
0584   F942 11 83 F7    	ld de, 0FFFFh & (inputbuffer)
0585   F945             ; 433     b = 0;
0586   F945 06 00       	ld b, 0
0587   F947 C9          	ret
0588   F948             ; 434 }
0589   F948             ; 435 
0590   F948             ; 436 // Функция для пользовательской программы.
0591   F948             ; 437 // Вывод строки на экран.
0592   F948             ; 438 // Параметры: hl - адрес стороки. Результат: hl - следующий адрес за терминатором строки. Сохраняются: b, de.
0593   F948             ; 439 
0594   F948             ; 440 void PrintString(...) {
0595   F948             printstring: 
0596   F948             ; 441     for (;;) {
0597   F948             l_7: 
0598   F948             ; 442         a = *hl;
0599   F948 7E          	ld a, (hl)
0600   F949             ; 443         if (flag_z(a &= a))
0601   F949 A7          	and a
0602   F94A             ; 444             return;
0603   F94A C8          	ret z
0604   F94B             ; 445         PrintCharA(a);
0605   F94B CD 22 FD    	call printchara
0606   F94E             ; 446         hl++;
0607   F94E 23          	inc hl
0608   F94F C3 48 F9    	jp l_7
0609   F952             ; 447     }
0610   F952             ; 448 }
0611   F952             ; 449 
0612   F952             ; 450 void ParseParams(...) {
0613   F952             parseparams: 
0614   F952             ; 451     hl = &param1;
0615   F952 21 75 F7    	ld hl, 0FFFFh & (param1)
0616   F955             ; 452     de = &param2Exists;
0617   F955 11 7B F7    	ld de, 0FFFFh & (param2exists)
0618   F958             ; 453     c = 0;
0619   F958 0E 00       	ld c, 0
0620   F95A             ; 454     CmdF();
0621   F95A CD 82 FA    	call cmdf
0622   F95D             ; 455 
0623   F95D             ; 456     de = inputBuffer + 1;
0624   F95D 11 84 F7    	ld de, 0FFFFh & ((inputbuffer) + (1))
0625   F960             ; 457 
0626   F960             ; 458     ParseWord();
0627   F960 CD 80 F9    	call parseword
0628   F963             ; 459     param1 = hl;
0629   F963 22 75 F7    	ld (param1), hl
0630   F966             ; 460     param2 = hl;
0631   F966 22 77 F7    	ld (param2), hl
0632   F969             ; 461     if (flag_c)
0633   F969             ; 462         return;
0634   F969 D8          	ret c
0635   F96A             ; 463 
0636   F96A             ; 464     param2Exists = a = 0xFF;
0637   F96A 3E FF       	ld a, 255
0638   F96C 32 7B F7    	ld (param2exists), a
0639   F96F             ; 465     ParseWord();
0640   F96F CD 80 F9    	call parseword
0641   F972             ; 466     param2 = hl;
0642   F972 22 77 F7    	ld (param2), hl
0643   F975             ; 467     if (flag_c)
0644   F975             ; 468         return;
0645   F975 D8          	ret c
0646   F976             ; 469 
0647   F976             ; 470     ParseWord();
0648   F976 CD 80 F9    	call parseword
0649   F979             ; 471     param3 = hl;
0650   F979 22 79 F7    	ld (param3), hl
0651   F97C             ; 472     if (flag_c)
0652   F97C             ; 473         return;
0653   F97C D8          	ret c
0654   F97D             ; 474 
0655   F97D             ; 475     MonitorError();
0656   F97D C3 B2 FB    	jp monitorerror
0657   F980             ; 476 }
0658   F980             ; 477 
0659   F980             ; 478 void ParseWord(...) {
0660   F980             parseword: 
0661   F980             ; 479     hl = 0;
0662   F980 21 00 00    	ld hl, 0
0663   F983             ; 480     for (;;) {
0664   F983             l_10: 
0665   F983             ; 481         a = *de;
0666   F983 1A          	ld a, (de)
0667   F984             ; 482         de++;
0668   F984 13          	inc de
0669   F985             ; 483         if (a == 13)
0670   F985 FE 0D       	cp 13
0671   F987             ; 484             return ParseWordReturnCf(hl);
0672   F987 CA B4 F9    	jp z, parsewordreturncf
0673   F98A             ; 485         if (a == ',')
0674   F98A FE 2C       	cp 44
0675   F98C             ; 486             return;
0676   F98C C8          	ret z
0677   F98D             ; 487         if (a == ' ')
0678   F98D FE 20       	cp 32
0679   F98F             ; 488             continue;
0680   F98F CA 83 F9    	jp z, l_10
0681   F992             ; 489         a -= '0';
0682   F992 D6 30       	sub 48
0683   F994             ; 490         if (flag_m)
0684   F994             ; 491             return MonitorError();
0685   F994 FA B2 FB    	jp m, monitorerror
0686   F997             ; 492         if (flag_p(compare(a, 10))) {
0687   F997 FE 0A       	cp 10
0688   F999 FA A8 F9    	jp m, l_12
0689   F99C             ; 493             if (flag_m(compare(a, 17)))
0690   F99C FE 11       	cp 17
0691   F99E             ; 494                 return MonitorError();
0692   F99E FA B2 FB    	jp m, monitorerror
0693   F9A1             ; 495             if (flag_p(compare(a, 23)))
0694   F9A1 FE 17       	cp 23
0695   F9A3             ; 496                 return MonitorError();
0696   F9A3 F2 B2 FB    	jp p, monitorerror
0697   F9A6             ; 497             a -= 7;
0698   F9A6 D6 07       	sub 7
0699   F9A8             l_12: 
0700   F9A8             ; 498         }
0701   F9A8             ; 499         c = a;
0702   F9A8 4F          	ld c, a
0703   F9A9             ; 500         hl += hl;
0704   F9A9 29          	add hl, hl
0705   F9AA             ; 501         hl += hl;
0706   F9AA 29          	add hl, hl
0707   F9AB             ; 502         hl += hl;
0708   F9AB 29          	add hl, hl
0709   F9AC             ; 503         hl += hl;
0710   F9AC 29          	add hl, hl
0711   F9AD             ; 504         if (flag_c)
0712   F9AD             ; 505             return MonitorError();
0713   F9AD DA B2 FB    	jp c, monitorerror
0714   F9B0             ; 506         hl += bc;
0715   F9B0 09          	add hl, bc
0716   F9B1 C3 83 F9    	jp l_10
0717   F9B4             ; 507     }
0718   F9B4             ; 508 }
0719   F9B4             ; 509 
0720   F9B4             ; 510 void ParseWordReturnCf(...) {
0721   F9B4             parsewordreturncf: 
0722   F9B4             ; 511     set_flag_c();
0723   F9B4 37          	scf
0724   F9B5 C9          	ret
0725   F9B6             ; 512 }
0726   F9B6             ; 513 
0727   F9B6             ; 514 void CompareHlDe(...) {
0728   F9B6             comparehlde: 
0729   F9B6             ; 515     if ((a = h) != d)
0730   F9B6 7C          	ld a, h
0731   F9B7 BA          	cp d
0732   F9B8             ; 516         return;
0733   F9B8 C0          	ret nz
0734   F9B9             ; 517     compare(a = l, e);
0735   F9B9 7D          	ld a, l
0736   F9BA BB          	cp e
0737   F9BB C9          	ret
0738   F9BC             ; 518 }
0739   F9BC             ; 519 
0740   F9BC             ; 520 void LoopWithBreak(...) {
0741   F9BC             loopwithbreak: 
0742   F9BC             ; 521     CtrlC();
0743   F9BC CD CA F9    	call ctrlc
0744   F9BF             ; 522     Loop(hl, de);
0745   F9BF             ; 523 }
0746   F9BF             ; 524 
0747   F9BF             ; 525 void Loop(...) {
0748   F9BF             loop: 
0749   F9BF             ; 526     CompareHlDe(hl, de);
0750   F9BF CD B6 F9    	call comparehlde
0751   F9C2             ; 527     if (flag_nz)
0752   F9C2             ; 528         return IncHl(hl);
0753   F9C2 C2 C8 F9    	jp nz, inchl
0754   F9C5             ; 529     PopRet();
0755   F9C5             ; 530 }
0756   F9C5             ; 531 
0757   F9C5             ; 532 void PopRet() {
0758   F9C5             popret: 
0759   F9C5             ; 533     sp++;
0760   F9C5 33          	inc sp
0761   F9C6             ; 534     sp++;
0762   F9C6 33          	inc sp
0763   F9C7 C9          	ret
0764   F9C8             ; 535 }
0765   F9C8             ; 536 
0766   F9C8             ; 537 void IncHl(...) {
0767   F9C8             inchl: 
0768   F9C8             ; 538     hl++;
0769   F9C8 23          	inc hl
0770   F9C9 C9          	ret
0771   F9CA             ; 539 }
0772   F9CA             ; 540 
0773   F9CA             ; 541 void CtrlC() {
0774   F9CA             ctrlc: 
0775   F9CA             ; 542     ScanKey();
0776   F9CA CD FE FE    	call scankey
0777   F9CD             ; 543     if (a != 3)  // УПР + C
0778   F9CD FE 03       	cp 3
0779   F9CF             ; 544         return;
0780   F9CF C0          	ret nz
0781   F9D0             ; 545     MonitorError();
0782   F9D0 C3 B2 FB    	jp monitorerror
0783   F9D3             ; 546 }
0784   F9D3             ; 547 
0785   F9D3             ; 548 void PrintCrLfTab() {
0786   F9D3             printcrlftab: 
0787   F9D3             ; 549     push_pop(hl) {
0788   F9D3 E5          	push hl
0789   F9D4             ; 550         PrintString(hl = aCrLfTab);
0790   F9D4 21 A5 FF    	ld hl, 0FFFFh & (acrlftab)
0791   F9D7 CD 48 F9    	call printstring
0792   F9DA E1          	pop hl
0793   F9DB C9          	ret
0794   F9DC             ; 551     }
0795   F9DC             ; 552 }
0796   F9DC             ; 553 
0797   F9DC             ; 554 void PrintHexByteFromHlSpace(...) {
0798   F9DC             printhexbytefromhlspace: 
0799   F9DC             ; 555     PrintHexByteSpace(a = *hl);
0800   F9DC 7E          	ld a, (hl)
0801   F9DD             ; 556 }
0802   F9DD             ; 557 
0803   F9DD             ; 558 void PrintHexByteSpace(...) {
0804   F9DD             printhexbytespace: 
0805   F9DD             ; 559     push_pop(bc) {
0806   F9DD C5          	push bc
0807   F9DE             ; 560         PrintHexByte(a);
0808   F9DE CD 0E FD    	call printhexbyte
0809   F9E1             ; 561         PrintSpace();
0810   F9E1 CD 67 FA    	call printspace
0811   F9E4 C1          	pop bc
0812   F9E5 C9          	ret
0813   F9E6             ; 562     }
0814   F9E6             ; 563 }
0815   F9E6             ; 564 
0816   F9E6             ; 565 // Команда R <начальный адрес ПЗУ> <конечный адрес ПЗУ> <начальный адрес назаначения>
0817   F9E6             ; 566 // Скопировать блок из внешнего ПЗУ в адресное пространство процессора
0818   F9E6             ; 567 
0819   F9E6             ; 568 void CmdR(...) {
0820   F9E6             cmdr: 
0821   F9E6             ; 569     out(PORT_EXT_MODE, a = 0x90);
0822   F9E6 3E 90       	ld a, 144
0823   F9E8 D3 A3       	out (163), a
0824   F9EA             ; 570     for (;;) {
0825   F9EA             l_15: 
0826   F9EA             ; 571         out(PORT_EXT_ADDR_LOW, a = l);
0827   F9EA 7D          	ld a, l
0828   F9EB D3 A1       	out (161), a
0829   F9ED             ; 572         out(PORT_EXT_ADDR_HIGH, a = h);
0830   F9ED 7C          	ld a, h
0831   F9EE D3 A2       	out (162), a
0832   F9F0             ; 573         *bc = a = in(PORT_EXT_DATA);
0833   F9F0 DB A0       	in a, (160)
0834   F9F2 02          	ld (bc), a
0835   F9F3             ; 574         bc++;
0836   F9F3 03          	inc bc
0837   F9F4             ; 575         Loop();
0838   F9F4 CD BF F9    	call loop
0839   F9F7 C3 EA F9    	jp l_15
0840   F9FA             ; 576     }
0841   F9FA             ; 577 }
0842   F9FA             ; 578 
0843   F9FA             ; 579 // Функция для пользовательской программы.
0844   F9FA             ; 580 // Получить адрес последнего доступного байта оперативной памяти.
0845   F9FA             ; 581 // Параметры: нет. Результат: hl - адрес. Сохраняет: a, bc, de.
0846   F9FA             ; 582 
0847   F9FA             ; 583 void GetRamTop(...) {
0848   F9FA             getramtop: 
0849   F9FA             ; 584     hl = ramTop;
0850   F9FA 2A 81 F7    	ld hl, (ramtop)
0851   F9FD C9          	ret
0852   F9FE             ; 585 }
0853   F9FE             ; 586 
0854   F9FE             ; 587 // Функция для пользовательской программы.
0855   F9FE             ; 588 // Установить адрес последнего доступного байта оперативной памяти.
0856   F9FE             ; 589 // Параметры: hl - адрес. Результат: нет. Сохраняет: a, bc, de, hl.
0857   F9FE             ; 590 
0858   F9FE             ; 591 void SetRamTop(...) {
0859   F9FE             setramtop: 
0860   F9FE             ; 592     ramTop = hl;
0861   F9FE 22 81 F7    	ld (ramtop), hl
0862   FA01 C9          	ret
0863   FA02             ; 593 }
0864   FA02             ; 594 
0865   FA02             ; 595 // Команда A <адрес>
0866   FA02             ; 596 // Установить программу преобразования кодировки символов выводимых на экран
0867   FA02             ; 597 
0868   FA02             ; 598 void CmdA(...) {
0869   FA02             cmda: 
0870   FA02             ; 599     translateCodePageAddress = hl;
0871   FA02 22 7F F7    	ld (translatecodepageaddress), hl
0872   FA05 C9          	ret
0873   FA06             ; 600 }
0874   FA06             ; 601 
0875   FA06             ; 602 // Команда D <начальный адрес> <конечный адрес>
0876   FA06             ; 603 // Вывод блока данных из адресного пространства на экран в 16-ричном виде
0877   FA06             ; 604 
0878   FA06             ; 605 void CmdD(...) {
0879   FA06             cmdd: 
0880   FA06             ; 606     for (;;) {
0881   FA06             l_18: 
0882   FA06             ; 607         PrintCrLf();
0883   FA06 CD AD FE    	call printcrlf
0884   FA09             ; 608         PrintHexWordSpace(hl);
0885   FA09 CD 5A FC    	call printhexwordspace
0886   FA0C             ; 609         push_pop(hl) {
0887   FA0C E5          	push hl
0888   FA0D             ; 610             c = ((a = l) &= 0x0F);
0889   FA0D 7D          	ld a, l
0890   FA0E E6 0F       	and 15
0891   FA10 4F          	ld c, a
0892   FA11             ; 611             carry_rotate_right(a, 1);
0893   FA11 1F          	rra
0894   FA12             ; 612             b = (((a += c) += c) += 5);
0895   FA12 81          	add c
0896   FA13 81          	add c
0897   FA14 C6 05       	add 5
0898   FA16 47          	ld b, a
0899   FA17             ; 613             PrintSpacesTo();
0900   FA17 CD 5A FA    	call printspacesto
0901   FA1A             ; 614             do {
0902   FA1A             l_20: 
0903   FA1A             ; 615                 PrintHexByte(a = *hl);
0904   FA1A 7E          	ld a, (hl)
0905   FA1B CD 0E FD    	call printhexbyte
0906   FA1E             ; 616                 CompareHlDe(hl, de);
0907   FA1E CD B6 F9    	call comparehlde
0908   FA21             ; 617                 hl++;
0909   FA21 23          	inc hl
0910   FA22             ; 618                 if (flag_z)
0911   FA22             ; 619                     break;
0912   FA22 CA 32 FA    	jp z, l_22
0913   FA25             ; 620                 (a = l) &= 0x0F;
0914   FA25 7D          	ld a, l
0915   FA26 E6 0F       	and 15
0916   FA28             ; 621                 push_pop(a) {
0917   FA28 F5          	push af
0918   FA29             ; 622                     a &= 1;
0919   FA29 E6 01       	and 1
0920   FA2B             ; 623                     if (flag_z)
0921   FA2B             ; 624                         PrintSpace();
0922   FA2B CC 67 FA    	call z, printspace
0923   FA2E F1          	pop af
0924   FA2F             l_21: 
0925   FA2F C2 1A FA    	jp nz, l_20
0926   FA32             l_22: 
0927   FA32 E1          	pop hl
0928   FA33             ; 625                 }
0929   FA33             ; 626             } while (flag_nz);
0930   FA33             ; 627         }
0931   FA33             ; 628 
0932   FA33             ; 629         b = (((a = l) &= 0x0F) += 46);
0933   FA33 7D          	ld a, l
0934   FA34 E6 0F       	and 15
0935   FA36 C6 2E       	add 46
0936   FA38 47          	ld b, a
0937   FA39             ; 630         PrintSpacesTo(b);
0938   FA39 CD 5A FA    	call printspacesto
0939   FA3C             ; 631 
0940   FA3C             ; 632         do {
0941   FA3C             l_23: 
0942   FA3C             ; 633             a = *hl;
0943   FA3C 7E          	ld a, (hl)
0944   FA3D             ; 634             if (a < 127)
0945   FA3D FE 7F       	cp 127
0946   FA3F             ; 635                 if (a >= 32)
0947   FA3F D2 47 FA    	jp nc, l_26
0948   FA42 FE 20       	cp 32
0949   FA44             ; 636                     goto loc_fa49;
0950   FA44 D2 49 FA    	jp nc, loc_fa49
0951   FA47             l_26: 
0952   FA47             ; 637             a = '.';
0953   FA47 3E 2E       	ld a, 46
0954   FA49             ; 638         loc_fa49:
0955   FA49             loc_fa49: 
0956   FA49             ; 639             PrintCharA(a);
0957   FA49 CD 22 FD    	call printchara
0958   FA4C             ; 640             CompareHlDe(hl, de);
0959   FA4C CD B6 F9    	call comparehlde
0960   FA4F             ; 641             if (flag_z)
0961   FA4F             ; 642                 return;
0962   FA4F C8          	ret z
0963   FA50             ; 643             hl++;
0964   FA50 23          	inc hl
0965   FA51             ; 644             (a = l) &= 0x0F;
0966   FA51 7D          	ld a, l
0967   FA52 E6 0F       	and 15
0968   FA54             l_24: 
0969   FA54 C2 3C FA    	jp nz, l_23
0970   FA57 C3 06 FA    	jp l_18
0971   FA5A             ; 645         } while (flag_nz);
0972   FA5A             ; 646     }
0973   FA5A             ; 647 }
0974   FA5A             ; 648 
0975   FA5A             ; 649 void PrintSpacesTo(...) {
0976   FA5A             printspacesto: 
0977   FA5A             ; 650     for (;;) {
0978   FA5A             l_29: 
0979   FA5A             ; 651         if (((a = cursor) &= (SCREEN_WIDTH - 1)) >= b)
0980   FA5A 3A 5A F7    	ld a, (cursor)
0981   FA5D E6 3F       	and 63
0982   FA5F B8          	cp b
0983   FA60             ; 652             return;
0984   FA60 D0          	ret nc
0985   FA61             ; 653         PrintSpace();
0986   FA61 CD 67 FA    	call printspace
0987   FA64 C3 5A FA    	jp l_29
0988   FA67             ; 654     }
0989   FA67             ; 655 }
0990   FA67             ; 656 
0991   FA67             ; 657 void PrintSpace() {
0992   FA67             printspace: 
0993   FA67             ; 658     return PrintCharA(a = ' ');
0994   FA67 3E 20       	ld a, 32
0995   FA69 C3 22 FD    	jp printchara
0996   FA6C             ; 659 }
0997   FA6C             ; 660 
0998   FA6C             ; 661 // Команда С <начальный адрес 1> <конечный адрес 1> <начальный адрес 2>
0999   FA6C             ; 662 // Сравнить два блока адресного пространство
1000   FA6C             ; 663 
1001   FA6C             ; 664 void CmdC(...) {
1002   FA6C             cmdc: 
1003   FA6C             ; 665     for (;;) {
1004   FA6C             l_32: 
1005   FA6C             ; 666         if ((a = *bc) != *hl) {
1006   FA6C 0A          	ld a, (bc)
1007   FA6D BE          	cp (hl)
1008   FA6E CA 7B FA    	jp z, l_34
1009   FA71             ; 667             PrintCrLfTabHexWordSpace(hl);
1010   FA71 CD 51 FC    	call printcrlftabhexwordspace
1011   FA74             ; 668             PrintHexByteFromHlSpace(hl);
1012   FA74 CD DC F9    	call printhexbytefromhlspace
1013   FA77             ; 669             PrintHexByteSpace(a = *bc);
1014   FA77 0A          	ld a, (bc)
1015   FA78 CD DD F9    	call printhexbytespace
1016   FA7B             l_34: 
1017   FA7B             ; 670         }
1018   FA7B             ; 671         bc++;
1019   FA7B 03          	inc bc
1020   FA7C             ; 672         LoopWithBreak();
1021   FA7C CD BC F9    	call loopwithbreak
1022   FA7F C3 6C FA    	jp l_32
1023   FA82             ; 673     }
1024   FA82             ; 674 }
1025   FA82             ; 675 
1026   FA82             ; 676 // Команда F <начальный адрес> <конечный адрес> <байт>
1027   FA82             ; 677 // Заполнить блок в адресном пространстве одним байтом
1028   FA82             ; 678 
1029   FA82             ; 679 void CmdF(...) {
1030   FA82             cmdf: 
1031   FA82             ; 680     for (;;) {
1032   FA82             l_37: 
1033   FA82             ; 681         *hl = c;
1034   FA82 71          	ld (hl), c
1035   FA83             ; 682         Loop();
1036   FA83 CD BF F9    	call loop
1037   FA86 C3 82 FA    	jp l_37
1038   FA89             ; 683     }
1039   FA89             ; 684 }
1040   FA89             ; 685 
1041   FA89             ; 686 // Команда S <начальный адрес> <конечный адрес> <байт>
1042   FA89             ; 687 // Найти байт (8 битное значение) в адресном пространстве
1043   FA89             ; 688 
1044   FA89             ; 689 void CmdS(...) {
1045   FA89             cmds: 
1046   FA89             ; 690     for (;;) {
1047   FA89             l_40: 
1048   FA89             ; 691         if ((a = c) == *hl)
1049   FA89 79          	ld a, c
1050   FA8A BE          	cp (hl)
1051   FA8B             ; 692             PrintCrLfTabHexWordSpace(hl);
1052   FA8B CC 51 FC    	call z, printcrlftabhexwordspace
1053   FA8E             ; 693         LoopWithBreak();
1054   FA8E CD BC F9    	call loopwithbreak
1055   FA91 C3 89 FA    	jp l_40
1056   FA94             ; 694     }
1057   FA94             ; 695 }
1058   FA94             ; 696 
1059   FA94             ; 697 // Команда W <начальный адрес> <конечный адрес> <слово>
1060   FA94             ; 698 // Найти слово (16 битное значение) в адресном пространстве
1061   FA94             ; 699 
1062   FA94             ; 700 void CmdW(...) {
1063   FA94             cmdw: 
1064   FA94             ; 701     for (;;) {
1065   FA94             l_43: 
1066   FA94             ; 702         if ((a = *hl) == c) {
1067   FA94 7E          	ld a, (hl)
1068   FA95 B9          	cp c
1069   FA96 C2 A0 FA    	jp nz, l_45
1070   FA99             ; 703             hl++;
1071   FA99 23          	inc hl
1072   FA9A             ; 704             compare((a = *hl), b);
1073   FA9A 7E          	ld a, (hl)
1074   FA9B B8          	cp b
1075   FA9C             ; 705             hl--;
1076   FA9C 2B          	dec hl
1077   FA9D             ; 706             if (flag_z)
1078   FA9D             ; 707                 PrintCrLfTabHexWordSpace(hl);
1079   FA9D CC 51 FC    	call z, printcrlftabhexwordspace
1080   FAA0             l_45: 
1081   FAA0             ; 708         }
1082   FAA0             ; 709         LoopWithBreak();
1083   FAA0 CD BC F9    	call loopwithbreak
1084   FAA3 C3 94 FA    	jp l_43
1085   FAA6             ; 710     }
1086   FAA6             ; 711 }
1087   FAA6             ; 712 
1088   FAA6             ; 713 // Команда T <начальный адрес источника> <конечный адрес источника> <начальный адрес назначения>
1089   FAA6             ; 714 // Копировать блок в адресном пространстве
1090   FAA6             ; 715 
1091   FAA6             ; 716 void CmdT(...) {
1092   FAA6             cmdt: 
1093   FAA6             ; 717     for (;;) {
1094   FAA6             l_48: 
1095   FAA6             ; 718         *bc = a = *hl;
1096   FAA6 7E          	ld a, (hl)
1097   FAA7 02          	ld (bc), a
1098   FAA8             ; 719         bc++;
1099   FAA8 03          	inc bc
1100   FAA9             ; 720         Loop();
1101   FAA9 CD BF F9    	call loop
1102   FAAC C3 A6 FA    	jp l_48
1103   FAAF             ; 721     }
1104   FAAF             ; 722 }
1105   FAAF             ; 723 
1106   FAAF             ; 724 // Команда M <начальный адрес>
1107   FAAF             ; 725 // Вывести на экран адресное пространство побайтно с возможностью изменения
1108   FAAF             ; 726 
1109   FAAF             ; 727 void CmdM(...) {
1110   FAAF             cmdm: 
1111   FAAF             ; 728     for (;;) {
1112   FAAF             l_51: 
1113   FAAF             ; 729         PrintCrLfTabHexWordSpace(hl);
1114   FAAF CD 51 FC    	call printcrlftabhexwordspace
1115   FAB2             ; 730         PrintHexByteFromHlSpace();
1116   FAB2 CD DC F9    	call printhexbytefromhlspace
1117   FAB5             ; 731         push_pop(hl) {
1118   FAB5 E5          	push hl
1119   FAB6             ; 732             ReadString();
1120   FAB6 CD 14 F9    	call readstring
1121   FAB9 E1          	pop hl
1122   FABA             ; 733         }
1123   FABA             ; 734         if (flag_c) {
1124   FABA D2 C4 FA    	jp nc, l_53
1125   FABD             ; 735             push_pop(hl) {
1126   FABD E5          	push hl
1127   FABE             ; 736                 ParseWord();
1128   FABE CD 80 F9    	call parseword
1129   FAC1             ; 737                 a = l;
1130   FAC1 7D          	ld a, l
1131   FAC2 E1          	pop hl
1132   FAC3             ; 738             }
1133   FAC3             ; 739             *hl = a;
1134   FAC3 77          	ld (hl), a
1135   FAC4             l_53: 
1136   FAC4             ; 740         }
1137   FAC4             ; 741         hl++;
1138   FAC4 23          	inc hl
1139   FAC5 C3 AF FA    	jp l_51
1140   FAC8             ; 742     }
1141   FAC8             ; 743 }
1142   FAC8             ; 744 
1143   FAC8             ; 745 // Команда G <начальный адрес> <конечный адрес>
1144   FAC8             ; 746 // Запуск программы и возможным указанием точки останова.
1145   FAC8             ; 747 
1146   FAC8             ; 748 void CmdG(...) {
1147   FAC8             cmdg: 
1148   FAC8             ; 749     CompareHlDe(hl, de);
1149   FAC8 CD B6 F9    	call comparehlde
1150   FACB             ; 750     if (flag_nz) {
1151   FACB CA E3 FA    	jp z, l_55
1152   FACE             ; 751         swap(hl, de);
1153   FACE EB          	ex hl, de
1154   FACF             ; 752         breakPointAddress = hl;
1155   FACF 22 71 F7    	ld (breakpointaddress), hl
1156   FAD2             ; 753         breakPointValue = a = *hl;
1157   FAD2 7E          	ld a, (hl)
1158   FAD3 32 73 F7    	ld (breakpointvalue), a
1159   FAD6             ; 754         *hl = OPCODE_RST_30;
1160   FAD6 36 F7       	ld (hl), 247
1161   FAD8             ; 755         rst30Opcode = a = OPCODE_JMP;
1162   FAD8 3E C3       	ld a, 195
1163   FADA 32 30 00    	ld (rst30opcode), a
1164   FADD             ; 756         rst30Address = hl = &BreakPointHandler;
1165   FADD 21 F1 FA    	ld hl, 0FFFFh & (breakpointhandler)
1166   FAE0 22 31 00    	ld (rst30address), hl
1167   FAE3             l_55: 
1168   FAE3             ; 757     }
1169   FAE3             ; 758     sp = &regBC;
1170   FAE3 31 66 F7    	ld sp, 0FFFFh & (regbc)
1171   FAE6             ; 759     pop(bc);
1172   FAE6 C1          	pop bc
1173   FAE7             ; 760     pop(de);
1174   FAE7 D1          	pop de
1175   FAE8             ; 761     pop(hl);
1176   FAE8 E1          	pop hl
1177   FAE9             ; 762     pop(a);
1178   FAE9 F1          	pop af
1179   FAEA             ; 763     sp = hl;
1180   FAEA F9          	ld sp, hl
1181   FAEB             ; 764     hl = regHL;
1182   FAEB 2A 64 F7    	ld hl, (reghl)
1183   FAEE             ; 765     return JmpParam1();
1184   FAEE C3 74 F7    	jp jmpparam1
1185   FAF1             ; 766 }
1186   FAF1             ; 767 
1187   FAF1             ; 768 void BreakPointHandler(...) {
1188   FAF1             breakpointhandler: 
1189   FAF1             ; 769     regHL = hl;
1190   FAF1 22 64 F7    	ld (reghl), hl
1191   FAF4             ; 770     push(a);
1192   FAF4 F5          	push af
1193   FAF5             ; 771     pop(hl);
1194   FAF5 E1          	pop hl
1195   FAF6             ; 772     regAF = hl;
1196   FAF6 22 6C F7    	ld (regaf), hl
1197   FAF9             ; 773     pop(hl);
1198   FAF9 E1          	pop hl
1199   FAFA             ; 774     hl--;
1200   FAFA 2B          	dec hl
1201   FAFB             ; 775     regPC = hl;
1202   FAFB 22 62 F7    	ld (regpc), hl
1203   FAFE             ; 776     (hl = 0) += sp;
1204   FAFE 21 00 00    	ld hl, 0
1205   FB01 39          	add hl, sp
1206   FB02             ; 777     sp = &regAF;
1207   FB02 31 6C F7    	ld sp, 0FFFFh & (regaf)
1208   FB05             ; 778     push(hl);
1209   FB05 E5          	push hl
1210   FB06             ; 779     push(de);
1211   FB06 D5          	push de
1212   FB07             ; 780     push(bc);
1213   FB07 C5          	push bc
1214   FB08             ; 781     sp = STACK_TOP;
1215   FB08 31 00 F8    	ld sp, 63488
1216   FB0B             ; 782     hl = regPC;
1217   FB0B 2A 62 F7    	ld hl, (regpc)
1218   FB0E             ; 783     swap(hl, de);
1219   FB0E EB          	ex hl, de
1220   FB0F             ; 784     hl = breakPointAddress;
1221   FB0F 2A 71 F7    	ld hl, (breakpointaddress)
1222   FB12             ; 785     CompareHlDe(hl, de);
1223   FB12 CD B6 F9    	call comparehlde
1224   FB15             ; 786     if (flag_nz)
1225   FB15             ; 787         return CmdX();
1226   FB15 C2 1C FB    	jp nz, cmdx
1227   FB18             ; 788     *hl = a = breakPointValue;
1228   FB18 3A 73 F7    	ld a, (breakpointvalue)
1229   FB1B 77          	ld (hl), a
1230   FB1C             ; 789     CmdX();
1231   FB1C             ; 790 }
1232   FB1C             ; 791 
1233   FB1C             ; 792 // Команда X
1234   FB1C             ; 793 // Вывод на экран содержимого регистров микропроцессора с возможностью их изменения.
1235   FB1C             ; 794 
1236   FB1C             ; 795 void CmdX(...) {
1237   FB1C             cmdx: 
1238   FB1C             ; 796     PrintString(hl = aRegisters);
1239   FB1C 21 AB FF    	ld hl, 0FFFFh & (aregisters)
1240   FB1F CD 48 F9    	call printstring
1241   FB22             ; 797     hl = &regPC;
1242   FB22 21 62 F7    	ld hl, 0FFFFh & (regpc)
1243   FB25             ; 798     b = 6;
1244   FB25 06 06       	ld b, 6
1245   FB27             ; 799     do {
1246   FB27             l_57: 
1247   FB27             ; 800         e = *hl;
1248   FB27 5E          	ld e, (hl)
1249   FB28             ; 801         hl++;
1250   FB28 23          	inc hl
1251   FB29             ; 802         d = *hl;
1252   FB29 56          	ld d, (hl)
1253   FB2A             ; 803         push(bc);
1254   FB2A C5          	push bc
1255   FB2B             ; 804         push(hl);
1256   FB2B E5          	push hl
1257   FB2C             ; 805         swap(hl, de);
1258   FB2C EB          	ex hl, de
1259   FB2D             ; 806         PrintCrLfTabHexWordSpace(hl);
1260   FB2D CD 51 FC    	call printcrlftabhexwordspace
1261   FB30             ; 807         ReadString();
1262   FB30 CD 14 F9    	call readstring
1263   FB33             ; 808         if (flag_c) {
1264   FB33 D2 3F FB    	jp nc, l_60
1265   FB36             ; 809             ParseWord();
1266   FB36 CD 80 F9    	call parseword
1267   FB39             ; 810             pop(de);
1268   FB39 D1          	pop de
1269   FB3A             ; 811             push(de);
1270   FB3A D5          	push de
1271   FB3B             ; 812             swap(hl, de);
1272   FB3B EB          	ex hl, de
1273   FB3C             ; 813             *hl = d;
1274   FB3C 72          	ld (hl), d
1275   FB3D             ; 814             hl--;
1276   FB3D 2B          	dec hl
1277   FB3E             ; 815             *hl = e;
1278   FB3E 73          	ld (hl), e
1279   FB3F             l_60: 
1280   FB3F             ; 816         }
1281   FB3F             ; 817         pop(hl);
1282   FB3F E1          	pop hl
1283   FB40             ; 818         pop(bc);
1284   FB40 C1          	pop bc
1285   FB41             ; 819         b--;
1286   FB41 05          	dec b
1287   FB42             ; 820         hl++;
1288   FB42 23          	inc hl
1289   FB43             l_58: 
1290   FB43 C2 27 FB    	jp nz, l_57
1291   FB46             ; 821     } while (flag_nz);
1292   FB46             ; 822     EntryF86C_Monitor();
1293   FB46 C3 6C F8    	jp entryf86c_monitor
1294   FB49             ; 823 }
1295   FB49             ; 824 
1296   FB49             ; 825 // Функция для пользовательской программы.
1297   FB49             ; 826 // Получить координаты курсора.
1298   FB49             ; 827 // Параметры: нет. Результат: l = x + 8, h = y + 3. Сохраняет регистры: bc, de, hl.
1299   FB49             ; 828 
1300   FB49             ; 829 void GetCursor() {
1301   FB49             getcursor: 
1302   FB49             ; 830     push_pop(a) {
1303   FB49 F5          	push af
1304   FB4A             ; 831         hl = cursor;
1305   FB4A 2A 5A F7    	ld hl, (cursor)
1306   FB4D             ; 832         h = ((a = h) &= 7);
1307   FB4D 7C          	ld a, h
1308   FB4E E6 07       	and 7
1309   FB50 67          	ld h, a
1310   FB51             ; 833 
1311   FB51             ; 834         // Вычисление X
1312   FB51             ; 835         a = l;
1313   FB51 7D          	ld a, l
1314   FB52             ; 836         a &= (SCREEN_WIDTH - 1);
1315   FB52 E6 3F       	and 63
1316   FB54             ; 837         a += 8;  // Смещение Радио 86РК
1317   FB54 C6 08       	add 8
1318   FB56             ; 838 
1319   FB56             ; 839         // Вычисление Y
1320   FB56             ; 840         hl += hl;
1321   FB56 29          	add hl, hl
1322   FB57             ; 841         hl += hl;
1323   FB57 29          	add hl, hl
1324   FB58             ; 842         h++;  // Смещение Радио 86РК
1325   FB58 24          	inc h
1326   FB59             ; 843         h++;
1327   FB59 24          	inc h
1328   FB5A             ; 844         h++;
1329   FB5A 24          	inc h
1330   FB5B             ; 845 
1331   FB5B             ; 846         l = a;
1332   FB5B 6F          	ld l, a
1333   FB5C F1          	pop af
1334   FB5D C9          	ret
1335   FB5E             ; 847     }
1336   FB5E             ; 848 }
1337   FB5E             ; 849 
1338   FB5E             ; 850 // Функция для пользовательской программы.
1339   FB5E             ; 851 // Получить символ под курсором.
1340   FB5E             ; 852 // Параметры: нет. Результат: a - код символа. Сохраняет регистры: bc, de, hl.
1341   FB5E             ; 853 
1342   FB5E             ; 854 void GetCursorChar() {
1343   FB5E             getcursorchar: 
1344   FB5E             ; 855     push_pop(hl) {
1345   FB5E E5          	push hl
1346   FB5F             ; 856         hl = cursor;
1347   FB5F 2A 5A F7    	ld hl, (cursor)
1348   FB62             ; 857         a = *hl;
1349   FB62 7E          	ld a, (hl)
1350   FB63 E1          	pop hl
1351   FB64 C9          	ret
1352   FB65             ; 858     }
1353   FB65             ; 859 }
1354   FB65             ; 860 
1355   FB65             ; 861 // Команда H
1356   FB65             ; 862 // Определить скорости записанной программы.
1357   FB65             ; 863 // Выводит 4 цифры на экран.
1358   FB65             ; 864 // Первые две цифры - константа вывода для команды O
1359   FB65             ; 865 // Последние две цифры - константа вввода для команды I
1360   FB65             ; 866 
1361   FB65             ; 867 void CmdH(...) {
1362   FB65             cmdh: 
1363   FB65             ; 868     PrintCrLfTab();
1364   FB65 CD D3 F9    	call printcrlftab
1365   FB68             ; 869     hl = 65408;
1366   FB68 21 80 FF    	ld hl, 65408
1367   FB6B             ; 870     b = 123;
1368   FB6B 06 7B       	ld b, 123
1369   FB6D             ; 871 
1370   FB6D             ; 872     c = a = in(PORT_TAPE);
1371   FB6D DB 01       	in a, (1)
1372   FB6F 4F          	ld c, a
1373   FB70             ; 873 
1374   FB70             ; 874     do {
1375   FB70             l_62: 
1376   FB70             l_63: 
1377   FB70             ; 875     } while ((a = in(PORT_TAPE)) == c);
1378   FB70 DB 01       	in a, (1)
1379   FB72 B9          	cp c
1380   FB73 CA 70 FB    	jp z, l_62
1381   FB76             ; 876 
1382   FB76             ; 877     do {
1383   FB76             l_65: 
1384   FB76             ; 878         c = a;
1385   FB76 4F          	ld c, a
1386   FB77             ; 879         do {
1387   FB77             l_68: 
1388   FB77             ; 880             hl++;
1389   FB77 23          	inc hl
1390   FB78             l_69: 
1391   FB78             ; 881         } while ((a = in(PORT_TAPE)) == c);
1392   FB78 DB 01       	in a, (1)
1393   FB7A B9          	cp c
1394   FB7B CA 77 FB    	jp z, l_68
1395   FB7E             l_66: 
1396   FB7E             ; 882     } while (flag_nz(b--));
1397   FB7E 05          	dec b
1398   FB7F C2 76 FB    	jp nz, l_65
1399   FB82             ; 883 
1400   FB82             ; 884     hl += hl;
1401   FB82 29          	add hl, hl
1402   FB83             ; 885     a = h;
1403   FB83 7C          	ld a, h
1404   FB84             ; 886     hl += hl;
1405   FB84 29          	add hl, hl
1406   FB85             ; 887     l = (a += h);
1407   FB85 84          	add h
1408   FB86 6F          	ld l, a
1409   FB87             ; 888 
1410   FB87             ; 889     PrintHexWordSpace();
1411   FB87 C3 5A FC    	jp printhexwordspace
1412   FB8A             ; 890 }
1413   FB8A             ; 891 
1414   FB8A             ; 892 // Команда I <смещение> <скорость>
1415   FB8A             ; 893 // Загрузить файл с магнитной ленты
1416   FB8A             ; 894 
1417   FB8A             ; 895 void CmdI(...) {
1418   FB8A             cmdi: 
1419   FB8A             ; 896     if ((a = param2Exists) != 0)
1420   FB8A 3A 7B F7    	ld a, (param2exists)
1421   FB8D B7          	or a
1422   FB8E             ; 897         tapeReadSpeed = a = e;
1423   FB8E CA 95 FB    	jp z, l_71
1424   FB91 7B          	ld a, e
1425   FB92 32 5C F7    	ld (tapereadspeed), a
1426   FB95             l_71: 
1427   FB95             ; 898     ReadTapeFile();
1428   FB95 CD BA FB    	call readtapefile
1429   FB98             ; 899     PrintCrLfTabHexWordSpace(hl);
1430   FB98 CD 51 FC    	call printcrlftabhexwordspace
1431   FB9B             ; 900     swap(hl, de);
1432   FB9B EB          	ex hl, de
1433   FB9C             ; 901     PrintCrLfTabHexWordSpace(hl);
1434   FB9C CD 51 FC    	call printcrlftabhexwordspace
1435   FB9F             ; 902     swap(hl, de);
1436   FB9F EB          	ex hl, de
1437   FBA0             ; 903     push(bc);
1438   FBA0 C5          	push bc
1439   FBA1             ; 904     CalculateCheckSum();
1440   FBA1 CD F1 FB    	call calculatechecksum
1441   FBA4             ; 905     h = b;
1442   FBA4 60          	ld h, b
1443   FBA5             ; 906     l = c;
1444   FBA5 69          	ld l, c
1445   FBA6             ; 907     PrintCrLfTabHexWordSpace(hl);
1446   FBA6 CD 51 FC    	call printcrlftabhexwordspace
1447   FBA9             ; 908     pop(de);
1448   FBA9 D1          	pop de
1449   FBAA             ; 909     CompareHlDe(hl, de);
1450   FBAA CD B6 F9    	call comparehlde
1451   FBAD             ; 910     if (flag_z)
1452   FBAD             ; 911         return;
1453   FBAD C8          	ret z
1454   FBAE             ; 912     swap(hl, de);
1455   FBAE EB          	ex hl, de
1456   FBAF             ; 913     PrintCrLfTabHexWordSpace(hl);
1457   FBAF CD 51 FC    	call printcrlftabhexwordspace
1458   FBB2             ; 914     MonitorError();
1459   FBB2             ; 915 }
1460   FBB2             ; 916 
1461   FBB2             ; 917 void MonitorError() {
1462   FBB2             monitorerror: 
1463   FBB2             ; 918     PrintCharA(a = '?');
1464   FBB2 3E 3F       	ld a, 63
1465   FBB4 CD 22 FD    	call printchara
1466   FBB7             ; 919     Monitor2();
1467   FBB7 C3 94 F8    	jp monitor2
1468   FBBA             ; 920 }
1469   FBBA             ; 921 
1470   FBBA             ; 922 // Функция для пользовательской программы.
1471   FBBA             ; 923 // Загрузить файл с магнитной ленты.
1472   FBBA             ; 924 // Параметры: hl - смещение загрузки. Результат: bc - прочитанная КС, hl - адрес загрузки
1473   FBBA             ; 925 
1474   FBBA             ; 926 void ReadTapeFile(...) {
1475   FBBA             readtapefile: 
1476   FBBA             ; 927     ReadTapeWord(a = READ_TAPE_FIRST_BYTE);
1477   FBBA 3E FF       	ld a, 255
1478   FBBC CD DA FB    	call readtapeword
1479   FBBF             ; 928     push_pop(hl) {
1480   FBBF E5          	push hl
1481   FBC0             ; 929         hl += bc;
1482   FBC0 09          	add hl, bc
1483   FBC1             ; 930         swap(hl, de);
1484   FBC1 EB          	ex hl, de
1485   FBC2             ; 931         ReadTapeWordNext();
1486   FBC2 CD D8 FB    	call readtapewordnext
1487   FBC5 E1          	pop hl
1488   FBC6             ; 932     }
1489   FBC6             ; 933     hl += bc;
1490   FBC6 09          	add hl, bc
1491   FBC7             ; 934     swap(hl, de);
1492   FBC7 EB          	ex hl, de
1493   FBC8             ; 935 
1494   FBC8             ; 936     a = in(PORT_KEYBOARD_MODS);
1495   FBC8 DB 05       	in a, (5)
1496   FBCA             ; 937     a &= KEYBOARD_SHIFT_MOD;
1497   FBCA E6 04       	and 4
1498   FBCC             ; 938     if (flag_z)
1499   FBCC             ; 939         return;
1500   FBCC C8          	ret z
1501   FBCD             ; 940 
1502   FBCD             ; 941     push_pop(hl) {
1503   FBCD E5          	push hl
1504   FBCE             ; 942         ReadTapeBlock();
1505   FBCE CD E5 FB    	call readtapeblock
1506   FBD1             ; 943         ReadTapeWord(a = READ_TAPE_FIRST_BYTE);
1507   FBD1 3E FF       	ld a, 255
1508   FBD3 CD DA FB    	call readtapeword
1509   FBD6 E1          	pop hl
1510   FBD7 C9          	ret
1511   FBD8             ; 944     }
1512   FBD8             ; 945 }
1513   FBD8             ; 946 
1514   FBD8             ; 947 void ReadTapeWordNext() {
1515   FBD8             readtapewordnext: 
1516   FBD8             ; 948     ReadTapeWord(a = READ_TAPE_NEXT_BYTE);
1517   FBD8 3E 08       	ld a, 8
1518   FBDA             ; 949 }
1519   FBDA             ; 950 
1520   FBDA             ; 951 void ReadTapeWord(...) {
1521   FBDA             readtapeword: 
1522   FBDA             ; 952     ReadTapeByte(a);
1523   FBDA CD 74 FC    	call readtapebyte
1524   FBDD             ; 953     b = a;
1525   FBDD 47          	ld b, a
1526   FBDE             ; 954     ReadTapeByte(a = READ_TAPE_NEXT_BYTE);
1527   FBDE 3E 08       	ld a, 8
1528   FBE0 CD 74 FC    	call readtapebyte
1529   FBE3             ; 955     c = a;
1530   FBE3 4F          	ld c, a
1531   FBE4 C9          	ret
1532   FBE5             ; 956 }
1533   FBE5             ; 957 
1534   FBE5             ; 958 void ReadTapeBlock(...) {
1535   FBE5             readtapeblock: 
1536   FBE5             ; 959     for (;;) {
1537   FBE5             l_74: 
1538   FBE5             ; 960         ReadTapeByte(a = READ_TAPE_NEXT_BYTE);
1539   FBE5 3E 08       	ld a, 8
1540   FBE7 CD 74 FC    	call readtapebyte
1541   FBEA             ; 961         *hl = a;
1542   FBEA 77          	ld (hl), a
1543   FBEB             ; 962         Loop();
1544   FBEB CD BF F9    	call loop
1545   FBEE C3 E5 FB    	jp l_74
1546   FBF1             ; 963     }
1547   FBF1             ; 964 }
1548   FBF1             ; 965 
1549   FBF1             ; 966 // Функция для пользовательской программы.
1550   FBF1             ; 967 // Вычистить 16-битную сумму всех байт по адресам hl..de.
1551   FBF1             ; 968 // Параметры: hl - начальный адрес, de - конечный адрес. Результат: bc - сумма. Сохраяет: de.
1552   FBF1             ; 969 
1553   FBF1             ; 970 void CalculateCheckSum(...) {
1554   FBF1             calculatechecksum: 
1555   FBF1             ; 971     bc = 0;
1556   FBF1 01 00 00    	ld bc, 0
1557   FBF4             ; 972     for (;;) {
1558   FBF4             l_77: 
1559   FBF4             ; 973         c = ((a = *hl) += c);
1560   FBF4 7E          	ld a, (hl)
1561   FBF5 81          	add c
1562   FBF6 4F          	ld c, a
1563   FBF7             ; 974         push_pop(a) {
1564   FBF7 F5          	push af
1565   FBF8             ; 975             CompareHlDe(hl, de);
1566   FBF8 CD B6 F9    	call comparehlde
1567   FBFB             ; 976             if (flag_z)
1568   FBFB             ; 977                 return PopRet();
1569   FBFB CA C5 F9    	jp z, popret
1570   FBFE F1          	pop af
1571   FBFF             ; 978         }
1572   FBFF             ; 979         a = b;
1573   FBFF 78          	ld a, b
1574   FC00             ; 980         carry_add(a, *hl);
1575   FC00 8E          	adc (hl)
1576   FC01             ; 981         b = a;
1577   FC01 47          	ld b, a
1578   FC02             ; 982         Loop();
1579   FC02 CD BF F9    	call loop
1580   FC05 C3 F4 FB    	jp l_77
1581   FC08             ; 983     }
1582   FC08             ; 984 }
1583   FC08             ; 985 
1584   FC08             ; 986 // Команда O <начальный адрес> <конечный адрес> <скорость>
1585   FC08             ; 987 // Сохранить блок данных на магнитную ленту
1586   FC08             ; 988 
1587   FC08             ; 989 void CmdO(...) {
1588   FC08             cmdo: 
1589   FC08             ; 990     if ((a = c) != 0)
1590   FC08 79          	ld a, c
1591   FC09 B7          	or a
1592   FC0A             ; 991         tapeWriteSpeed = a;
1593   FC0A CA 10 FC    	jp z, l_79
1594   FC0D 32 5D F7    	ld (tapewritespeed), a
1595   FC10             l_79: 
1596   FC10             ; 992     push_pop(hl) {
1597   FC10 E5          	push hl
1598   FC11             ; 993         CalculateCheckSum(hl, de);
1599   FC11 CD F1 FB    	call calculatechecksum
1600   FC14 E1          	pop hl
1601   FC15             ; 994     }
1602   FC15             ; 995     PrintCrLfTabHexWordSpace(hl);
1603   FC15 CD 51 FC    	call printcrlftabhexwordspace
1604   FC18             ; 996     swap(hl, de);
1605   FC18 EB          	ex hl, de
1606   FC19             ; 997     PrintCrLfTabHexWordSpace(hl);
1607   FC19 CD 51 FC    	call printcrlftabhexwordspace
1608   FC1C             ; 998     swap(hl, de);
1609   FC1C EB          	ex hl, de
1610   FC1D             ; 999     push_pop(hl) {
1611   FC1D E5          	push hl
1612   FC1E             ; 1000         h = b;
1613   FC1E 60          	ld h, b
1614   FC1F             ; 1001         l = c;
1615   FC1F 69          	ld l, c
1616   FC20             ; 1002         PrintCrLfTabHexWordSpace(hl);
1617   FC20 CD 51 FC    	call printcrlftabhexwordspace
1618   FC23 E1          	pop hl
1619   FC24             ; 1003     }
1620   FC24             ; 1004     WriteTapeFile(hl, de);
1621   FC24             ; 1005 }
1622   FC24             ; 1006 
1623   FC24             ; 1007 // Функция для пользовательской программы.
1624   FC24             ; 1008 // Запись файла на магнитную ленту.
1625   FC24             ; 1009 // Параметры: de - начальный адрес, hl - конечный адрес, bc - контрольная сумма. Результат: нет.
1626   FC24             ; 1010 
1627   FC24             ; 1011 void WriteTapeFile(...) {
1628   FC24             writetapefile: 
1629   FC24             ; 1012     push(bc);
1630   FC24 C5          	push bc
1631   FC25             ; 1013     bc = 0;
1632   FC25 01 00 00    	ld bc, 0
1633   FC28             ; 1014     do {
1634   FC28             l_81: 
1635   FC28             ; 1015         WriteTapeByte(c);
1636   FC28 CD DD FC    	call writetapebyte
1637   FC2B             ; 1016         b--;
1638   FC2B 05          	dec b
1639   FC2C             ; 1017         swap(hl, *sp);
1640   FC2C E3          	ex (sp), hl
1641   FC2D             ; 1018         swap(hl, *sp);
1642   FC2D E3          	ex (sp), hl
1643   FC2E             l_82: 
1644   FC2E C2 28 FC    	jp nz, l_81
1645   FC31             ; 1019     } while (flag_nz);
1646   FC31             ; 1020     WriteTapeByte(c = TAPE_START);
1647   FC31 0E E6       	ld c, 230
1648   FC33 CD DD FC    	call writetapebyte
1649   FC36             ; 1021     WriteTapeWord(hl);
1650   FC36 CD 6C FC    	call writetapeword
1651   FC39             ; 1022     swap(hl, de);
1652   FC39 EB          	ex hl, de
1653   FC3A             ; 1023     WriteTapeWord(hl);
1654   FC3A CD 6C FC    	call writetapeword
1655   FC3D             ; 1024     swap(hl, de);
1656   FC3D EB          	ex hl, de
1657   FC3E             ; 1025     WriteTapeBlock(hl, de);
1658   FC3E CD 62 FC    	call writetapeblock
1659   FC41             ; 1026     WriteTapeWord(hl = 0);
1660   FC41 21 00 00    	ld hl, 0
1661   FC44 CD 6C FC    	call writetapeword
1662   FC47             ; 1027     WriteTapeByte(c = TAPE_START);
1663   FC47 0E E6       	ld c, 230
1664   FC49 CD DD FC    	call writetapebyte
1665   FC4C             ; 1028     pop(hl);
1666   FC4C E1          	pop hl
1667   FC4D             ; 1029     WriteTapeWord(hl);
1668   FC4D CD 6C FC    	call writetapeword
1669   FC50             ; 1030     return;
1670   FC50 C9          	ret
1671   FC51             ; 1031 }
1672   FC51             ; 1032 
1673   FC51             ; 1033 void PrintCrLfTabHexWordSpace(...) {
1674   FC51             printcrlftabhexwordspace: 
1675   FC51             ; 1034     push_pop(bc) {
1676   FC51 C5          	push bc
1677   FC52             ; 1035         PrintCrLfTab();
1678   FC52 CD D3 F9    	call printcrlftab
1679   FC55             ; 1036         PrintHexWordSpace(hl);
1680   FC55 CD 5A FC    	call printhexwordspace
1681   FC58 C1          	pop bc
1682   FC59 C9          	ret
1683   FC5A             ; 1037     }
1684   FC5A             ; 1038 }
1685   FC5A             ; 1039 
1686   FC5A             ; 1040 void PrintHexWordSpace(...) {
1687   FC5A             printhexwordspace: 
1688   FC5A             ; 1041     PrintHexByte(a = h);
1689   FC5A 7C          	ld a, h
1690   FC5B CD 0E FD    	call printhexbyte
1691   FC5E             ; 1042     PrintHexByteSpace(a = l);
1692   FC5E 7D          	ld a, l
1693   FC5F C3 DD F9    	jp printhexbytespace
1694   FC62             ; 1043 }
1695   FC62             ; 1044 
1696   FC62             ; 1045 void WriteTapeBlock(...) {
1697   FC62             writetapeblock: 
1698   FC62             ; 1046     for (;;) {
1699   FC62             l_85: 
1700   FC62             ; 1047         WriteTapeByte(c = *hl);
1701   FC62 4E          	ld c, (hl)
1702   FC63 CD DD FC    	call writetapebyte
1703   FC66             ; 1048         Loop();
1704   FC66 CD BF F9    	call loop
1705   FC69 C3 62 FC    	jp l_85
1706   FC6C             ; 1049     }
1707   FC6C             ; 1050 }
1708   FC6C             ; 1051 
1709   FC6C             ; 1052 void WriteTapeWord(...) {
1710   FC6C             writetapeword: 
1711   FC6C             ; 1053     WriteTapeByte(c = h);
1712   FC6C 4C          	ld c, h
1713   FC6D CD DD FC    	call writetapebyte
1714   FC70             ; 1054     WriteTapeByte(c = l);
1715   FC70 4D          	ld c, l
1716   FC71 C3 DD FC    	jp writetapebyte
1717   FC74             ; 1055 }
1718   FC74             ; 1056 
1719   FC74             ; 1057 // Загрузка байта с магнитной ленты.
1720   FC74             ; 1058 // Параметры: a = 0xFF с синхронизацией, = 8 без синхронизации.
1721   FC74             ; 1059 // Результат: a = прочитанный байт.
1722   FC74             ; 1060 
1723   FC74             ; 1061 void ReadTapeByte(...) {
1724   FC74             readtapebyte: 
1725   FC74             ; 1062     push(hl, bc, de);
1726   FC74 E5          	push hl
1727   FC75 C5          	push bc
1728   FC76 D5          	push de
1729   FC77             ; 1063     d = a;
1730   FC77 57          	ld d, a
1731   FC78             ; 1064     ReadTapeByteInternal(d);
1732   FC78             ; 1065 }
1733   FC78             ; 1066 
1734   FC78             ; 1067 void ReadTapeByteInternal(...) {
1735   FC78             readtapebyteinternal: 
1736   FC78             ; 1068     c = 0;
1737   FC78 0E 00       	ld c, 0
1738   FC7A             ; 1069     e = ((a = in(PORT_TAPE)) &= PORT_TAPE_BIT);
1739   FC7A DB 01       	in a, (1)
1740   FC7C E6 01       	and 1
1741   FC7E 5F          	ld e, a
1742   FC7F             ; 1070     do {
1743   FC7F             l_87: 
1744   FC7F             ; 1071     retry:  // Сдвиг результата
1745   FC7F             retry: 
1746   FC7F             ; 1072         (a = c) &= 0x7F;
1747   FC7F 79          	ld a, c
1748   FC80 E6 7F       	and 127
1749   FC82             ; 1073         cyclic_rotate_left(a, 1);
1750   FC82 07          	rlca
1751   FC83             ; 1074         c = a;
1752   FC83 4F          	ld c, a
1753   FC84             ; 1075 
1754   FC84             ; 1076         // Ожидание изменения бита
1755   FC84             ; 1077         h = 0;
1756   FC84 26 00       	ld h, 0
1757   FC86             ; 1078         do {
1758   FC86             l_90: 
1759   FC86             ; 1079             h--;
1760   FC86 25          	dec h
1761   FC87             ; 1080             if (flag_z)
1762   FC87             ; 1081                 return ReadTapeByteTimeout(d);
1763   FC87 CA D2 FC    	jp z, readtapebytetimeout
1764   FC8A             l_91: 
1765   FC8A             ; 1082         } while (((a = in(PORT_TAPE)) &= PORT_TAPE_BIT) == e);
1766   FC8A DB 01       	in a, (1)
1767   FC8C E6 01       	and 1
1768   FC8E BB          	cp e
1769   FC8F CA 86 FC    	jp z, l_90
1770   FC92             ; 1083 
1771   FC92             ; 1084         // Сохранение бита
1772   FC92             ; 1085         c = (a |= c);
1773   FC92 B1          	or c
1774   FC93 4F          	ld c, a
1775   FC94             ; 1086 
1776   FC94             ; 1087         // Задержка
1777   FC94             ; 1088         d--;
1778   FC94 15          	dec d
1779   FC95             ; 1089         a = tapeReadSpeed;
1780   FC95 3A 5C F7    	ld a, (tapereadspeed)
1781   FC98             ; 1090         if (flag_z)
1782   FC98             ; 1091             a -= 18;
1783   FC98 C2 9D FC    	jp nz, l_93
1784   FC9B D6 12       	sub 18
1785   FC9D             l_93: 
1786   FC9D             ; 1092         b = a;
1787   FC9D 47          	ld b, a
1788   FC9E             ; 1093         do {
1789   FC9E             l_95: 
1790   FC9E             l_96: 
1791   FC9E             ; 1094         } while (flag_nz(b--));
1792   FC9E 05          	dec b
1793   FC9F C2 9E FC    	jp nz, l_95
1794   FCA2             ; 1095         d++;
1795   FCA2 14          	inc d
1796   FCA3             ; 1096 
1797   FCA3             ; 1097         // Новое значение бита
1798   FCA3             ; 1098         e = ((a = in(PORT_TAPE)) &= PORT_TAPE_BIT);
1799   FCA3 DB 01       	in a, (1)
1800   FCA5 E6 01       	and 1
1801   FCA7 5F          	ld e, a
1802   FCA8             ; 1099 
1803   FCA8             ; 1100         // Режим поиска синхробайта
1804   FCA8             ; 1101         if (flag_m((a = d) |= a)) {
1805   FCA8 7A          	ld a, d
1806   FCA9 B7          	or a
1807   FCAA F2 C6 FC    	jp p, l_98
1808   FCAD             ; 1102             if ((a = c) == TAPE_START) {
1809   FCAD 79          	ld a, c
1810   FCAE FE E6       	cp 230
1811   FCB0 C2 BA FC    	jp nz, l_100
1812   FCB3             ; 1103                 tapePolarity = (a ^= a);
1813   FCB3 AF          	xor a
1814   FCB4 32 7C F7    	ld (tapepolarity), a
1815   FCB7 C3 C4 FC    	jp l_101
1816   FCBA             l_100: 
1817   FCBA             ; 1104             } else {
1818   FCBA             ; 1105                 if (a != ~TAPE_START)
1819   FCBA FE 19       	cp 65305
1820   FCBC             ; 1106                     goto retry;
1821   FCBC C2 7F FC    	jp nz, retry
1822   FCBF             ; 1107                 tapePolarity = a = 255;
1823   FCBF 3E FF       	ld a, 255
1824   FCC1 32 7C F7    	ld (tapepolarity), a
1825   FCC4             l_101: 
1826   FCC4             ; 1108             }
1827   FCC4             ; 1109             d = 8 + 1;
1828   FCC4 16 09       	ld d, 9
1829   FCC6             l_98: 
1830   FCC6             l_88: 
1831   FCC6             ; 1110         }
1832   FCC6             ; 1111     } while (flag_nz(d--));
1833   FCC6 15          	dec d
1834   FCC7 C2 7F FC    	jp nz, l_87
1835   FCCA             ; 1112     (a = tapePolarity) ^= c;
1836   FCCA 3A 7C F7    	ld a, (tapepolarity)
1837   FCCD A9          	xor c
1838   FCCE             ; 1113     pop(hl, bc, de);
1839   FCCE D1          	pop de
1840   FCCF C1          	pop bc
1841   FCD0 E1          	pop hl
1842   FCD1 C9          	ret
1843   FCD2             ; 1114 }
1844   FCD2             ; 1115 
1845   FCD2             ; 1116 void ReadTapeByteTimeout(...) {
1846   FCD2             readtapebytetimeout: 
1847   FCD2             ; 1117     if (flag_p((a = d) |= a))
1848   FCD2 7A          	ld a, d
1849   FCD3 B7          	or a
1850   FCD4             ; 1118         return MonitorError();
1851   FCD4 F2 B2 FB    	jp p, monitorerror
1852   FCD7             ; 1119     CtrlC();
1853   FCD7 CD CA F9    	call ctrlc
1854   FCDA             ; 1120     return ReadTapeByteInternal();
1855   FCDA C3 78 FC    	jp readtapebyteinternal
1856   FCDD             ; 1121 }
1857   FCDD             ; 1122 
1858   FCDD             ; 1123 // Функция для пользовательской программы.
1859   FCDD             ; 1124 // Запись байта на магнитную ленту.
1860   FCDD             ; 1125 // Параметры: c = байт. Результат: нет. Сохрнаяет: a, bc, de, hl.
1861   FCDD             ; 1126 
1862   FCDD             ; 1127 void WriteTapeByte(...) {
1863   FCDD             writetapebyte: 
1864   FCDD             ; 1128     push_pop(bc, de, a) {
1865   FCDD C5          	push bc
1866   FCDE D5          	push de
1867   FCDF F5          	push af
1868   FCE0             ; 1129         d = 8;
1869   FCE0 16 08       	ld d, 8
1870   FCE2             ; 1130         do {
1871   FCE2             l_102: 
1872   FCE2             ; 1131             // Сдвиг исходного байта
1873   FCE2             ; 1132             a = c;
1874   FCE2 79          	ld a, c
1875   FCE3             ; 1133             cyclic_rotate_left(a, 1);
1876   FCE3 07          	rlca
1877   FCE4             ; 1134             c = a;
1878   FCE4 4F          	ld c, a
1879   FCE5             ; 1135 
1880   FCE5             ; 1136             // Вывод
1881   FCE5             ; 1137             (a = PORT_TAPE_BIT) ^= c;
1882   FCE5 3E 01       	ld a, 1
1883   FCE7 A9          	xor c
1884   FCE8             ; 1138             out(PORT_TAPE, a);
1885   FCE8 D3 01       	out (1), a
1886   FCEA             ; 1139 
1887   FCEA             ; 1140             // Задержка
1888   FCEA             ; 1141             b = a = tapeWriteSpeed;
1889   FCEA 3A 5D F7    	ld a, (tapewritespeed)
1890   FCED 47          	ld b, a
1891   FCEE             ; 1142             do {
1892   FCEE             l_105: 
1893   FCEE             ; 1143                 b--;
1894   FCEE 05          	dec b
1895   FCEF             l_106: 
1896   FCEF C2 EE FC    	jp nz, l_105
1897   FCF2             ; 1144             } while (flag_nz);
1898   FCF2             ; 1145 
1899   FCF2             ; 1146             // Вывод
1900   FCF2             ; 1147             (a = 0) ^= c;
1901   FCF2 3E 00       	ld a, 0
1902   FCF4 A9          	xor c
1903   FCF5             ; 1148             out(PORT_TAPE, a);
1904   FCF5 D3 01       	out (1), a
1905   FCF7             ; 1149 
1906   FCF7             ; 1150             // Задержка
1907   FCF7             ; 1151             d--;
1908   FCF7 15          	dec d
1909   FCF8             ; 1152             a = tapeWriteSpeed;
1910   FCF8 3A 5D F7    	ld a, (tapewritespeed)
1911   FCFB             ; 1153             if (flag_z)
1912   FCFB             ; 1154                 a -= 14;
1913   FCFB C2 00 FD    	jp nz, l_108
1914   FCFE D6 0E       	sub 14
1915   FD00             l_108: 
1916   FD00             ; 1155             b = a;
1917   FD00 47          	ld b, a
1918   FD01             ; 1156             do {
1919   FD01             l_110: 
1920   FD01             ; 1157                 b--;
1921   FD01 05          	dec b
1922   FD02             l_111: 
1923   FD02 C2 01 FD    	jp nz, l_110
1924   FD05             ; 1158             } while (flag_nz);
1925   FD05             ; 1159             d++;
1926   FD05 14          	inc d
1927   FD06             l_103: 
1928   FD06             ; 1160         } while (flag_nz(d--));
1929   FD06 15          	dec d
1930   FD07 C2 E2 FC    	jp nz, l_102
1931   FD0A F1          	pop af
1932   FD0B D1          	pop de
1933   FD0C C1          	pop bc
1934   FD0D C9          	ret
1935   FD0E             ; 1161     }
1936   FD0E             ; 1162 }
1937   FD0E             ; 1163 
1938   FD0E             ; 1164 // Функция для пользовательской программы.
1939   FD0E             ; 1165 // Вывод 8 битного числа на экран.
1940   FD0E             ; 1166 // Параметры: а - число. Результат: нет. Сохраняет: bc, de, hl.
1941   FD0E             ; 1167 
1942   FD0E             ; 1168 void PrintHexByte(...) {
1943   FD0E             printhexbyte: 
1944   FD0E             ; 1169     push_pop(a) {
1945   FD0E F5          	push af
1946   FD0F             ; 1170         cyclic_rotate_right(a, 4);
1947   FD0F 0F          	rrca
1948   FD10 0F          	rrca
1949   FD11 0F          	rrca
1950   FD12 0F          	rrca
1951   FD13             ; 1171         PrintHexNibble(a);
1952   FD13 CD 17 FD    	call printhexnibble
1953   FD16 F1          	pop af
1954   FD17             ; 1172     }
1955   FD17             ; 1173     PrintHexNibble(a);
1956   FD17             ; 1174 }
1957   FD17             ; 1175 
1958   FD17             ; 1176 void PrintHexNibble(...) {
1959   FD17             printhexnibble: 
1960   FD17             ; 1177     a &= 0x0F;
1961   FD17 E6 0F       	and 15
1962   FD19             ; 1178     if (flag_p(compare(a, 10)))
1963   FD19 FE 0A       	cp 10
1964   FD1B             ; 1179         a += 'A' - '0' - 10;
1965   FD1B FA 20 FD    	jp m, l_113
1966   FD1E C6 07       	add 7
1967   FD20             l_113: 
1968   FD20             ; 1180     a += '0';
1969   FD20 C6 30       	add 48
1970   FD22             ; 1181     PrintCharA(a);
1971   FD22             ; 1182 }
1972   FD22             ; 1183 
1973   FD22             ; 1184 // Вывод символа на экран.
1974   FD22             ; 1185 // Параметры: а - символ. Результат: a и c - символ. Сохраняет: a, b, de, hl.
1975   FD22             ; 1186 
1976   FD22             ; 1187 void PrintCharA(...) {
1977   FD22             printchara: 
1978   FD22             ; 1188     PrintChar(c = a);
1979   FD22 4F          	ld c, a
1980   FD23             ; 1189 }
1981   FD23             ; 1190 
1982   FD23             ; 1191 // Функция для пользовательской программы.
1983   FD23             ; 1192 // Вывод символа на экран.
1984   FD23             ; 1193 // Параметры: c - символ. Результат: нет. Сохраняет: a, b, de, hl.
1985   FD23             ; 1194 
1986   FD23             ; 1195 void PrintChar(...) {
1987   FD23             printchar: 
1988   FD23             ; 1196     push(a, bc, de, hl);
1989   FD23 F5          	push af
1990   FD24 C5          	push bc
1991   FD25 D5          	push de
1992   FD26 E5          	push hl
1993   FD27             ; 1197     IsAnyKeyPressed();
1994   FD27 CD B7 FE    	call isanykeypressed
1995   FD2A             ; 1198     DrawCursor(b = 0);
1996   FD2A 06 00       	ld b, 0
1997   FD2C CD 77 FD    	call drawcursor
1998   FD2F             ; 1199     hl = cursor;
1999   FD2F 2A 5A F7    	ld hl, (cursor)
2000   FD32             ; 1200     a = escState;
2001   FD32 3A 5F F7    	ld a, (escstate)
2002   FD35             ; 1201     a--;
2003   FD35 3D          	dec a
2004   FD36             ; 1202     if (flag_m)
2005   FD36             ; 1203         return PrintCharNoEsc();
2006   FD36 FA BF FD    	jp m, printcharnoesc
2007   FD39             ; 1204     if (flag_z)
2008   FD39             ; 1205         return PrintCharEsc();
2009   FD39 CA A0 FD    	jp z, printcharesc
2010   FD3C             ; 1206     a--;
2011   FD3C 3D          	dec a
2012   FD3D             ; 1207     if (flag_nz)
2013   FD3D             ; 1208         return PrintCharEscY2();
2014   FD3D C2 85 FD    	jp nz, printcharescy2
2015   FD40             ; 1209 
2016   FD40             ; 1210     // Первый параметр ESC Y
2017   FD40             ; 1211     a = c;
2018   FD40 79          	ld a, c
2019   FD41             ; 1212     a -= ' ';
2020   FD41 D6 20       	sub 32
2021   FD43             ; 1213     if (flag_m) {
2022   FD43 F2 4A FD    	jp p, l_115
2023   FD46             ; 1214         a ^= a;
2024   FD46 AF          	xor a
2025   FD47 C3 51 FD    	jp l_116
2026   FD4A             l_115: 
2027   FD4A             ; 1215     } else {
2028   FD4A             ; 1216         if (flag_p(compare(a, SCREEN_HEIGHT)))
2029   FD4A FE 20       	cp 32
2030   FD4C             ; 1217             a = SCREEN_HEIGHT - 1;
2031   FD4C FA 51 FD    	jp m, l_117
2032   FD4F 3E 1F       	ld a, 31
2033   FD51             l_117: 
2034   FD51             l_116: 
2035   FD51             ; 1218     }
2036   FD51             ; 1219     cyclic_rotate_right(a, 2);
2037   FD51 0F          	rrca
2038   FD52 0F          	rrca
2039   FD53             ; 1220     c = a;
2040   FD53 4F          	ld c, a
2041   FD54             ; 1221     b = (a &= 192);
2042   FD54 E6 C0       	and 192
2043   FD56 47          	ld b, a
2044   FD57             ; 1222     l = (((a = l) &= 63) |= b);
2045   FD57 7D          	ld a, l
2046   FD58 E6 3F       	and 63
2047   FD5A B0          	or b
2048   FD5B 6F          	ld l, a
2049   FD5C             ; 1223     b = ((a = c) &= 7);
2050   FD5C 79          	ld a, c
2051   FD5D E6 07       	and 7
2052   FD5F 47          	ld b, a
2053   FD60             ; 1224     h = (((a = h) &= 248) |= b);
2054   FD60 7C          	ld a, h
2055   FD61 E6 F8       	and 248
2056   FD63 B0          	or b
2057   FD64 67          	ld h, a
2058   FD65             ; 1225     PrintCharSetEscState(hl, a = 3);
2059   FD65 3E 03       	ld a, 3
2060   FD67             ; 1226 }
2061   FD67             ; 1227 
2062   FD67             ; 1228 void PrintCharSetEscState(...) {
2063   FD67             printcharsetescstate: 
2064   FD67             ; 1229     escState = a;
2065   FD67 32 5F F7    	ld (escstate), a
2066   FD6A             ; 1230     PrintCharSaveCursor(hl);
2067   FD6A             ; 1231 }
2068   FD6A             ; 1232 
2069   FD6A             ; 1233 void PrintCharSaveCursor(...) {
2070   FD6A             printcharsavecursor: 
2071   FD6A             ; 1234     cursor = hl;
2072   FD6A 22 5A F7    	ld (cursor), hl
2073   FD6D             ; 1235     PrintCharExit();
2074   FD6D             ; 1236 }
2075   FD6D             ; 1237 
2076   FD6D             ; 1238 void PrintCharExit(...) {
2077   FD6D             printcharexit: 
2078   FD6D             ; 1239     DrawCursor(b = 0xFF);
2079   FD6D 06 FF       	ld b, 255
2080   FD6F CD 77 FD    	call drawcursor
2081   FD72             ; 1240     pop(a, bc, de, hl);
2082   FD72 E1          	pop hl
2083   FD73 D1          	pop de
2084   FD74 C1          	pop bc
2085   FD75 F1          	pop af
2086   FD76 C9          	ret
2087   FD77             ; 1241 }
2088   FD77             ; 1242 
2089   FD77             ; 1243 void DrawCursor(...) {
2090   FD77             drawcursor: 
2091   FD77             ; 1244     if ((a = cursorVisible) == 0)
2092   FD77 3A 5E F7    	ld a, (cursorvisible)
2093   FD7A B7          	or a
2094   FD7B             ; 1245         return;
2095   FD7B C8          	ret z
2096   FD7C             ; 1246     hl = cursor;
2097   FD7C 2A 5A F7    	ld hl, (cursor)
2098   FD7F             ; 1247     hl += (de = -SCREEN_SIZE + 1);
2099   FD7F 11 01 F8    	ld de, 63489
2100   FD82 19          	add hl, de
2101   FD83             ; 1248     *hl = b;
2102   FD83 70          	ld (hl), b
2103   FD84 C9          	ret
2104   FD85             ; 1249 }
2105   FD85             ; 1250 
2106   FD85             ; 1251 void PrintCharEscY2(...) {
2107   FD85             printcharescy2: 
2108   FD85             ; 1252     a = c;
2109   FD85 79          	ld a, c
2110   FD86             ; 1253     a -= ' ';
2111   FD86 D6 20       	sub 32
2112   FD88             ; 1254     if (flag_m) {
2113   FD88 F2 8F FD    	jp p, l_119
2114   FD8B             ; 1255         a ^= a;
2115   FD8B AF          	xor a
2116   FD8C C3 96 FD    	jp l_120
2117   FD8F             l_119: 
2118   FD8F             ; 1256     } else {
2119   FD8F             ; 1257         if (flag_p(compare(a, SCREEN_WIDTH)))
2120   FD8F FE 40       	cp 64
2121   FD91             ; 1258             a = SCREEN_WIDTH - 1;
2122   FD91 FA 96 FD    	jp m, l_121
2123   FD94 3E 3F       	ld a, 63
2124   FD96             l_121: 
2125   FD96             l_120: 
2126   FD96             ; 1259     }
2127   FD96             ; 1260     b = a;
2128   FD96 47          	ld b, a
2129   FD97             ; 1261     l = (((a = l) &= 192) |= b);
2130   FD97 7D          	ld a, l
2131   FD98 E6 C0       	and 192
2132   FD9A B0          	or b
2133   FD9B 6F          	ld l, a
2134   FD9C             ; 1262     PrintCharResetEscState();
2135   FD9C             ; 1263 }
2136   FD9C             ; 1264 
2137   FD9C             ; 1265 void PrintCharResetEscState(...) {
2138   FD9C             printcharresetescstate: 
2139   FD9C             ; 1266     a ^= a;
2140   FD9C AF          	xor a
2141   FD9D             ; 1267     return PrintCharSetEscState();
2142   FD9D C3 67 FD    	jp printcharsetescstate
2143   FDA0             ; 1268 }
2144   FDA0             ; 1269 
2145   FDA0             ; 1270 void PrintCharEsc(...) {
2146   FDA0             printcharesc: 
2147   FDA0             ; 1271     a = c;
2148   FDA0 79          	ld a, c
2149   FDA1             ; 1272     if (a == 'Y') {
2150   FDA1 FE 59       	cp 89
2151   FDA3 C2 AB FD    	jp nz, l_123
2152   FDA6             ; 1273         a = 2;
2153   FDA6 3E 02       	ld a, 2
2154   FDA8             ; 1274         return PrintCharSetEscState();
2155   FDA8 C3 67 FD    	jp printcharsetescstate
2156   FDAB             l_123: 
2157   FDAB             ; 1275     }
2158   FDAB             ; 1276     if (a == 97) {
2159   FDAB FE 61       	cp 97
2160   FDAD C2 B4 FD    	jp nz, l_125
2161   FDB0             ; 1277         a ^= a;
2162   FDB0 AF          	xor a
2163   FDB1             ; 1278         return SetCursorVisible();
2164   FDB1 C3 B9 FD    	jp setcursorvisible
2165   FDB4             l_125: 
2166   FDB4             ; 1279     }
2167   FDB4             ; 1280     if (a != 98)
2168   FDB4 FE 62       	cp 98
2169   FDB6             ; 1281         return PrintCharResetEscState();
2170   FDB6 C2 9C FD    	jp nz, printcharresetescstate
2171   FDB9             ; 1282     SetCursorVisible();
2172   FDB9             ; 1283 }
2173   FDB9             ; 1284 
2174   FDB9             ; 1285 void SetCursorVisible(...) {
2175   FDB9             setcursorvisible: 
2176   FDB9             ; 1286     cursorVisible = a;
2177   FDB9 32 5E F7    	ld (cursorvisible), a
2178   FDBC             ; 1287     return PrintCharResetEscState();
2179   FDBC C3 9C FD    	jp printcharresetescstate
2180   FDBF             ; 1288 }
2181   FDBF             ; 1289 
2182   FDBF             ; 1290 void PrintCharNoEsc(...) {
2183   FDBF             printcharnoesc: 
2184   FDBF             ; 1291     // Остановка вывода нажатием УС + Шифт
2185   FDBF             ; 1292     do {
2186   FDBF             l_127: 
2187   FDBF             ; 1293         a = in(PORT_KEYBOARD_MODS);
2188   FDBF DB 05       	in a, (5)
2189   FDC1             l_128: 
2190   FDC1             ; 1294     } while (flag_z(a &= (KEYBOARD_US_MOD | KEYBOARD_SHIFT_MOD)));
2191   FDC1 E6 06       	and 6
2192   FDC3 CA BF FD    	jp z, l_127
2193   FDC6             ; 1295 
2194   FDC6             ; 1296     compare(a = 16, c);
2195   FDC6 3E 10       	ld a, 16
2196   FDC8 B9          	cp c
2197   FDC9             ; 1297     a = translateCodeEnabled;
2198   FDC9 3A 7D F7    	ld a, (translatecodeenabled)
2199   FDCC             ; 1298     if (flag_z) {
2200   FDCC C2 D6 FD    	jp nz, l_130
2201   FDCF             ; 1299         invert(a);
2202   FDCF 2F          	cpl
2203   FDD0             ; 1300         translateCodeEnabled = a;
2204   FDD0 32 7D F7    	ld (translatecodeenabled), a
2205   FDD3             ; 1301         return PrintCharSaveCursor();
2206   FDD3 C3 6A FD    	jp printcharsavecursor
2207   FDD6             l_130: 
2208   FDD6             ; 1302     }
2209   FDD6             ; 1303     if (a != 0)
2210   FDD6 B7          	or a
2211   FDD7             ; 1304         TranslateCodePage(c);
2212   FDD7 C4 7E F7    	call nz, translatecodepage
2213   FDDA             ; 1305     a = c;
2214   FDDA 79          	ld a, c
2215   FDDB             ; 1306     if (a == 31)
2216   FDDB FE 1F       	cp 31
2217   FDDD             ; 1307         return ClearScreen();
2218   FDDD CA F1 FD    	jp z, clearscreen
2219   FDE0             ; 1308     if (flag_m)
2220   FDE0             ; 1309         return PrintChar3(a);
2221   FDE0 FA 06 FE    	jp m, printchar3
2222   FDE3             ; 1310     PrintChar4(a);
2223   FDE3             ; 1311 }
2224   FDE3             ; 1312 
2225   FDE3             ; 1313 void PrintChar4(...) {
2226   FDE3             printchar4: 
2227   FDE3             ; 1314     *hl = a;
2228   FDE3 77          	ld (hl), a
2229   FDE4             ; 1315     hl++;
2230   FDE4 23          	inc hl
2231   FDE5             ; 1316     if (flag_m(compare(a = h, SCREEN_END >> 8)))
2232   FDE5 7C          	ld a, h
2233   FDE6 FE F0       	cp 240
2234   FDE8             ; 1317         return PrintCharSaveCursor(hl);
2235   FDE8 FA 6A FD    	jp m, printcharsavecursor
2236   FDEB             ; 1318     PrintCrLf();
2237   FDEB CD AD FE    	call printcrlf
2238   FDEE             ; 1319     PrintCharExit();
2239   FDEE C3 6D FD    	jp printcharexit
2240   FDF1             ; 1320 }
2241   FDF1             ; 1321 
2242   FDF1             ; 1322 void ClearScreen(...) {
2243   FDF1             clearscreen: 
2244   FDF1             ; 1323     b = ' ';
2245   FDF1 06 20       	ld b, 32
2246   FDF3             ; 1324     a = SCREEN_END >> 8;
2247   FDF3 3E F0       	ld a, 240
2248   FDF5             ; 1325     hl = SCREEN_ATTRIB_BEGIN;
2249   FDF5 21 00 E0    	ld hl, 57344
2250   FDF8             ; 1326     do {
2251   FDF8             l_132: 
2252   FDF8             ; 1327         *hl = b;
2253   FDF8 70          	ld (hl), b
2254   FDF9             ; 1328         hl++;
2255   FDF9 23          	inc hl
2256   FDFA             ; 1329         *hl = b;
2257   FDFA 70          	ld (hl), b
2258   FDFB             ; 1330         hl++;
2259   FDFB 23          	inc hl
2260   FDFC             l_133: 
2261   FDFC             ; 1331     } while (a != h);
2262   FDFC BC          	cp h
2263   FDFD C2 F8 FD    	jp nz, l_132
2264   FE00             ; 1332     MoveCursorHome();
2265   FE00             ; 1333 }
2266   FE00             ; 1334 
2267   FE00             ; 1335 void MoveCursorHome(...) {
2268   FE00             movecursorhome: 
2269   FE00             ; 1336     return PrintCharSaveCursor(hl = SCREEN_BEGIN);
2270   FE00 21 00 E8    	ld hl, 59392
2271   FE03 C3 6A FD    	jp printcharsavecursor
2272   FE06             ; 1337 }
2273   FE06             ; 1338 
2274   FE06             ; 1339 void PrintChar3(...) {
2275   FE06             printchar3: 
2276   FE06             ; 1340     if (a == 12)
2277   FE06 FE 0C       	cp 12
2278   FE08             ; 1341         return MoveCursorHome();
2279   FE08 CA 00 FE    	jp z, movecursorhome
2280   FE0B             ; 1342     if (a == 13)
2281   FE0B FE 0D       	cp 13
2282   FE0D             ; 1343         return MoveCursorCr(hl);
2283   FE0D CA 55 FE    	jp z, movecursorcr
2284   FE10             ; 1344     if (a == 10)
2285   FE10 FE 0A       	cp 10
2286   FE12             ; 1345         return MoveCursorLf(hl);
2287   FE12 CA 6A FE    	jp z, movecursorlf
2288   FE15             ; 1346     if (a == 8)
2289   FE15 FE 08       	cp 8
2290   FE17             ; 1347         return MoveCursorLeft(hl);
2291   FE17 CA 66 FE    	jp z, movecursorleft
2292   FE1A             ; 1348     if (a == 24)
2293   FE1A FE 18       	cp 24
2294   FE1C             ; 1349         return MoveCursorRight(hl);
2295   FE1C CA 5C FE    	jp z, movecursorright
2296   FE1F             ; 1350     if (a == 25)
2297   FE1F FE 19       	cp 25
2298   FE21             ; 1351         return MoveCursorUp(hl);
2299   FE21 CA A0 FE    	jp z, movecursorup
2300   FE24             ; 1352     if (a == 7)
2301   FE24 FE 07       	cp 7
2302   FE26             ; 1353         return PrintCharBeep();
2303   FE26 CA 38 FE    	jp z, printcharbeep
2304   FE29             ; 1354     if (a == 26)
2305   FE29 FE 1A       	cp 26
2306   FE2B             ; 1355         return MoveCursorDown();
2307   FE2B CA A7 FE    	jp z, movecursordown
2308   FE2E             ; 1356     if (a != 27)
2309   FE2E FE 1B       	cp 27
2310   FE30             ; 1357         return PrintChar4(hl, a);
2311   FE30 C2 E3 FD    	jp nz, printchar4
2312   FE33             ; 1358     a = 1;
2313   FE33 3E 01       	ld a, 1
2314   FE35             ; 1359     PrintCharSetEscState();
2315   FE35 C3 67 FD    	jp printcharsetescstate
2316   FE38             ; 1360 }
2317   FE38             ; 1361 
2318   FE38             ; 1362 void PrintCharBeep(...) {
2319   FE38             printcharbeep: 
2320   FE38             ; 1363     c = 128;  // Длительность
2321   FE38 0E 80       	ld c, 128
2322   FE3A             ; 1364     e = 32;   // Частота
2323   FE3A 1E 20       	ld e, 32
2324   FE3C             ; 1365     do {
2325   FE3C             l_135: 
2326   FE3C             ; 1366         d = e;
2327   FE3C 53          	ld d, e
2328   FE3D             ; 1367         do {
2329   FE3D             l_138: 
2330   FE3D             ; 1368             out(PORT_KEYBOARD_MODE, a = 1 | (7 << 1));
2331   FE3D 3E 0F       	ld a, 15
2332   FE3F D3 04       	out (4), a
2333   FE41             l_139: 
2334   FE41             ; 1369         } while (flag_nz(e--));
2335   FE41 1D          	dec e
2336   FE42 C2 3D FE    	jp nz, l_138
2337   FE45             ; 1370         e = d;
2338   FE45 5A          	ld e, d
2339   FE46             ; 1371         do {
2340   FE46             l_141: 
2341   FE46             ; 1372             out(PORT_KEYBOARD_MODE, a = (7 << 1));
2342   FE46 3E 0E       	ld a, 14
2343   FE48 D3 04       	out (4), a
2344   FE4A             l_142: 
2345   FE4A             ; 1373         } while (flag_nz(d--));
2346   FE4A 15          	dec d
2347   FE4B C2 46 FE    	jp nz, l_141
2348   FE4E             l_136: 
2349   FE4E             ; 1374     } while (flag_nz(c--));
2350   FE4E 0D          	dec c
2351   FE4F C2 3C FE    	jp nz, l_135
2352   FE52             ; 1375 
2353   FE52             ; 1376     PrintCharExit();
2354   FE52 C3 6D FD    	jp printcharexit
2355   FE55             ; 1377 }
2356   FE55             ; 1378 
2357   FE55             ; 1379 void MoveCursorCr(...) {
2358   FE55             movecursorcr: 
2359   FE55             ; 1380     l = ((a = l) &= ~(SCREEN_WIDTH - 1));
2360   FE55 7D          	ld a, l
2361   FE56 E6 C0       	and 192
2362   FE58 6F          	ld l, a
2363   FE59             ; 1381     PrintCharSaveCursor(hl);
2364   FE59 C3 6A FD    	jp printcharsavecursor
2365   FE5C             ; 1382 }
2366   FE5C             ; 1383 
2367   FE5C             ; 1384 void MoveCursorRight(...) {
2368   FE5C             movecursorright: 
2369   FE5C             ; 1385     hl++;
2370   FE5C 23          	inc hl
2371   FE5D             ; 1386     MoveCursorBoundary(hl);
2372   FE5D             ; 1387 }
2373   FE5D             ; 1388 
2374   FE5D             ; 1389 void MoveCursorBoundary(...) {
2375   FE5D             movecursorboundary: 
2376   FE5D             ; 1390     a = h;
2377   FE5D 7C          	ld a, h
2378   FE5E             ; 1391     a &= 7;
2379   FE5E E6 07       	and 7
2380   FE60             ; 1392     a |= SCREEN_BEGIN >> 8;
2381   FE60 F6 E8       	or 232
2382   FE62             ; 1393     h = a;
2383   FE62 67          	ld h, a
2384   FE63             ; 1394     return PrintCharSaveCursor(hl);
2385   FE63 C3 6A FD    	jp printcharsavecursor
2386   FE66             ; 1395 }
2387   FE66             ; 1396 
2388   FE66             ; 1397 void MoveCursorLeft(...) {
2389   FE66             movecursorleft: 
2390   FE66             ; 1398     hl--;
2391   FE66 2B          	dec hl
2392   FE67             ; 1399     return MoveCursorBoundary(hl);
2393   FE67 C3 5D FE    	jp movecursorboundary
2394   FE6A             ; 1400 }
2395   FE6A             ; 1401 
2396   FE6A             ; 1402 void MoveCursorLf(...) {
2397   FE6A             movecursorlf: 
2398   FE6A             ; 1403     hl += (bc = SCREEN_WIDTH);
2399   FE6A 01 40 00    	ld bc, 64
2400   FE6D 09          	add hl, bc
2401   FE6E             ; 1404     if (flag_m(compare(a = h, SCREEN_END >> 8)))
2402   FE6E 7C          	ld a, h
2403   FE6F FE F0       	cp 240
2404   FE71             ; 1405         return PrintCharSaveCursor(hl);
2405   FE71 FA 6A FD    	jp m, printcharsavecursor
2406   FE74             ; 1406 
2407   FE74             ; 1407     hl = SCREEN_BEGIN;
2408   FE74 21 00 E8    	ld hl, 59392
2409   FE77             ; 1408     bc = (SCREEN_BEGIN + SCREEN_WIDTH);
2410   FE77 01 40 E8    	ld bc, 59456
2411   FE7A             ; 1409     do {
2412   FE7A             l_144: 
2413   FE7A             ; 1410         *hl = a = *bc;
2414   FE7A 0A          	ld a, (bc)
2415   FE7B 77          	ld (hl), a
2416   FE7C             ; 1411         hl++;
2417   FE7C 23          	inc hl
2418   FE7D             ; 1412         bc++;
2419   FE7D 03          	inc bc
2420   FE7E             ; 1413         *hl = a = *bc;
2421   FE7E 0A          	ld a, (bc)
2422   FE7F 77          	ld (hl), a
2423   FE80             ; 1414         hl++;
2424   FE80 23          	inc hl
2425   FE81             ; 1415         bc++;
2426   FE81 03          	inc bc
2427   FE82             l_145: 
2428   FE82             ; 1416     } while (flag_m(compare(a = b, SCREEN_END >> 8)));
2429   FE82 78          	ld a, b
2430   FE83 FE F0       	cp 240
2431   FE85 FA 7A FE    	jp m, l_144
2432   FE88             ; 1417     a = SCREEN_END >> 8;
2433   FE88 3E F0       	ld a, 240
2434   FE8A             ; 1418     c = ' ';
2435   FE8A 0E 20       	ld c, 32
2436   FE8C             ; 1419     do {
2437   FE8C             l_147: 
2438   FE8C             ; 1420         *hl = c;
2439   FE8C 71          	ld (hl), c
2440   FE8D             ; 1421         hl++;
2441   FE8D 23          	inc hl
2442   FE8E             ; 1422         *hl = c;
2443   FE8E 71          	ld (hl), c
2444   FE8F             ; 1423         hl++;
2445   FE8F 23          	inc hl
2446   FE90             l_148: 
2447   FE90             ; 1424     } while (a != h);
2448   FE90 BC          	cp h
2449   FE91 C2 8C FE    	jp nz, l_147
2450   FE94             ; 1425     hl = cursor;
2451   FE94 2A 5A F7    	ld hl, (cursor)
2452   FE97             ; 1426     h = ((SCREEN_END >> 8) - 1);
2453   FE97 26 EF       	ld h, 239
2454   FE99             ; 1427     l = ((a = l) |= 192);
2455   FE99 7D          	ld a, l
2456   FE9A F6 C0       	or 192
2457   FE9C 6F          	ld l, a
2458   FE9D             ; 1428     PrintCharSaveCursor(hl);
2459   FE9D C3 6A FD    	jp printcharsavecursor
2460   FEA0             ; 1429 }
2461   FEA0             ; 1430 
2462   FEA0             ; 1431 void MoveCursorUp(...) {
2463   FEA0             movecursorup: 
2464   FEA0             ; 1432     MoveCursor(hl, bc = -SCREEN_WIDTH);
2465   FEA0 01 C0 FF    	ld bc, 65472
2466   FEA3             ; 1433 }
2467   FEA3             ; 1434 
2468   FEA3             ; 1435 void MoveCursor(...) {
2469   FEA3             movecursor: 
2470   FEA3             ; 1436     hl += bc;
2471   FEA3 09          	add hl, bc
2472   FEA4             ; 1437     MoveCursorBoundary(hl);
2473   FEA4 C3 5D FE    	jp movecursorboundary
2474   FEA7             ; 1438 }
2475   FEA7             ; 1439 
2476   FEA7             ; 1440 void MoveCursorDown(...) {
2477   FEA7             movecursordown: 
2478   FEA7             ; 1441     MoveCursor(hl, bc = SCREEN_WIDTH);
2479   FEA7 01 40 00    	ld bc, 64
2480   FEAA C3 A3 FE    	jp movecursor
2481   FEAD             ; 1442 }
2482   FEAD             ; 1443 
2483   FEAD             ; 1444 void PrintCrLf() {
2484   FEAD             printcrlf: 
2485   FEAD             ; 1445     PrintChar(c = 13);
2486   FEAD 0E 0D       	ld c, 13
2487   FEAF CD 23 FD    	call printchar
2488   FEB2             ; 1446     PrintChar(c = 10);
2489   FEB2 0E 0A       	ld c, 10
2490   FEB4 C3 23 FD    	jp printchar
2491   FEB7             ; 1447 }
2492   FEB7             ; 1448 
2493   FEB7             ; 1449 // Функция для пользовательской программы.
2494   FEB7             ; 1450 // Нажата ли хотя бы одна клавиша на клавиатуре?
2495   FEB7             ; 1451 // Параметры: нет. Результат:  a - 0xFF если клавиша нажата, 0 если нет. Сохраняет: bc, de, hl.
2496   FEB7             ; 1452 
2497   FEB7             ; 1453 void IsAnyKeyPressed() {
2498   FEB7             isanykeypressed: 
2499   FEB7             ; 1454     out(PORT_KEYBOARD_COLUMN, a ^= a);
2500   FEB7 AF          	xor a
2501   FEB8 D3 07       	out (7), a
2502   FEBA             ; 1455     a = in(PORT_KEYBOARD_ROW);
2503   FEBA DB 06       	in a, (6)
2504   FEBC             ; 1456     a &= KEYBOARD_ROW_MASK;
2505   FEBC E6 7F       	and 127
2506   FEBE             ; 1457     if (a == KEYBOARD_ROW_MASK) {
2507   FEBE FE 7F       	cp 127
2508   FEC0 C2 C5 FE    	jp nz, l_150
2509   FEC3             ; 1458         a ^= a;
2510   FEC3 AF          	xor a
2511   FEC4             ; 1459         return;
2512   FEC4 C9          	ret
2513   FEC5             l_150: 
2514   FEC5             ; 1460     }
2515   FEC5             ; 1461     a = 0xFF;
2516   FEC5 3E FF       	ld a, 255
2517   FEC7 C9          	ret
2518   FEC8             ; 1462 }
2519   FEC8             ; 1463 
2520   FEC8             ; 1464 // Функция для пользовательской программы.
2521   FEC8             ; 1465 // Получить код нажатой клавиши на клавиатуре.
2522   FEC8             ; 1466 // В отличии от функции ScanKey, в этой функции есть задержка повтора.
2523   FEC8             ; 1467 // Параметры: нет. Результат: a. Сохраняет: bc, de, hl.
2524   FEC8             ; 1468 
2525   FEC8             ; 1469 void ReadKey() {
2526   FEC8             readkey: 
2527   FEC8             ; 1470     push_pop(hl) {
2528   FEC8 E5          	push hl
2529   FEC9             ; 1471         hl = keyDelay;
2530   FEC9 2A 60 F7    	ld hl, (keydelay)
2531   FECC             ; 1472         ReadKeyInternal(hl);
2532   FECC CD E8 FE    	call readkeyinternal
2533   FECF             ; 1473         l = 32;         // Задержка повтора нажатия клавиши
2534   FECF 2E 20       	ld l, 32
2535   FED1             ; 1474         if (flag_nz) {  // Не таймаут
2536   FED1 CA E3 FE    	jp z, l_152
2537   FED4             ; 1475             do {
2538   FED4             l_154: 
2539   FED4             ; 1476                 do {
2540   FED4             l_157: 
2541   FED4             ; 1477                     l = 2;
2542   FED4 2E 02       	ld l, 2
2543   FED6             ; 1478                     ReadKeyInternal(hl);
2544   FED6 CD E8 FE    	call readkeyinternal
2545   FED9             l_158: 
2546   FED9 C2 D4 FE    	jp nz, l_157
2547   FEDC             l_155: 
2548   FEDC             ; 1479                 } while (flag_nz);  // Цикл длится, пока не наступит таймаут
2549   FEDC             ; 1480             } while (a >= 128);     // Цикл длится, пока не нажата клавиша
2550   FEDC FE 80       	cp 128
2551   FEDE D2 D4 FE    	jp nc, l_154
2552   FEE1             ; 1481             l = 128;                // Задержка повтора первого нажатия клавиши
2553   FEE1 2E 80       	ld l, 128
2554   FEE3             l_152: 
2555   FEE3             ; 1482         }
2556   FEE3             ; 1483         keyDelay = hl;
2557   FEE3 22 60 F7    	ld (keydelay), hl
2558   FEE6 E1          	pop hl
2559   FEE7 C9          	ret
2560   FEE8             ; 1484     }
2561   FEE8             ; 1485 }
2562   FEE8             ; 1486 
2563   FEE8             ; 1487 void ReadKeyInternal(...) {
2564   FEE8             readkeyinternal: 
2565   FEE8             ; 1488     do {
2566   FEE8             l_160: 
2567   FEE8             ; 1489         ScanKey();
2568   FEE8 CD FE FE    	call scankey
2569   FEEB             ; 1490         if (a != h)
2570   FEEB BC          	cp h
2571   FEEC             ; 1491             break;
2572   FEEC C2 FC FE    	jp nz, l_162
2573   FEEF             ; 1492 
2574   FEEF             ; 1493         // Задержка
2575   FEEF             ; 1494         push_pop(a) {
2576   FEEF F5          	push af
2577   FEF0             ; 1495             a ^= a;
2578   FEF0 AF          	xor a
2579   FEF1             ; 1496             do {
2580   FEF1             l_163: 
2581   FEF1             ; 1497                 swap(hl, de);
2582   FEF1 EB          	ex hl, de
2583   FEF2             ; 1498                 swap(hl, de);
2584   FEF2 EB          	ex hl, de
2585   FEF3             l_164: 
2586   FEF3             ; 1499             } while (flag_nz(a--));
2587   FEF3 3D          	dec a
2588   FEF4 C2 F1 FE    	jp nz, l_163
2589   FEF7 F1          	pop af
2590   FEF8             l_161: 
2591   FEF8             ; 1500         }
2592   FEF8             ; 1501     } while (flag_nz(l--));
2593   FEF8 2D          	dec l
2594   FEF9 C2 E8 FE    	jp nz, l_160
2595   FEFC             l_162: 
2596   FEFC             ; 1502     h = a;
2597   FEFC 67          	ld h, a
2598   FEFD C9          	ret
2599   FEFE             ; 1503 }
2600   FEFE             ; 1504 
2601   FEFE             ; 1505 // Функция для пользовательской программы.
2602   FEFE             ; 1506 // Получить код нажатой клавиши на клавиатуре.
2603   FEFE             ; 1507 // Параметры: нет. Результат: a. Сохраняет: bc, de, hl.
2604   FEFE             ; 1508 
2605   FEFE             ; 1509 void ScanKey() {
2606   FEFE             scankey: 
2607   FEFE             ; 1510     push(bc, de, hl);
2608   FEFE C5          	push bc
2609   FEFF D5          	push de
2610   FF00 E5          	push hl
2611   FF01             ; 1511 
2612   FF01             ; 1512     bc = 0x00FE;
2613   FF01 01 FE 00    	ld bc, 254
2614   FF04             ; 1513     d = KEYBOARD_COLUMN_COUNT;
2615   FF04 16 08       	ld d, 8
2616   FF06             ; 1514     do {
2617   FF06             l_166: 
2618   FF06             ; 1515         a = c;
2619   FF06 79          	ld a, c
2620   FF07             ; 1516         out(PORT_KEYBOARD_COLUMN, a);
2621   FF07 D3 07       	out (7), a
2622   FF09             ; 1517         cyclic_rotate_left(a, 1);
2623   FF09 07          	rlca
2624   FF0A             ; 1518         c = a;
2625   FF0A 4F          	ld c, a
2626   FF0B             ; 1519         a = in(PORT_KEYBOARD_ROW);
2627   FF0B DB 06       	in a, (6)
2628   FF0D             ; 1520         a &= KEYBOARD_ROW_MASK;
2629   FF0D E6 7F       	and 127
2630   FF0F             ; 1521         if (a != KEYBOARD_ROW_MASK)
2631   FF0F FE 7F       	cp 127
2632   FF11             ; 1522             return ScanKey2(a);
2633   FF11 C2 28 FF    	jp nz, scankey2
2634   FF14             ; 1523         b = ((a = b) += KEYBOARD_ROW_COUNT);
2635   FF14 78          	ld a, b
2636   FF15 C6 07       	add 7
2637   FF17 47          	ld b, a
2638   FF18             l_167: 
2639   FF18             ; 1524     } while (flag_nz(d--));
2640   FF18 15          	dec d
2641   FF19 C2 06 FF    	jp nz, l_166
2642   FF1C             ; 1525 
2643   FF1C             ; 1526     a = in(PORT_KEYBOARD_MODS);
2644   FF1C DB 05       	in a, (5)
2645   FF1E             ; 1527     carry_rotate_right(a, 1);
2646   FF1E 1F          	rra
2647   FF1F             ; 1528     a = 0xFF;  // Клавиша не нажата
2648   FF1F 3E FF       	ld a, 255
2649   FF21             ; 1529     if (flag_c)
2650   FF21             ; 1530         return ScanKeyExit(a);
2651   FF21 DA 64 FF    	jp c, scankeyexit
2652   FF24             ; 1531     a--;  // Рус/Лат
2653   FF24 3D          	dec a
2654   FF25             ; 1532     ScanKeyExit(a);
2655   FF25 C3 64 FF    	jp scankeyexit
2656   FF28             ; 1533 }
2657   FF28             ; 1534 
2658   FF28             ; 1535 void ScanKey2(...) {
2659   FF28             scankey2: 
2660   FF28             ; 1536     for (;;) {
2661   FF28             l_170: 
2662   FF28             ; 1537         carry_rotate_right(a, 1);
2663   FF28 1F          	rra
2664   FF29             ; 1538         if (flag_nc)
2665   FF29             ; 1539             break;
2666   FF29 D2 30 FF    	jp nc, l_171
2667   FF2C             ; 1540         b++;
2668   FF2C 04          	inc b
2669   FF2D C3 28 FF    	jp l_170
2670   FF30             l_171: 
2671   FF30             ; 1541     }
2672   FF30             ; 1542 
2673   FF30             ; 1543     /* b - key number */
2674   FF30             ; 1544 
2675   FF30             ; 1545     /*  0    0    1 !   2 "   3 #   4 $   5 %   6 &   7 ,
2676   FF30             ; 1546      *  8   8 (   9 )   : *   ; +   , <   - =   . >   / ?
2677   FF30             ; 1547      * 16   @ Ю   A А   B Б   C Ц   D Д   E Е   F Ф   G Г
2678   FF30             ; 1548      * 24   H Х   I И   J Й   K К   L Л   M М   N Н   O О
2679   FF30             ; 1549      * 32   P П   Q Я   R Р   S С   T Т   U У   V Ж   W В
2680   FF30             ; 1550      * 40   X Ь   Y Ы   Z З   [ Ш   \ Э   ] Щ   ^ Ч    _
2681   FF30             ; 1551      * 48   Space Right Left  Up    Down  Vk    Str   Home */
2682   FF30             ; 1552 
2683   FF30             ; 1553     a = b;
2684   FF30 78          	ld a, b
2685   FF31             ; 1554     if (a >= 48)
2686   FF31 FE 30       	cp 48
2687   FF33             ; 1555         return ScanKeySpecial(a);
2688   FF33 D2 8A FF    	jp nc, scankeyspecial
2689   FF36             ; 1556     a += 48;
2690   FF36 C6 30       	add 48
2691   FF38             ; 1557     if (a >= 60)
2692   FF38 FE 3C       	cp 60
2693   FF3A             ; 1558         if (a < 64)
2694   FF3A DA 44 FF    	jp c, l_172
2695   FF3D FE 40       	cp 64
2696   FF3F             ; 1559             a &= 47;
2697   FF3F D2 44 FF    	jp nc, l_174
2698   FF42 E6 2F       	and 47
2699   FF44             l_174: 
2700   FF44             l_172: 
2701   FF44             ; 1560 
2702   FF44             ; 1561     if (a == 95)
2703   FF44 FE 5F       	cp 95
2704   FF46             ; 1562         a = 127;
2705   FF46 C2 4B FF    	jp nz, l_176
2706   FF49 3E 7F       	ld a, 127
2707   FF4B             l_176: 
2708   FF4B             ; 1563 
2709   FF4B             ; 1564     c = a;
2710   FF4B 4F          	ld c, a
2711   FF4C             ; 1565     a = in(PORT_KEYBOARD_MODS);
2712   FF4C DB 05       	in a, (5)
2713   FF4E             ; 1566     a &= KEYBOARD_MODS_MASK;
2714   FF4E E6 07       	and 7
2715   FF50             ; 1567     compare(a, KEYBOARD_MODS_MASK);
2716   FF50 FE 07       	cp 7
2717   FF52             ; 1568     b = a;
2718   FF52 47          	ld b, a
2719   FF53             ; 1569     a = c;
2720   FF53 79          	ld a, c
2721   FF54             ; 1570     if (flag_z)
2722   FF54             ; 1571         return ScanKeyExit(a);
2723   FF54 CA 64 FF    	jp z, scankeyexit
2724   FF57             ; 1572     a = b;
2725   FF57 78          	ld a, b
2726   FF58             ; 1573     carry_rotate_right(a, 2);
2727   FF58 1F          	rra
2728   FF59 1F          	rra
2729   FF5A             ; 1574     if (flag_nc)
2730   FF5A             ; 1575         return ScanKeyControl(c);
2731   FF5A D2 68 FF    	jp nc, scankeycontrol
2732   FF5D             ; 1576     carry_rotate_right(a, 1);
2733   FF5D 1F          	rra
2734   FF5E             ; 1577     if (flag_nc)
2735   FF5E             ; 1578         return ScanKeyShift();
2736   FF5E D2 6E FF    	jp nc, scankeyshift
2737   FF61             ; 1579     (a = c) |= 0x20;
2738   FF61 79          	ld a, c
2739   FF62 F6 20       	or 32
2740   FF64             ; 1580     ScanKeyExit(a);
2741   FF64             ; 1581 }
2742   FF64             ; 1582 
2743   FF64             ; 1583 void ScanKeyExit(...) {
2744   FF64             scankeyexit: 
2745   FF64             ; 1584     pop(bc, de, hl);
2746   FF64 E1          	pop hl
2747   FF65 D1          	pop de
2748   FF66 C1          	pop bc
2749   FF67 C9          	ret
2750   FF68             ; 1585 }
2751   FF68             ; 1586 
2752   FF68             ; 1587 void ScanKeyControl(...) {
2753   FF68             scankeycontrol: 
2754   FF68             ; 1588     a = c;
2755   FF68 79          	ld a, c
2756   FF69             ; 1589     a &= 0x1F;
2757   FF69 E6 1F       	and 31
2758   FF6B             ; 1590     return ScanKeyExit(a);
2759   FF6B C3 64 FF    	jp scankeyexit
2760   FF6E             ; 1591 }
2761   FF6E             ; 1592 
2762   FF6E             ; 1593 void ScanKeyShift(...) {
2763   FF6E             scankeyshift: 
2764   FF6E             ; 1594     if ((a = c) == 127)
2765   FF6E 79          	ld a, c
2766   FF6F FE 7F       	cp 127
2767   FF71             ; 1595         a = 95;
2768   FF71 C2 76 FF    	jp nz, l_178
2769   FF74 3E 5F       	ld a, 95
2770   FF76             l_178: 
2771   FF76             ; 1596     if (a >= 64)
2772   FF76 FE 40       	cp 64
2773   FF78             ; 1597         return ScanKeyExit();
2774   FF78 D2 64 FF    	jp nc, scankeyexit
2775   FF7B             ; 1598     if (a < 48) {
2776   FF7B FE 30       	cp 48
2777   FF7D D2 85 FF    	jp nc, l_180
2778   FF80             ; 1599         a |= 16;
2779   FF80 F6 10       	or 16
2780   FF82             ; 1600         return ScanKeyExit();
2781   FF82 C3 64 FF    	jp scankeyexit
2782   FF85             l_180: 
2783   FF85             ; 1601     }
2784   FF85             ; 1602     a &= 47;
2785   FF85 E6 2F       	and 47
2786   FF87             ; 1603     return ScanKeyExit();
2787   FF87 C3 64 FF    	jp scankeyexit
2788   FF8A             ; 1604 }
2789   FF8A             ; 1605 
2790   FF8A             ; 1606 void ScanKeySpecial(...) {
2791   FF8A             scankeyspecial: 
2792   FF8A             ; 1607     hl = specialKeyTable;
2793   FF8A 21 97 FF    	ld hl, 0FFFFh & (specialkeytable)
2794   FF8D             ; 1608     c = (a -= 48);
2795   FF8D D6 30       	sub 48
2796   FF8F 4F          	ld c, a
2797   FF90             ; 1609     b = 0;
2798   FF90 06 00       	ld b, 0
2799   FF92             ; 1610     hl += bc;
2800   FF92 09          	add hl, bc
2801   FF93             ; 1611     a = *hl;
2802   FF93 7E          	ld a, (hl)
2803   FF94             ; 1612     return ScanKeyExit(a);
2804   FF94 C3 64 FF    	jp scankeyexit
2805   FF97             ; 1613 }
2806   FF97             ; 1614 
2807   FF97             ; 1615 uint8_t specialKeyTable[] = {
2808   FF97             specialkeytable: 
2809   FF97 20          	db 32
2810   FF98 18          	db 24
2811   FF99 08          	db 8
2812   FF9A 19          	db 25
2813   FF9B 1A          	db 26
2814   FF9C 0D          	db 13
2815   FF9D 1F          	db 31
2816   FF9E 0C          	db 12
2817   FF9F             ; 1626  aPrompt[6] = "\r\n-->";
2818   FF9F             aprompt: 
2819   FF9F 0D          	db 13
2820   FFA0 0A          	db 10
2821   FFA1 2D          	db 45
2822   FFA2 2D          	db 45
2823   FFA3 3E          	db 62
2824   FFA4 00          	ds 1
2825   FFA5             ; 1627  aCrLfTab[6] = "\r\n\x18\x18\x18";
2826   FFA5             acrlftab: 
2827   FFA5 0D          	db 13
2828   FFA6 0A          	db 10
2829   FFA7 18          	db 24
2830   FFA8 18          	db 24
2831   FFA9 18          	db 24
2832   FFAA 00          	ds 1
2833   FFAB             ; 1628  aRegisters[] = "\r\nPC-\r\nHL-\r\nBC-\r\nDE-\r\nSP-\r\nAF-\x19\x19\x19\x19\x19\x19";
2834   FFAB             aregisters: 
2835   FFAB 0D          	db 13
2836   FFAC 0A          	db 10
2837   FFAD 50          	db 80
2838   FFAE 43          	db 67
2839   FFAF 2D          	db 45
2840   FFB0 0D          	db 13
2841   FFB1 0A          	db 10
2842   FFB2 48          	db 72
2843   FFB3 4C          	db 76
2844   FFB4 2D          	db 45
2845   FFB5 0D          	db 13
2846   FFB6 0A          	db 10
2847   FFB7 42          	db 66
2848   FFB8 43          	db 67
2849   FFB9 2D          	db 45
2850   FFBA 0D          	db 13
2851   FFBB 0A          	db 10
2852   FFBC 44          	db 68
2853   FFBD 45          	db 69
2854   FFBE 2D          	db 45
2855   FFBF 0D          	db 13
2856   FFC0 0A          	db 10
2857   FFC1 53          	db 83
2858   FFC2 50          	db 80
2859   FFC3 2D          	db 45
2860   FFC4 0D          	db 13
2861   FFC5 0A          	db 10
2862   FFC6 41          	db 65
2863   FFC7 46          	db 70
2864   FFC8 2D          	db 45
2865   FFC9 19          	db 25
2866   FFCA 19          	db 25
2867   FFCB 19          	db 25
2868   FFCC 19          	db 25
2869   FFCD 19          	db 25
2870   FFCE 19          	db 25
2871   FFCF 00          	ds 1
2872   FFD0             ; 1629  aBackspace[4] = "\x08 \x08";
2873   FFD0             abackspace: 
2874   FFD0 08          	db 8
2875   FFD1 20          	db 32
2876   FFD2 08          	db 8
2877   FFD3 00          	ds 1
2878   FFD4             ; 1630  aHello[] = "\x1F\nm/80k ";
2879   FFD4             ahello: 
2880   FFD4 1F          	db 31
2881   FFD5 0A          	db 10
2882   FFD6 6D          	db 109
2883   FFD7 2F          	db 47
2884   FFD8 38          	db 56
2885   FFD9 30          	db 48
2886   FFDA 6B          	db 107
2887   FFDB 20          	db 32
2888   FFDC 00          	ds 1
2889   FFDD             ; 1632  TranslateCodePageDefault(...) {
2890   FFDD             translatecodepagedefault: 
2891   FFDD C9          	ret
2892   FFDE             ; 1633 }
2893   FFDE             ; 1634 
2894   FFDE             ; 1635 uint8_t padding[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
2895   FFDE             padding: 
2896   FFDE FF          	db 255
2897   FFDF FF          	db 255
2898   FFE0 FF          	db 255
2899   FFE1 FF          	db 255
2900   FFE2 FF          	db 255
2901   FFE3 FF          	db 255
2902   FFE4 FF          	db 255
2903   FFE5 FF          	db 255
2904   FFE6 FF          	db 255
2905   FFE7 FF          	db 255
2906   FFE8 FF          	db 255
2907   FFE9 FF          	db 255
2908   FFEA FF          	db 255
2909   FFEB FF          	db 255
2910   FFEC FF          	db 255
2911   FFED FF          	db 255
2912   FFEE FF          	db 255
2913   FFEF FF          	db 255
2914   FFF0 FF          	db 255
2915   FFF1 FF          	db 255
2916   FFF2 FF          	db 255
2917   FFF3 FF          	db 255
2918   FFF4 FF          	db 255
2919   FFF5 FF          	db 255
2920   FFF6 FF          	db 255
2921   FFF7 FF          	db 255
2922   FFF8 FF          	db 255
2923   FFF9 FF          	db 255
2924   FFFA FF          	db 255
2925   FFFB FF          	db 255
2926   FFFC FF          	db 255
2927   FFFD FF          	db 255
2928   FFFE FF          	db 255
2929   FFFF FF          	db 255
2930   0000              savebin "micro80.bin", 0xF800, 0x10000
2931   0000             
