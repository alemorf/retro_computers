0001   0000                 device zxspectrum48 ; It has nothing to do with ZX Spectrum 48K, it is needed for the sjasmplus compiler.
0002   0000             rst30opcode equ 48
0003   0000             rst30address equ 49
0004   0000             rst38opcode equ 56
0005   0000             rst38address equ 57
0006   0000             cursor equ 63322
0007   0000             tapereadspeed equ 63324
0008   0000             tapewritespeed equ 63325
0009   0000             cursorvisible equ 63326
0010   0000             escstate equ 63327
0011   0000             keydelay equ 63328
0012   0000             regpc equ 63330
0013   0000             reghl equ 63332
0014   0000             regbc equ 63334
0015   0000             regde equ 63336
0016   0000             regsp equ 63338
0017   0000             regaf equ 63340
0018   0000             breakpointaddress equ 63345
0019   0000             breakpointvalue equ 63347
0020   0000             jmpparam1opcode equ 63348
0021   0000             param1 equ 63349
0022   0000             param2 equ 63351
0023   0000             param3 equ 63353
0024   0000             param2exists equ 63355
0025   0000             tapepolarity equ 63356
0026   0000             translatecodeenabled equ 63357
0027   0000             translatecodepagejump equ 63358
0028   0000             translatecodepageaddress equ 63359
0029   0000             ramtop equ 63361
0030   0000             inputbuffer equ 63363
0031   0000             jmpparam1 equ 63348
0032   0000             translatecodepage equ 63358
0033   0000              .org 0xF800
0034   F800             ; 52  uint8_t rst30Opcode __address(0x30);
0035   F800             ; 53 extern uint16_t rst30Address __address(0x31);
0036   F800             ; 54 extern uint8_t rst38Opcode __address(0x38);
0037   F800             ; 55 extern uint16_t rst38Address __address(0x39);
0038   F800             ; 56 
0039   F800             ; 57 // Прототипы
0040   F800             ; 58 void Reboot(...);
0041   F800             ; 59 void EntryF86C_Monitor(...);
0042   F800             ; 60 void Reboot2(...);
0043   F800             ; 61 void Monitor(...);
0044   F800             ; 62 void Monitor2();
0045   F800             ; 63 void ReadStringBackspace(...);
0046   F800             ; 64 void ReadString(...);
0047   F800             ; 65 void ReadStringBegin(...);
0048   F800             ; 66 void ReadStringLoop(...);
0049   F800             ; 67 void ReadStringExit(...);
0050   F800             ; 68 void PrintString(...);
0051   F800             ; 69 void ParseParams(...);
0052   F800             ; 70 void ParseWord(...);
0053   F800             ; 71 void ParseWordReturnCf(...);
0054   F800             ; 72 void CompareHlDe(...);
0055   F800             ; 73 void LoopWithBreak(...);
0056   F800             ; 74 void Loop(...);
0057   F800             ; 75 void PopRet();
0058   F800             ; 76 void IncHl(...);
0059   F800             ; 77 void CtrlC(...);
0060   F800             ; 78 void PrintCrLfTab();
0061   F800             ; 79 void PrintHexByteFromHlSpace(...);
0062   F800             ; 80 void PrintHexByteSpace(...);
0063   F800             ; 81 void CmdR(...);
0064   F800             ; 82 void GetRamTop(...);
0065   F800             ; 83 void SetRamTop(...);
0066   F800             ; 84 void CmdA(...);
0067   F800             ; 85 void CmdD(...);
0068   F800             ; 86 void PrintSpacesTo(...);
0069   F800             ; 87 void PrintSpace();
0070   F800             ; 88 void CmdC(...);
0071   F800             ; 89 void CmdF(...);
0072   F800             ; 90 void CmdS(...);
0073   F800             ; 91 void CmdW(...);
0074   F800             ; 92 void CmdT(...);
0075   F800             ; 93 void CmdM(...);
0076   F800             ; 94 void CmdG(...);
0077   F800             ; 95 void BreakPointHandler(...);
0078   F800             ; 96 void CmdX(...);
0079   F800             ; 97 void GetCursor();
0080   F800             ; 98 void GetCursorChar();
0081   F800             ; 99 void CmdH(...);
0082   F800             ; 100 void CmdI(...);
0083   F800             ; 101 void MonitorError();
0084   F800             ; 102 void ReadTapeFile(...);
0085   F800             ; 103 void ReadTapeWordNext();
0086   F800             ; 104 void ReadTapeWord(...);
0087   F800             ; 105 void ReadTapeBlock(...);
0088   F800             ; 106 void CalculateCheckSum(...);
0089   F800             ; 107 void CmdO(...);
0090   F800             ; 108 void WriteTapeFile(...);
0091   F800             ; 109 void PrintCrLfTabHexWordSpace(...);
0092   F800             ; 110 void PrintHexWordSpace(...);
0093   F800             ; 111 void WriteTapeBlock(...);
0094   F800             ; 112 void WriteTapeWord(...);
0095   F800             ; 113 void ReadTapeByte(...);
0096   F800             ; 114 void ReadTapeByteInternal(...);
0097   F800             ; 115 void ReadTapeByteTimeout(...);
0098   F800             ; 116 void WriteTapeByte(...);
0099   F800             ; 117 void PrintHexByte(...);
0100   F800             ; 118 void PrintHexNibble(...);
0101   F800             ; 119 void PrintCharA(...);
0102   F800             ; 120 void PrintChar(...);
0103   F800             ; 121 void PrintCharSetEscState(...);
0104   F800             ; 122 void PrintCharSaveCursor(...);
0105   F800             ; 123 void PrintCharExit(...);
0106   F800             ; 124 void DrawCursor(...);
0107   F800             ; 125 void PrintCharEscY2(...);
0108   F800             ; 126 void PrintCharResetEscState(...);
0109   F800             ; 127 void PrintCharEsc(...);
0110   F800             ; 128 void SetCursorVisible(...);
0111   F800             ; 129 void PrintCharNoEsc(...);
0112   F800             ; 130 void PrintChar4(...);
0113   F800             ; 131 void ClearScreen(...);
0114   F800             ; 132 void MoveCursorHome(...);
0115   F800             ; 133 void PrintChar3(...);
0116   F800             ; 134 void PrintCharBeep(...);
0117   F800             ; 135 void MoveCursorCr(...);
0118   F800             ; 136 void MoveCursorRight(...);
0119   F800             ; 137 void MoveCursorBoundary(...);
0120   F800             ; 138 void MoveCursorLeft(...);
0121   F800             ; 139 void MoveCursorLf(...);
0122   F800             ; 140 void MoveCursorUp(...);
0123   F800             ; 141 void MoveCursor(...);
0124   F800             ; 142 void MoveCursorDown(...);
0125   F800             ; 143 void PrintCrLf();
0126   F800             ; 144 void IsAnyKeyPressed();
0127   F800             ; 145 void ReadKey();
0128   F800             ; 146 void ReadKeyInternal(...);
0129   F800             ; 147 void ScanKey();
0130   F800             ; 148 void ScanKey2(...);
0131   F800             ; 149 void ScanKeyExit(...);
0132   F800             ; 150 void ScanKeyControl(...);
0133   F800             ; 151 void ScanKeyShift(...);
0134   F800             ; 152 void ScanKeySpecial(...);
0135   F800             ; 153 void TranslateCodePageDefault(...);
0136   F800             ; 154 
0137   F800             ; 155 // Переменные Монитора
0138   F800             ; 156 
0139   F800             ; 157 extern uint16_t cursor __address(0xF75A);
0140   F800             ; 158 extern uint8_t tapeReadSpeed __address(0xF75C);
0141   F800             ; 159 extern uint8_t tapeWriteSpeed __address(0xF75D);
0142   F800             ; 160 extern uint8_t cursorVisible __address(0xF75E);
0143   F800             ; 161 extern uint8_t escState __address(0xF75F);
0144   F800             ; 162 extern uint16_t keyDelay __address(0xF760);
0145   F800             ; 163 extern uint16_t regPC __address(0xF762);
0146   F800             ; 164 extern uint16_t regHL __address(0xF764);
0147   F800             ; 165 extern uint16_t regBC __address(0xF766);
0148   F800             ; 166 extern uint16_t regDE __address(0xF768);
0149   F800             ; 167 extern uint16_t regSP __address(0xF76A);
0150   F800             ; 168 extern uint16_t regAF __address(0xF76C);
0151   F800             ; 169 extern uint16_t breakPointAddress __address(0xF771);
0152   F800             ; 170 extern uint8_t breakPointValue __address(0xF773);
0153   F800             ; 171 extern uint8_t jmpParam1Opcode __address(0xF774);
0154   F800             ; 172 extern uint16_t param1 __address(0xF775);
0155   F800             ; 173 extern uint16_t param2 __address(0xF777);
0156   F800             ; 174 extern uint16_t param3 __address(0xF779);
0157   F800             ; 175 extern uint8_t param2Exists __address(0xF77B);
0158   F800             ; 176 extern uint8_t tapePolarity __address(0xF77C);
0159   F800             ; 177 extern uint8_t translateCodeEnabled __address(0xF77D);
0160   F800             ; 178 extern uint8_t translateCodePageJump __address(0xF77E);
0161   F800             ; 179 extern uint16_t translateCodePageAddress __address(0xF77F);
0162   F800             ; 180 extern uint16_t ramTop __address(0xF781);
0163   F800             ; 181 extern uint8_t inputBuffer[32] __address(0xF783);
0164   F800             ; 182 
0165   F800             ; 183 extern uint8_t specialKeyTable[8];
0166   F800             ; 184 extern uint8_t aPrompt[6];
0167   F800             ; 185 extern uint8_t aCrLfTab[6];
0168   F800             ; 186 extern uint8_t aRegisters[37];
0169   F800             ; 187 extern uint8_t aBackspace[4];
0170   F800             ; 188 extern uint8_t aHello[9];
0171   F800             ; 189 
0172   F800             ; 190 // Для удобства
0173   F800             ; 191 
0174   F800             ; 192 void JmpParam1() __address(0xF774);
0175   F800             ; 193 void TranslateCodePage() __address(0xF77E);
0176   F800             ; 194 
0177   F800             ; 195 // Точки входа
0178   F800             ; 196 
0179   F800             ; 197 void EntryF800_Reboot() {
0180   F800             entryf800_reboot: 
0181   F800             ; 198     Reboot();
0182   F800 C3 36 F8    	jp reboot
0183   F803             ; 199 }
0184   F803             ; 200 
0185   F803             ; 201 void EntryF803_ReadKey() {
0186   F803             entryf803_readkey: 
0187   F803             ; 202     ReadKey();
0188   F803 C3 C8 FE    	jp readkey
0189   F806             ; 203 }
0190   F806             ; 204 
0191   F806             ; 205 void EntryF806_ReadTapeByte(...) {
0192   F806             entryf806_readtapebyte: 
0193   F806             ; 206     ReadTapeByte(a);
0194   F806 C3 74 FC    	jp readtapebyte
0195   F809             ; 207 }
0196   F809             ; 208 
0197   F809             ; 209 void EntryF809_PrintChar(...) {
0198   F809             entryf809_printchar: 
0199   F809             ; 210     PrintChar(c);
0200   F809 C3 23 FD    	jp printchar
0201   F80C             ; 211 }
0202   F80C             ; 212 
0203   F80C             ; 213 void EntryF80C_WriteTapeByte(...) {
0204   F80C             entryf80c_writetapebyte: 
0205   F80C             ; 214     WriteTapeByte(c);
0206   F80C C3 DD FC    	jp writetapebyte
0207   F80F             ; 215 }
0208   F80F             ; 216 
0209   F80F             ; 217 void EntryF80F_TranslateCodePage(...) {
0210   F80F             entryf80f_translatecodepage: 
0211   F80F             ; 218     TranslateCodePage(c);
0212   F80F C3 7E F7    	jp translatecodepage
0213   F812             ; 219 }
0214   F812             ; 220 
0215   F812             ; 221 void EntryF812_IsAnyKeyPressed() {
0216   F812             entryf812_isanykeypressed: 
0217   F812             ; 222     IsAnyKeyPressed();
0218   F812 C3 B7 FE    	jp isanykeypressed
0219   F815             ; 223 }
0220   F815             ; 224 
0221   F815             ; 225 void EntryF815_PrintHexByte(...) {
0222   F815             entryf815_printhexbyte: 
0223   F815             ; 226     PrintHexByte(a);
0224   F815 C3 0E FD    	jp printhexbyte
0225   F818             ; 227 }
0226   F818             ; 228 
0227   F818             ; 229 void EntryF818_PrintString(...) {
0228   F818             entryf818_printstring: 
0229   F818             ; 230     PrintString(hl);
0230   F818 C3 48 F9    	jp printstring
0231   F81B             ; 231 }
0232   F81B             ; 232 
0233   F81B             ; 233 void EntryF81B_ScanKey() {
0234   F81B             entryf81b_scankey: 
0235   F81B             ; 234     ScanKey();
0236   F81B C3 FE FE    	jp scankey
0237   F81E             ; 235 }
0238   F81E             ; 236 
0239   F81E             ; 237 void EntryF81E_GetCursor() {
0240   F81E             entryf81e_getcursor: 
0241   F81E             ; 238     GetCursor();
0242   F81E C3 49 FB    	jp getcursor
0243   F821             ; 239 }
0244   F821             ; 240 
0245   F821             ; 241 void EntryF821_GetCursorChar() {
0246   F821             entryf821_getcursorchar: 
0247   F821             ; 242     GetCursorChar();
0248   F821 C3 5E FB    	jp getcursorchar
0249   F824             ; 243 }
0250   F824             ; 244 
0251   F824             ; 245 void EntryF824_ReadTapeFile(...) {
0252   F824             entryf824_readtapefile: 
0253   F824             ; 246     ReadTapeFile(hl);
0254   F824 C3 BA FB    	jp readtapefile
0255   F827             ; 247 }
0256   F827             ; 248 
0257   F827             ; 249 void EntryF827_WriteTapeFile(...) {
0258   F827             entryf827_writetapefile: 
0259   F827             ; 250     WriteTapeFile(bc, de, hl);
0260   F827 C3 24 FC    	jp writetapefile
0261   F82A             ; 251 }
0262   F82A             ; 252 
0263   F82A             ; 253 void EntryF82A_CalculateCheckSum(...) {
0264   F82A             entryf82a_calculatechecksum: 
0265   F82A             ; 254     CalculateCheckSum(hl, de);
0266   F82A C3 F1 FB    	jp calculatechecksum
0267   F82D             ; 255 }
0268   F82D             ; 256 
0269   F82D             ; 257 void EntryF82D_EnableScreen() {
0270   F82D             entryf82d_enablescreen: 
0271   F82D C9          	ret
0272   F82E             ; 258 }
0273   F82E             ; 259 
0274   F82E             ; 260 uint16_t empty = 0;
0275   F82E             empty: 
0276   F82E 00 00       	dw 0
0277   F830             ; 262  EntryF830_GetRamTop() {
0278   F830             entryf830_getramtop: 
0279   F830             ; 263     GetRamTop();
0280   F830 C3 FA F9    	jp getramtop
0281   F833             ; 264 }
0282   F833             ; 265 
0283   F833             ; 266 void EntryF833_SetRamTop(...) {
0284   F833             entryf833_setramtop: 
0285   F833             ; 267     SetRamTop(hl);
0286   F833 C3 FE F9    	jp setramtop
0287   F836             ; 268 }
0288   F836             ; 269 
0289   F836             ; 270 // Инициализация. Выполняется после перезагрузки или пользовательской программой.
0290   F836             ; 271 // Параметры: нет. Функция никогда не завершается.
0291   F836             ; 272 
0292   F836             ; 273 void Reboot(...) {
0293   F836             reboot: 
0294   F836             ; 274     sp = STACK_TOP;
0295   F836 31 00 F8    	ld sp, 63488
0296   F839             ; 275 
0297   F839             ; 276     // Очистка памяти
0298   F839             ; 277     hl = &tapeWriteSpeed;
0299   F839 21 5D F7    	ld hl, 0FFFFh & (tapewritespeed)
0300   F83C             ; 278     de = inputBuffer + sizeof(inputBuffer) - 1;
0301   F83C 11 A2 F7    	ld de, 0FFFFh & (((inputbuffer) + (32)) - (1))
0302   F83F             ; 279     bc = 0;
0303   F83F 01 00 00    	ld bc, 0
0304   F842             ; 280     CmdF();
0305   F842 CD 82 FA    	call cmdf
0306   F845             ; 281 
0307   F845             ; 282     translateCodePageJump = a = OPCODE_JMP;
0308   F845 3E C3       	ld a, 195
0309   F847 32 7E F7    	ld (translatecodepagejump), a
0310   F84A             ; 283 
0311   F84A             ; 284     PrintString(hl = aHello);
0312   F84A 21 D4 FF    	ld hl, 0FFFFh & (ahello)
0313   F84D CD 48 F9    	call printstring
0314   F850             ; 285 
0315   F850             ; 286     // Проверка ОЗУ
0316   F850             ; 287     hl = 0;
0317   F850 21 00 00    	ld hl, 0
0318   F853             ; 288     for (;;) {
0319   F853             l_1: 
0320   F853             ; 289         c = *hl;
0321   F853 4E          	ld c, (hl)
0322   F854             ; 290         a = 0x55;
0323   F854 3E 55       	ld a, 85
0324   F856             ; 291         *hl = a;
0325   F856 77          	ld (hl), a
0326   F857             ; 292         a ^= *hl;
0327   F857 AE          	xor (hl)
0328   F858             ; 293         b = a;
0329   F858 47          	ld b, a
0330   F859             ; 294         a = 0xAA;
0331   F859 3E AA       	ld a, 170
0332   F85B             ; 295         *hl = a;
0333   F85B 77          	ld (hl), a
0334   F85C             ; 296         a ^= *hl;
0335   F85C AE          	xor (hl)
0336   F85D             ; 297         a |= b;
0337   F85D B0          	or b
0338   F85E             ; 298         if (flag_nz)
0339   F85E             ; 299             return Reboot2();
0340   F85E C2 6F F8    	jp nz, reboot2
0341   F861             ; 300         *hl = c;
0342   F861 71          	ld (hl), c
0343   F862             ; 301         hl++;
0344   F862 23          	inc hl
0345   F863             ; 302         if ((a = h) == SCREEN_ATTRIB_BEGIN >> 8)
0346   F863 7C          	ld a, h
0347   F864 FE E0       	cp 65504
0348   F866             ; 303             return Reboot2();
0349   F866 CA 6F F8    	jp z, reboot2
0350   F869 C3 53 F8    	jp l_1
0351   F86C             ; 304     }
0352   F86C             ; 305 
0353   F86C             ; 306     Reboot2();
0354   F86C C3 6F F8    	jp reboot2
0355   F86F              .org 0xF86C
0356   F86C             ; 307 }
0357   F86C             ; 308 
0358   F86C             ; 309 asm(" .org 0xF86C");
0359   F86C             ; 310 
0360   F86C             ; 311 void EntryF86C_Monitor() {
0361   F86C             entryf86c_monitor: 
0362   F86C             ; 312     Monitor();
0363   F86C C3 88 F8    	jp monitor
0364   F86F             ; 313 }
0365   F86F             ; 314 
0366   F86F             ; 315 void Reboot2(...) {
0367   F86F             reboot2: 
0368   F86F             ; 316     hl--;
0369   F86F 2B          	dec hl
0370   F870             ; 317     ramTop = hl;
0371   F870 22 81 F7    	ld (ramtop), hl
0372   F873             ; 318     PrintHexWordSpace(hl);
0373   F873 CD 5A FC    	call printhexwordspace
0374   F876             ; 319     tapeReadSpeed = hl = TAPE_SPEED;
0375   F876 21 54 38    	ld hl, 14420
0376   F879 22 5C F7    	ld (tapereadspeed), hl
0377   F87C             ; 320     translateCodePageAddress = hl = &TranslateCodePageDefault;
0378   F87C 21 DD FF    	ld hl, 0FFFFh & (translatecodepagedefault)
0379   F87F 22 7F F7    	ld (translatecodepageaddress), hl
0380   F882             ; 321     regSP = hl = 0xF7FE;
0381   F882 21 FE F7    	ld hl, 63486
0382   F885 22 6A F7    	ld (regsp), hl
0383   F888             ; 322     Monitor();
0384   F888             ; 323 }
0385   F888             ; 324 
0386   F888             ; 325 void Monitor() {
0387   F888             monitor: 
0388   F888             ; 326     out(PORT_KEYBOARD_MODE, a = 0x83);
0389   F888 3E 83       	ld a, 131
0390   F88A D3 04       	out (4), a
0391   F88C             ; 327     cursorVisible = a;
0392   F88C 32 5E F7    	ld (cursorvisible), a
0393   F88F             ; 328     jmpParam1Opcode = a = OPCODE_JMP;
0394   F88F 3E C3       	ld a, 195
0395   F891 32 74 F7    	ld (jmpparam1opcode), a
0396   F894             ; 329     Monitor2();
0397   F894             ; 330 }
0398   F894             ; 331 
0399   F894             ; 332 void Monitor2() {
0400   F894             monitor2: 
0401   F894             ; 333     sp = STACK_TOP;
0402   F894 31 00 F8    	ld sp, 63488
0403   F897             ; 334     PrintString(hl = aPrompt);
0404   F897 21 9F FF    	ld hl, 0FFFFh & (aprompt)
0405   F89A CD 48 F9    	call printstring
0406   F89D             ; 335     ReadString();
0407   F89D CD 14 F9    	call readstring
0408   F8A0             ; 336 
0409   F8A0             ; 337     push(hl = &EntryF86C_Monitor);
0410   F8A0 21 6C F8    	ld hl, 0FFFFh & (entryf86c_monitor)
0411   F8A3 E5          	push hl
0412   F8A4             ; 338 
0413   F8A4             ; 339     hl = inputBuffer;
0414   F8A4 21 83 F7    	ld hl, 0FFFFh & (inputbuffer)
0415   F8A7             ; 340     a = *hl;
0416   F8A7 7E          	ld a, (hl)
0417   F8A8             ; 341 
0418   F8A8             ; 342     if (a == 'X')
0419   F8A8 FE 58       	cp 88
0420   F8AA             ; 343         return CmdX();
0421   F8AA CA 1C FB    	jp z, cmdx
0422   F8AD             ; 344 
0423   F8AD             ; 345     push_pop(a) {
0424   F8AD F5          	push af
0425   F8AE             ; 346         ParseParams();
0426   F8AE CD 52 F9    	call parseparams
0427   F8B1             ; 347         hl = param3;
0428   F8B1 2A 79 F7    	ld hl, (param3)
0429   F8B4             ; 348         c = l;
0430   F8B4 4D          	ld c, l
0431   F8B5             ; 349         b = h;
0432   F8B5 44          	ld b, h
0433   F8B6             ; 350         hl = param2;
0434   F8B6 2A 77 F7    	ld hl, (param2)
0435   F8B9             ; 351         swap(hl, de);
0436   F8B9 EB          	ex hl, de
0437   F8BA             ; 352         hl = param1;
0438   F8BA 2A 75 F7    	ld hl, (param1)
0439   F8BD F1          	pop af
0440   F8BE             ; 353     }
0441   F8BE             ; 354 
0442   F8BE             ; 355     if (a == 'D')
0443   F8BE FE 44       	cp 68
0444   F8C0             ; 356         return CmdD();
0445   F8C0 CA 06 FA    	jp z, cmdd
0446   F8C3             ; 357     if (a == 'C')
0447   F8C3 FE 43       	cp 67
0448   F8C5             ; 358         return CmdC();
0449   F8C5 CA 6C FA    	jp z, cmdc
0450   F8C8             ; 359     if (a == 'F')
0451   F8C8 FE 46       	cp 70
0452   F8CA             ; 360         return CmdF();
0453   F8CA CA 82 FA    	jp z, cmdf
0454   F8CD             ; 361     if (a == 'S')
0455   F8CD FE 53       	cp 83
0456   F8CF             ; 362         return CmdS();
0457   F8CF CA 89 FA    	jp z, cmds
0458   F8D2             ; 363     if (a == 'T')
0459   F8D2 FE 54       	cp 84
0460   F8D4             ; 364         return CmdT();
0461   F8D4 CA A6 FA    	jp z, cmdt
0462   F8D7             ; 365     if (a == 'M')
0463   F8D7 FE 4D       	cp 77
0464   F8D9             ; 366         return CmdM();
0465   F8D9 CA AF FA    	jp z, cmdm
0466   F8DC             ; 367     if (a == 'G')
0467   F8DC FE 47       	cp 71
0468   F8DE             ; 368         return CmdG();
0469   F8DE CA C8 FA    	jp z, cmdg
0470   F8E1             ; 369     if (a == 'I')
0471   F8E1 FE 49       	cp 73
0472   F8E3             ; 370         return CmdI();
0473   F8E3 CA 8A FB    	jp z, cmdi
0474   F8E6             ; 371     if (a == 'O')
0475   F8E6 FE 4F       	cp 79
0476   F8E8             ; 372         return CmdO();
0477   F8E8 CA 08 FC    	jp z, cmdo
0478   F8EB             ; 373     if (a == 'W')
0479   F8EB FE 57       	cp 87
0480   F8ED             ; 374         return CmdW();
0481   F8ED CA 94 FA    	jp z, cmdw
0482   F8F0             ; 375     if (a == 'A')
0483   F8F0 FE 41       	cp 65
0484   F8F2             ; 376         return CmdA();
0485   F8F2 CA 02 FA    	jp z, cmda
0486   F8F5             ; 377     if (a == 'H')
0487   F8F5 FE 48       	cp 72
0488   F8F7             ; 378         return CmdH();
0489   F8F7 CA 65 FB    	jp z, cmdh
0490   F8FA             ; 379     if (a == 'R')
0491   F8FA FE 52       	cp 82
0492   F8FC             ; 380         return CmdR();
0493   F8FC CA E6 F9    	jp z, cmdr
0494   F8FF             ; 381     return MonitorError();
0495   F8FF C3 B2 FB    	jp monitorerror
0496   F902             ; 382 }
0497   F902             ; 383 
0498   F902             ; 384 void ReadStringBackspace(...) {
0499   F902             readstringbackspace: 
0500   F902             ; 385     if ((a = inputBuffer) == l)
0501   F902 3E 83       	ld a, 0FFh & (inputbuffer)
0502   F904 BD          	cp l
0503   F905             ; 386         return ReadStringBegin(hl);
0504   F905 CA 17 F9    	jp z, readstringbegin
0505   F908             ; 387     push_pop(hl) {
0506   F908 E5          	push hl
0507   F909             ; 388         PrintString(hl = aBackspace);
0508   F909 21 D0 FF    	ld hl, 0FFFFh & (abackspace)
0509   F90C CD 48 F9    	call printstring
0510   F90F E1          	pop hl
0511   F910             ; 389     }
0512   F910             ; 390     hl--;
0513   F910 2B          	dec hl
0514   F911             ; 391     return ReadStringLoop(b, hl);
0515   F911 C3 19 F9    	jp readstringloop
0516   F914             ; 392 }
0517   F914             ; 393 
0518   F914             ; 394 void ReadString() {
0519   F914             readstring: 
0520   F914             ; 395     hl = inputBuffer;
0521   F914 21 83 F7    	ld hl, 0FFFFh & (inputbuffer)
0522   F917             ; 396     ReadStringBegin(hl);
0523   F917             ; 397 }
0524   F917             ; 398 
0525   F917             ; 399 void ReadStringBegin(...) {
0526   F917             readstringbegin: 
0527   F917             ; 400     b = 0;
0528   F917 06 00       	ld b, 0
0529   F919             ; 401     ReadStringLoop(b, hl);
0530   F919             ; 402 }
0531   F919             ; 403 
0532   F919             ; 404 void ReadStringLoop(...) {
0533   F919             readstringloop: 
0534   F919             ; 405     for (;;) {
0535   F919             l_4: 
0536   F919             ; 406         ReadKey();
0537   F919 CD C8 FE    	call readkey
0538   F91C             ; 407         if (a == 127)
0539   F91C FE 7F       	cp 127
0540   F91E             ; 408             return ReadStringBackspace();
0541   F91E CA 02 F9    	jp z, readstringbackspace
0542   F921             ; 409         if (a == 8)
0543   F921 FE 08       	cp 8
0544   F923             ; 410             return ReadStringBackspace();
0545   F923 CA 02 F9    	jp z, readstringbackspace
0546   F926             ; 411         if (flag_nz)
0547   F926             ; 412             PrintCharA(a);
0548   F926 C4 22 FD    	call nz, printchara
0549   F929             ; 413         *hl = a;
0550   F929 77          	ld (hl), a
0551   F92A             ; 414         if (a == 13)
0552   F92A FE 0D       	cp 13
0553   F92C             ; 415             return ReadStringExit(b);
0554   F92C CA 40 F9    	jp z, readstringexit
0555   F92F             ; 416         if (a == '.')
0556   F92F FE 2E       	cp 46
0557   F931             ; 417             return Monitor2();
0558   F931 CA 94 F8    	jp z, monitor2
0559   F934             ; 418         b = 255;
0560   F934 06 FF       	ld b, 255
0561   F936             ; 419         if ((a = inputBuffer + sizeof(inputBuffer) - 1) == l)
0562   F936 3E A2       	ld a, 0FFh & (((inputbuffer) + (32)) - (1))
0563   F938 BD          	cp l
0564   F939             ; 420             return MonitorError();
0565   F939 CA B2 FB    	jp z, monitorerror
0566   F93C             ; 421         hl++;
0567   F93C 23          	inc hl
0568   F93D C3 19 F9    	jp l_4
0569   F940             ; 422     }
0570   F940             ; 423 }
0571   F940             ; 424 
0572   F940             ; 425 void ReadStringExit(...) {
0573   F940             readstringexit: 
0574   F940             ; 426     a = b;
0575   F940 78          	ld a, b
0576   F941             ; 427     carry_rotate_left(a, 1);
0577   F941 17          	rla
0578   F942             ; 428     de = inputBuffer;
0579   F942 11 83 F7    	ld de, 0FFFFh & (inputbuffer)
0580   F945             ; 429     b = 0;
0581   F945 06 00       	ld b, 0
0582   F947 C9          	ret
0583   F948             ; 430 }
0584   F948             ; 431 
0585   F948             ; 432 // Функция для пользовательской программы.
0586   F948             ; 433 // Вывод строки на экран.
0587   F948             ; 434 // Параметры: hl - адрес стороки. Результат: hl - следующий адрес за терминатором строки. Сохраняются: b, de.
0588   F948             ; 435 
0589   F948             ; 436 void PrintString(...) {
0590   F948             printstring: 
0591   F948             ; 437     for (;;) {
0592   F948             l_7: 
0593   F948             ; 438         a = *hl;
0594   F948 7E          	ld a, (hl)
0595   F949             ; 439         if (flag_z(a &= a))
0596   F949 A7          	and a
0597   F94A             ; 440             return;
0598   F94A C8          	ret z
0599   F94B             ; 441         PrintCharA(a);
0600   F94B CD 22 FD    	call printchara
0601   F94E             ; 442         hl++;
0602   F94E 23          	inc hl
0603   F94F C3 48 F9    	jp l_7
0604   F952             ; 443     }
0605   F952             ; 444 }
0606   F952             ; 445 
0607   F952             ; 446 void ParseParams(...) {
0608   F952             parseparams: 
0609   F952             ; 447     hl = &param1;
0610   F952 21 75 F7    	ld hl, 0FFFFh & (param1)
0611   F955             ; 448     de = &param2Exists;
0612   F955 11 7B F7    	ld de, 0FFFFh & (param2exists)
0613   F958             ; 449     c = 0;
0614   F958 0E 00       	ld c, 0
0615   F95A             ; 450     CmdF();
0616   F95A CD 82 FA    	call cmdf
0617   F95D             ; 451 
0618   F95D             ; 452     de = inputBuffer + 1;
0619   F95D 11 84 F7    	ld de, 0FFFFh & ((inputbuffer) + (1))
0620   F960             ; 453 
0621   F960             ; 454     ParseWord();
0622   F960 CD 80 F9    	call parseword
0623   F963             ; 455     param1 = hl;
0624   F963 22 75 F7    	ld (param1), hl
0625   F966             ; 456     param2 = hl;
0626   F966 22 77 F7    	ld (param2), hl
0627   F969             ; 457     if (flag_c)
0628   F969             ; 458         return;
0629   F969 D8          	ret c
0630   F96A             ; 459 
0631   F96A             ; 460     param2Exists = a = 0xFF;
0632   F96A 3E FF       	ld a, 255
0633   F96C 32 7B F7    	ld (param2exists), a
0634   F96F             ; 461     ParseWord();
0635   F96F CD 80 F9    	call parseword
0636   F972             ; 462     param2 = hl;
0637   F972 22 77 F7    	ld (param2), hl
0638   F975             ; 463     if (flag_c)
0639   F975             ; 464         return;
0640   F975 D8          	ret c
0641   F976             ; 465 
0642   F976             ; 466     ParseWord();
0643   F976 CD 80 F9    	call parseword
0644   F979             ; 467     param3 = hl;
0645   F979 22 79 F7    	ld (param3), hl
0646   F97C             ; 468     if (flag_c)
0647   F97C             ; 469         return;
0648   F97C D8          	ret c
0649   F97D             ; 470 
0650   F97D             ; 471     MonitorError();
0651   F97D C3 B2 FB    	jp monitorerror
0652   F980             ; 472 }
0653   F980             ; 473 
0654   F980             ; 474 void ParseWord(...) {
0655   F980             parseword: 
0656   F980             ; 475     hl = 0;
0657   F980 21 00 00    	ld hl, 0
0658   F983             ; 476     for (;;) {
0659   F983             l_10: 
0660   F983             ; 477         a = *de;
0661   F983 1A          	ld a, (de)
0662   F984             ; 478         de++;
0663   F984 13          	inc de
0664   F985             ; 479         if (a == 13)
0665   F985 FE 0D       	cp 13
0666   F987             ; 480             return ParseWordReturnCf(hl);
0667   F987 CA B4 F9    	jp z, parsewordreturncf
0668   F98A             ; 481         if (a == ',')
0669   F98A FE 2C       	cp 44
0670   F98C             ; 482             return;
0671   F98C C8          	ret z
0672   F98D             ; 483         if (a == ' ')
0673   F98D FE 20       	cp 32
0674   F98F             ; 484             continue;
0675   F98F CA 83 F9    	jp z, l_10
0676   F992             ; 485         a -= '0';
0677   F992 D6 30       	sub 48
0678   F994             ; 486         if (flag_m)
0679   F994             ; 487             return MonitorError();
0680   F994 FA B2 FB    	jp m, monitorerror
0681   F997             ; 488         if (flag_p(compare(a, 10))) {
0682   F997 FE 0A       	cp 10
0683   F999 FA A8 F9    	jp m, l_12
0684   F99C             ; 489             if (flag_m(compare(a, 17)))
0685   F99C FE 11       	cp 17
0686   F99E             ; 490                 return MonitorError();
0687   F99E FA B2 FB    	jp m, monitorerror
0688   F9A1             ; 491             if (flag_p(compare(a, 23)))
0689   F9A1 FE 17       	cp 23
0690   F9A3             ; 492                 return MonitorError();
0691   F9A3 F2 B2 FB    	jp p, monitorerror
0692   F9A6             ; 493             a -= 7;
0693   F9A6 D6 07       	sub 7
0694   F9A8             l_12: 
0695   F9A8             ; 494         }
0696   F9A8             ; 495         c = a;
0697   F9A8 4F          	ld c, a
0698   F9A9             ; 496         hl += hl;
0699   F9A9 29          	add hl, hl
0700   F9AA             ; 497         hl += hl;
0701   F9AA 29          	add hl, hl
0702   F9AB             ; 498         hl += hl;
0703   F9AB 29          	add hl, hl
0704   F9AC             ; 499         hl += hl;
0705   F9AC 29          	add hl, hl
0706   F9AD             ; 500         if (flag_c)
0707   F9AD             ; 501             return MonitorError();
0708   F9AD DA B2 FB    	jp c, monitorerror
0709   F9B0             ; 502         hl += bc;
0710   F9B0 09          	add hl, bc
0711   F9B1 C3 83 F9    	jp l_10
0712   F9B4             ; 503     }
0713   F9B4             ; 504 }
0714   F9B4             ; 505 
0715   F9B4             ; 506 void ParseWordReturnCf(...) {
0716   F9B4             parsewordreturncf: 
0717   F9B4             ; 507     set_flag_c();
0718   F9B4 37          	scf
0719   F9B5 C9          	ret
0720   F9B6             ; 508 }
0721   F9B6             ; 509 
0722   F9B6             ; 510 void CompareHlDe(...) {
0723   F9B6             comparehlde: 
0724   F9B6             ; 511     if ((a = h) != d)
0725   F9B6 7C          	ld a, h
0726   F9B7 BA          	cp d
0727   F9B8             ; 512         return;
0728   F9B8 C0          	ret nz
0729   F9B9             ; 513     compare(a = l, e);
0730   F9B9 7D          	ld a, l
0731   F9BA BB          	cp e
0732   F9BB C9          	ret
0733   F9BC             ; 514 }
0734   F9BC             ; 515 
0735   F9BC             ; 516 void LoopWithBreak(...) {
0736   F9BC             loopwithbreak: 
0737   F9BC             ; 517     CtrlC();
0738   F9BC CD CA F9    	call ctrlc
0739   F9BF             ; 518     Loop(hl, de);
0740   F9BF             ; 519 }
0741   F9BF             ; 520 
0742   F9BF             ; 521 void Loop(...) {
0743   F9BF             loop: 
0744   F9BF             ; 522     CompareHlDe(hl, de);
0745   F9BF CD B6 F9    	call comparehlde
0746   F9C2             ; 523     if (flag_nz)
0747   F9C2             ; 524         return IncHl(hl);
0748   F9C2 C2 C8 F9    	jp nz, inchl
0749   F9C5             ; 525     PopRet();
0750   F9C5             ; 526 }
0751   F9C5             ; 527 
0752   F9C5             ; 528 void PopRet() {
0753   F9C5             popret: 
0754   F9C5             ; 529     sp++;
0755   F9C5 33          	inc sp
0756   F9C6             ; 530     sp++;
0757   F9C6 33          	inc sp
0758   F9C7 C9          	ret
0759   F9C8             ; 531 }
0760   F9C8             ; 532 
0761   F9C8             ; 533 void IncHl(...) {
0762   F9C8             inchl: 
0763   F9C8             ; 534     hl++;
0764   F9C8 23          	inc hl
0765   F9C9 C9          	ret
0766   F9CA             ; 535 }
0767   F9CA             ; 536 
0768   F9CA             ; 537 void CtrlC() {
0769   F9CA             ctrlc: 
0770   F9CA             ; 538     ScanKey();
0771   F9CA CD FE FE    	call scankey
0772   F9CD             ; 539     if (a != 3)  // УПР + C
0773   F9CD FE 03       	cp 3
0774   F9CF             ; 540         return;
0775   F9CF C0          	ret nz
0776   F9D0             ; 541     MonitorError();
0777   F9D0 C3 B2 FB    	jp monitorerror
0778   F9D3             ; 542 }
0779   F9D3             ; 543 
0780   F9D3             ; 544 void PrintCrLfTab() {
0781   F9D3             printcrlftab: 
0782   F9D3             ; 545     push_pop(hl) {
0783   F9D3 E5          	push hl
0784   F9D4             ; 546         PrintString(hl = aCrLfTab);
0785   F9D4 21 A5 FF    	ld hl, 0FFFFh & (acrlftab)
0786   F9D7 CD 48 F9    	call printstring
0787   F9DA E1          	pop hl
0788   F9DB C9          	ret
0789   F9DC             ; 547     }
0790   F9DC             ; 548 }
0791   F9DC             ; 549 
0792   F9DC             ; 550 void PrintHexByteFromHlSpace(...) {
0793   F9DC             printhexbytefromhlspace: 
0794   F9DC             ; 551     PrintHexByteSpace(a = *hl);
0795   F9DC 7E          	ld a, (hl)
0796   F9DD             ; 552 }
0797   F9DD             ; 553 
0798   F9DD             ; 554 void PrintHexByteSpace(...) {
0799   F9DD             printhexbytespace: 
0800   F9DD             ; 555     push_pop(bc) {
0801   F9DD C5          	push bc
0802   F9DE             ; 556         PrintHexByte(a);
0803   F9DE CD 0E FD    	call printhexbyte
0804   F9E1             ; 557         PrintSpace();
0805   F9E1 CD 67 FA    	call printspace
0806   F9E4 C1          	pop bc
0807   F9E5 C9          	ret
0808   F9E6             ; 558     }
0809   F9E6             ; 559 }
0810   F9E6             ; 560 
0811   F9E6             ; 561 // Команда R <начальный адрес ПЗУ> <конечный адрес ПЗУ> <начальный адрес назаначения>
0812   F9E6             ; 562 // Скопировать блок из внешнего ПЗУ в адресное пространство процессора
0813   F9E6             ; 563 
0814   F9E6             ; 564 void CmdR(...) {
0815   F9E6             cmdr: 
0816   F9E6             ; 565     out(PORT_EXT_MODE, a = 0x90);
0817   F9E6 3E 90       	ld a, 144
0818   F9E8 D3 A3       	out (163), a
0819   F9EA             ; 566     for (;;) {
0820   F9EA             l_15: 
0821   F9EA             ; 567         out(PORT_EXT_ADDR_LOW, a = l);
0822   F9EA 7D          	ld a, l
0823   F9EB D3 A1       	out (161), a
0824   F9ED             ; 568         out(PORT_EXT_ADDR_HIGH, a = h);
0825   F9ED 7C          	ld a, h
0826   F9EE D3 A2       	out (162), a
0827   F9F0             ; 569         *bc = a = in(PORT_EXT_DATA);
0828   F9F0 DB A0       	in a, (160)
0829   F9F2 02          	ld (bc), a
0830   F9F3             ; 570         bc++;
0831   F9F3 03          	inc bc
0832   F9F4             ; 571         Loop();
0833   F9F4 CD BF F9    	call loop
0834   F9F7 C3 EA F9    	jp l_15
0835   F9FA             ; 572     }
0836   F9FA             ; 573 }
0837   F9FA             ; 574 
0838   F9FA             ; 575 // Функция для пользовательской программы.
0839   F9FA             ; 576 // Получить адрес последнего доступного байта оперативной памяти.
0840   F9FA             ; 577 // Параметры: нет. Результат: hl - адрес. Сохраняет: a, bc, de.
0841   F9FA             ; 578 
0842   F9FA             ; 579 void GetRamTop(...) {
0843   F9FA             getramtop: 
0844   F9FA             ; 580     hl = ramTop;
0845   F9FA 2A 81 F7    	ld hl, (ramtop)
0846   F9FD C9          	ret
0847   F9FE             ; 581 }
0848   F9FE             ; 582 
0849   F9FE             ; 583 // Функция для пользовательской программы.
0850   F9FE             ; 584 // Установить адрес последнего доступного байта оперативной памяти.
0851   F9FE             ; 585 // Параметры: hl - адрес. Результат: нет. Сохраняет: a, bc, de, hl.
0852   F9FE             ; 586 
0853   F9FE             ; 587 void SetRamTop(...) {
0854   F9FE             setramtop: 
0855   F9FE             ; 588     ramTop = hl;
0856   F9FE 22 81 F7    	ld (ramtop), hl
0857   FA01 C9          	ret
0858   FA02             ; 589 }
0859   FA02             ; 590 
0860   FA02             ; 591 // Команда A <адрес>
0861   FA02             ; 592 // Установить программу преобразования кодировки символов выводимых на экран
0862   FA02             ; 593 
0863   FA02             ; 594 void CmdA(...) {
0864   FA02             cmda: 
0865   FA02             ; 595     translateCodePageAddress = hl;
0866   FA02 22 7F F7    	ld (translatecodepageaddress), hl
0867   FA05 C9          	ret
0868   FA06             ; 596 }
0869   FA06             ; 597 
0870   FA06             ; 598 // Команда D <начальный адрес> <конечный адрес>
0871   FA06             ; 599 // Вывод блока данных из адресного пространства на экран в 16-ричном виде
0872   FA06             ; 600 
0873   FA06             ; 601 void CmdD(...) {
0874   FA06             cmdd: 
0875   FA06             ; 602     for (;;) {
0876   FA06             l_18: 
0877   FA06             ; 603         PrintCrLf();
0878   FA06 CD AD FE    	call printcrlf
0879   FA09             ; 604         PrintHexWordSpace(hl);
0880   FA09 CD 5A FC    	call printhexwordspace
0881   FA0C             ; 605         push_pop(hl) {
0882   FA0C E5          	push hl
0883   FA0D             ; 606             c = ((a = l) &= 0x0F);
0884   FA0D 7D          	ld a, l
0885   FA0E E6 0F       	and 15
0886   FA10 4F          	ld c, a
0887   FA11             ; 607             carry_rotate_right(a, 1);
0888   FA11 1F          	rra
0889   FA12             ; 608             b = (((a += c) += c) += 5);
0890   FA12 81          	add c
0891   FA13 81          	add c
0892   FA14 C6 05       	add 5
0893   FA16 47          	ld b, a
0894   FA17             ; 609             PrintSpacesTo();
0895   FA17 CD 5A FA    	call printspacesto
0896   FA1A             ; 610             do {
0897   FA1A             l_20: 
0898   FA1A             ; 611                 PrintHexByte(a = *hl);
0899   FA1A 7E          	ld a, (hl)
0900   FA1B CD 0E FD    	call printhexbyte
0901   FA1E             ; 612                 CompareHlDe(hl, de);
0902   FA1E CD B6 F9    	call comparehlde
0903   FA21             ; 613                 hl++;
0904   FA21 23          	inc hl
0905   FA22             ; 614                 if (flag_z)
0906   FA22             ; 615                     break;
0907   FA22 CA 32 FA    	jp z, l_22
0908   FA25             ; 616                 (a = l) &= 0x0F;
0909   FA25 7D          	ld a, l
0910   FA26 E6 0F       	and 15
0911   FA28             ; 617                 push_pop(a) {
0912   FA28 F5          	push af
0913   FA29             ; 618                     a &= 1;
0914   FA29 E6 01       	and 1
0915   FA2B             ; 619                     if (flag_z)
0916   FA2B             ; 620                         PrintSpace();
0917   FA2B CC 67 FA    	call z, printspace
0918   FA2E F1          	pop af
0919   FA2F             l_21: 
0920   FA2F C2 1A FA    	jp nz, l_20
0921   FA32             l_22: 
0922   FA32 E1          	pop hl
0923   FA33             ; 621                 }
0924   FA33             ; 622             } while (flag_nz);
0925   FA33             ; 623         }
0926   FA33             ; 624 
0927   FA33             ; 625         b = (((a = l) &= 0x0F) += 46);
0928   FA33 7D          	ld a, l
0929   FA34 E6 0F       	and 15
0930   FA36 C6 2E       	add 46
0931   FA38 47          	ld b, a
0932   FA39             ; 626         PrintSpacesTo(b);
0933   FA39 CD 5A FA    	call printspacesto
0934   FA3C             ; 627 
0935   FA3C             ; 628         do {
0936   FA3C             l_23: 
0937   FA3C             ; 629             a = *hl;
0938   FA3C 7E          	ld a, (hl)
0939   FA3D             ; 630             if (a < 127)
0940   FA3D FE 7F       	cp 127
0941   FA3F             ; 631                 if (a >= 32)
0942   FA3F D2 47 FA    	jp nc, l_26
0943   FA42 FE 20       	cp 32
0944   FA44             ; 632                     goto loc_fa49;
0945   FA44 D2 49 FA    	jp nc, loc_fa49
0946   FA47             l_26: 
0947   FA47             ; 633             a = '.';
0948   FA47 3E 2E       	ld a, 46
0949   FA49             ; 634         loc_fa49:
0950   FA49             loc_fa49: 
0951   FA49             ; 635             PrintCharA(a);
0952   FA49 CD 22 FD    	call printchara
0953   FA4C             ; 636             CompareHlDe(hl, de);
0954   FA4C CD B6 F9    	call comparehlde
0955   FA4F             ; 637             if (flag_z)
0956   FA4F             ; 638                 return;
0957   FA4F C8          	ret z
0958   FA50             ; 639             hl++;
0959   FA50 23          	inc hl
0960   FA51             ; 640             (a = l) &= 0x0F;
0961   FA51 7D          	ld a, l
0962   FA52 E6 0F       	and 15
0963   FA54             l_24: 
0964   FA54 C2 3C FA    	jp nz, l_23
0965   FA57 C3 06 FA    	jp l_18
0966   FA5A             ; 641         } while (flag_nz);
0967   FA5A             ; 642     }
0968   FA5A             ; 643 }
0969   FA5A             ; 644 
0970   FA5A             ; 645 void PrintSpacesTo(...) {
0971   FA5A             printspacesto: 
0972   FA5A             ; 646     for (;;) {
0973   FA5A             l_29: 
0974   FA5A             ; 647         if (((a = cursor) &= (SCREEN_WIDTH - 1)) >= b)
0975   FA5A 3A 5A F7    	ld a, (cursor)
0976   FA5D E6 3F       	and 63
0977   FA5F B8          	cp b
0978   FA60             ; 648             return;
0979   FA60 D0          	ret nc
0980   FA61             ; 649         PrintSpace();
0981   FA61 CD 67 FA    	call printspace
0982   FA64 C3 5A FA    	jp l_29
0983   FA67             ; 650     }
0984   FA67             ; 651 }
0985   FA67             ; 652 
0986   FA67             ; 653 void PrintSpace() {
0987   FA67             printspace: 
0988   FA67             ; 654     return PrintCharA(a = ' ');
0989   FA67 3E 20       	ld a, 32
0990   FA69 C3 22 FD    	jp printchara
0991   FA6C             ; 655 }
0992   FA6C             ; 656 
0993   FA6C             ; 657 // Команда С <начальный адрес 1> <конечный адрес 1> <начальный адрес 2>
0994   FA6C             ; 658 // Сравнить два блока адресного пространство
0995   FA6C             ; 659 
0996   FA6C             ; 660 void CmdC(...) {
0997   FA6C             cmdc: 
0998   FA6C             ; 661     for (;;) {
0999   FA6C             l_32: 
1000   FA6C             ; 662         if ((a = *bc) != *hl) {
1001   FA6C 0A          	ld a, (bc)
1002   FA6D BE          	cp (hl)
1003   FA6E CA 7B FA    	jp z, l_34
1004   FA71             ; 663             PrintCrLfTabHexWordSpace(hl);
1005   FA71 CD 51 FC    	call printcrlftabhexwordspace
1006   FA74             ; 664             PrintHexByteFromHlSpace(hl);
1007   FA74 CD DC F9    	call printhexbytefromhlspace
1008   FA77             ; 665             PrintHexByteSpace(a = *bc);
1009   FA77 0A          	ld a, (bc)
1010   FA78 CD DD F9    	call printhexbytespace
1011   FA7B             l_34: 
1012   FA7B             ; 666         }
1013   FA7B             ; 667         bc++;
1014   FA7B 03          	inc bc
1015   FA7C             ; 668         LoopWithBreak();
1016   FA7C CD BC F9    	call loopwithbreak
1017   FA7F C3 6C FA    	jp l_32
1018   FA82             ; 669     }
1019   FA82             ; 670 }
1020   FA82             ; 671 
1021   FA82             ; 672 // Команда F <начальный адрес> <конечный адрес> <байт>
1022   FA82             ; 673 // Заполнить блок в адресном пространстве одним байтом
1023   FA82             ; 674 
1024   FA82             ; 675 void CmdF(...) {
1025   FA82             cmdf: 
1026   FA82             ; 676     for (;;) {
1027   FA82             l_37: 
1028   FA82             ; 677         *hl = c;
1029   FA82 71          	ld (hl), c
1030   FA83             ; 678         Loop();
1031   FA83 CD BF F9    	call loop
1032   FA86 C3 82 FA    	jp l_37
1033   FA89             ; 679     }
1034   FA89             ; 680 }
1035   FA89             ; 681 
1036   FA89             ; 682 // Команда S <начальный адрес> <конечный адрес> <байт>
1037   FA89             ; 683 // Найти байт (8 битное значение) в адресном пространстве
1038   FA89             ; 684 
1039   FA89             ; 685 void CmdS(...) {
1040   FA89             cmds: 
1041   FA89             ; 686     for (;;) {
1042   FA89             l_40: 
1043   FA89             ; 687         if ((a = c) == *hl)
1044   FA89 79          	ld a, c
1045   FA8A BE          	cp (hl)
1046   FA8B             ; 688             PrintCrLfTabHexWordSpace(hl);
1047   FA8B CC 51 FC    	call z, printcrlftabhexwordspace
1048   FA8E             ; 689         LoopWithBreak();
1049   FA8E CD BC F9    	call loopwithbreak
1050   FA91 C3 89 FA    	jp l_40
1051   FA94             ; 690     }
1052   FA94             ; 691 }
1053   FA94             ; 692 
1054   FA94             ; 693 // Команда W <начальный адрес> <конечный адрес> <слово>
1055   FA94             ; 694 // Найти слово (16 битное значение) в адресном пространстве
1056   FA94             ; 695 
1057   FA94             ; 696 void CmdW(...) {
1058   FA94             cmdw: 
1059   FA94             ; 697     for (;;) {
1060   FA94             l_43: 
1061   FA94             ; 698         if ((a = *hl) == c) {
1062   FA94 7E          	ld a, (hl)
1063   FA95 B9          	cp c
1064   FA96 C2 A0 FA    	jp nz, l_45
1065   FA99             ; 699             hl++;
1066   FA99 23          	inc hl
1067   FA9A             ; 700             compare((a = *hl), b);
1068   FA9A 7E          	ld a, (hl)
1069   FA9B B8          	cp b
1070   FA9C             ; 701             hl--;
1071   FA9C 2B          	dec hl
1072   FA9D             ; 702             if (flag_z)
1073   FA9D             ; 703                 PrintCrLfTabHexWordSpace(hl);
1074   FA9D CC 51 FC    	call z, printcrlftabhexwordspace
1075   FAA0             l_45: 
1076   FAA0             ; 704         }
1077   FAA0             ; 705         LoopWithBreak();
1078   FAA0 CD BC F9    	call loopwithbreak
1079   FAA3 C3 94 FA    	jp l_43
1080   FAA6             ; 706     }
1081   FAA6             ; 707 }
1082   FAA6             ; 708 
1083   FAA6             ; 709 // Команда T <начальный адрес источника> <конечный адрес источника> <начальный адрес назначения>
1084   FAA6             ; 710 // Копировать блок в адресном пространстве
1085   FAA6             ; 711 
1086   FAA6             ; 712 void CmdT(...) {
1087   FAA6             cmdt: 
1088   FAA6             ; 713     for (;;) {
1089   FAA6             l_48: 
1090   FAA6             ; 714         *bc = a = *hl;
1091   FAA6 7E          	ld a, (hl)
1092   FAA7 02          	ld (bc), a
1093   FAA8             ; 715         bc++;
1094   FAA8 03          	inc bc
1095   FAA9             ; 716         Loop();
1096   FAA9 CD BF F9    	call loop
1097   FAAC C3 A6 FA    	jp l_48
1098   FAAF             ; 717     }
1099   FAAF             ; 718 }
1100   FAAF             ; 719 
1101   FAAF             ; 720 // Команда M <начальный адрес>
1102   FAAF             ; 721 // Вывести на экран адресное пространство побайтно с возможностью изменения
1103   FAAF             ; 722 
1104   FAAF             ; 723 void CmdM(...) {
1105   FAAF             cmdm: 
1106   FAAF             ; 724     for (;;) {
1107   FAAF             l_51: 
1108   FAAF             ; 725         PrintCrLfTabHexWordSpace(hl);
1109   FAAF CD 51 FC    	call printcrlftabhexwordspace
1110   FAB2             ; 726         PrintHexByteFromHlSpace();
1111   FAB2 CD DC F9    	call printhexbytefromhlspace
1112   FAB5             ; 727         push_pop(hl) {
1113   FAB5 E5          	push hl
1114   FAB6             ; 728             ReadString();
1115   FAB6 CD 14 F9    	call readstring
1116   FAB9 E1          	pop hl
1117   FABA             ; 729         }
1118   FABA             ; 730         if (flag_c) {
1119   FABA D2 C4 FA    	jp nc, l_53
1120   FABD             ; 731             push_pop(hl) {
1121   FABD E5          	push hl
1122   FABE             ; 732                 ParseWord();
1123   FABE CD 80 F9    	call parseword
1124   FAC1             ; 733                 a = l;
1125   FAC1 7D          	ld a, l
1126   FAC2 E1          	pop hl
1127   FAC3             ; 734             }
1128   FAC3             ; 735             *hl = a;
1129   FAC3 77          	ld (hl), a
1130   FAC4             l_53: 
1131   FAC4             ; 736         }
1132   FAC4             ; 737         hl++;
1133   FAC4 23          	inc hl
1134   FAC5 C3 AF FA    	jp l_51
1135   FAC8             ; 738     }
1136   FAC8             ; 739 }
1137   FAC8             ; 740 
1138   FAC8             ; 741 // Команда G <начальный адрес> <конечный адрес>
1139   FAC8             ; 742 // Запуск программы и возможным указанием точки останова.
1140   FAC8             ; 743 
1141   FAC8             ; 744 void CmdG(...) {
1142   FAC8             cmdg: 
1143   FAC8             ; 745     CompareHlDe(hl, de);
1144   FAC8 CD B6 F9    	call comparehlde
1145   FACB             ; 746     if (flag_nz) {
1146   FACB CA E3 FA    	jp z, l_55
1147   FACE             ; 747         swap(hl, de);
1148   FACE EB          	ex hl, de
1149   FACF             ; 748         breakPointAddress = hl;
1150   FACF 22 71 F7    	ld (breakpointaddress), hl
1151   FAD2             ; 749         breakPointValue = a = *hl;
1152   FAD2 7E          	ld a, (hl)
1153   FAD3 32 73 F7    	ld (breakpointvalue), a
1154   FAD6             ; 750         *hl = OPCODE_RST_30;
1155   FAD6 36 F7       	ld (hl), 247
1156   FAD8             ; 751         rst30Opcode = a = OPCODE_JMP;
1157   FAD8 3E C3       	ld a, 195
1158   FADA 32 30 00    	ld (rst30opcode), a
1159   FADD             ; 752         rst30Address = hl = &BreakPointHandler;
1160   FADD 21 F1 FA    	ld hl, 0FFFFh & (breakpointhandler)
1161   FAE0 22 31 00    	ld (rst30address), hl
1162   FAE3             l_55: 
1163   FAE3             ; 753     }
1164   FAE3             ; 754     sp = &regBC;
1165   FAE3 31 66 F7    	ld sp, 0FFFFh & (regbc)
1166   FAE6             ; 755     pop(bc);
1167   FAE6 C1          	pop bc
1168   FAE7             ; 756     pop(de);
1169   FAE7 D1          	pop de
1170   FAE8             ; 757     pop(hl);
1171   FAE8 E1          	pop hl
1172   FAE9             ; 758     pop(a);
1173   FAE9 F1          	pop af
1174   FAEA             ; 759     sp = hl;
1175   FAEA F9          	ld sp, hl
1176   FAEB             ; 760     hl = regHL;
1177   FAEB 2A 64 F7    	ld hl, (reghl)
1178   FAEE             ; 761     return JmpParam1();
1179   FAEE C3 74 F7    	jp jmpparam1
1180   FAF1             ; 762 }
1181   FAF1             ; 763 
1182   FAF1             ; 764 void BreakPointHandler(...) {
1183   FAF1             breakpointhandler: 
1184   FAF1             ; 765     regHL = hl;
1185   FAF1 22 64 F7    	ld (reghl), hl
1186   FAF4             ; 766     push(a);
1187   FAF4 F5          	push af
1188   FAF5             ; 767     pop(hl);
1189   FAF5 E1          	pop hl
1190   FAF6             ; 768     regAF = hl;
1191   FAF6 22 6C F7    	ld (regaf), hl
1192   FAF9             ; 769     pop(hl);
1193   FAF9 E1          	pop hl
1194   FAFA             ; 770     hl--;
1195   FAFA 2B          	dec hl
1196   FAFB             ; 771     regPC = hl;
1197   FAFB 22 62 F7    	ld (regpc), hl
1198   FAFE             ; 772     (hl = 0) += sp;
1199   FAFE 21 00 00    	ld hl, 0
1200   FB01 39          	add hl, sp
1201   FB02             ; 773     sp = &regAF;
1202   FB02 31 6C F7    	ld sp, 0FFFFh & (regaf)
1203   FB05             ; 774     push(hl);
1204   FB05 E5          	push hl
1205   FB06             ; 775     push(de);
1206   FB06 D5          	push de
1207   FB07             ; 776     push(bc);
1208   FB07 C5          	push bc
1209   FB08             ; 777     sp = STACK_TOP;
1210   FB08 31 00 F8    	ld sp, 63488
1211   FB0B             ; 778     hl = regPC;
1212   FB0B 2A 62 F7    	ld hl, (regpc)
1213   FB0E             ; 779     swap(hl, de);
1214   FB0E EB          	ex hl, de
1215   FB0F             ; 780     hl = breakPointAddress;
1216   FB0F 2A 71 F7    	ld hl, (breakpointaddress)
1217   FB12             ; 781     CompareHlDe(hl, de);
1218   FB12 CD B6 F9    	call comparehlde
1219   FB15             ; 782     if (flag_nz)
1220   FB15             ; 783         return CmdX();
1221   FB15 C2 1C FB    	jp nz, cmdx
1222   FB18             ; 784     *hl = a = breakPointValue;
1223   FB18 3A 73 F7    	ld a, (breakpointvalue)
1224   FB1B 77          	ld (hl), a
1225   FB1C             ; 785     CmdX();
1226   FB1C             ; 786 }
1227   FB1C             ; 787 
1228   FB1C             ; 788 // Команда X
1229   FB1C             ; 789 // Вывод на экран содержимого регистров микропроцессора с возможностью их изменения.
1230   FB1C             ; 790 
1231   FB1C             ; 791 void CmdX(...) {
1232   FB1C             cmdx: 
1233   FB1C             ; 792     PrintString(hl = aRegisters);
1234   FB1C 21 AB FF    	ld hl, 0FFFFh & (aregisters)
1235   FB1F CD 48 F9    	call printstring
1236   FB22             ; 793     hl = &regPC;
1237   FB22 21 62 F7    	ld hl, 0FFFFh & (regpc)
1238   FB25             ; 794     b = 6;
1239   FB25 06 06       	ld b, 6
1240   FB27             ; 795     do {
1241   FB27             l_57: 
1242   FB27             ; 796         e = *hl;
1243   FB27 5E          	ld e, (hl)
1244   FB28             ; 797         hl++;
1245   FB28 23          	inc hl
1246   FB29             ; 798         d = *hl;
1247   FB29 56          	ld d, (hl)
1248   FB2A             ; 799         push(bc);
1249   FB2A C5          	push bc
1250   FB2B             ; 800         push(hl);
1251   FB2B E5          	push hl
1252   FB2C             ; 801         swap(hl, de);
1253   FB2C EB          	ex hl, de
1254   FB2D             ; 802         PrintCrLfTabHexWordSpace(hl);
1255   FB2D CD 51 FC    	call printcrlftabhexwordspace
1256   FB30             ; 803         ReadString();
1257   FB30 CD 14 F9    	call readstring
1258   FB33             ; 804         if (flag_c) {
1259   FB33 D2 3F FB    	jp nc, l_60
1260   FB36             ; 805             ParseWord();
1261   FB36 CD 80 F9    	call parseword
1262   FB39             ; 806             pop(de);
1263   FB39 D1          	pop de
1264   FB3A             ; 807             push(de);
1265   FB3A D5          	push de
1266   FB3B             ; 808             swap(hl, de);
1267   FB3B EB          	ex hl, de
1268   FB3C             ; 809             *hl = d;
1269   FB3C 72          	ld (hl), d
1270   FB3D             ; 810             hl--;
1271   FB3D 2B          	dec hl
1272   FB3E             ; 811             *hl = e;
1273   FB3E 73          	ld (hl), e
1274   FB3F             l_60: 
1275   FB3F             ; 812         }
1276   FB3F             ; 813         pop(hl);
1277   FB3F E1          	pop hl
1278   FB40             ; 814         pop(bc);
1279   FB40 C1          	pop bc
1280   FB41             ; 815         b--;
1281   FB41 05          	dec b
1282   FB42             ; 816         hl++;
1283   FB42 23          	inc hl
1284   FB43             l_58: 
1285   FB43 C2 27 FB    	jp nz, l_57
1286   FB46             ; 817     } while (flag_nz);
1287   FB46             ; 818     EntryF86C_Monitor();
1288   FB46 C3 6C F8    	jp entryf86c_monitor
1289   FB49             ; 819 }
1290   FB49             ; 820 
1291   FB49             ; 821 // Функция для пользовательской программы.
1292   FB49             ; 822 // Получить координаты курсора.
1293   FB49             ; 823 // Параметры: нет. Результат: l = x + 8, h = y + 3. Сохраняет регистры: bc, de, hl.
1294   FB49             ; 824 
1295   FB49             ; 825 void GetCursor() {
1296   FB49             getcursor: 
1297   FB49             ; 826     push_pop(a) {
1298   FB49 F5          	push af
1299   FB4A             ; 827         hl = cursor;
1300   FB4A 2A 5A F7    	ld hl, (cursor)
1301   FB4D             ; 828         h = ((a = h) &= 7);
1302   FB4D 7C          	ld a, h
1303   FB4E E6 07       	and 7
1304   FB50 67          	ld h, a
1305   FB51             ; 829 
1306   FB51             ; 830         // Вычисление X
1307   FB51             ; 831         a = l;
1308   FB51 7D          	ld a, l
1309   FB52             ; 832         a &= (SCREEN_WIDTH - 1);
1310   FB52 E6 3F       	and 63
1311   FB54             ; 833         a += 8;  // Смещение Радио 86РК
1312   FB54 C6 08       	add 8
1313   FB56             ; 834 
1314   FB56             ; 835         // Вычисление Y
1315   FB56             ; 836         hl += hl;
1316   FB56 29          	add hl, hl
1317   FB57             ; 837         hl += hl;
1318   FB57 29          	add hl, hl
1319   FB58             ; 838         h++;  // Смещение Радио 86РК
1320   FB58 24          	inc h
1321   FB59             ; 839         h++;
1322   FB59 24          	inc h
1323   FB5A             ; 840         h++;
1324   FB5A 24          	inc h
1325   FB5B             ; 841 
1326   FB5B             ; 842         l = a;
1327   FB5B 6F          	ld l, a
1328   FB5C F1          	pop af
1329   FB5D C9          	ret
1330   FB5E             ; 843     }
1331   FB5E             ; 844 }
1332   FB5E             ; 845 
1333   FB5E             ; 846 // Функция для пользовательской программы.
1334   FB5E             ; 847 // Получить символ под курсором.
1335   FB5E             ; 848 // Параметры: нет. Результат: a - код символа. Сохраняет регистры: bc, de, hl.
1336   FB5E             ; 849 
1337   FB5E             ; 850 void GetCursorChar() {
1338   FB5E             getcursorchar: 
1339   FB5E             ; 851     push_pop(hl) {
1340   FB5E E5          	push hl
1341   FB5F             ; 852         hl = cursor;
1342   FB5F 2A 5A F7    	ld hl, (cursor)
1343   FB62             ; 853         a = *hl;
1344   FB62 7E          	ld a, (hl)
1345   FB63 E1          	pop hl
1346   FB64 C9          	ret
1347   FB65             ; 854     }
1348   FB65             ; 855 }
1349   FB65             ; 856 
1350   FB65             ; 857 // Команда H
1351   FB65             ; 858 // Определить скорости записанной программы.
1352   FB65             ; 859 // Выводит 4 цифры на экран.
1353   FB65             ; 860 // Первые две цифры - константа вывода для команды O
1354   FB65             ; 861 // Последние две цифры - константа вввода для команды I
1355   FB65             ; 862 
1356   FB65             ; 863 void CmdH(...) {
1357   FB65             cmdh: 
1358   FB65             ; 864     PrintCrLfTab();
1359   FB65 CD D3 F9    	call printcrlftab
1360   FB68             ; 865     hl = 65408;
1361   FB68 21 80 FF    	ld hl, 65408
1362   FB6B             ; 866     b = 123;
1363   FB6B 06 7B       	ld b, 123
1364   FB6D             ; 867 
1365   FB6D             ; 868     c = a = in(PORT_TAPE);
1366   FB6D DB 01       	in a, (1)
1367   FB6F 4F          	ld c, a
1368   FB70             ; 869 
1369   FB70             ; 870     do {
1370   FB70             l_62: 
1371   FB70             l_63: 
1372   FB70             ; 871     } while ((a = in(PORT_TAPE)) == c);
1373   FB70 DB 01       	in a, (1)
1374   FB72 B9          	cp c
1375   FB73 CA 70 FB    	jp z, l_62
1376   FB76             ; 872 
1377   FB76             ; 873     do {
1378   FB76             l_65: 
1379   FB76             ; 874         c = a;
1380   FB76 4F          	ld c, a
1381   FB77             ; 875         do {
1382   FB77             l_68: 
1383   FB77             ; 876             hl++;
1384   FB77 23          	inc hl
1385   FB78             l_69: 
1386   FB78             ; 877         } while ((a = in(PORT_TAPE)) == c);
1387   FB78 DB 01       	in a, (1)
1388   FB7A B9          	cp c
1389   FB7B CA 77 FB    	jp z, l_68
1390   FB7E             l_66: 
1391   FB7E             ; 878     } while (flag_nz(b--));
1392   FB7E 05          	dec b
1393   FB7F C2 76 FB    	jp nz, l_65
1394   FB82             ; 879 
1395   FB82             ; 880     hl += hl;
1396   FB82 29          	add hl, hl
1397   FB83             ; 881     a = h;
1398   FB83 7C          	ld a, h
1399   FB84             ; 882     hl += hl;
1400   FB84 29          	add hl, hl
1401   FB85             ; 883     l = (a += h);
1402   FB85 84          	add h
1403   FB86 6F          	ld l, a
1404   FB87             ; 884 
1405   FB87             ; 885     PrintHexWordSpace();
1406   FB87 C3 5A FC    	jp printhexwordspace
1407   FB8A             ; 886 }
1408   FB8A             ; 887 
1409   FB8A             ; 888 // Команда I <смещение> <скорость>
1410   FB8A             ; 889 // Загрузить файл с магнитной ленты
1411   FB8A             ; 890 
1412   FB8A             ; 891 void CmdI(...) {
1413   FB8A             cmdi: 
1414   FB8A             ; 892     if ((a = param2Exists) != 0)
1415   FB8A 3A 7B F7    	ld a, (param2exists)
1416   FB8D B7          	or a
1417   FB8E             ; 893         tapeReadSpeed = a = e;
1418   FB8E CA 95 FB    	jp z, l_71
1419   FB91 7B          	ld a, e
1420   FB92 32 5C F7    	ld (tapereadspeed), a
1421   FB95             l_71: 
1422   FB95             ; 894     ReadTapeFile();
1423   FB95 CD BA FB    	call readtapefile
1424   FB98             ; 895     PrintCrLfTabHexWordSpace(hl);
1425   FB98 CD 51 FC    	call printcrlftabhexwordspace
1426   FB9B             ; 896     swap(hl, de);
1427   FB9B EB          	ex hl, de
1428   FB9C             ; 897     PrintCrLfTabHexWordSpace(hl);
1429   FB9C CD 51 FC    	call printcrlftabhexwordspace
1430   FB9F             ; 898     swap(hl, de);
1431   FB9F EB          	ex hl, de
1432   FBA0             ; 899     push(bc);
1433   FBA0 C5          	push bc
1434   FBA1             ; 900     CalculateCheckSum();
1435   FBA1 CD F1 FB    	call calculatechecksum
1436   FBA4             ; 901     h = b;
1437   FBA4 60          	ld h, b
1438   FBA5             ; 902     l = c;
1439   FBA5 69          	ld l, c
1440   FBA6             ; 903     PrintCrLfTabHexWordSpace(hl);
1441   FBA6 CD 51 FC    	call printcrlftabhexwordspace
1442   FBA9             ; 904     pop(de);
1443   FBA9 D1          	pop de
1444   FBAA             ; 905     CompareHlDe(hl, de);
1445   FBAA CD B6 F9    	call comparehlde
1446   FBAD             ; 906     if (flag_z)
1447   FBAD             ; 907         return;
1448   FBAD C8          	ret z
1449   FBAE             ; 908     swap(hl, de);
1450   FBAE EB          	ex hl, de
1451   FBAF             ; 909     PrintCrLfTabHexWordSpace(hl);
1452   FBAF CD 51 FC    	call printcrlftabhexwordspace
1453   FBB2             ; 910     MonitorError();
1454   FBB2             ; 911 }
1455   FBB2             ; 912 
1456   FBB2             ; 913 void MonitorError() {
1457   FBB2             monitorerror: 
1458   FBB2             ; 914     PrintCharA(a = '?');
1459   FBB2 3E 3F       	ld a, 63
1460   FBB4 CD 22 FD    	call printchara
1461   FBB7             ; 915     Monitor2();
1462   FBB7 C3 94 F8    	jp monitor2
1463   FBBA             ; 916 }
1464   FBBA             ; 917 
1465   FBBA             ; 918 // Функция для пользовательской программы.
1466   FBBA             ; 919 // Загрузить файл с магнитной ленты.
1467   FBBA             ; 920 // Параметры: hl - смещение загрузки. Результат: bc - прочитанная КС, hl - адрес загрузки
1468   FBBA             ; 921 
1469   FBBA             ; 922 void ReadTapeFile(...) {
1470   FBBA             readtapefile: 
1471   FBBA             ; 923     ReadTapeWord(a = READ_TAPE_FIRST_BYTE);
1472   FBBA 3E FF       	ld a, 255
1473   FBBC CD DA FB    	call readtapeword
1474   FBBF             ; 924     push_pop(hl) {
1475   FBBF E5          	push hl
1476   FBC0             ; 925         hl += bc;
1477   FBC0 09          	add hl, bc
1478   FBC1             ; 926         swap(hl, de);
1479   FBC1 EB          	ex hl, de
1480   FBC2             ; 927         ReadTapeWordNext();
1481   FBC2 CD D8 FB    	call readtapewordnext
1482   FBC5 E1          	pop hl
1483   FBC6             ; 928     }
1484   FBC6             ; 929     hl += bc;
1485   FBC6 09          	add hl, bc
1486   FBC7             ; 930     swap(hl, de);
1487   FBC7 EB          	ex hl, de
1488   FBC8             ; 931 
1489   FBC8             ; 932     a = in(PORT_KEYBOARD_MODS);
1490   FBC8 DB 05       	in a, (5)
1491   FBCA             ; 933     a &= KEYBOARD_SHIFT_MOD;
1492   FBCA E6 04       	and 4
1493   FBCC             ; 934     if (flag_z)
1494   FBCC             ; 935         return;
1495   FBCC C8          	ret z
1496   FBCD             ; 936 
1497   FBCD             ; 937     push_pop(hl) {
1498   FBCD E5          	push hl
1499   FBCE             ; 938         ReadTapeBlock();
1500   FBCE CD E5 FB    	call readtapeblock
1501   FBD1             ; 939         ReadTapeWord(a = READ_TAPE_FIRST_BYTE);
1502   FBD1 3E FF       	ld a, 255
1503   FBD3 CD DA FB    	call readtapeword
1504   FBD6 E1          	pop hl
1505   FBD7 C9          	ret
1506   FBD8             ; 940     }
1507   FBD8             ; 941 }
1508   FBD8             ; 942 
1509   FBD8             ; 943 void ReadTapeWordNext() {
1510   FBD8             readtapewordnext: 
1511   FBD8             ; 944     ReadTapeWord(a = READ_TAPE_NEXT_BYTE);
1512   FBD8 3E 08       	ld a, 8
1513   FBDA             ; 945 }
1514   FBDA             ; 946 
1515   FBDA             ; 947 void ReadTapeWord(...) {
1516   FBDA             readtapeword: 
1517   FBDA             ; 948     ReadTapeByte(a);
1518   FBDA CD 74 FC    	call readtapebyte
1519   FBDD             ; 949     b = a;
1520   FBDD 47          	ld b, a
1521   FBDE             ; 950     ReadTapeByte(a = READ_TAPE_NEXT_BYTE);
1522   FBDE 3E 08       	ld a, 8
1523   FBE0 CD 74 FC    	call readtapebyte
1524   FBE3             ; 951     c = a;
1525   FBE3 4F          	ld c, a
1526   FBE4 C9          	ret
1527   FBE5             ; 952 }
1528   FBE5             ; 953 
1529   FBE5             ; 954 void ReadTapeBlock(...) {
1530   FBE5             readtapeblock: 
1531   FBE5             ; 955     for (;;) {
1532   FBE5             l_74: 
1533   FBE5             ; 956         ReadTapeByte(a = READ_TAPE_NEXT_BYTE);
1534   FBE5 3E 08       	ld a, 8
1535   FBE7 CD 74 FC    	call readtapebyte
1536   FBEA             ; 957         *hl = a;
1537   FBEA 77          	ld (hl), a
1538   FBEB             ; 958         Loop();
1539   FBEB CD BF F9    	call loop
1540   FBEE C3 E5 FB    	jp l_74
1541   FBF1             ; 959     }
1542   FBF1             ; 960 }
1543   FBF1             ; 961 
1544   FBF1             ; 962 // Функция для пользовательской программы.
1545   FBF1             ; 963 // Вычистить 16-битную сумму всех байт по адресам hl..de.
1546   FBF1             ; 964 // Параметры: hl - начальный адрес, de - конечный адрес. Результат: bc - сумма. Сохраяет: de.
1547   FBF1             ; 965 
1548   FBF1             ; 966 void CalculateCheckSum(...) {
1549   FBF1             calculatechecksum: 
1550   FBF1             ; 967     bc = 0;
1551   FBF1 01 00 00    	ld bc, 0
1552   FBF4             ; 968     for (;;) {
1553   FBF4             l_77: 
1554   FBF4             ; 969         c = ((a = *hl) += c);
1555   FBF4 7E          	ld a, (hl)
1556   FBF5 81          	add c
1557   FBF6 4F          	ld c, a
1558   FBF7             ; 970         push_pop(a) {
1559   FBF7 F5          	push af
1560   FBF8             ; 971             CompareHlDe(hl, de);
1561   FBF8 CD B6 F9    	call comparehlde
1562   FBFB             ; 972             if (flag_z)
1563   FBFB             ; 973                 return PopRet();
1564   FBFB CA C5 F9    	jp z, popret
1565   FBFE F1          	pop af
1566   FBFF             ; 974         }
1567   FBFF             ; 975         a = b;
1568   FBFF 78          	ld a, b
1569   FC00             ; 976         carry_add(a, *hl);
1570   FC00 8E          	adc (hl)
1571   FC01             ; 977         b = a;
1572   FC01 47          	ld b, a
1573   FC02             ; 978         Loop();
1574   FC02 CD BF F9    	call loop
1575   FC05 C3 F4 FB    	jp l_77
1576   FC08             ; 979     }
1577   FC08             ; 980 }
1578   FC08             ; 981 
1579   FC08             ; 982 // Команда O <начальный адрес> <конечный адрес> <скорость>
1580   FC08             ; 983 // Сохранить блок данных на магнитную ленту
1581   FC08             ; 984 
1582   FC08             ; 985 void CmdO(...) {
1583   FC08             cmdo: 
1584   FC08             ; 986     if ((a = c) != 0)
1585   FC08 79          	ld a, c
1586   FC09 B7          	or a
1587   FC0A             ; 987         tapeWriteSpeed = a;
1588   FC0A CA 10 FC    	jp z, l_79
1589   FC0D 32 5D F7    	ld (tapewritespeed), a
1590   FC10             l_79: 
1591   FC10             ; 988     push_pop(hl) {
1592   FC10 E5          	push hl
1593   FC11             ; 989         CalculateCheckSum(hl, de);
1594   FC11 CD F1 FB    	call calculatechecksum
1595   FC14 E1          	pop hl
1596   FC15             ; 990     }
1597   FC15             ; 991     PrintCrLfTabHexWordSpace(hl);
1598   FC15 CD 51 FC    	call printcrlftabhexwordspace
1599   FC18             ; 992     swap(hl, de);
1600   FC18 EB          	ex hl, de
1601   FC19             ; 993     PrintCrLfTabHexWordSpace(hl);
1602   FC19 CD 51 FC    	call printcrlftabhexwordspace
1603   FC1C             ; 994     swap(hl, de);
1604   FC1C EB          	ex hl, de
1605   FC1D             ; 995     push_pop(hl) {
1606   FC1D E5          	push hl
1607   FC1E             ; 996         h = b;
1608   FC1E 60          	ld h, b
1609   FC1F             ; 997         l = c;
1610   FC1F 69          	ld l, c
1611   FC20             ; 998         PrintCrLfTabHexWordSpace(hl);
1612   FC20 CD 51 FC    	call printcrlftabhexwordspace
1613   FC23 E1          	pop hl
1614   FC24             ; 999     }
1615   FC24             ; 1000     WriteTapeFile(hl, de);
1616   FC24             ; 1001 }
1617   FC24             ; 1002 
1618   FC24             ; 1003 // Функция для пользовательской программы.
1619   FC24             ; 1004 // Запись файла на магнитную ленту.
1620   FC24             ; 1005 // Параметры: de - начальный адрес, hl - конечный адрес, bc - контрольная сумма. Результат: нет.
1621   FC24             ; 1006 
1622   FC24             ; 1007 void WriteTapeFile(...) {
1623   FC24             writetapefile: 
1624   FC24             ; 1008     push(bc);
1625   FC24 C5          	push bc
1626   FC25             ; 1009     bc = 0;
1627   FC25 01 00 00    	ld bc, 0
1628   FC28             ; 1010     do {
1629   FC28             l_81: 
1630   FC28             ; 1011         WriteTapeByte(c);
1631   FC28 CD DD FC    	call writetapebyte
1632   FC2B             ; 1012         b--;
1633   FC2B 05          	dec b
1634   FC2C             ; 1013         swap(hl, *sp);
1635   FC2C E3          	ex (sp), hl
1636   FC2D             ; 1014         swap(hl, *sp);
1637   FC2D E3          	ex (sp), hl
1638   FC2E             l_82: 
1639   FC2E C2 28 FC    	jp nz, l_81
1640   FC31             ; 1015     } while (flag_nz);
1641   FC31             ; 1016     WriteTapeByte(c = TAPE_START);
1642   FC31 0E E6       	ld c, 230
1643   FC33 CD DD FC    	call writetapebyte
1644   FC36             ; 1017     WriteTapeWord(hl);
1645   FC36 CD 6C FC    	call writetapeword
1646   FC39             ; 1018     swap(hl, de);
1647   FC39 EB          	ex hl, de
1648   FC3A             ; 1019     WriteTapeWord(hl);
1649   FC3A CD 6C FC    	call writetapeword
1650   FC3D             ; 1020     swap(hl, de);
1651   FC3D EB          	ex hl, de
1652   FC3E             ; 1021     WriteTapeBlock(hl, de);
1653   FC3E CD 62 FC    	call writetapeblock
1654   FC41             ; 1022     WriteTapeWord(hl = 0);
1655   FC41 21 00 00    	ld hl, 0
1656   FC44 CD 6C FC    	call writetapeword
1657   FC47             ; 1023     WriteTapeByte(c = TAPE_START);
1658   FC47 0E E6       	ld c, 230
1659   FC49 CD DD FC    	call writetapebyte
1660   FC4C             ; 1024     pop(hl);
1661   FC4C E1          	pop hl
1662   FC4D             ; 1025     WriteTapeWord(hl);
1663   FC4D CD 6C FC    	call writetapeword
1664   FC50             ; 1026     return;
1665   FC50 C9          	ret
1666   FC51             ; 1027 }
1667   FC51             ; 1028 
1668   FC51             ; 1029 void PrintCrLfTabHexWordSpace(...) {
1669   FC51             printcrlftabhexwordspace: 
1670   FC51             ; 1030     push_pop(bc) {
1671   FC51 C5          	push bc
1672   FC52             ; 1031         PrintCrLfTab();
1673   FC52 CD D3 F9    	call printcrlftab
1674   FC55             ; 1032         PrintHexWordSpace(hl);
1675   FC55 CD 5A FC    	call printhexwordspace
1676   FC58 C1          	pop bc
1677   FC59 C9          	ret
1678   FC5A             ; 1033     }
1679   FC5A             ; 1034 }
1680   FC5A             ; 1035 
1681   FC5A             ; 1036 void PrintHexWordSpace(...) {
1682   FC5A             printhexwordspace: 
1683   FC5A             ; 1037     PrintHexByte(a = h);
1684   FC5A 7C          	ld a, h
1685   FC5B CD 0E FD    	call printhexbyte
1686   FC5E             ; 1038     PrintHexByteSpace(a = l);
1687   FC5E 7D          	ld a, l
1688   FC5F C3 DD F9    	jp printhexbytespace
1689   FC62             ; 1039 }
1690   FC62             ; 1040 
1691   FC62             ; 1041 void WriteTapeBlock(...) {
1692   FC62             writetapeblock: 
1693   FC62             ; 1042     for (;;) {
1694   FC62             l_85: 
1695   FC62             ; 1043         WriteTapeByte(c = *hl);
1696   FC62 4E          	ld c, (hl)
1697   FC63 CD DD FC    	call writetapebyte
1698   FC66             ; 1044         Loop();
1699   FC66 CD BF F9    	call loop
1700   FC69 C3 62 FC    	jp l_85
1701   FC6C             ; 1045     }
1702   FC6C             ; 1046 }
1703   FC6C             ; 1047 
1704   FC6C             ; 1048 void WriteTapeWord(...) {
1705   FC6C             writetapeword: 
1706   FC6C             ; 1049     WriteTapeByte(c = h);
1707   FC6C 4C          	ld c, h
1708   FC6D CD DD FC    	call writetapebyte
1709   FC70             ; 1050     WriteTapeByte(c = l);
1710   FC70 4D          	ld c, l
1711   FC71 C3 DD FC    	jp writetapebyte
1712   FC74             ; 1051 }
1713   FC74             ; 1052 
1714   FC74             ; 1053 // Загрузка байта с магнитной ленты.
1715   FC74             ; 1054 // Параметры: a = 0xFF с синхронизацией, = 8 без синхронизации.
1716   FC74             ; 1055 // Результат: a = прочитанный байт.
1717   FC74             ; 1056 
1718   FC74             ; 1057 void ReadTapeByte(...) {
1719   FC74             readtapebyte: 
1720   FC74             ; 1058     push(hl, bc, de);
1721   FC74 E5          	push hl
1722   FC75 C5          	push bc
1723   FC76 D5          	push de
1724   FC77             ; 1059     d = a;
1725   FC77 57          	ld d, a
1726   FC78             ; 1060     ReadTapeByteInternal(d);
1727   FC78             ; 1061 }
1728   FC78             ; 1062 
1729   FC78             ; 1063 void ReadTapeByteInternal(...) {
1730   FC78             readtapebyteinternal: 
1731   FC78             ; 1064     c = 0;
1732   FC78 0E 00       	ld c, 0
1733   FC7A             ; 1065     e = ((a = in(PORT_TAPE)) &= PORT_TAPE_BIT);
1734   FC7A DB 01       	in a, (1)
1735   FC7C E6 01       	and 1
1736   FC7E 5F          	ld e, a
1737   FC7F             ; 1066     do {
1738   FC7F             l_87: 
1739   FC7F             ; 1067     retry:  // Сдвиг результата
1740   FC7F             retry: 
1741   FC7F             ; 1068         (a = c) &= 0x7F;
1742   FC7F 79          	ld a, c
1743   FC80 E6 7F       	and 127
1744   FC82             ; 1069         cyclic_rotate_left(a, 1);
1745   FC82 07          	rlca
1746   FC83             ; 1070         c = a;
1747   FC83 4F          	ld c, a
1748   FC84             ; 1071 
1749   FC84             ; 1072         // Ожидание изменения бита
1750   FC84             ; 1073         h = 0;
1751   FC84 26 00       	ld h, 0
1752   FC86             ; 1074         do {
1753   FC86             l_90: 
1754   FC86             ; 1075             h--;
1755   FC86 25          	dec h
1756   FC87             ; 1076             if (flag_z)
1757   FC87             ; 1077                 return ReadTapeByteTimeout(d);
1758   FC87 CA D2 FC    	jp z, readtapebytetimeout
1759   FC8A             l_91: 
1760   FC8A             ; 1078         } while (((a = in(PORT_TAPE)) &= PORT_TAPE_BIT) == e);
1761   FC8A DB 01       	in a, (1)
1762   FC8C E6 01       	and 1
1763   FC8E BB          	cp e
1764   FC8F CA 86 FC    	jp z, l_90
1765   FC92             ; 1079 
1766   FC92             ; 1080         // Сохранение бита
1767   FC92             ; 1081         c = (a |= c);
1768   FC92 B1          	or c
1769   FC93 4F          	ld c, a
1770   FC94             ; 1082 
1771   FC94             ; 1083         // Задержка
1772   FC94             ; 1084         d--;
1773   FC94 15          	dec d
1774   FC95             ; 1085         a = tapeReadSpeed;
1775   FC95 3A 5C F7    	ld a, (tapereadspeed)
1776   FC98             ; 1086         if (flag_z)
1777   FC98             ; 1087             a -= 18;
1778   FC98 C2 9D FC    	jp nz, l_93
1779   FC9B D6 12       	sub 18
1780   FC9D             l_93: 
1781   FC9D             ; 1088         b = a;
1782   FC9D 47          	ld b, a
1783   FC9E             ; 1089         do {
1784   FC9E             l_95: 
1785   FC9E             l_96: 
1786   FC9E             ; 1090         } while (flag_nz(b--));
1787   FC9E 05          	dec b
1788   FC9F C2 9E FC    	jp nz, l_95
1789   FCA2             ; 1091         d++;
1790   FCA2 14          	inc d
1791   FCA3             ; 1092 
1792   FCA3             ; 1093         // Новое значение бита
1793   FCA3             ; 1094         e = ((a = in(PORT_TAPE)) &= PORT_TAPE_BIT);
1794   FCA3 DB 01       	in a, (1)
1795   FCA5 E6 01       	and 1
1796   FCA7 5F          	ld e, a
1797   FCA8             ; 1095 
1798   FCA8             ; 1096         // Режим поиска синхробайта
1799   FCA8             ; 1097         if (flag_m((a = d) |= a)) {
1800   FCA8 7A          	ld a, d
1801   FCA9 B7          	or a
1802   FCAA F2 C6 FC    	jp p, l_98
1803   FCAD             ; 1098             if ((a = c) == TAPE_START) {
1804   FCAD 79          	ld a, c
1805   FCAE FE E6       	cp 230
1806   FCB0 C2 BA FC    	jp nz, l_100
1807   FCB3             ; 1099                 tapePolarity = (a ^= a);
1808   FCB3 AF          	xor a
1809   FCB4 32 7C F7    	ld (tapepolarity), a
1810   FCB7 C3 C4 FC    	jp l_101
1811   FCBA             l_100: 
1812   FCBA             ; 1100             } else {
1813   FCBA             ; 1101                 if (a != ~TAPE_START)
1814   FCBA FE 19       	cp 65305
1815   FCBC             ; 1102                     goto retry;
1816   FCBC C2 7F FC    	jp nz, retry
1817   FCBF             ; 1103                 tapePolarity = a = 255;
1818   FCBF 3E FF       	ld a, 255
1819   FCC1 32 7C F7    	ld (tapepolarity), a
1820   FCC4             l_101: 
1821   FCC4             ; 1104             }
1822   FCC4             ; 1105             d = 8 + 1;
1823   FCC4 16 09       	ld d, 9
1824   FCC6             l_98: 
1825   FCC6             l_88: 
1826   FCC6             ; 1106         }
1827   FCC6             ; 1107     } while (flag_nz(d--));
1828   FCC6 15          	dec d
1829   FCC7 C2 7F FC    	jp nz, l_87
1830   FCCA             ; 1108     (a = tapePolarity) ^= c;
1831   FCCA 3A 7C F7    	ld a, (tapepolarity)
1832   FCCD A9          	xor c
1833   FCCE             ; 1109     pop(hl, bc, de);
1834   FCCE D1          	pop de
1835   FCCF C1          	pop bc
1836   FCD0 E1          	pop hl
1837   FCD1 C9          	ret
1838   FCD2             ; 1110 }
1839   FCD2             ; 1111 
1840   FCD2             ; 1112 void ReadTapeByteTimeout(...) {
1841   FCD2             readtapebytetimeout: 
1842   FCD2             ; 1113     if (flag_p((a = d) |= a))
1843   FCD2 7A          	ld a, d
1844   FCD3 B7          	or a
1845   FCD4             ; 1114         return MonitorError();
1846   FCD4 F2 B2 FB    	jp p, monitorerror
1847   FCD7             ; 1115     CtrlC();
1848   FCD7 CD CA F9    	call ctrlc
1849   FCDA             ; 1116     return ReadTapeByteInternal();
1850   FCDA C3 78 FC    	jp readtapebyteinternal
1851   FCDD             ; 1117 }
1852   FCDD             ; 1118 
1853   FCDD             ; 1119 // Функция для пользовательской программы.
1854   FCDD             ; 1120 // Запись байта на магнитную ленту.
1855   FCDD             ; 1121 // Параметры: c = байт. Результат: нет. Сохрнаяет: a, bc, de, hl.
1856   FCDD             ; 1122 
1857   FCDD             ; 1123 void WriteTapeByte(...) {
1858   FCDD             writetapebyte: 
1859   FCDD             ; 1124     push_pop(bc, de, a) {
1860   FCDD C5          	push bc
1861   FCDE D5          	push de
1862   FCDF F5          	push af
1863   FCE0             ; 1125         d = 8;
1864   FCE0 16 08       	ld d, 8
1865   FCE2             ; 1126         do {
1866   FCE2             l_102: 
1867   FCE2             ; 1127             // Сдвиг исходного байта
1868   FCE2             ; 1128             a = c;
1869   FCE2 79          	ld a, c
1870   FCE3             ; 1129             cyclic_rotate_left(a, 1);
1871   FCE3 07          	rlca
1872   FCE4             ; 1130             c = a;
1873   FCE4 4F          	ld c, a
1874   FCE5             ; 1131 
1875   FCE5             ; 1132             // Вывод
1876   FCE5             ; 1133             (a = PORT_TAPE_BIT) ^= c;
1877   FCE5 3E 01       	ld a, 1
1878   FCE7 A9          	xor c
1879   FCE8             ; 1134             out(PORT_TAPE, a);
1880   FCE8 D3 01       	out (1), a
1881   FCEA             ; 1135 
1882   FCEA             ; 1136             // Задержка
1883   FCEA             ; 1137             b = a = tapeWriteSpeed;
1884   FCEA 3A 5D F7    	ld a, (tapewritespeed)
1885   FCED 47          	ld b, a
1886   FCEE             ; 1138             do {
1887   FCEE             l_105: 
1888   FCEE             ; 1139                 b--;
1889   FCEE 05          	dec b
1890   FCEF             l_106: 
1891   FCEF C2 EE FC    	jp nz, l_105
1892   FCF2             ; 1140             } while (flag_nz);
1893   FCF2             ; 1141 
1894   FCF2             ; 1142             // Вывод
1895   FCF2             ; 1143             (a = 0) ^= c;
1896   FCF2 3E 00       	ld a, 0
1897   FCF4 A9          	xor c
1898   FCF5             ; 1144             out(PORT_TAPE, a);
1899   FCF5 D3 01       	out (1), a
1900   FCF7             ; 1145 
1901   FCF7             ; 1146             // Задержка
1902   FCF7             ; 1147             d--;
1903   FCF7 15          	dec d
1904   FCF8             ; 1148             a = tapeWriteSpeed;
1905   FCF8 3A 5D F7    	ld a, (tapewritespeed)
1906   FCFB             ; 1149             if (flag_z)
1907   FCFB             ; 1150                 a -= 14;
1908   FCFB C2 00 FD    	jp nz, l_108
1909   FCFE D6 0E       	sub 14
1910   FD00             l_108: 
1911   FD00             ; 1151             b = a;
1912   FD00 47          	ld b, a
1913   FD01             ; 1152             do {
1914   FD01             l_110: 
1915   FD01             ; 1153                 b--;
1916   FD01 05          	dec b
1917   FD02             l_111: 
1918   FD02 C2 01 FD    	jp nz, l_110
1919   FD05             ; 1154             } while (flag_nz);
1920   FD05             ; 1155             d++;
1921   FD05 14          	inc d
1922   FD06             l_103: 
1923   FD06             ; 1156         } while (flag_nz(d--));
1924   FD06 15          	dec d
1925   FD07 C2 E2 FC    	jp nz, l_102
1926   FD0A F1          	pop af
1927   FD0B D1          	pop de
1928   FD0C C1          	pop bc
1929   FD0D C9          	ret
1930   FD0E             ; 1157     }
1931   FD0E             ; 1158 }
1932   FD0E             ; 1159 
1933   FD0E             ; 1160 // Функция для пользовательской программы.
1934   FD0E             ; 1161 // Вывод 8 битного числа на экран.
1935   FD0E             ; 1162 // Параметры: а - число. Результат: нет. Сохраняет: bc, de, hl.
1936   FD0E             ; 1163 
1937   FD0E             ; 1164 void PrintHexByte(...) {
1938   FD0E             printhexbyte: 
1939   FD0E             ; 1165     push_pop(a) {
1940   FD0E F5          	push af
1941   FD0F             ; 1166         cyclic_rotate_right(a, 4);
1942   FD0F 0F          	rrca
1943   FD10 0F          	rrca
1944   FD11 0F          	rrca
1945   FD12 0F          	rrca
1946   FD13             ; 1167         PrintHexNibble(a);
1947   FD13 CD 17 FD    	call printhexnibble
1948   FD16 F1          	pop af
1949   FD17             ; 1168     }
1950   FD17             ; 1169     PrintHexNibble(a);
1951   FD17             ; 1170 }
1952   FD17             ; 1171 
1953   FD17             ; 1172 void PrintHexNibble(...) {
1954   FD17             printhexnibble: 
1955   FD17             ; 1173     a &= 0x0F;
1956   FD17 E6 0F       	and 15
1957   FD19             ; 1174     if (flag_p(compare(a, 10)))
1958   FD19 FE 0A       	cp 10
1959   FD1B             ; 1175         a += 'A' - '0' - 10;
1960   FD1B FA 20 FD    	jp m, l_113
1961   FD1E C6 07       	add 7
1962   FD20             l_113: 
1963   FD20             ; 1176     a += '0';
1964   FD20 C6 30       	add 48
1965   FD22             ; 1177     PrintCharA(a);
1966   FD22             ; 1178 }
1967   FD22             ; 1179 
1968   FD22             ; 1180 // Вывод символа на экран.
1969   FD22             ; 1181 // Параметры: а - символ. Результат: a и c - символ. Сохраняет: a, b, de, hl.
1970   FD22             ; 1182 
1971   FD22             ; 1183 void PrintCharA(...) {
1972   FD22             printchara: 
1973   FD22             ; 1184     PrintChar(c = a);
1974   FD22 4F          	ld c, a
1975   FD23             ; 1185 }
1976   FD23             ; 1186 
1977   FD23             ; 1187 // Функция для пользовательской программы.
1978   FD23             ; 1188 // Вывод символа на экран.
1979   FD23             ; 1189 // Параметры: c - символ. Результат: нет. Сохраняет: a, b, de, hl.
1980   FD23             ; 1190 
1981   FD23             ; 1191 void PrintChar(...) {
1982   FD23             printchar: 
1983   FD23             ; 1192     push(a, bc, de, hl);
1984   FD23 F5          	push af
1985   FD24 C5          	push bc
1986   FD25 D5          	push de
1987   FD26 E5          	push hl
1988   FD27             ; 1193     IsAnyKeyPressed();
1989   FD27 CD B7 FE    	call isanykeypressed
1990   FD2A             ; 1194     DrawCursor(b = 0);
1991   FD2A 06 00       	ld b, 0
1992   FD2C CD 77 FD    	call drawcursor
1993   FD2F             ; 1195     hl = cursor;
1994   FD2F 2A 5A F7    	ld hl, (cursor)
1995   FD32             ; 1196     a = escState;
1996   FD32 3A 5F F7    	ld a, (escstate)
1997   FD35             ; 1197     a--;
1998   FD35 3D          	dec a
1999   FD36             ; 1198     if (flag_m)
2000   FD36             ; 1199         return PrintCharNoEsc();
2001   FD36 FA BF FD    	jp m, printcharnoesc
2002   FD39             ; 1200     if (flag_z)
2003   FD39             ; 1201         return PrintCharEsc();
2004   FD39 CA A0 FD    	jp z, printcharesc
2005   FD3C             ; 1202     a--;
2006   FD3C 3D          	dec a
2007   FD3D             ; 1203     if (flag_nz)
2008   FD3D             ; 1204         return PrintCharEscY2();
2009   FD3D C2 85 FD    	jp nz, printcharescy2
2010   FD40             ; 1205 
2011   FD40             ; 1206     // Первый параметр ESC Y
2012   FD40             ; 1207     a = c;
2013   FD40 79          	ld a, c
2014   FD41             ; 1208     a -= ' ';
2015   FD41 D6 20       	sub 32
2016   FD43             ; 1209     if (flag_m) {
2017   FD43 F2 4A FD    	jp p, l_115
2018   FD46             ; 1210         a ^= a;
2019   FD46 AF          	xor a
2020   FD47 C3 51 FD    	jp l_116
2021   FD4A             l_115: 
2022   FD4A             ; 1211     } else {
2023   FD4A             ; 1212         if (flag_p(compare(a, SCREEN_HEIGHT)))
2024   FD4A FE 20       	cp 32
2025   FD4C             ; 1213             a = SCREEN_HEIGHT - 1;
2026   FD4C FA 51 FD    	jp m, l_117
2027   FD4F 3E 1F       	ld a, 31
2028   FD51             l_117: 
2029   FD51             l_116: 
2030   FD51             ; 1214     }
2031   FD51             ; 1215     cyclic_rotate_right(a, 2);
2032   FD51 0F          	rrca
2033   FD52 0F          	rrca
2034   FD53             ; 1216     c = a;
2035   FD53 4F          	ld c, a
2036   FD54             ; 1217     b = (a &= 192);
2037   FD54 E6 C0       	and 192
2038   FD56 47          	ld b, a
2039   FD57             ; 1218     l = (((a = l) &= 63) |= b);
2040   FD57 7D          	ld a, l
2041   FD58 E6 3F       	and 63
2042   FD5A B0          	or b
2043   FD5B 6F          	ld l, a
2044   FD5C             ; 1219     b = ((a = c) &= 7);
2045   FD5C 79          	ld a, c
2046   FD5D E6 07       	and 7
2047   FD5F 47          	ld b, a
2048   FD60             ; 1220     h = (((a = h) &= 248) |= b);
2049   FD60 7C          	ld a, h
2050   FD61 E6 F8       	and 248
2051   FD63 B0          	or b
2052   FD64 67          	ld h, a
2053   FD65             ; 1221     PrintCharSetEscState(hl, a = 3);
2054   FD65 3E 03       	ld a, 3
2055   FD67             ; 1222 }
2056   FD67             ; 1223 
2057   FD67             ; 1224 void PrintCharSetEscState(...) {
2058   FD67             printcharsetescstate: 
2059   FD67             ; 1225     escState = a;
2060   FD67 32 5F F7    	ld (escstate), a
2061   FD6A             ; 1226     PrintCharSaveCursor(hl);
2062   FD6A             ; 1227 }
2063   FD6A             ; 1228 
2064   FD6A             ; 1229 void PrintCharSaveCursor(...) {
2065   FD6A             printcharsavecursor: 
2066   FD6A             ; 1230     cursor = hl;
2067   FD6A 22 5A F7    	ld (cursor), hl
2068   FD6D             ; 1231     PrintCharExit();
2069   FD6D             ; 1232 }
2070   FD6D             ; 1233 
2071   FD6D             ; 1234 void PrintCharExit(...) {
2072   FD6D             printcharexit: 
2073   FD6D             ; 1235     DrawCursor(b = 0xFF);
2074   FD6D 06 FF       	ld b, 255
2075   FD6F CD 77 FD    	call drawcursor
2076   FD72             ; 1236     pop(a, bc, de, hl);
2077   FD72 E1          	pop hl
2078   FD73 D1          	pop de
2079   FD74 C1          	pop bc
2080   FD75 F1          	pop af
2081   FD76 C9          	ret
2082   FD77             ; 1237 }
2083   FD77             ; 1238 
2084   FD77             ; 1239 void DrawCursor(...) {
2085   FD77             drawcursor: 
2086   FD77             ; 1240     if ((a = cursorVisible) == 0)
2087   FD77 3A 5E F7    	ld a, (cursorvisible)
2088   FD7A B7          	or a
2089   FD7B             ; 1241         return;
2090   FD7B C8          	ret z
2091   FD7C             ; 1242     hl = cursor;
2092   FD7C 2A 5A F7    	ld hl, (cursor)
2093   FD7F             ; 1243     hl += (de = -SCREEN_SIZE + 1);
2094   FD7F 11 01 F8    	ld de, 63489
2095   FD82 19          	add hl, de
2096   FD83             ; 1244     *hl = b;
2097   FD83 70          	ld (hl), b
2098   FD84 C9          	ret
2099   FD85             ; 1245 }
2100   FD85             ; 1246 
2101   FD85             ; 1247 void PrintCharEscY2(...) {
2102   FD85             printcharescy2: 
2103   FD85             ; 1248     a = c;
2104   FD85 79          	ld a, c
2105   FD86             ; 1249     a -= ' ';
2106   FD86 D6 20       	sub 32
2107   FD88             ; 1250     if (flag_m) {
2108   FD88 F2 8F FD    	jp p, l_119
2109   FD8B             ; 1251         a ^= a;
2110   FD8B AF          	xor a
2111   FD8C C3 96 FD    	jp l_120
2112   FD8F             l_119: 
2113   FD8F             ; 1252     } else {
2114   FD8F             ; 1253         if (flag_p(compare(a, SCREEN_WIDTH)))
2115   FD8F FE 40       	cp 64
2116   FD91             ; 1254             a = SCREEN_WIDTH - 1;
2117   FD91 FA 96 FD    	jp m, l_121
2118   FD94 3E 3F       	ld a, 63
2119   FD96             l_121: 
2120   FD96             l_120: 
2121   FD96             ; 1255     }
2122   FD96             ; 1256     b = a;
2123   FD96 47          	ld b, a
2124   FD97             ; 1257     l = (((a = l) &= 192) |= b);
2125   FD97 7D          	ld a, l
2126   FD98 E6 C0       	and 192
2127   FD9A B0          	or b
2128   FD9B 6F          	ld l, a
2129   FD9C             ; 1258     PrintCharResetEscState();
2130   FD9C             ; 1259 }
2131   FD9C             ; 1260 
2132   FD9C             ; 1261 void PrintCharResetEscState(...) {
2133   FD9C             printcharresetescstate: 
2134   FD9C             ; 1262     a ^= a;
2135   FD9C AF          	xor a
2136   FD9D             ; 1263     return PrintCharSetEscState();
2137   FD9D C3 67 FD    	jp printcharsetescstate
2138   FDA0             ; 1264 }
2139   FDA0             ; 1265 
2140   FDA0             ; 1266 void PrintCharEsc(...) {
2141   FDA0             printcharesc: 
2142   FDA0             ; 1267     a = c;
2143   FDA0 79          	ld a, c
2144   FDA1             ; 1268     if (a == 'Y') {
2145   FDA1 FE 59       	cp 89
2146   FDA3 C2 AB FD    	jp nz, l_123
2147   FDA6             ; 1269         a = 2;
2148   FDA6 3E 02       	ld a, 2
2149   FDA8             ; 1270         return PrintCharSetEscState();
2150   FDA8 C3 67 FD    	jp printcharsetescstate
2151   FDAB             l_123: 
2152   FDAB             ; 1271     }
2153   FDAB             ; 1272     if (a == 97) {
2154   FDAB FE 61       	cp 97
2155   FDAD C2 B4 FD    	jp nz, l_125
2156   FDB0             ; 1273         a ^= a;
2157   FDB0 AF          	xor a
2158   FDB1             ; 1274         return SetCursorVisible();
2159   FDB1 C3 B9 FD    	jp setcursorvisible
2160   FDB4             l_125: 
2161   FDB4             ; 1275     }
2162   FDB4             ; 1276     if (a != 98)
2163   FDB4 FE 62       	cp 98
2164   FDB6             ; 1277         return PrintCharResetEscState();
2165   FDB6 C2 9C FD    	jp nz, printcharresetescstate
2166   FDB9             ; 1278     SetCursorVisible();
2167   FDB9             ; 1279 }
2168   FDB9             ; 1280 
2169   FDB9             ; 1281 void SetCursorVisible(...) {
2170   FDB9             setcursorvisible: 
2171   FDB9             ; 1282     cursorVisible = a;
2172   FDB9 32 5E F7    	ld (cursorvisible), a
2173   FDBC             ; 1283     return PrintCharResetEscState();
2174   FDBC C3 9C FD    	jp printcharresetescstate
2175   FDBF             ; 1284 }
2176   FDBF             ; 1285 
2177   FDBF             ; 1286 void PrintCharNoEsc(...) {
2178   FDBF             printcharnoesc: 
2179   FDBF             ; 1287     // Остановка вывода нажатием УС + Шифт
2180   FDBF             ; 1288     do {
2181   FDBF             l_127: 
2182   FDBF             ; 1289         a = in(PORT_KEYBOARD_MODS);
2183   FDBF DB 05       	in a, (5)
2184   FDC1             l_128: 
2185   FDC1             ; 1290     } while (flag_z(a &= (KEYBOARD_US_MOD | KEYBOARD_SHIFT_MOD)));
2186   FDC1 E6 06       	and 6
2187   FDC3 CA BF FD    	jp z, l_127
2188   FDC6             ; 1291 
2189   FDC6             ; 1292     compare(a = 16, c);
2190   FDC6 3E 10       	ld a, 16
2191   FDC8 B9          	cp c
2192   FDC9             ; 1293     a = translateCodeEnabled;
2193   FDC9 3A 7D F7    	ld a, (translatecodeenabled)
2194   FDCC             ; 1294     if (flag_z) {
2195   FDCC C2 D6 FD    	jp nz, l_130
2196   FDCF             ; 1295         invert(a);
2197   FDCF 2F          	cpl
2198   FDD0             ; 1296         translateCodeEnabled = a;
2199   FDD0 32 7D F7    	ld (translatecodeenabled), a
2200   FDD3             ; 1297         return PrintCharSaveCursor();
2201   FDD3 C3 6A FD    	jp printcharsavecursor
2202   FDD6             l_130: 
2203   FDD6             ; 1298     }
2204   FDD6             ; 1299     if (a != 0)
2205   FDD6 B7          	or a
2206   FDD7             ; 1300         TranslateCodePage(c);
2207   FDD7 C4 7E F7    	call nz, translatecodepage
2208   FDDA             ; 1301     a = c;
2209   FDDA 79          	ld a, c
2210   FDDB             ; 1302     if (a == 31)
2211   FDDB FE 1F       	cp 31
2212   FDDD             ; 1303         return ClearScreen();
2213   FDDD CA F1 FD    	jp z, clearscreen
2214   FDE0             ; 1304     if (flag_m)
2215   FDE0             ; 1305         return PrintChar3(a);
2216   FDE0 FA 06 FE    	jp m, printchar3
2217   FDE3             ; 1306     PrintChar4(a);
2218   FDE3             ; 1307 }
2219   FDE3             ; 1308 
2220   FDE3             ; 1309 void PrintChar4(...) {
2221   FDE3             printchar4: 
2222   FDE3             ; 1310     *hl = a;
2223   FDE3 77          	ld (hl), a
2224   FDE4             ; 1311     hl++;
2225   FDE4 23          	inc hl
2226   FDE5             ; 1312     if (flag_m(compare(a = h, SCREEN_END >> 8)))
2227   FDE5 7C          	ld a, h
2228   FDE6 FE F0       	cp 240
2229   FDE8             ; 1313         return PrintCharSaveCursor(hl);
2230   FDE8 FA 6A FD    	jp m, printcharsavecursor
2231   FDEB             ; 1314     PrintCrLf();
2232   FDEB CD AD FE    	call printcrlf
2233   FDEE             ; 1315     PrintCharExit();
2234   FDEE C3 6D FD    	jp printcharexit
2235   FDF1             ; 1316 }
2236   FDF1             ; 1317 
2237   FDF1             ; 1318 void ClearScreen(...) {
2238   FDF1             clearscreen: 
2239   FDF1             ; 1319     b = ' ';
2240   FDF1 06 20       	ld b, 32
2241   FDF3             ; 1320     a = SCREEN_END >> 8;
2242   FDF3 3E F0       	ld a, 240
2243   FDF5             ; 1321     hl = SCREEN_ATTRIB_BEGIN;
2244   FDF5 21 00 E0    	ld hl, 57344
2245   FDF8             ; 1322     do {
2246   FDF8             l_132: 
2247   FDF8             ; 1323         *hl = b;
2248   FDF8 70          	ld (hl), b
2249   FDF9             ; 1324         hl++;
2250   FDF9 23          	inc hl
2251   FDFA             ; 1325         *hl = b;
2252   FDFA 70          	ld (hl), b
2253   FDFB             ; 1326         hl++;
2254   FDFB 23          	inc hl
2255   FDFC             l_133: 
2256   FDFC             ; 1327     } while (a != h);
2257   FDFC BC          	cp h
2258   FDFD C2 F8 FD    	jp nz, l_132
2259   FE00             ; 1328     MoveCursorHome();
2260   FE00             ; 1329 }
2261   FE00             ; 1330 
2262   FE00             ; 1331 void MoveCursorHome(...) {
2263   FE00             movecursorhome: 
2264   FE00             ; 1332     return PrintCharSaveCursor(hl = SCREEN_BEGIN);
2265   FE00 21 00 E8    	ld hl, 59392
2266   FE03 C3 6A FD    	jp printcharsavecursor
2267   FE06             ; 1333 }
2268   FE06             ; 1334 
2269   FE06             ; 1335 void PrintChar3(...) {
2270   FE06             printchar3: 
2271   FE06             ; 1336     if (a == 12)
2272   FE06 FE 0C       	cp 12
2273   FE08             ; 1337         return MoveCursorHome();
2274   FE08 CA 00 FE    	jp z, movecursorhome
2275   FE0B             ; 1338     if (a == 13)
2276   FE0B FE 0D       	cp 13
2277   FE0D             ; 1339         return MoveCursorCr(hl);
2278   FE0D CA 55 FE    	jp z, movecursorcr
2279   FE10             ; 1340     if (a == 10)
2280   FE10 FE 0A       	cp 10
2281   FE12             ; 1341         return MoveCursorLf(hl);
2282   FE12 CA 6A FE    	jp z, movecursorlf
2283   FE15             ; 1342     if (a == 8)
2284   FE15 FE 08       	cp 8
2285   FE17             ; 1343         return MoveCursorLeft(hl);
2286   FE17 CA 66 FE    	jp z, movecursorleft
2287   FE1A             ; 1344     if (a == 24)
2288   FE1A FE 18       	cp 24
2289   FE1C             ; 1345         return MoveCursorRight(hl);
2290   FE1C CA 5C FE    	jp z, movecursorright
2291   FE1F             ; 1346     if (a == 25)
2292   FE1F FE 19       	cp 25
2293   FE21             ; 1347         return MoveCursorUp(hl);
2294   FE21 CA A0 FE    	jp z, movecursorup
2295   FE24             ; 1348     if (a == 7)
2296   FE24 FE 07       	cp 7
2297   FE26             ; 1349         return PrintCharBeep();
2298   FE26 CA 38 FE    	jp z, printcharbeep
2299   FE29             ; 1350     if (a == 26)
2300   FE29 FE 1A       	cp 26
2301   FE2B             ; 1351         return MoveCursorDown();
2302   FE2B CA A7 FE    	jp z, movecursordown
2303   FE2E             ; 1352     if (a != 27)
2304   FE2E FE 1B       	cp 27
2305   FE30             ; 1353         return PrintChar4(hl, a);
2306   FE30 C2 E3 FD    	jp nz, printchar4
2307   FE33             ; 1354     a = 1;
2308   FE33 3E 01       	ld a, 1
2309   FE35             ; 1355     PrintCharSetEscState();
2310   FE35 C3 67 FD    	jp printcharsetescstate
2311   FE38             ; 1356 }
2312   FE38             ; 1357 
2313   FE38             ; 1358 void PrintCharBeep(...) {
2314   FE38             printcharbeep: 
2315   FE38             ; 1359     c = 128;  // Длительность
2316   FE38 0E 80       	ld c, 128
2317   FE3A             ; 1360     e = 32;   // Частота
2318   FE3A 1E 20       	ld e, 32
2319   FE3C             ; 1361     do {
2320   FE3C             l_135: 
2321   FE3C             ; 1362         d = e;
2322   FE3C 53          	ld d, e
2323   FE3D             ; 1363         do {
2324   FE3D             l_138: 
2325   FE3D             ; 1364             out(PORT_KEYBOARD_MODE, a = 1 | (7 << 1));
2326   FE3D 3E 0F       	ld a, 15
2327   FE3F D3 04       	out (4), a
2328   FE41             l_139: 
2329   FE41             ; 1365         } while (flag_nz(e--));
2330   FE41 1D          	dec e
2331   FE42 C2 3D FE    	jp nz, l_138
2332   FE45             ; 1366         e = d;
2333   FE45 5A          	ld e, d
2334   FE46             ; 1367         do {
2335   FE46             l_141: 
2336   FE46             ; 1368             out(PORT_KEYBOARD_MODE, a = (7 << 1));
2337   FE46 3E 0E       	ld a, 14
2338   FE48 D3 04       	out (4), a
2339   FE4A             l_142: 
2340   FE4A             ; 1369         } while (flag_nz(d--));
2341   FE4A 15          	dec d
2342   FE4B C2 46 FE    	jp nz, l_141
2343   FE4E             l_136: 
2344   FE4E             ; 1370     } while (flag_nz(c--));
2345   FE4E 0D          	dec c
2346   FE4F C2 3C FE    	jp nz, l_135
2347   FE52             ; 1371 
2348   FE52             ; 1372     PrintCharExit();
2349   FE52 C3 6D FD    	jp printcharexit
2350   FE55             ; 1373 }
2351   FE55             ; 1374 
2352   FE55             ; 1375 void MoveCursorCr(...) {
2353   FE55             movecursorcr: 
2354   FE55             ; 1376     l = ((a = l) &= ~(SCREEN_WIDTH - 1));
2355   FE55 7D          	ld a, l
2356   FE56 E6 C0       	and 192
2357   FE58 6F          	ld l, a
2358   FE59             ; 1377     PrintCharSaveCursor(hl);
2359   FE59 C3 6A FD    	jp printcharsavecursor
2360   FE5C             ; 1378 }
2361   FE5C             ; 1379 
2362   FE5C             ; 1380 void MoveCursorRight(...) {
2363   FE5C             movecursorright: 
2364   FE5C             ; 1381     hl++;
2365   FE5C 23          	inc hl
2366   FE5D             ; 1382     MoveCursorBoundary(hl);
2367   FE5D             ; 1383 }
2368   FE5D             ; 1384 
2369   FE5D             ; 1385 void MoveCursorBoundary(...) {
2370   FE5D             movecursorboundary: 
2371   FE5D             ; 1386     a = h;
2372   FE5D 7C          	ld a, h
2373   FE5E             ; 1387     a &= 7;
2374   FE5E E6 07       	and 7
2375   FE60             ; 1388     a |= SCREEN_BEGIN >> 8;
2376   FE60 F6 E8       	or 232
2377   FE62             ; 1389     h = a;
2378   FE62 67          	ld h, a
2379   FE63             ; 1390     return PrintCharSaveCursor(hl);
2380   FE63 C3 6A FD    	jp printcharsavecursor
2381   FE66             ; 1391 }
2382   FE66             ; 1392 
2383   FE66             ; 1393 void MoveCursorLeft(...) {
2384   FE66             movecursorleft: 
2385   FE66             ; 1394     hl--;
2386   FE66 2B          	dec hl
2387   FE67             ; 1395     return MoveCursorBoundary(hl);
2388   FE67 C3 5D FE    	jp movecursorboundary
2389   FE6A             ; 1396 }
2390   FE6A             ; 1397 
2391   FE6A             ; 1398 void MoveCursorLf(...) {
2392   FE6A             movecursorlf: 
2393   FE6A             ; 1399     hl += (bc = SCREEN_WIDTH);
2394   FE6A 01 40 00    	ld bc, 64
2395   FE6D 09          	add hl, bc
2396   FE6E             ; 1400     if (flag_m(compare(a = h, SCREEN_END >> 8)))
2397   FE6E 7C          	ld a, h
2398   FE6F FE F0       	cp 240
2399   FE71             ; 1401         return PrintCharSaveCursor(hl);
2400   FE71 FA 6A FD    	jp m, printcharsavecursor
2401   FE74             ; 1402 
2402   FE74             ; 1403     hl = SCREEN_BEGIN;
2403   FE74 21 00 E8    	ld hl, 59392
2404   FE77             ; 1404     bc = (SCREEN_BEGIN + SCREEN_WIDTH);
2405   FE77 01 40 E8    	ld bc, 59456
2406   FE7A             ; 1405     do {
2407   FE7A             l_144: 
2408   FE7A             ; 1406         *hl = a = *bc;
2409   FE7A 0A          	ld a, (bc)
2410   FE7B 77          	ld (hl), a
2411   FE7C             ; 1407         hl++;
2412   FE7C 23          	inc hl
2413   FE7D             ; 1408         bc++;
2414   FE7D 03          	inc bc
2415   FE7E             ; 1409         *hl = a = *bc;
2416   FE7E 0A          	ld a, (bc)
2417   FE7F 77          	ld (hl), a
2418   FE80             ; 1410         hl++;
2419   FE80 23          	inc hl
2420   FE81             ; 1411         bc++;
2421   FE81 03          	inc bc
2422   FE82             l_145: 
2423   FE82             ; 1412     } while (flag_m(compare(a = b, SCREEN_END >> 8)));
2424   FE82 78          	ld a, b
2425   FE83 FE F0       	cp 240
2426   FE85 FA 7A FE    	jp m, l_144
2427   FE88             ; 1413     a = SCREEN_END >> 8;
2428   FE88 3E F0       	ld a, 240
2429   FE8A             ; 1414     c = ' ';
2430   FE8A 0E 20       	ld c, 32
2431   FE8C             ; 1415     do {
2432   FE8C             l_147: 
2433   FE8C             ; 1416         *hl = c;
2434   FE8C 71          	ld (hl), c
2435   FE8D             ; 1417         hl++;
2436   FE8D 23          	inc hl
2437   FE8E             ; 1418         *hl = c;
2438   FE8E 71          	ld (hl), c
2439   FE8F             ; 1419         hl++;
2440   FE8F 23          	inc hl
2441   FE90             l_148: 
2442   FE90             ; 1420     } while (a != h);
2443   FE90 BC          	cp h
2444   FE91 C2 8C FE    	jp nz, l_147
2445   FE94             ; 1421     hl = cursor;
2446   FE94 2A 5A F7    	ld hl, (cursor)
2447   FE97             ; 1422     h = ((SCREEN_END >> 8) - 1);
2448   FE97 26 EF       	ld h, 239
2449   FE99             ; 1423     l = ((a = l) |= 192);
2450   FE99 7D          	ld a, l
2451   FE9A F6 C0       	or 192
2452   FE9C 6F          	ld l, a
2453   FE9D             ; 1424     PrintCharSaveCursor(hl);
2454   FE9D C3 6A FD    	jp printcharsavecursor
2455   FEA0             ; 1425 }
2456   FEA0             ; 1426 
2457   FEA0             ; 1427 void MoveCursorUp(...) {
2458   FEA0             movecursorup: 
2459   FEA0             ; 1428     MoveCursor(hl, bc = -SCREEN_WIDTH);
2460   FEA0 01 C0 FF    	ld bc, 65472
2461   FEA3             ; 1429 }
2462   FEA3             ; 1430 
2463   FEA3             ; 1431 void MoveCursor(...) {
2464   FEA3             movecursor: 
2465   FEA3             ; 1432     hl += bc;
2466   FEA3 09          	add hl, bc
2467   FEA4             ; 1433     MoveCursorBoundary(hl);
2468   FEA4 C3 5D FE    	jp movecursorboundary
2469   FEA7             ; 1434 }
2470   FEA7             ; 1435 
2471   FEA7             ; 1436 void MoveCursorDown(...) {
2472   FEA7             movecursordown: 
2473   FEA7             ; 1437     return MoveCursor(hl, bc = SCREEN_WIDTH);
2474   FEA7 01 40 00    	ld bc, 64
2475   FEAA C3 A3 FE    	jp movecursor
2476   FEAD             ; 1438 }
2477   FEAD             ; 1439 
2478   FEAD             ; 1440 void PrintCrLf() {
2479   FEAD             printcrlf: 
2480   FEAD             ; 1441     PrintChar(c = 13);
2481   FEAD 0E 0D       	ld c, 13
2482   FEAF CD 23 FD    	call printchar
2483   FEB2             ; 1442     PrintChar(c = 10);
2484   FEB2 0E 0A       	ld c, 10
2485   FEB4 C3 23 FD    	jp printchar
2486   FEB7             ; 1443 }
2487   FEB7             ; 1444 
2488   FEB7             ; 1445 // Функция для пользовательской программы.
2489   FEB7             ; 1446 // Нажата ли хотя бы одна клавиша на клавиатуре?
2490   FEB7             ; 1447 // Параметры: нет. Результат:  a - 0xFF если клавиша нажата, 0 если нет. Сохраняет: bc, de, hl.
2491   FEB7             ; 1448 
2492   FEB7             ; 1449 void IsAnyKeyPressed() {
2493   FEB7             isanykeypressed: 
2494   FEB7             ; 1450     out(PORT_KEYBOARD_COLUMN, a ^= a);
2495   FEB7 AF          	xor a
2496   FEB8 D3 07       	out (7), a
2497   FEBA             ; 1451     a = in(PORT_KEYBOARD_ROW);
2498   FEBA DB 06       	in a, (6)
2499   FEBC             ; 1452     a &= KEYBOARD_ROW_MASK;
2500   FEBC E6 7F       	and 127
2501   FEBE             ; 1453     if (a == KEYBOARD_ROW_MASK) {
2502   FEBE FE 7F       	cp 127
2503   FEC0 C2 C5 FE    	jp nz, l_150
2504   FEC3             ; 1454         a ^= a;
2505   FEC3 AF          	xor a
2506   FEC4             ; 1455         return;
2507   FEC4 C9          	ret
2508   FEC5             l_150: 
2509   FEC5             ; 1456     }
2510   FEC5             ; 1457     a = 0xFF;
2511   FEC5 3E FF       	ld a, 255
2512   FEC7 C9          	ret
2513   FEC8             ; 1458 }
2514   FEC8             ; 1459 
2515   FEC8             ; 1460 // Функция для пользовательской программы.
2516   FEC8             ; 1461 // Получить код нажатой клавиши на клавиатуре.
2517   FEC8             ; 1462 // В отличии от функции ScanKey, в этой функции есть задержка повтора.
2518   FEC8             ; 1463 // Параметры: нет. Результат: a. Сохраняет: bc, de, hl.
2519   FEC8             ; 1464 
2520   FEC8             ; 1465 void ReadKey() {
2521   FEC8             readkey: 
2522   FEC8             ; 1466     push_pop(hl) {
2523   FEC8 E5          	push hl
2524   FEC9             ; 1467         hl = keyDelay;
2525   FEC9 2A 60 F7    	ld hl, (keydelay)
2526   FECC             ; 1468         ReadKeyInternal(hl);
2527   FECC CD E8 FE    	call readkeyinternal
2528   FECF             ; 1469         l = 32;         // Задержка повтора нажатия клавиши
2529   FECF 2E 20       	ld l, 32
2530   FED1             ; 1470         if (flag_nz) {  // Не таймаут
2531   FED1 CA E3 FE    	jp z, l_152
2532   FED4             ; 1471             do {
2533   FED4             l_154: 
2534   FED4             ; 1472                 do {
2535   FED4             l_157: 
2536   FED4             ; 1473                     l = 2;
2537   FED4 2E 02       	ld l, 2
2538   FED6             ; 1474                     ReadKeyInternal(hl);
2539   FED6 CD E8 FE    	call readkeyinternal
2540   FED9             l_158: 
2541   FED9 C2 D4 FE    	jp nz, l_157
2542   FEDC             l_155: 
2543   FEDC             ; 1475                 } while (flag_nz);  // Цикл длится, пока не наступит таймаут
2544   FEDC             ; 1476             } while (a >= 128);     // Цикл длится, пока не нажата клавиша
2545   FEDC FE 80       	cp 128
2546   FEDE D2 D4 FE    	jp nc, l_154
2547   FEE1             ; 1477             l = 128;                // Задержка повтора первого нажатия клавиши
2548   FEE1 2E 80       	ld l, 128
2549   FEE3             l_152: 
2550   FEE3             ; 1478         }
2551   FEE3             ; 1479         keyDelay = hl;
2552   FEE3 22 60 F7    	ld (keydelay), hl
2553   FEE6 E1          	pop hl
2554   FEE7 C9          	ret
2555   FEE8             ; 1480     }
2556   FEE8             ; 1481 }
2557   FEE8             ; 1482 
2558   FEE8             ; 1483 void ReadKeyInternal(...) {
2559   FEE8             readkeyinternal: 
2560   FEE8             ; 1484     do {
2561   FEE8             l_160: 
2562   FEE8             ; 1485         ScanKey();
2563   FEE8 CD FE FE    	call scankey
2564   FEEB             ; 1486         if (a != h)
2565   FEEB BC          	cp h
2566   FEEC             ; 1487             break;
2567   FEEC C2 FC FE    	jp nz, l_162
2568   FEEF             ; 1488 
2569   FEEF             ; 1489         // Задержка
2570   FEEF             ; 1490         push_pop(a) {
2571   FEEF F5          	push af
2572   FEF0             ; 1491             a ^= a;
2573   FEF0 AF          	xor a
2574   FEF1             ; 1492             do {
2575   FEF1             l_163: 
2576   FEF1             ; 1493                 swap(hl, de);
2577   FEF1 EB          	ex hl, de
2578   FEF2             ; 1494                 swap(hl, de);
2579   FEF2 EB          	ex hl, de
2580   FEF3             l_164: 
2581   FEF3             ; 1495             } while (flag_nz(a--));
2582   FEF3 3D          	dec a
2583   FEF4 C2 F1 FE    	jp nz, l_163
2584   FEF7 F1          	pop af
2585   FEF8             l_161: 
2586   FEF8             ; 1496         }
2587   FEF8             ; 1497     } while (flag_nz(l--));
2588   FEF8 2D          	dec l
2589   FEF9 C2 E8 FE    	jp nz, l_160
2590   FEFC             l_162: 
2591   FEFC             ; 1498     h = a;
2592   FEFC 67          	ld h, a
2593   FEFD C9          	ret
2594   FEFE             ; 1499 }
2595   FEFE             ; 1500 
2596   FEFE             ; 1501 // Функция для пользовательской программы.
2597   FEFE             ; 1502 // Получить код нажатой клавиши на клавиатуре.
2598   FEFE             ; 1503 // Параметры: нет. Результат: a. Сохраняет: bc, de, hl.
2599   FEFE             ; 1504 
2600   FEFE             ; 1505 void ScanKey() {
2601   FEFE             scankey: 
2602   FEFE             ; 1506     push(bc, de, hl);
2603   FEFE C5          	push bc
2604   FEFF D5          	push de
2605   FF00 E5          	push hl
2606   FF01             ; 1507 
2607   FF01             ; 1508     bc = 0x00FE;
2608   FF01 01 FE 00    	ld bc, 254
2609   FF04             ; 1509     d = KEYBOARD_COLUMN_COUNT;
2610   FF04 16 08       	ld d, 8
2611   FF06             ; 1510     do {
2612   FF06             l_166: 
2613   FF06             ; 1511         a = c;
2614   FF06 79          	ld a, c
2615   FF07             ; 1512         out(PORT_KEYBOARD_COLUMN, a);
2616   FF07 D3 07       	out (7), a
2617   FF09             ; 1513         cyclic_rotate_left(a, 1);
2618   FF09 07          	rlca
2619   FF0A             ; 1514         c = a;
2620   FF0A 4F          	ld c, a
2621   FF0B             ; 1515         a = in(PORT_KEYBOARD_ROW);
2622   FF0B DB 06       	in a, (6)
2623   FF0D             ; 1516         a &= KEYBOARD_ROW_MASK;
2624   FF0D E6 7F       	and 127
2625   FF0F             ; 1517         if (a != KEYBOARD_ROW_MASK)
2626   FF0F FE 7F       	cp 127
2627   FF11             ; 1518             return ScanKey2(a);
2628   FF11 C2 28 FF    	jp nz, scankey2
2629   FF14             ; 1519         b = ((a = b) += KEYBOARD_ROW_COUNT);
2630   FF14 78          	ld a, b
2631   FF15 C6 07       	add 7
2632   FF17 47          	ld b, a
2633   FF18             l_167: 
2634   FF18             ; 1520     } while (flag_nz(d--));
2635   FF18 15          	dec d
2636   FF19 C2 06 FF    	jp nz, l_166
2637   FF1C             ; 1521 
2638   FF1C             ; 1522     a = in(PORT_KEYBOARD_MODS);
2639   FF1C DB 05       	in a, (5)
2640   FF1E             ; 1523     carry_rotate_right(a, 1);
2641   FF1E 1F          	rra
2642   FF1F             ; 1524     a = 0xFF;  // No key
2643   FF1F 3E FF       	ld a, 255
2644   FF21             ; 1525     if (flag_c)
2645   FF21             ; 1526         return ScanKeyExit(a);
2646   FF21 DA 64 FF    	jp c, scankeyexit
2647   FF24             ; 1527     a--;  // Rus key
2648   FF24 3D          	dec a
2649   FF25             ; 1528     return ScanKeyExit(a);
2650   FF25 C3 64 FF    	jp scankeyexit
2651   FF28             ; 1529 }
2652   FF28             ; 1530 
2653   FF28             ; 1531 void ScanKey2(...) {
2654   FF28             scankey2: 
2655   FF28             ; 1532     for (;;) {
2656   FF28             l_170: 
2657   FF28             ; 1533         carry_rotate_right(a, 1);
2658   FF28 1F          	rra
2659   FF29             ; 1534         if (flag_nc)
2660   FF29             ; 1535             break;
2661   FF29 D2 30 FF    	jp nc, l_171
2662   FF2C             ; 1536         b++;
2663   FF2C 04          	inc b
2664   FF2D C3 28 FF    	jp l_170
2665   FF30             l_171: 
2666   FF30             ; 1537     }
2667   FF30             ; 1538 
2668   FF30             ; 1539     /* b - key number */
2669   FF30             ; 1540 
2670   FF30             ; 1541     /*  0    0    1 !   2 "   3 #   4 $   5 %   6 &   7 ,
2671   FF30             ; 1542      *  8   8 (   9 )   : *   ; +   , <   - =   . >   / ?
2672   FF30             ; 1543      * 16   @ Ю   A А   B Б   C Ц   D Д   E Е   F Ф   G Г
2673   FF30             ; 1544      * 24   H Х   I И   J Й   K К   L Л   M М   N Н   O О
2674   FF30             ; 1545      * 32   P П   Q Я   R Р   S С   T Т   U У   V Ж   W В
2675   FF30             ; 1546      * 40   X Ь   Y Ы   Z З   [ Ш   \ Э   ] Щ   ^ Ч    _
2676   FF30             ; 1547      * 48   Space Right Left  Up    Down  Vk    Str   Home */
2677   FF30             ; 1548 
2678   FF30             ; 1549     a = b;
2679   FF30 78          	ld a, b
2680   FF31             ; 1550     if (a >= 48)
2681   FF31 FE 30       	cp 48
2682   FF33             ; 1551         return ScanKeySpecial(a);
2683   FF33 D2 8A FF    	jp nc, scankeyspecial
2684   FF36             ; 1552     a += 48;
2685   FF36 C6 30       	add 48
2686   FF38             ; 1553     if (a >= 60)
2687   FF38 FE 3C       	cp 60
2688   FF3A             ; 1554         if (a < 64)
2689   FF3A DA 44 FF    	jp c, l_172
2690   FF3D FE 40       	cp 64
2691   FF3F             ; 1555             a &= 47;
2692   FF3F D2 44 FF    	jp nc, l_174
2693   FF42 E6 2F       	and 47
2694   FF44             l_174: 
2695   FF44             l_172: 
2696   FF44             ; 1556 
2697   FF44             ; 1557     if (a == 95)
2698   FF44 FE 5F       	cp 95
2699   FF46             ; 1558         a = 127;
2700   FF46 C2 4B FF    	jp nz, l_176
2701   FF49 3E 7F       	ld a, 127
2702   FF4B             l_176: 
2703   FF4B             ; 1559 
2704   FF4B             ; 1560     c = a;
2705   FF4B 4F          	ld c, a
2706   FF4C             ; 1561     a = in(PORT_KEYBOARD_MODS);
2707   FF4C DB 05       	in a, (5)
2708   FF4E             ; 1562     a &= KEYBOARD_MODS_MASK;
2709   FF4E E6 07       	and 7
2710   FF50             ; 1563     compare(a, KEYBOARD_MODS_MASK);
2711   FF50 FE 07       	cp 7
2712   FF52             ; 1564     b = a;
2713   FF52 47          	ld b, a
2714   FF53             ; 1565     a = c;
2715   FF53 79          	ld a, c
2716   FF54             ; 1566     if (flag_z)
2717   FF54             ; 1567         return ScanKeyExit(a);
2718   FF54 CA 64 FF    	jp z, scankeyexit
2719   FF57             ; 1568     a = b;
2720   FF57 78          	ld a, b
2721   FF58             ; 1569     carry_rotate_right(a, 2);
2722   FF58 1F          	rra
2723   FF59 1F          	rra
2724   FF5A             ; 1570     if (flag_nc)
2725   FF5A             ; 1571         return ScanKeyControl(c);
2726   FF5A D2 68 FF    	jp nc, scankeycontrol
2727   FF5D             ; 1572     carry_rotate_right(a, 1);
2728   FF5D 1F          	rra
2729   FF5E             ; 1573     if (flag_nc)
2730   FF5E             ; 1574         return ScanKeyShift();
2731   FF5E D2 6E FF    	jp nc, scankeyshift
2732   FF61             ; 1575     (a = c) |= 0x20;
2733   FF61 79          	ld a, c
2734   FF62 F6 20       	or 32
2735   FF64             ; 1576     ScanKeyExit(a);
2736   FF64             ; 1577 }
2737   FF64             ; 1578 
2738   FF64             ; 1579 void ScanKeyExit(...) {
2739   FF64             scankeyexit: 
2740   FF64             ; 1580     pop(bc, de, hl);
2741   FF64 E1          	pop hl
2742   FF65 D1          	pop de
2743   FF66 C1          	pop bc
2744   FF67 C9          	ret
2745   FF68             ; 1581 }
2746   FF68             ; 1582 
2747   FF68             ; 1583 void ScanKeyControl(...) {
2748   FF68             scankeycontrol: 
2749   FF68             ; 1584     a = c;
2750   FF68 79          	ld a, c
2751   FF69             ; 1585     a &= 0x1F;
2752   FF69 E6 1F       	and 31
2753   FF6B             ; 1586     return ScanKeyExit(a);
2754   FF6B C3 64 FF    	jp scankeyexit
2755   FF6E             ; 1587 }
2756   FF6E             ; 1588 
2757   FF6E             ; 1589 void ScanKeyShift(...) {
2758   FF6E             scankeyshift: 
2759   FF6E             ; 1590     if ((a = c) == 127)
2760   FF6E 79          	ld a, c
2761   FF6F FE 7F       	cp 127
2762   FF71             ; 1591         a = 95;
2763   FF71 C2 76 FF    	jp nz, l_178
2764   FF74 3E 5F       	ld a, 95
2765   FF76             l_178: 
2766   FF76             ; 1592     if (a >= 64)
2767   FF76 FE 40       	cp 64
2768   FF78             ; 1593         return ScanKeyExit();
2769   FF78 D2 64 FF    	jp nc, scankeyexit
2770   FF7B             ; 1594     if (a < 48) {
2771   FF7B FE 30       	cp 48
2772   FF7D D2 85 FF    	jp nc, l_180
2773   FF80             ; 1595         a |= 16;
2774   FF80 F6 10       	or 16
2775   FF82             ; 1596         return ScanKeyExit();
2776   FF82 C3 64 FF    	jp scankeyexit
2777   FF85             l_180: 
2778   FF85             ; 1597     }
2779   FF85             ; 1598     a &= 47;
2780   FF85 E6 2F       	and 47
2781   FF87             ; 1599     return ScanKeyExit();
2782   FF87 C3 64 FF    	jp scankeyexit
2783   FF8A             ; 1600 }
2784   FF8A             ; 1601 
2785   FF8A             ; 1602 void ScanKeySpecial(...) {
2786   FF8A             scankeyspecial: 
2787   FF8A             ; 1603     hl = specialKeyTable;
2788   FF8A 21 97 FF    	ld hl, 0FFFFh & (specialkeytable)
2789   FF8D             ; 1604     c = (a -= 48);
2790   FF8D D6 30       	sub 48
2791   FF8F 4F          	ld c, a
2792   FF90             ; 1605     b = 0;
2793   FF90 06 00       	ld b, 0
2794   FF92             ; 1606     hl += bc;
2795   FF92 09          	add hl, bc
2796   FF93             ; 1607     a = *hl;
2797   FF93 7E          	ld a, (hl)
2798   FF94             ; 1608     return ScanKeyExit(a);
2799   FF94 C3 64 FF    	jp scankeyexit
2800   FF97             ; 1609 }
2801   FF97             ; 1610 
2802   FF97             ; 1611 uint8_t specialKeyTable[] = {
2803   FF97             specialkeytable: 
2804   FF97 20          	db 32
2805   FF98 18          	db 24
2806   FF99 08          	db 8
2807   FF9A 19          	db 25
2808   FF9B 1A          	db 26
2809   FF9C 0D          	db 13
2810   FF9D 1F          	db 31
2811   FF9E 0C          	db 12
2812   FF9F             ; 1622  aPrompt[6] = "\r\n-->";
2813   FF9F             aprompt: 
2814   FF9F 0D          	db 13
2815   FFA0 0A          	db 10
2816   FFA1 2D          	db 45
2817   FFA2 2D          	db 45
2818   FFA3 3E          	db 62
2819   FFA4 00          	ds 1
2820   FFA5             ; 1623  aCrLfTab[6] = "\r\n\x18\x18\x18";
2821   FFA5             acrlftab: 
2822   FFA5 0D          	db 13
2823   FFA6 0A          	db 10
2824   FFA7 18          	db 24
2825   FFA8 18          	db 24
2826   FFA9 18          	db 24
2827   FFAA 00          	ds 1
2828   FFAB             ; 1624  aRegisters[] = "\r\nPC-\r\nHL-\r\nBC-\r\nDE-\r\nSP-\r\nAF-\x19\x19\x19\x19\x19\x19";
2829   FFAB             aregisters: 
2830   FFAB 0D          	db 13
2831   FFAC 0A          	db 10
2832   FFAD 50          	db 80
2833   FFAE 43          	db 67
2834   FFAF 2D          	db 45
2835   FFB0 0D          	db 13
2836   FFB1 0A          	db 10
2837   FFB2 48          	db 72
2838   FFB3 4C          	db 76
2839   FFB4 2D          	db 45
2840   FFB5 0D          	db 13
2841   FFB6 0A          	db 10
2842   FFB7 42          	db 66
2843   FFB8 43          	db 67
2844   FFB9 2D          	db 45
2845   FFBA 0D          	db 13
2846   FFBB 0A          	db 10
2847   FFBC 44          	db 68
2848   FFBD 45          	db 69
2849   FFBE 2D          	db 45
2850   FFBF 0D          	db 13
2851   FFC0 0A          	db 10
2852   FFC1 53          	db 83
2853   FFC2 50          	db 80
2854   FFC3 2D          	db 45
2855   FFC4 0D          	db 13
2856   FFC5 0A          	db 10
2857   FFC6 41          	db 65
2858   FFC7 46          	db 70
2859   FFC8 2D          	db 45
2860   FFC9 19          	db 25
2861   FFCA 19          	db 25
2862   FFCB 19          	db 25
2863   FFCC 19          	db 25
2864   FFCD 19          	db 25
2865   FFCE 19          	db 25
2866   FFCF 00          	ds 1
2867   FFD0             ; 1625  aBackspace[4] = "\x08 \x08";
2868   FFD0             abackspace: 
2869   FFD0 08          	db 8
2870   FFD1 20          	db 32
2871   FFD2 08          	db 8
2872   FFD3 00          	ds 1
2873   FFD4             ; 1626  aHello[] = "\x1F\nm/80k ";
2874   FFD4             ahello: 
2875   FFD4 1F          	db 31
2876   FFD5 0A          	db 10
2877   FFD6 6D          	db 109
2878   FFD7 2F          	db 47
2879   FFD8 38          	db 56
2880   FFD9 30          	db 48
2881   FFDA 6B          	db 107
2882   FFDB 20          	db 32
2883   FFDC 00          	ds 1
2884   FFDD             ; 1628  TranslateCodePageDefault(...) {
2885   FFDD             translatecodepagedefault: 
2886   FFDD C9          	ret
2887   FFDE             ; 1629 }
2888   FFDE             ; 1630 
2889   FFDE             ; 1631 uint8_t padding[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
2890   FFDE             padding: 
2891   FFDE FF          	db 255
2892   FFDF FF          	db 255
2893   FFE0 FF          	db 255
2894   FFE1 FF          	db 255
2895   FFE2 FF          	db 255
2896   FFE3 FF          	db 255
2897   FFE4 FF          	db 255
2898   FFE5 FF          	db 255
2899   FFE6 FF          	db 255
2900   FFE7 FF          	db 255
2901   FFE8 FF          	db 255
2902   FFE9 FF          	db 255
2903   FFEA FF          	db 255
2904   FFEB FF          	db 255
2905   FFEC FF          	db 255
2906   FFED FF          	db 255
2907   FFEE FF          	db 255
2908   FFEF FF          	db 255
2909   FFF0 FF          	db 255
2910   FFF1 FF          	db 255
2911   FFF2 FF          	db 255
2912   FFF3 FF          	db 255
2913   FFF4 FF          	db 255
2914   FFF5 FF          	db 255
2915   FFF6 FF          	db 255
2916   FFF7 FF          	db 255
2917   FFF8 FF          	db 255
2918   FFF9 FF          	db 255
2919   FFFA FF          	db 255
2920   FFFB FF          	db 255
2921   FFFC FF          	db 255
2922   FFFD FF          	db 255
2923   FFFE FF          	db 255
2924   FFFF FF          	db 255
2925   0000              savebin "micro80.bin", 0xF800, 0x10000
2926   0000             
