0001   0000                 device zxspectrum48 ; It has nothing to do with ZX Spectrum 48K, it is needed for the sjasmplus compiler.
0002   0000             rst30opcode equ 48
0003   0000             rst30address equ 49
0004   0000             rst38opcode equ 56
0005   0000             rst38address equ 57
0006   0000             cursor equ 63322
0007   0000             tapereadspeed equ 63324
0008   0000             tapewritespeed equ 63325
0009   0000             cursorvisible equ 63326
0010   0000             escstate equ 63327
0011   0000             keydelay equ 63328
0012   0000             regpc equ 63330
0013   0000             reghl equ 63332
0014   0000             regbc equ 63334
0015   0000             regde equ 63336
0016   0000             regsp equ 63338
0017   0000             regaf equ 63340
0018   0000             breakpointaddress equ 63345
0019   0000             breakpointvalue equ 63347
0020   0000             jmpparam1opcode equ 63348
0021   0000             param1 equ 63349
0022   0000             param2 equ 63351
0023   0000             param3 equ 63353
0024   0000             param2exists equ 63355
0025   0000             tapepolarity equ 63356
0026   0000             translatecodeenabled equ 63357
0027   0000             translatecodepagejump equ 63358
0028   0000             translatecodepageaddress equ 63359
0029   0000             ramtop equ 63361
0030   0000             inputbuffer equ 63363
0031   0000             jmpparam1 equ 63348
0032   0000             translatecodepage equ 63358
0033   0000              .org 0xF800
0034   F800             ; 53  uint8_t rst30Opcode __address(0x30);
0035   F800             ; 54 extern uint16_t rst30Address __address(0x31);
0036   F800             ; 55 extern uint8_t rst38Opcode __address(0x38);
0037   F800             ; 56 extern uint16_t rst38Address __address(0x39);
0038   F800             ; 57 
0039   F800             ; 58 // Прототипы
0040   F800             ; 59 void Reboot(...);
0041   F800             ; 60 void EntryF86C_Monitor(...);
0042   F800             ; 61 void Reboot2(...);
0043   F800             ; 62 void Monitor(...);
0044   F800             ; 63 void Monitor2();
0045   F800             ; 64 void ReadStringBackspace(...);
0046   F800             ; 65 void ReadString(...);
0047   F800             ; 66 void ReadStringBegin(...);
0048   F800             ; 67 void ReadStringLoop(...);
0049   F800             ; 68 void ReadStringExit(...);
0050   F800             ; 69 void PrintString(...);
0051   F800             ; 70 void ParseParams(...);
0052   F800             ; 71 void ParseWord(...);
0053   F800             ; 72 void ParseWordReturnCf(...);
0054   F800             ; 73 void CompareHlDe(...);
0055   F800             ; 74 void LoopWithBreak(...);
0056   F800             ; 75 void Loop(...);
0057   F800             ; 76 void PopRet();
0058   F800             ; 77 void IncHl(...);
0059   F800             ; 78 void CtrlC(...);
0060   F800             ; 79 void PrintCrLfTab();
0061   F800             ; 80 void PrintHexByteFromHlSpace(...);
0062   F800             ; 81 void PrintHexByteSpace(...);
0063   F800             ; 82 void CmdR(...);
0064   F800             ; 83 void GetRamTop(...);
0065   F800             ; 84 void SetRamTop(...);
0066   F800             ; 85 void CmdA(...);
0067   F800             ; 86 void CmdD(...);
0068   F800             ; 87 void PrintSpacesTo(...);
0069   F800             ; 88 void PrintSpace();
0070   F800             ; 89 void CmdC(...);
0071   F800             ; 90 void CmdF(...);
0072   F800             ; 91 void CmdS(...);
0073   F800             ; 92 void CmdW(...);
0074   F800             ; 93 void CmdT(...);
0075   F800             ; 94 void CmdM(...);
0076   F800             ; 95 void CmdG(...);
0077   F800             ; 96 void BreakPointHandler(...);
0078   F800             ; 97 void CmdX(...);
0079   F800             ; 98 void GetCursor();
0080   F800             ; 99 void GetCursorChar();
0081   F800             ; 100 void CmdH(...);
0082   F800             ; 101 void CmdI(...);
0083   F800             ; 102 void MonitorError();
0084   F800             ; 103 void ReadTapeFile(...);
0085   F800             ; 104 void ReadTapeWordNext();
0086   F800             ; 105 void ReadTapeWord(...);
0087   F800             ; 106 void ReadTapeBlock(...);
0088   F800             ; 107 void CalculateCheckSum(...);
0089   F800             ; 108 void CmdO(...);
0090   F800             ; 109 void WriteTapeFile(...);
0091   F800             ; 110 void PrintCrLfTabHexWordSpace(...);
0092   F800             ; 111 void PrintHexWordSpace(...);
0093   F800             ; 112 void WriteTapeBlock(...);
0094   F800             ; 113 void WriteTapeWord(...);
0095   F800             ; 114 void ReadTapeByte(...);
0096   F800             ; 115 void ReadTapeByteInternal(...);
0097   F800             ; 116 void ReadTapeByteTimeout(...);
0098   F800             ; 117 void WriteTapeByte(...);
0099   F800             ; 118 void PrintHexByte(...);
0100   F800             ; 119 void PrintHexNibble(...);
0101   F800             ; 120 void PrintCharA(...);
0102   F800             ; 121 void PrintChar(...);
0103   F800             ; 122 void PrintCharSetEscState(...);
0104   F800             ; 123 void PrintCharSaveCursor(...);
0105   F800             ; 124 void PrintCharExit(...);
0106   F800             ; 125 void DrawCursor(...);
0107   F800             ; 126 void PrintCharEscY2(...);
0108   F800             ; 127 void PrintCharResetEscState(...);
0109   F800             ; 128 void PrintCharEsc(...);
0110   F800             ; 129 void SetCursorVisible(...);
0111   F800             ; 130 void PrintCharNoEsc(...);
0112   F800             ; 131 void PrintChar4(...);
0113   F800             ; 132 void ClearScreen(...);
0114   F800             ; 133 void MoveCursorHome(...);
0115   F800             ; 134 void PrintChar3(...);
0116   F800             ; 135 void PrintCharBeep(...);
0117   F800             ; 136 void MoveCursorCr(...);
0118   F800             ; 137 void MoveCursorRight(...);
0119   F800             ; 138 void MoveCursorBoundary(...);
0120   F800             ; 139 void MoveCursorLeft(...);
0121   F800             ; 140 void MoveCursorLf(...);
0122   F800             ; 141 void MoveCursorUp(...);
0123   F800             ; 142 void MoveCursor(...);
0124   F800             ; 143 void MoveCursorDown(...);
0125   F800             ; 144 void PrintCrLf();
0126   F800             ; 145 void IsAnyKeyPressed();
0127   F800             ; 146 void ReadKey();
0128   F800             ; 147 void ReadKeyInternal(...);
0129   F800             ; 148 void ScanKey();
0130   F800             ; 149 void ScanKey2(...);
0131   F800             ; 150 void ScanKeyExit(...);
0132   F800             ; 151 void ScanKeyControl(...);
0133   F800             ; 152 void ScanKeyShift(...);
0134   F800             ; 153 void ScanKeySpecial(...);
0135   F800             ; 154 void TranslateCodePageDefault(...);
0136   F800             ; 155 void TryScrollUp(...);
0137   F800             ; 156 
0138   F800             ; 157 // Переменные Монитора
0139   F800             ; 158 
0140   F800             ; 159 extern uint16_t cursor __address(0xF75A);
0141   F800             ; 160 extern uint8_t tapeReadSpeed __address(0xF75C);
0142   F800             ; 161 extern uint8_t tapeWriteSpeed __address(0xF75D);
0143   F800             ; 162 extern uint8_t cursorVisible __address(0xF75E);
0144   F800             ; 163 extern uint8_t escState __address(0xF75F);
0145   F800             ; 164 extern uint16_t keyDelay __address(0xF760);
0146   F800             ; 165 extern uint16_t regPC __address(0xF762);
0147   F800             ; 166 extern uint16_t regHL __address(0xF764);
0148   F800             ; 167 extern uint16_t regBC __address(0xF766);
0149   F800             ; 168 extern uint16_t regDE __address(0xF768);
0150   F800             ; 169 extern uint16_t regSP __address(0xF76A);
0151   F800             ; 170 extern uint16_t regAF __address(0xF76C);
0152   F800             ; 171 extern uint16_t breakPointAddress __address(0xF771);
0153   F800             ; 172 extern uint8_t breakPointValue __address(0xF773);
0154   F800             ; 173 extern uint8_t jmpParam1Opcode __address(0xF774);
0155   F800             ; 174 extern uint16_t param1 __address(0xF775);
0156   F800             ; 175 extern uint16_t param2 __address(0xF777);
0157   F800             ; 176 extern uint16_t param3 __address(0xF779);
0158   F800             ; 177 extern uint8_t param2Exists __address(0xF77B);
0159   F800             ; 178 extern uint8_t tapePolarity __address(0xF77C);
0160   F800             ; 179 extern uint8_t translateCodeEnabled __address(0xF77D);
0161   F800             ; 180 extern uint8_t translateCodePageJump __address(0xF77E);
0162   F800             ; 181 extern uint16_t translateCodePageAddress __address(0xF77F);
0163   F800             ; 182 extern uint16_t ramTop __address(0xF781);
0164   F800             ; 183 extern uint8_t inputBuffer[32] __address(0xF783);
0165   F800             ; 184 
0166   F800             ; 185 #define firstVariableAddress (&tapeWriteSpeed)
0167   F800             ; 186 #define lastVariableAddress (&inputBuffer[sizeof(inputBuffer) - 1])
0168   F800             ; 187 
0169   F800             ; 188 extern uint8_t specialKeyTable[8];
0170   F800             ; 189 extern uint8_t aPrompt[6];
0171   F800             ; 190 extern uint8_t aCrLfTab[6];
0172   F800             ; 191 extern uint8_t aRegisters[37];
0173   F800             ; 192 extern uint8_t aBackspace[4];
0174   F800             ; 193 extern uint8_t aHello[9];
0175   F800             ; 194 
0176   F800             ; 195 // Для удобства
0177   F800             ; 196 
0178   F800             ; 197 void JmpParam1() __address(0xF774);
0179   F800             ; 198 void TranslateCodePage() __address(0xF77E);
0180   F800             ; 199 
0181   F800             ; 200 // Точки входа
0182   F800             ; 201 
0183   F800             ; 202 void EntryF800_Reboot() {
0184   F800             entryf800_reboot: 
0185   F800             ; 203     Reboot();
0186   F800 C3 36 F8    	jp reboot
0187   F803             ; 204 }
0188   F803             ; 205 
0189   F803             ; 206 void EntryF803_ReadKey() {
0190   F803             entryf803_readkey: 
0191   F803             ; 207     ReadKey();
0192   F803 C3 C8 FE    	jp readkey
0193   F806             ; 208 }
0194   F806             ; 209 
0195   F806             ; 210 void EntryF806_ReadTapeByte(...) {
0196   F806             entryf806_readtapebyte: 
0197   F806             ; 211     ReadTapeByte(a);
0198   F806 C3 74 FC    	jp readtapebyte
0199   F809             ; 212 }
0200   F809             ; 213 
0201   F809             ; 214 void EntryF809_PrintChar(...) {
0202   F809             entryf809_printchar: 
0203   F809             ; 215     PrintChar(c);
0204   F809 C3 23 FD    	jp printchar
0205   F80C             ; 216 }
0206   F80C             ; 217 
0207   F80C             ; 218 void EntryF80C_WriteTapeByte(...) {
0208   F80C             entryf80c_writetapebyte: 
0209   F80C             ; 219     WriteTapeByte(c);
0210   F80C C3 DD FC    	jp writetapebyte
0211   F80F             ; 220 }
0212   F80F             ; 221 
0213   F80F             ; 222 void EntryF80F_TranslateCodePage(...) {
0214   F80F             entryf80f_translatecodepage: 
0215   F80F             ; 223     TranslateCodePage(c);
0216   F80F C3 7E F7    	jp translatecodepage
0217   F812             ; 224 }
0218   F812             ; 225 
0219   F812             ; 226 void EntryF812_IsAnyKeyPressed() {
0220   F812             entryf812_isanykeypressed: 
0221   F812             ; 227     IsAnyKeyPressed();
0222   F812 C3 B7 FE    	jp isanykeypressed
0223   F815             ; 228 }
0224   F815             ; 229 
0225   F815             ; 230 void EntryF815_PrintHexByte(...) {
0226   F815             entryf815_printhexbyte: 
0227   F815             ; 231     PrintHexByte(a);
0228   F815 C3 0E FD    	jp printhexbyte
0229   F818             ; 232 }
0230   F818             ; 233 
0231   F818             ; 234 void EntryF818_PrintString(...) {
0232   F818             entryf818_printstring: 
0233   F818             ; 235     PrintString(hl);
0234   F818 C3 48 F9    	jp printstring
0235   F81B             ; 236 }
0236   F81B             ; 237 
0237   F81B             ; 238 void EntryF81B_ScanKey() {
0238   F81B             entryf81b_scankey: 
0239   F81B             ; 239     ScanKey();
0240   F81B C3 FE FE    	jp scankey
0241   F81E             ; 240 }
0242   F81E             ; 241 
0243   F81E             ; 242 void EntryF81E_GetCursor() {
0244   F81E             entryf81e_getcursor: 
0245   F81E             ; 243     GetCursor();
0246   F81E C3 49 FB    	jp getcursor
0247   F821             ; 244 }
0248   F821             ; 245 
0249   F821             ; 246 void EntryF821_GetCursorChar() {
0250   F821             entryf821_getcursorchar: 
0251   F821             ; 247     GetCursorChar();
0252   F821 C3 5E FB    	jp getcursorchar
0253   F824             ; 248 }
0254   F824             ; 249 
0255   F824             ; 250 void EntryF824_ReadTapeFile(...) {
0256   F824             entryf824_readtapefile: 
0257   F824             ; 251     ReadTapeFile(hl);
0258   F824 C3 BA FB    	jp readtapefile
0259   F827             ; 252 }
0260   F827             ; 253 
0261   F827             ; 254 void EntryF827_WriteTapeFile(...) {
0262   F827             entryf827_writetapefile: 
0263   F827             ; 255     WriteTapeFile(bc, de, hl);
0264   F827 C3 24 FC    	jp writetapefile
0265   F82A             ; 256 }
0266   F82A             ; 257 
0267   F82A             ; 258 void EntryF82A_CalculateCheckSum(...) {
0268   F82A             entryf82a_calculatechecksum: 
0269   F82A             ; 259     CalculateCheckSum(hl, de);
0270   F82A C3 F1 FB    	jp calculatechecksum
0271   F82D             ; 260 }
0272   F82D             ; 261 
0273   F82D             ; 262 void EntryF82D_EnableScreen() {
0274   F82D             entryf82d_enablescreen: 
0275   F82D             ; 263     return;
0276   F82D C9          	ret
0277   F82E             ; 264     return;
0278   F82E C9          	ret
0279   F82F             ; 265     return;
0280   F82F C9          	ret
0281   F830             ; 266 }
0282   F830             ; 267 
0283   F830             ; 268 void EntryF830_GetRamTop() {
0284   F830             entryf830_getramtop: 
0285   F830             ; 269     GetRamTop();
0286   F830 C3 FA F9    	jp getramtop
0287   F833             ; 270 }
0288   F833             ; 271 
0289   F833             ; 272 void EntryF833_SetRamTop(...) {
0290   F833             entryf833_setramtop: 
0291   F833             ; 273     SetRamTop(hl);
0292   F833 C3 FE F9    	jp setramtop
0293   F836             ; 274 }
0294   F836             ; 275 
0295   F836             ; 276 // Инициализация. Выполняется после перезагрузки или пользовательской программой.
0296   F836             ; 277 // Параметры: нет. Функция никогда не завершается.
0297   F836             ; 278 
0298   F836             ; 279 void Reboot(...) {
0299   F836             reboot: 
0300   F836             ; 280     sp = STACK_TOP;
0301   F836 31 00 F8    	ld sp, 63488
0302   F839             ; 281 
0303   F839             ; 282     // Очистка памяти
0304   F839             ; 283     hl = firstVariableAddress;
0305   F839 21 5D F7    	ld hl, 0FFFFh & (tapewritespeed)
0306   F83C             ; 284     de = lastVariableAddress;
0307   F83C 11 A2 F7    	ld de, 0FFFFh & ((inputbuffer) + (31))
0308   F83F             ; 285     bc = 0;
0309   F83F 01 00 00    	ld bc, 0
0310   F842             ; 286     CmdF();
0311   F842 CD 82 FA    	call cmdf
0312   F845             ; 287 
0313   F845             ; 288     translateCodePageJump = a = OPCODE_JMP;
0314   F845 3E C3       	ld a, 195
0315   F847 32 7E F7    	ld (translatecodepagejump), a
0316   F84A             ; 289 
0317   F84A             ; 290     PrintString(hl = aHello);
0318   F84A 21 D4 FF    	ld hl, 0FFFFh & (ahello)
0319   F84D CD 48 F9    	call printstring
0320   F850             ; 291 
0321   F850             ; 292     // Проверка ОЗУ
0322   F850             ; 293     hl = 0;
0323   F850 21 00 00    	ld hl, 0
0324   F853             ; 294     for (;;) {
0325   F853             l_1: 
0326   F853             ; 295         c = *hl;
0327   F853 4E          	ld c, (hl)
0328   F854             ; 296         a = 0x55;
0329   F854 3E 55       	ld a, 85
0330   F856             ; 297         *hl = a;
0331   F856 77          	ld (hl), a
0332   F857             ; 298         a ^= *hl;
0333   F857 AE          	xor (hl)
0334   F858             ; 299         b = a;
0335   F858 47          	ld b, a
0336   F859             ; 300         a = 0xAA;
0337   F859 3E AA       	ld a, 170
0338   F85B             ; 301         *hl = a;
0339   F85B 77          	ld (hl), a
0340   F85C             ; 302         a ^= *hl;
0341   F85C AE          	xor (hl)
0342   F85D             ; 303         a |= b;
0343   F85D B0          	or b
0344   F85E             ; 304         if (flag_nz)
0345   F85E             ; 305             return Reboot2();
0346   F85E C2 6F F8    	jp nz, reboot2
0347   F861             ; 306         *hl = c;
0348   F861 71          	ld (hl), c
0349   F862             ; 307         hl++;
0350   F862 23          	inc hl
0351   F863             ; 308         if ((a = h) == SCREEN_ATTRIB_BEGIN >> 8)
0352   F863 7C          	ld a, h
0353   F864 FE E0       	cp 65504
0354   F866             ; 309             return Reboot2();
0355   F866 CA 6F F8    	jp z, reboot2
0356   F869 C3 53 F8    	jp l_1
0357   F86C             ; 310     }
0358   F86C             ; 311 
0359   F86C             ; 312     Reboot2();
0360   F86C C3 6F F8    	jp reboot2
0361   F86F              .org 0xF86C
0362   F86C             ; 313 }
0363   F86C             ; 314 
0364   F86C             ; 315 asm(" .org 0xF86C");
0365   F86C             ; 316 
0366   F86C             ; 317 void EntryF86C_Monitor() {
0367   F86C             entryf86c_monitor: 
0368   F86C             ; 318     Monitor();
0369   F86C C3 88 F8    	jp monitor
0370   F86F             ; 319 }
0371   F86F             ; 320 
0372   F86F             ; 321 void Reboot2(...) {
0373   F86F             reboot2: 
0374   F86F             ; 322     hl--;
0375   F86F 2B          	dec hl
0376   F870             ; 323     ramTop = hl;
0377   F870 22 81 F7    	ld (ramtop), hl
0378   F873             ; 324     PrintHexWordSpace(hl);
0379   F873 CD 5A FC    	call printhexwordspace
0380   F876             ; 325     tapeReadSpeed = hl = TAPE_SPEED;
0381   F876 21 54 38    	ld hl, 14420
0382   F879 22 5C F7    	ld (tapereadspeed), hl
0383   F87C             ; 326     translateCodePageAddress = hl = &TranslateCodePageDefault;
0384   F87C 21 DD FF    	ld hl, 0FFFFh & (translatecodepagedefault)
0385   F87F 22 7F F7    	ld (translatecodepageaddress), hl
0386   F882             ; 327     regSP = hl = 0xF7FE;
0387   F882 21 FE F7    	ld hl, 63486
0388   F885 22 6A F7    	ld (regsp), hl
0389   F888             ; 328     Monitor();
0390   F888             ; 329 }
0391   F888             ; 330 
0392   F888             ; 331 void Monitor() {
0393   F888             monitor: 
0394   F888             ; 332     out(PORT_KEYBOARD_MODE, a = 0x83);
0395   F888 3E 83       	ld a, 131
0396   F88A D3 04       	out (4), a
0397   F88C             ; 333     cursorVisible = a;
0398   F88C 32 5E F7    	ld (cursorvisible), a
0399   F88F             ; 334     jmpParam1Opcode = a = OPCODE_JMP;
0400   F88F 3E C3       	ld a, 195
0401   F891 32 74 F7    	ld (jmpparam1opcode), a
0402   F894             ; 335     Monitor2();
0403   F894             ; 336 }
0404   F894             ; 337 
0405   F894             ; 338 void Monitor2() {
0406   F894             monitor2: 
0407   F894             ; 339     sp = STACK_TOP;
0408   F894 31 00 F8    	ld sp, 63488
0409   F897             ; 340     PrintString(hl = aPrompt);
0410   F897 21 9F FF    	ld hl, 0FFFFh & (aprompt)
0411   F89A CD 48 F9    	call printstring
0412   F89D             ; 341     ReadString();
0413   F89D CD 14 F9    	call readstring
0414   F8A0             ; 342 
0415   F8A0             ; 343     push(hl = &EntryF86C_Monitor);
0416   F8A0 21 6C F8    	ld hl, 0FFFFh & (entryf86c_monitor)
0417   F8A3 E5          	push hl
0418   F8A4             ; 344 
0419   F8A4             ; 345     hl = inputBuffer;
0420   F8A4 21 83 F7    	ld hl, 0FFFFh & (inputbuffer)
0421   F8A7             ; 346     a = *hl;
0422   F8A7 7E          	ld a, (hl)
0423   F8A8             ; 347 
0424   F8A8             ; 348     if (a == 'X')
0425   F8A8 FE 58       	cp 88
0426   F8AA             ; 349         return CmdX();
0427   F8AA CA 1C FB    	jp z, cmdx
0428   F8AD             ; 350 
0429   F8AD             ; 351     push_pop(a) {
0430   F8AD F5          	push af
0431   F8AE             ; 352         ParseParams();
0432   F8AE CD 52 F9    	call parseparams
0433   F8B1             ; 353         hl = param3;
0434   F8B1 2A 79 F7    	ld hl, (param3)
0435   F8B4             ; 354         c = l;
0436   F8B4 4D          	ld c, l
0437   F8B5             ; 355         b = h;
0438   F8B5 44          	ld b, h
0439   F8B6             ; 356         hl = param2;
0440   F8B6 2A 77 F7    	ld hl, (param2)
0441   F8B9             ; 357         swap(hl, de);
0442   F8B9 EB          	ex hl, de
0443   F8BA             ; 358         hl = param1;
0444   F8BA 2A 75 F7    	ld hl, (param1)
0445   F8BD F1          	pop af
0446   F8BE             ; 359     }
0447   F8BE             ; 360 
0448   F8BE             ; 361     if (a == 'D')
0449   F8BE FE 44       	cp 68
0450   F8C0             ; 362         return CmdD();
0451   F8C0 CA 06 FA    	jp z, cmdd
0452   F8C3             ; 363     if (a == 'C')
0453   F8C3 FE 43       	cp 67
0454   F8C5             ; 364         return CmdC();
0455   F8C5 CA 6C FA    	jp z, cmdc
0456   F8C8             ; 365     if (a == 'F')
0457   F8C8 FE 46       	cp 70
0458   F8CA             ; 366         return CmdF();
0459   F8CA CA 82 FA    	jp z, cmdf
0460   F8CD             ; 367     if (a == 'S')
0461   F8CD FE 53       	cp 83
0462   F8CF             ; 368         return CmdS();
0463   F8CF CA 89 FA    	jp z, cmds
0464   F8D2             ; 369     if (a == 'T')
0465   F8D2 FE 54       	cp 84
0466   F8D4             ; 370         return CmdT();
0467   F8D4 CA A6 FA    	jp z, cmdt
0468   F8D7             ; 371     if (a == 'M')
0469   F8D7 FE 4D       	cp 77
0470   F8D9             ; 372         return CmdM();
0471   F8D9 CA AF FA    	jp z, cmdm
0472   F8DC             ; 373     if (a == 'G')
0473   F8DC FE 47       	cp 71
0474   F8DE             ; 374         return CmdG();
0475   F8DE CA C8 FA    	jp z, cmdg
0476   F8E1             ; 375     if (a == 'I')
0477   F8E1 FE 49       	cp 73
0478   F8E3             ; 376         return CmdI();
0479   F8E3 CA 8A FB    	jp z, cmdi
0480   F8E6             ; 377     if (a == 'O')
0481   F8E6 FE 4F       	cp 79
0482   F8E8             ; 378         return CmdO();
0483   F8E8 CA 08 FC    	jp z, cmdo
0484   F8EB             ; 379     if (a == 'W')
0485   F8EB FE 57       	cp 87
0486   F8ED             ; 380         return CmdW();
0487   F8ED CA 94 FA    	jp z, cmdw
0488   F8F0             ; 381     if (a == 'A')
0489   F8F0 FE 41       	cp 65
0490   F8F2             ; 382         return CmdA();
0491   F8F2 CA 02 FA    	jp z, cmda
0492   F8F5             ; 383     if (a == 'H')
0493   F8F5 FE 48       	cp 72
0494   F8F7             ; 384         return CmdH();
0495   F8F7 CA 65 FB    	jp z, cmdh
0496   F8FA             ; 385     if (a == 'R')
0497   F8FA FE 52       	cp 82
0498   F8FC             ; 386         return CmdR();
0499   F8FC CA E6 F9    	jp z, cmdr
0500   F8FF             ; 387     return MonitorError();
0501   F8FF C3 B2 FB    	jp monitorerror
0502   F902             ; 388 }
0503   F902             ; 389 
0504   F902             ; 390 void ReadStringBackspace(...) {
0505   F902             readstringbackspace: 
0506   F902             ; 391     if ((a = inputBuffer) == l)
0507   F902 3E 83       	ld a, 0FFh & (inputbuffer)
0508   F904 BD          	cp l
0509   F905             ; 392         return ReadStringBegin(hl);
0510   F905 CA 17 F9    	jp z, readstringbegin
0511   F908             ; 393     push_pop(hl) {
0512   F908 E5          	push hl
0513   F909             ; 394         PrintString(hl = aBackspace);
0514   F909 21 D0 FF    	ld hl, 0FFFFh & (abackspace)
0515   F90C CD 48 F9    	call printstring
0516   F90F E1          	pop hl
0517   F910             ; 395     }
0518   F910             ; 396     hl--;
0519   F910 2B          	dec hl
0520   F911             ; 397     return ReadStringLoop(b, hl);
0521   F911 C3 19 F9    	jp readstringloop
0522   F914             ; 398 }
0523   F914             ; 399 
0524   F914             ; 400 void ReadString() {
0525   F914             readstring: 
0526   F914             ; 401     hl = inputBuffer;
0527   F914 21 83 F7    	ld hl, 0FFFFh & (inputbuffer)
0528   F917             ; 402     ReadStringBegin(hl);
0529   F917             ; 403 }
0530   F917             ; 404 
0531   F917             ; 405 void ReadStringBegin(...) {
0532   F917             readstringbegin: 
0533   F917             ; 406     b = 0;
0534   F917 06 00       	ld b, 0
0535   F919             ; 407     ReadStringLoop(b, hl);
0536   F919             ; 408 }
0537   F919             ; 409 
0538   F919             ; 410 void ReadStringLoop(...) {
0539   F919             readstringloop: 
0540   F919             ; 411     for (;;) {
0541   F919             l_4: 
0542   F919             ; 412         ReadKey();
0543   F919 CD C8 FE    	call readkey
0544   F91C             ; 413         if (a == 127)
0545   F91C FE 7F       	cp 127
0546   F91E             ; 414             return ReadStringBackspace();
0547   F91E CA 02 F9    	jp z, readstringbackspace
0548   F921             ; 415         if (a == 8)
0549   F921 FE 08       	cp 8
0550   F923             ; 416             return ReadStringBackspace();
0551   F923 CA 02 F9    	jp z, readstringbackspace
0552   F926             ; 417         if (flag_nz)
0553   F926             ; 418             PrintCharA(a);
0554   F926 C4 22 FD    	call nz, printchara
0555   F929             ; 419         *hl = a;
0556   F929 77          	ld (hl), a
0557   F92A             ; 420         if (a == 13)
0558   F92A FE 0D       	cp 13
0559   F92C             ; 421             return ReadStringExit(b);
0560   F92C CA 40 F9    	jp z, readstringexit
0561   F92F             ; 422         if (a == '.')
0562   F92F FE 2E       	cp 46
0563   F931             ; 423             return Monitor2();
0564   F931 CA 94 F8    	jp z, monitor2
0565   F934             ; 424         b = 255;
0566   F934 06 FF       	ld b, 255
0567   F936             ; 425         if ((a = inputBuffer + sizeof(inputBuffer) - 1) == l)
0568   F936 3E A2       	ld a, 0FFh & (((inputbuffer) + (32)) - (1))
0569   F938 BD          	cp l
0570   F939             ; 426             return MonitorError();
0571   F939 CA B2 FB    	jp z, monitorerror
0572   F93C             ; 427         hl++;
0573   F93C 23          	inc hl
0574   F93D C3 19 F9    	jp l_4
0575   F940             ; 428     }
0576   F940             ; 429 }
0577   F940             ; 430 
0578   F940             ; 431 void ReadStringExit(...) {
0579   F940             readstringexit: 
0580   F940             ; 432     a = b;
0581   F940 78          	ld a, b
0582   F941             ; 433     carry_rotate_left(a, 1);
0583   F941 17          	rla
0584   F942             ; 434     de = inputBuffer;
0585   F942 11 83 F7    	ld de, 0FFFFh & (inputbuffer)
0586   F945             ; 435     b = 0;
0587   F945 06 00       	ld b, 0
0588   F947 C9          	ret
0589   F948             ; 436 }
0590   F948             ; 437 
0591   F948             ; 438 // Функция для пользовательской программы.
0592   F948             ; 439 // Вывод строки на экран.
0593   F948             ; 440 // Параметры: hl - адрес стороки. Результат: hl - следующий адрес за терминатором строки. Сохраняются: b, de.
0594   F948             ; 441 
0595   F948             ; 442 void PrintString(...) {
0596   F948             printstring: 
0597   F948             ; 443     for (;;) {
0598   F948             l_7: 
0599   F948             ; 444         a = *hl;
0600   F948 7E          	ld a, (hl)
0601   F949             ; 445         if (flag_z(a &= a))
0602   F949 A7          	and a
0603   F94A             ; 446             return;
0604   F94A C8          	ret z
0605   F94B             ; 447         PrintCharA(a);
0606   F94B CD 22 FD    	call printchara
0607   F94E             ; 448         hl++;
0608   F94E 23          	inc hl
0609   F94F C3 48 F9    	jp l_7
0610   F952             ; 449     }
0611   F952             ; 450 }
0612   F952             ; 451 
0613   F952             ; 452 void ParseParams(...) {
0614   F952             parseparams: 
0615   F952             ; 453     hl = &param1;
0616   F952 21 75 F7    	ld hl, 0FFFFh & (param1)
0617   F955             ; 454     de = &param2Exists;
0618   F955 11 7B F7    	ld de, 0FFFFh & (param2exists)
0619   F958             ; 455     c = 0;
0620   F958 0E 00       	ld c, 0
0621   F95A             ; 456     CmdF();
0622   F95A CD 82 FA    	call cmdf
0623   F95D             ; 457 
0624   F95D             ; 458     de = inputBuffer + 1;
0625   F95D 11 84 F7    	ld de, 0FFFFh & ((inputbuffer) + (1))
0626   F960             ; 459 
0627   F960             ; 460     ParseWord();
0628   F960 CD 80 F9    	call parseword
0629   F963             ; 461     param1 = hl;
0630   F963 22 75 F7    	ld (param1), hl
0631   F966             ; 462     param2 = hl;
0632   F966 22 77 F7    	ld (param2), hl
0633   F969             ; 463     if (flag_c)
0634   F969             ; 464         return;
0635   F969 D8          	ret c
0636   F96A             ; 465 
0637   F96A             ; 466     param2Exists = a = 0xFF;
0638   F96A 3E FF       	ld a, 255
0639   F96C 32 7B F7    	ld (param2exists), a
0640   F96F             ; 467     ParseWord();
0641   F96F CD 80 F9    	call parseword
0642   F972             ; 468     param2 = hl;
0643   F972 22 77 F7    	ld (param2), hl
0644   F975             ; 469     if (flag_c)
0645   F975             ; 470         return;
0646   F975 D8          	ret c
0647   F976             ; 471 
0648   F976             ; 472     ParseWord();
0649   F976 CD 80 F9    	call parseword
0650   F979             ; 473     param3 = hl;
0651   F979 22 79 F7    	ld (param3), hl
0652   F97C             ; 474     if (flag_c)
0653   F97C             ; 475         return;
0654   F97C D8          	ret c
0655   F97D             ; 476 
0656   F97D             ; 477     MonitorError();
0657   F97D C3 B2 FB    	jp monitorerror
0658   F980             ; 478 }
0659   F980             ; 479 
0660   F980             ; 480 void ParseWord(...) {
0661   F980             parseword: 
0662   F980             ; 481     hl = 0;
0663   F980 21 00 00    	ld hl, 0
0664   F983             ; 482     for (;;) {
0665   F983             l_10: 
0666   F983             ; 483         a = *de;
0667   F983 1A          	ld a, (de)
0668   F984             ; 484         de++;
0669   F984 13          	inc de
0670   F985             ; 485         if (a == 13)
0671   F985 FE 0D       	cp 13
0672   F987             ; 486             return ParseWordReturnCf(hl);
0673   F987 CA B4 F9    	jp z, parsewordreturncf
0674   F98A             ; 487         if (a == ',')
0675   F98A FE 2C       	cp 44
0676   F98C             ; 488             return;
0677   F98C C8          	ret z
0678   F98D             ; 489         if (a == ' ')
0679   F98D FE 20       	cp 32
0680   F98F             ; 490             continue;
0681   F98F CA 83 F9    	jp z, l_10
0682   F992             ; 491         a -= '0';
0683   F992 D6 30       	sub 48
0684   F994             ; 492         if (flag_m)
0685   F994             ; 493             return MonitorError();
0686   F994 FA B2 FB    	jp m, monitorerror
0687   F997             ; 494         if (flag_p(compare(a, 10))) {
0688   F997 FE 0A       	cp 10
0689   F999 FA A8 F9    	jp m, l_12
0690   F99C             ; 495             if (flag_m(compare(a, 17)))
0691   F99C FE 11       	cp 17
0692   F99E             ; 496                 return MonitorError();
0693   F99E FA B2 FB    	jp m, monitorerror
0694   F9A1             ; 497             if (flag_p(compare(a, 23)))
0695   F9A1 FE 17       	cp 23
0696   F9A3             ; 498                 return MonitorError();
0697   F9A3 F2 B2 FB    	jp p, monitorerror
0698   F9A6             ; 499             a -= 7;
0699   F9A6 D6 07       	sub 7
0700   F9A8             l_12: 
0701   F9A8             ; 500         }
0702   F9A8             ; 501         c = a;
0703   F9A8 4F          	ld c, a
0704   F9A9             ; 502         hl += hl;
0705   F9A9 29          	add hl, hl
0706   F9AA             ; 503         hl += hl;
0707   F9AA 29          	add hl, hl
0708   F9AB             ; 504         hl += hl;
0709   F9AB 29          	add hl, hl
0710   F9AC             ; 505         hl += hl;
0711   F9AC 29          	add hl, hl
0712   F9AD             ; 506         if (flag_c)
0713   F9AD             ; 507             return MonitorError();
0714   F9AD DA B2 FB    	jp c, monitorerror
0715   F9B0             ; 508         hl += bc;
0716   F9B0 09          	add hl, bc
0717   F9B1 C3 83 F9    	jp l_10
0718   F9B4             ; 509     }
0719   F9B4             ; 510 }
0720   F9B4             ; 511 
0721   F9B4             ; 512 void ParseWordReturnCf(...) {
0722   F9B4             parsewordreturncf: 
0723   F9B4             ; 513     set_flag_c();
0724   F9B4 37          	scf
0725   F9B5 C9          	ret
0726   F9B6             ; 514 }
0727   F9B6             ; 515 
0728   F9B6             ; 516 void CompareHlDe(...) {
0729   F9B6             comparehlde: 
0730   F9B6             ; 517     if ((a = h) != d)
0731   F9B6 7C          	ld a, h
0732   F9B7 BA          	cp d
0733   F9B8             ; 518         return;
0734   F9B8 C0          	ret nz
0735   F9B9             ; 519     compare(a = l, e);
0736   F9B9 7D          	ld a, l
0737   F9BA BB          	cp e
0738   F9BB C9          	ret
0739   F9BC             ; 520 }
0740   F9BC             ; 521 
0741   F9BC             ; 522 void LoopWithBreak(...) {
0742   F9BC             loopwithbreak: 
0743   F9BC             ; 523     CtrlC();
0744   F9BC CD CA F9    	call ctrlc
0745   F9BF             ; 524     Loop(hl, de);
0746   F9BF             ; 525 }
0747   F9BF             ; 526 
0748   F9BF             ; 527 void Loop(...) {
0749   F9BF             loop: 
0750   F9BF             ; 528     CompareHlDe(hl, de);
0751   F9BF CD B6 F9    	call comparehlde
0752   F9C2             ; 529     if (flag_nz)
0753   F9C2             ; 530         return IncHl(hl);
0754   F9C2 C2 C8 F9    	jp nz, inchl
0755   F9C5             ; 531     PopRet();
0756   F9C5             ; 532 }
0757   F9C5             ; 533 
0758   F9C5             ; 534 void PopRet() {
0759   F9C5             popret: 
0760   F9C5             ; 535     sp++;
0761   F9C5 33          	inc sp
0762   F9C6             ; 536     sp++;
0763   F9C6 33          	inc sp
0764   F9C7 C9          	ret
0765   F9C8             ; 537 }
0766   F9C8             ; 538 
0767   F9C8             ; 539 void IncHl(...) {
0768   F9C8             inchl: 
0769   F9C8             ; 540     hl++;
0770   F9C8 23          	inc hl
0771   F9C9 C9          	ret
0772   F9CA             ; 541 }
0773   F9CA             ; 542 
0774   F9CA             ; 543 void CtrlC() {
0775   F9CA             ctrlc: 
0776   F9CA             ; 544     ScanKey();
0777   F9CA CD FE FE    	call scankey
0778   F9CD             ; 545     if (a != 3)  // УПР + C
0779   F9CD FE 03       	cp 3
0780   F9CF             ; 546         return;
0781   F9CF C0          	ret nz
0782   F9D0             ; 547     MonitorError();
0783   F9D0 C3 B2 FB    	jp monitorerror
0784   F9D3             ; 548 }
0785   F9D3             ; 549 
0786   F9D3             ; 550 void PrintCrLfTab() {
0787   F9D3             printcrlftab: 
0788   F9D3             ; 551     push_pop(hl) {
0789   F9D3 E5          	push hl
0790   F9D4             ; 552         PrintString(hl = aCrLfTab);
0791   F9D4 21 A5 FF    	ld hl, 0FFFFh & (acrlftab)
0792   F9D7 CD 48 F9    	call printstring
0793   F9DA E1          	pop hl
0794   F9DB C9          	ret
0795   F9DC             ; 553     }
0796   F9DC             ; 554 }
0797   F9DC             ; 555 
0798   F9DC             ; 556 void PrintHexByteFromHlSpace(...) {
0799   F9DC             printhexbytefromhlspace: 
0800   F9DC             ; 557     PrintHexByteSpace(a = *hl);
0801   F9DC 7E          	ld a, (hl)
0802   F9DD             ; 558 }
0803   F9DD             ; 559 
0804   F9DD             ; 560 void PrintHexByteSpace(...) {
0805   F9DD             printhexbytespace: 
0806   F9DD             ; 561     push_pop(bc) {
0807   F9DD C5          	push bc
0808   F9DE             ; 562         PrintHexByte(a);
0809   F9DE CD 0E FD    	call printhexbyte
0810   F9E1             ; 563         PrintSpace();
0811   F9E1 CD 67 FA    	call printspace
0812   F9E4 C1          	pop bc
0813   F9E5 C9          	ret
0814   F9E6             ; 564     }
0815   F9E6             ; 565 }
0816   F9E6             ; 566 
0817   F9E6             ; 567 // Команда R <начальный адрес ПЗУ> <конечный адрес ПЗУ> <начальный адрес назаначения>
0818   F9E6             ; 568 // Скопировать блок из внешнего ПЗУ в адресное пространство процессора
0819   F9E6             ; 569 
0820   F9E6             ; 570 void CmdR(...) {
0821   F9E6             cmdr: 
0822   F9E6             ; 571     out(PORT_EXT_MODE, a = 0x90);
0823   F9E6 3E 90       	ld a, 144
0824   F9E8 D3 A3       	out (163), a
0825   F9EA             ; 572     for (;;) {
0826   F9EA             l_15: 
0827   F9EA             ; 573         out(PORT_EXT_ADDR_LOW, a = l);
0828   F9EA 7D          	ld a, l
0829   F9EB D3 A1       	out (161), a
0830   F9ED             ; 574         out(PORT_EXT_ADDR_HIGH, a = h);
0831   F9ED 7C          	ld a, h
0832   F9EE D3 A2       	out (162), a
0833   F9F0             ; 575         *bc = a = in(PORT_EXT_DATA);
0834   F9F0 DB A0       	in a, (160)
0835   F9F2 02          	ld (bc), a
0836   F9F3             ; 576         bc++;
0837   F9F3 03          	inc bc
0838   F9F4             ; 577         Loop();
0839   F9F4 CD BF F9    	call loop
0840   F9F7 C3 EA F9    	jp l_15
0841   F9FA             ; 578     }
0842   F9FA             ; 579 }
0843   F9FA             ; 580 
0844   F9FA             ; 581 // Функция для пользовательской программы.
0845   F9FA             ; 582 // Получить адрес последнего доступного байта оперативной памяти.
0846   F9FA             ; 583 // Параметры: нет. Результат: hl - адрес. Сохраняет: a, bc, de.
0847   F9FA             ; 584 
0848   F9FA             ; 585 void GetRamTop(...) {
0849   F9FA             getramtop: 
0850   F9FA             ; 586     hl = ramTop;
0851   F9FA 2A 81 F7    	ld hl, (ramtop)
0852   F9FD C9          	ret
0853   F9FE             ; 587 }
0854   F9FE             ; 588 
0855   F9FE             ; 589 // Функция для пользовательской программы.
0856   F9FE             ; 590 // Установить адрес последнего доступного байта оперативной памяти.
0857   F9FE             ; 591 // Параметры: hl - адрес. Результат: нет. Сохраняет: a, bc, de, hl.
0858   F9FE             ; 592 
0859   F9FE             ; 593 void SetRamTop(...) {
0860   F9FE             setramtop: 
0861   F9FE             ; 594     ramTop = hl;
0862   F9FE 22 81 F7    	ld (ramtop), hl
0863   FA01 C9          	ret
0864   FA02             ; 595 }
0865   FA02             ; 596 
0866   FA02             ; 597 // Команда A <адрес>
0867   FA02             ; 598 // Установить программу преобразования кодировки символов выводимых на экран
0868   FA02             ; 599 
0869   FA02             ; 600 void CmdA(...) {
0870   FA02             cmda: 
0871   FA02             ; 601     translateCodePageAddress = hl;
0872   FA02 22 7F F7    	ld (translatecodepageaddress), hl
0873   FA05 C9          	ret
0874   FA06             ; 602 }
0875   FA06             ; 603 
0876   FA06             ; 604 // Команда D <начальный адрес> <конечный адрес>
0877   FA06             ; 605 // Вывод блока данных из адресного пространства на экран в 16-ричном виде
0878   FA06             ; 606 
0879   FA06             ; 607 void CmdD(...) {
0880   FA06             cmdd: 
0881   FA06             ; 608     for (;;) {
0882   FA06             l_18: 
0883   FA06             ; 609         PrintCrLf();
0884   FA06 CD AD FE    	call printcrlf
0885   FA09             ; 610         PrintHexWordSpace(hl);
0886   FA09 CD 5A FC    	call printhexwordspace
0887   FA0C             ; 611         push_pop(hl) {
0888   FA0C E5          	push hl
0889   FA0D             ; 612             c = ((a = l) &= 0x0F);
0890   FA0D 7D          	ld a, l
0891   FA0E E6 0F       	and 15
0892   FA10 4F          	ld c, a
0893   FA11             ; 613             carry_rotate_right(a, 1);
0894   FA11 1F          	rra
0895   FA12             ; 614             b = (((a += c) += c) += 5);
0896   FA12 81          	add c
0897   FA13 81          	add c
0898   FA14 C6 05       	add 5
0899   FA16 47          	ld b, a
0900   FA17             ; 615             PrintSpacesTo();
0901   FA17 CD 5A FA    	call printspacesto
0902   FA1A             ; 616             do {
0903   FA1A             l_20: 
0904   FA1A             ; 617                 PrintHexByte(a = *hl);
0905   FA1A 7E          	ld a, (hl)
0906   FA1B CD 0E FD    	call printhexbyte
0907   FA1E             ; 618                 CompareHlDe(hl, de);
0908   FA1E CD B6 F9    	call comparehlde
0909   FA21             ; 619                 hl++;
0910   FA21 23          	inc hl
0911   FA22             ; 620                 if (flag_z)
0912   FA22             ; 621                     break;
0913   FA22 CA 32 FA    	jp z, l_22
0914   FA25             ; 622                 (a = l) &= 0x0F;
0915   FA25 7D          	ld a, l
0916   FA26 E6 0F       	and 15
0917   FA28             ; 623                 push_pop(a) {
0918   FA28 F5          	push af
0919   FA29             ; 624                     a &= 1;
0920   FA29 E6 01       	and 1
0921   FA2B             ; 625                     if (flag_z)
0922   FA2B             ; 626                         PrintSpace();
0923   FA2B CC 67 FA    	call z, printspace
0924   FA2E F1          	pop af
0925   FA2F             l_21: 
0926   FA2F C2 1A FA    	jp nz, l_20
0927   FA32             l_22: 
0928   FA32 E1          	pop hl
0929   FA33             ; 627                 }
0930   FA33             ; 628             } while (flag_nz);
0931   FA33             ; 629         }
0932   FA33             ; 630 
0933   FA33             ; 631         b = (((a = l) &= 0x0F) += 46);
0934   FA33 7D          	ld a, l
0935   FA34 E6 0F       	and 15
0936   FA36 C6 2E       	add 46
0937   FA38 47          	ld b, a
0938   FA39             ; 632         PrintSpacesTo(b);
0939   FA39 CD 5A FA    	call printspacesto
0940   FA3C             ; 633 
0941   FA3C             ; 634         do {
0942   FA3C             l_23: 
0943   FA3C             ; 635             a = *hl;
0944   FA3C 7E          	ld a, (hl)
0945   FA3D             ; 636             if (a < 127)
0946   FA3D FE 7F       	cp 127
0947   FA3F             ; 637                 if (a >= 32)
0948   FA3F D2 47 FA    	jp nc, l_26
0949   FA42 FE 20       	cp 32
0950   FA44             ; 638                     goto loc_fa49;
0951   FA44 D2 49 FA    	jp nc, loc_fa49
0952   FA47             l_26: 
0953   FA47             ; 639             a = '.';
0954   FA47 3E 2E       	ld a, 46
0955   FA49             ; 640         loc_fa49:
0956   FA49             loc_fa49: 
0957   FA49             ; 641             PrintCharA(a);
0958   FA49 CD 22 FD    	call printchara
0959   FA4C             ; 642             CompareHlDe(hl, de);
0960   FA4C CD B6 F9    	call comparehlde
0961   FA4F             ; 643             if (flag_z)
0962   FA4F             ; 644                 return;
0963   FA4F C8          	ret z
0964   FA50             ; 645             hl++;
0965   FA50 23          	inc hl
0966   FA51             ; 646             (a = l) &= 0x0F;
0967   FA51 7D          	ld a, l
0968   FA52 E6 0F       	and 15
0969   FA54             l_24: 
0970   FA54 C2 3C FA    	jp nz, l_23
0971   FA57 C3 06 FA    	jp l_18
0972   FA5A             ; 647         } while (flag_nz);
0973   FA5A             ; 648     }
0974   FA5A             ; 649 }
0975   FA5A             ; 650 
0976   FA5A             ; 651 void PrintSpacesTo(...) {
0977   FA5A             printspacesto: 
0978   FA5A             ; 652     for (;;) {
0979   FA5A             l_29: 
0980   FA5A             ; 653         if (((a = cursor) &= (SCREEN_WIDTH - 1)) >= b)
0981   FA5A 3A 5A F7    	ld a, (cursor)
0982   FA5D E6 3F       	and 63
0983   FA5F B8          	cp b
0984   FA60             ; 654             return;
0985   FA60 D0          	ret nc
0986   FA61             ; 655         PrintSpace();
0987   FA61 CD 67 FA    	call printspace
0988   FA64 C3 5A FA    	jp l_29
0989   FA67             ; 656     }
0990   FA67             ; 657 }
0991   FA67             ; 658 
0992   FA67             ; 659 void PrintSpace() {
0993   FA67             printspace: 
0994   FA67             ; 660     PrintCharA(a = ' ');
0995   FA67 3E 20       	ld a, 32
0996   FA69 C3 22 FD    	jp printchara
0997   FA6C             ; 661 }
0998   FA6C             ; 662 
0999   FA6C             ; 663 // Команда С <начальный адрес 1> <конечный адрес 1> <начальный адрес 2>
1000   FA6C             ; 664 // Сравнить два блока адресного пространство
1001   FA6C             ; 665 
1002   FA6C             ; 666 void CmdC(...) {
1003   FA6C             cmdc: 
1004   FA6C             ; 667     for (;;) {
1005   FA6C             l_32: 
1006   FA6C             ; 668         if ((a = *bc) != *hl) {
1007   FA6C 0A          	ld a, (bc)
1008   FA6D BE          	cp (hl)
1009   FA6E CA 7B FA    	jp z, l_34
1010   FA71             ; 669             PrintCrLfTabHexWordSpace(hl);
1011   FA71 CD 51 FC    	call printcrlftabhexwordspace
1012   FA74             ; 670             PrintHexByteFromHlSpace(hl);
1013   FA74 CD DC F9    	call printhexbytefromhlspace
1014   FA77             ; 671             PrintHexByteSpace(a = *bc);
1015   FA77 0A          	ld a, (bc)
1016   FA78 CD DD F9    	call printhexbytespace
1017   FA7B             l_34: 
1018   FA7B             ; 672         }
1019   FA7B             ; 673         bc++;
1020   FA7B 03          	inc bc
1021   FA7C             ; 674         LoopWithBreak();
1022   FA7C CD BC F9    	call loopwithbreak
1023   FA7F C3 6C FA    	jp l_32
1024   FA82             ; 675     }
1025   FA82             ; 676 }
1026   FA82             ; 677 
1027   FA82             ; 678 // Команда F <начальный адрес> <конечный адрес> <байт>
1028   FA82             ; 679 // Заполнить блок в адресном пространстве одним байтом
1029   FA82             ; 680 
1030   FA82             ; 681 void CmdF(...) {
1031   FA82             cmdf: 
1032   FA82             ; 682     for (;;) {
1033   FA82             l_37: 
1034   FA82             ; 683         *hl = c;
1035   FA82 71          	ld (hl), c
1036   FA83             ; 684         Loop();
1037   FA83 CD BF F9    	call loop
1038   FA86 C3 82 FA    	jp l_37
1039   FA89             ; 685     }
1040   FA89             ; 686 }
1041   FA89             ; 687 
1042   FA89             ; 688 // Команда S <начальный адрес> <конечный адрес> <байт>
1043   FA89             ; 689 // Найти байт (8 битное значение) в адресном пространстве
1044   FA89             ; 690 
1045   FA89             ; 691 void CmdS(...) {
1046   FA89             cmds: 
1047   FA89             ; 692     for (;;) {
1048   FA89             l_40: 
1049   FA89             ; 693         if ((a = c) == *hl)
1050   FA89 79          	ld a, c
1051   FA8A BE          	cp (hl)
1052   FA8B             ; 694             PrintCrLfTabHexWordSpace(hl);
1053   FA8B CC 51 FC    	call z, printcrlftabhexwordspace
1054   FA8E             ; 695         LoopWithBreak();
1055   FA8E CD BC F9    	call loopwithbreak
1056   FA91 C3 89 FA    	jp l_40
1057   FA94             ; 696     }
1058   FA94             ; 697 }
1059   FA94             ; 698 
1060   FA94             ; 699 // Команда W <начальный адрес> <конечный адрес> <слово>
1061   FA94             ; 700 // Найти слово (16 битное значение) в адресном пространстве
1062   FA94             ; 701 
1063   FA94             ; 702 void CmdW(...) {
1064   FA94             cmdw: 
1065   FA94             ; 703     for (;;) {
1066   FA94             l_43: 
1067   FA94             ; 704         if ((a = *hl) == c) {
1068   FA94 7E          	ld a, (hl)
1069   FA95 B9          	cp c
1070   FA96 C2 A0 FA    	jp nz, l_45
1071   FA99             ; 705             hl++;
1072   FA99 23          	inc hl
1073   FA9A             ; 706             compare((a = *hl), b);
1074   FA9A 7E          	ld a, (hl)
1075   FA9B B8          	cp b
1076   FA9C             ; 707             hl--;
1077   FA9C 2B          	dec hl
1078   FA9D             ; 708             if (flag_z)
1079   FA9D             ; 709                 PrintCrLfTabHexWordSpace(hl);
1080   FA9D CC 51 FC    	call z, printcrlftabhexwordspace
1081   FAA0             l_45: 
1082   FAA0             ; 710         }
1083   FAA0             ; 711         LoopWithBreak();
1084   FAA0 CD BC F9    	call loopwithbreak
1085   FAA3 C3 94 FA    	jp l_43
1086   FAA6             ; 712     }
1087   FAA6             ; 713 }
1088   FAA6             ; 714 
1089   FAA6             ; 715 // Команда T <начальный адрес источника> <конечный адрес источника> <начальный адрес назначения>
1090   FAA6             ; 716 // Копировать блок в адресном пространстве
1091   FAA6             ; 717 
1092   FAA6             ; 718 void CmdT(...) {
1093   FAA6             cmdt: 
1094   FAA6             ; 719     for (;;) {
1095   FAA6             l_48: 
1096   FAA6             ; 720         *bc = a = *hl;
1097   FAA6 7E          	ld a, (hl)
1098   FAA7 02          	ld (bc), a
1099   FAA8             ; 721         bc++;
1100   FAA8 03          	inc bc
1101   FAA9             ; 722         Loop();
1102   FAA9 CD BF F9    	call loop
1103   FAAC C3 A6 FA    	jp l_48
1104   FAAF             ; 723     }
1105   FAAF             ; 724 }
1106   FAAF             ; 725 
1107   FAAF             ; 726 // Команда M <начальный адрес>
1108   FAAF             ; 727 // Вывести на экран адресное пространство побайтно с возможностью изменения
1109   FAAF             ; 728 
1110   FAAF             ; 729 void CmdM(...) {
1111   FAAF             cmdm: 
1112   FAAF             ; 730     for (;;) {
1113   FAAF             l_51: 
1114   FAAF             ; 731         PrintCrLfTabHexWordSpace(hl);
1115   FAAF CD 51 FC    	call printcrlftabhexwordspace
1116   FAB2             ; 732         PrintHexByteFromHlSpace();
1117   FAB2 CD DC F9    	call printhexbytefromhlspace
1118   FAB5             ; 733         push_pop(hl) {
1119   FAB5 E5          	push hl
1120   FAB6             ; 734             ReadString();
1121   FAB6 CD 14 F9    	call readstring
1122   FAB9 E1          	pop hl
1123   FABA             ; 735         }
1124   FABA             ; 736         if (flag_c) {
1125   FABA D2 C4 FA    	jp nc, l_53
1126   FABD             ; 737             push_pop(hl) {
1127   FABD E5          	push hl
1128   FABE             ; 738                 ParseWord();
1129   FABE CD 80 F9    	call parseword
1130   FAC1             ; 739                 a = l;
1131   FAC1 7D          	ld a, l
1132   FAC2 E1          	pop hl
1133   FAC3             ; 740             }
1134   FAC3             ; 741             *hl = a;
1135   FAC3 77          	ld (hl), a
1136   FAC4             l_53: 
1137   FAC4             ; 742         }
1138   FAC4             ; 743         hl++;
1139   FAC4 23          	inc hl
1140   FAC5 C3 AF FA    	jp l_51
1141   FAC8             ; 744     }
1142   FAC8             ; 745 }
1143   FAC8             ; 746 
1144   FAC8             ; 747 // Команда G <начальный адрес> <конечный адрес>
1145   FAC8             ; 748 // Запуск программы и возможным указанием точки останова.
1146   FAC8             ; 749 
1147   FAC8             ; 750 void CmdG(...) {
1148   FAC8             cmdg: 
1149   FAC8             ; 751     CompareHlDe(hl, de);
1150   FAC8 CD B6 F9    	call comparehlde
1151   FACB             ; 752     if (flag_nz) {
1152   FACB CA E3 FA    	jp z, l_55
1153   FACE             ; 753         swap(hl, de);
1154   FACE EB          	ex hl, de
1155   FACF             ; 754         breakPointAddress = hl;
1156   FACF 22 71 F7    	ld (breakpointaddress), hl
1157   FAD2             ; 755         breakPointValue = a = *hl;
1158   FAD2 7E          	ld a, (hl)
1159   FAD3 32 73 F7    	ld (breakpointvalue), a
1160   FAD6             ; 756         *hl = OPCODE_RST_30;
1161   FAD6 36 F7       	ld (hl), 247
1162   FAD8             ; 757         rst30Opcode = a = OPCODE_JMP;
1163   FAD8 3E C3       	ld a, 195
1164   FADA 32 30 00    	ld (rst30opcode), a
1165   FADD             ; 758         rst30Address = hl = &BreakPointHandler;
1166   FADD 21 F1 FA    	ld hl, 0FFFFh & (breakpointhandler)
1167   FAE0 22 31 00    	ld (rst30address), hl
1168   FAE3             l_55: 
1169   FAE3             ; 759     }
1170   FAE3             ; 760     sp = &regBC;
1171   FAE3 31 66 F7    	ld sp, 0FFFFh & (regbc)
1172   FAE6             ; 761     pop(bc);
1173   FAE6 C1          	pop bc
1174   FAE7             ; 762     pop(de);
1175   FAE7 D1          	pop de
1176   FAE8             ; 763     pop(hl);
1177   FAE8 E1          	pop hl
1178   FAE9             ; 764     pop(a);
1179   FAE9 F1          	pop af
1180   FAEA             ; 765     sp = hl;
1181   FAEA F9          	ld sp, hl
1182   FAEB             ; 766     hl = regHL;
1183   FAEB 2A 64 F7    	ld hl, (reghl)
1184   FAEE             ; 767     JmpParam1();
1185   FAEE C3 74 F7    	jp jmpparam1
1186   FAF1             ; 768 }
1187   FAF1             ; 769 
1188   FAF1             ; 770 void BreakPointHandler(...) {
1189   FAF1             breakpointhandler: 
1190   FAF1             ; 771     regHL = hl;
1191   FAF1 22 64 F7    	ld (reghl), hl
1192   FAF4             ; 772     push(a);
1193   FAF4 F5          	push af
1194   FAF5             ; 773     pop(hl);
1195   FAF5 E1          	pop hl
1196   FAF6             ; 774     regAF = hl;
1197   FAF6 22 6C F7    	ld (regaf), hl
1198   FAF9             ; 775     pop(hl);
1199   FAF9 E1          	pop hl
1200   FAFA             ; 776     hl--;
1201   FAFA 2B          	dec hl
1202   FAFB             ; 777     regPC = hl;
1203   FAFB 22 62 F7    	ld (regpc), hl
1204   FAFE             ; 778     (hl = 0) += sp;
1205   FAFE 21 00 00    	ld hl, 0
1206   FB01 39          	add hl, sp
1207   FB02             ; 779     sp = &regAF;
1208   FB02 31 6C F7    	ld sp, 0FFFFh & (regaf)
1209   FB05             ; 780     push(hl);
1210   FB05 E5          	push hl
1211   FB06             ; 781     push(de);
1212   FB06 D5          	push de
1213   FB07             ; 782     push(bc);
1214   FB07 C5          	push bc
1215   FB08             ; 783     sp = STACK_TOP;
1216   FB08 31 00 F8    	ld sp, 63488
1217   FB0B             ; 784     hl = regPC;
1218   FB0B 2A 62 F7    	ld hl, (regpc)
1219   FB0E             ; 785     swap(hl, de);
1220   FB0E EB          	ex hl, de
1221   FB0F             ; 786     hl = breakPointAddress;
1222   FB0F 2A 71 F7    	ld hl, (breakpointaddress)
1223   FB12             ; 787     CompareHlDe(hl, de);
1224   FB12 CD B6 F9    	call comparehlde
1225   FB15             ; 788     if (flag_nz)
1226   FB15             ; 789         return CmdX();
1227   FB15 C2 1C FB    	jp nz, cmdx
1228   FB18             ; 790     *hl = a = breakPointValue;
1229   FB18 3A 73 F7    	ld a, (breakpointvalue)
1230   FB1B 77          	ld (hl), a
1231   FB1C             ; 791     CmdX();
1232   FB1C             ; 792 }
1233   FB1C             ; 793 
1234   FB1C             ; 794 // Команда X
1235   FB1C             ; 795 // Вывод на экран содержимого регистров микропроцессора с возможностью их изменения.
1236   FB1C             ; 796 
1237   FB1C             ; 797 void CmdX(...) {
1238   FB1C             cmdx: 
1239   FB1C             ; 798     PrintString(hl = aRegisters);
1240   FB1C 21 AB FF    	ld hl, 0FFFFh & (aregisters)
1241   FB1F CD 48 F9    	call printstring
1242   FB22             ; 799     hl = &regPC;
1243   FB22 21 62 F7    	ld hl, 0FFFFh & (regpc)
1244   FB25             ; 800     b = 6;
1245   FB25 06 06       	ld b, 6
1246   FB27             ; 801     do {
1247   FB27             l_57: 
1248   FB27             ; 802         e = *hl;
1249   FB27 5E          	ld e, (hl)
1250   FB28             ; 803         hl++;
1251   FB28 23          	inc hl
1252   FB29             ; 804         d = *hl;
1253   FB29 56          	ld d, (hl)
1254   FB2A             ; 805         push(bc);
1255   FB2A C5          	push bc
1256   FB2B             ; 806         push(hl);
1257   FB2B E5          	push hl
1258   FB2C             ; 807         swap(hl, de);
1259   FB2C EB          	ex hl, de
1260   FB2D             ; 808         PrintCrLfTabHexWordSpace(hl);
1261   FB2D CD 51 FC    	call printcrlftabhexwordspace
1262   FB30             ; 809         ReadString();
1263   FB30 CD 14 F9    	call readstring
1264   FB33             ; 810         if (flag_c) {
1265   FB33 D2 3F FB    	jp nc, l_60
1266   FB36             ; 811             ParseWord();
1267   FB36 CD 80 F9    	call parseword
1268   FB39             ; 812             pop(de);
1269   FB39 D1          	pop de
1270   FB3A             ; 813             push(de);
1271   FB3A D5          	push de
1272   FB3B             ; 814             swap(hl, de);
1273   FB3B EB          	ex hl, de
1274   FB3C             ; 815             *hl = d;
1275   FB3C 72          	ld (hl), d
1276   FB3D             ; 816             hl--;
1277   FB3D 2B          	dec hl
1278   FB3E             ; 817             *hl = e;
1279   FB3E 73          	ld (hl), e
1280   FB3F             l_60: 
1281   FB3F             ; 818         }
1282   FB3F             ; 819         pop(hl);
1283   FB3F E1          	pop hl
1284   FB40             ; 820         pop(bc);
1285   FB40 C1          	pop bc
1286   FB41             ; 821         b--;
1287   FB41 05          	dec b
1288   FB42             ; 822         hl++;
1289   FB42 23          	inc hl
1290   FB43             l_58: 
1291   FB43 C2 27 FB    	jp nz, l_57
1292   FB46             ; 823     } while (flag_nz);
1293   FB46             ; 824     EntryF86C_Monitor();
1294   FB46 C3 6C F8    	jp entryf86c_monitor
1295   FB49             ; 825 }
1296   FB49             ; 826 
1297   FB49             ; 827 // Функция для пользовательской программы.
1298   FB49             ; 828 // Получить координаты курсора.
1299   FB49             ; 829 // Параметры: нет. Результат: l = x + 8, h = y + 3. Сохраняет регистры: bc, de, hl.
1300   FB49             ; 830 
1301   FB49             ; 831 void GetCursor() {
1302   FB49             getcursor: 
1303   FB49             ; 832     push_pop(a) {
1304   FB49 F5          	push af
1305   FB4A             ; 833         hl = cursor;
1306   FB4A 2A 5A F7    	ld hl, (cursor)
1307   FB4D             ; 834         h = ((a = h) &= 7);
1308   FB4D 7C          	ld a, h
1309   FB4E E6 07       	and 7
1310   FB50 67          	ld h, a
1311   FB51             ; 835 
1312   FB51             ; 836         // Вычисление X
1313   FB51             ; 837         a = l;
1314   FB51 7D          	ld a, l
1315   FB52             ; 838         a &= (SCREEN_WIDTH - 1);
1316   FB52 E6 3F       	and 63
1317   FB54             ; 839         a += 8;  // Смещение Радио 86РК
1318   FB54 C6 08       	add 8
1319   FB56             ; 840 
1320   FB56             ; 841         // Вычисление Y
1321   FB56             ; 842         hl += hl;
1322   FB56 29          	add hl, hl
1323   FB57             ; 843         hl += hl;
1324   FB57 29          	add hl, hl
1325   FB58             ; 844         h++;  // Смещение Радио 86РК
1326   FB58 24          	inc h
1327   FB59             ; 845         h++;
1328   FB59 24          	inc h
1329   FB5A             ; 846         h++;
1330   FB5A 24          	inc h
1331   FB5B             ; 847 
1332   FB5B             ; 848         l = a;
1333   FB5B 6F          	ld l, a
1334   FB5C F1          	pop af
1335   FB5D C9          	ret
1336   FB5E             ; 849     }
1337   FB5E             ; 850 }
1338   FB5E             ; 851 
1339   FB5E             ; 852 // Функция для пользовательской программы.
1340   FB5E             ; 853 // Получить символ под курсором.
1341   FB5E             ; 854 // Параметры: нет. Результат: a - код символа. Сохраняет регистры: bc, de, hl.
1342   FB5E             ; 855 
1343   FB5E             ; 856 void GetCursorChar() {
1344   FB5E             getcursorchar: 
1345   FB5E             ; 857     push_pop(hl) {
1346   FB5E E5          	push hl
1347   FB5F             ; 858         hl = cursor;
1348   FB5F 2A 5A F7    	ld hl, (cursor)
1349   FB62             ; 859         a = *hl;
1350   FB62 7E          	ld a, (hl)
1351   FB63 E1          	pop hl
1352   FB64 C9          	ret
1353   FB65             ; 860     }
1354   FB65             ; 861 }
1355   FB65             ; 862 
1356   FB65             ; 863 // Команда H
1357   FB65             ; 864 // Определить скорости записанной программы.
1358   FB65             ; 865 // Выводит 4 цифры на экран.
1359   FB65             ; 866 // Первые две цифры - константа вывода для команды O
1360   FB65             ; 867 // Последние две цифры - константа вввода для команды I
1361   FB65             ; 868 
1362   FB65             ; 869 void CmdH(...) {
1363   FB65             cmdh: 
1364   FB65             ; 870     PrintCrLfTab();
1365   FB65 CD D3 F9    	call printcrlftab
1366   FB68             ; 871     hl = 65408;
1367   FB68 21 80 FF    	ld hl, 65408
1368   FB6B             ; 872     b = 123;
1369   FB6B 06 7B       	ld b, 123
1370   FB6D             ; 873 
1371   FB6D             ; 874     c = a = in(PORT_TAPE);
1372   FB6D DB 01       	in a, (1)
1373   FB6F 4F          	ld c, a
1374   FB70             ; 875 
1375   FB70             ; 876     do {
1376   FB70             l_62: 
1377   FB70             l_63: 
1378   FB70             ; 877     } while ((a = in(PORT_TAPE)) == c);
1379   FB70 DB 01       	in a, (1)
1380   FB72 B9          	cp c
1381   FB73 CA 70 FB    	jp z, l_62
1382   FB76             ; 878 
1383   FB76             ; 879     do {
1384   FB76             l_65: 
1385   FB76             ; 880         c = a;
1386   FB76 4F          	ld c, a
1387   FB77             ; 881         do {
1388   FB77             l_68: 
1389   FB77             ; 882             hl++;
1390   FB77 23          	inc hl
1391   FB78             l_69: 
1392   FB78             ; 883         } while ((a = in(PORT_TAPE)) == c);
1393   FB78 DB 01       	in a, (1)
1394   FB7A B9          	cp c
1395   FB7B CA 77 FB    	jp z, l_68
1396   FB7E             l_66: 
1397   FB7E             ; 884     } while (flag_nz(b--));
1398   FB7E 05          	dec b
1399   FB7F C2 76 FB    	jp nz, l_65
1400   FB82             ; 885 
1401   FB82             ; 886     hl += hl;
1402   FB82 29          	add hl, hl
1403   FB83             ; 887     a = h;
1404   FB83 7C          	ld a, h
1405   FB84             ; 888     hl += hl;
1406   FB84 29          	add hl, hl
1407   FB85             ; 889     l = (a += h);
1408   FB85 84          	add h
1409   FB86 6F          	ld l, a
1410   FB87             ; 890 
1411   FB87             ; 891     PrintHexWordSpace();
1412   FB87 C3 5A FC    	jp printhexwordspace
1413   FB8A             ; 892 }
1414   FB8A             ; 893 
1415   FB8A             ; 894 // Команда I <смещение> <скорость>
1416   FB8A             ; 895 // Загрузить файл с магнитной ленты
1417   FB8A             ; 896 
1418   FB8A             ; 897 void CmdI(...) {
1419   FB8A             cmdi: 
1420   FB8A             ; 898     if ((a = param2Exists) != 0)
1421   FB8A 3A 7B F7    	ld a, (param2exists)
1422   FB8D B7          	or a
1423   FB8E             ; 899         tapeReadSpeed = a = e;
1424   FB8E CA 95 FB    	jp z, l_71
1425   FB91 7B          	ld a, e
1426   FB92 32 5C F7    	ld (tapereadspeed), a
1427   FB95             l_71: 
1428   FB95             ; 900     ReadTapeFile();
1429   FB95 CD BA FB    	call readtapefile
1430   FB98             ; 901     PrintCrLfTabHexWordSpace(hl);
1431   FB98 CD 51 FC    	call printcrlftabhexwordspace
1432   FB9B             ; 902     swap(hl, de);
1433   FB9B EB          	ex hl, de
1434   FB9C             ; 903     PrintCrLfTabHexWordSpace(hl);
1435   FB9C CD 51 FC    	call printcrlftabhexwordspace
1436   FB9F             ; 904     swap(hl, de);
1437   FB9F EB          	ex hl, de
1438   FBA0             ; 905     push(bc);
1439   FBA0 C5          	push bc
1440   FBA1             ; 906     CalculateCheckSum();
1441   FBA1 CD F1 FB    	call calculatechecksum
1442   FBA4             ; 907     h = b;
1443   FBA4 60          	ld h, b
1444   FBA5             ; 908     l = c;
1445   FBA5 69          	ld l, c
1446   FBA6             ; 909     PrintCrLfTabHexWordSpace(hl);
1447   FBA6 CD 51 FC    	call printcrlftabhexwordspace
1448   FBA9             ; 910     pop(de);
1449   FBA9 D1          	pop de
1450   FBAA             ; 911     CompareHlDe(hl, de);
1451   FBAA CD B6 F9    	call comparehlde
1452   FBAD             ; 912     if (flag_z)
1453   FBAD             ; 913         return;
1454   FBAD C8          	ret z
1455   FBAE             ; 914     swap(hl, de);
1456   FBAE EB          	ex hl, de
1457   FBAF             ; 915     PrintCrLfTabHexWordSpace(hl);
1458   FBAF CD 51 FC    	call printcrlftabhexwordspace
1459   FBB2             ; 916     MonitorError();
1460   FBB2             ; 917 }
1461   FBB2             ; 918 
1462   FBB2             ; 919 void MonitorError() {
1463   FBB2             monitorerror: 
1464   FBB2             ; 920     PrintCharA(a = '?');
1465   FBB2 3E 3F       	ld a, 63
1466   FBB4 CD 22 FD    	call printchara
1467   FBB7             ; 921     Monitor2();
1468   FBB7 C3 94 F8    	jp monitor2
1469   FBBA             ; 922 }
1470   FBBA             ; 923 
1471   FBBA             ; 924 // Функция для пользовательской программы.
1472   FBBA             ; 925 // Загрузить файл с магнитной ленты.
1473   FBBA             ; 926 // Параметры: hl - смещение загрузки. Результат: bc - прочитанная КС, hl - адрес загрузки
1474   FBBA             ; 927 
1475   FBBA             ; 928 void ReadTapeFile(...) {
1476   FBBA             readtapefile: 
1477   FBBA             ; 929     ReadTapeWord(a = READ_TAPE_FIRST_BYTE);
1478   FBBA 3E FF       	ld a, 255
1479   FBBC CD DA FB    	call readtapeword
1480   FBBF             ; 930     push_pop(hl) {
1481   FBBF E5          	push hl
1482   FBC0             ; 931         hl += bc;
1483   FBC0 09          	add hl, bc
1484   FBC1             ; 932         swap(hl, de);
1485   FBC1 EB          	ex hl, de
1486   FBC2             ; 933         ReadTapeWordNext();
1487   FBC2 CD D8 FB    	call readtapewordnext
1488   FBC5 E1          	pop hl
1489   FBC6             ; 934     }
1490   FBC6             ; 935     hl += bc;
1491   FBC6 09          	add hl, bc
1492   FBC7             ; 936     swap(hl, de);
1493   FBC7 EB          	ex hl, de
1494   FBC8             ; 937 
1495   FBC8             ; 938     a = in(PORT_KEYBOARD_MODS);
1496   FBC8 DB 05       	in a, (5)
1497   FBCA             ; 939     a &= KEYBOARD_SHIFT_MOD;
1498   FBCA E6 04       	and 4
1499   FBCC             ; 940     if (flag_z)
1500   FBCC             ; 941         return;
1501   FBCC C8          	ret z
1502   FBCD             ; 942 
1503   FBCD             ; 943     push_pop(hl) {
1504   FBCD E5          	push hl
1505   FBCE             ; 944         ReadTapeBlock();
1506   FBCE CD E5 FB    	call readtapeblock
1507   FBD1             ; 945         ReadTapeWord(a = READ_TAPE_FIRST_BYTE);
1508   FBD1 3E FF       	ld a, 255
1509   FBD3 CD DA FB    	call readtapeword
1510   FBD6 E1          	pop hl
1511   FBD7 C9          	ret
1512   FBD8             ; 946     }
1513   FBD8             ; 947 }
1514   FBD8             ; 948 
1515   FBD8             ; 949 void ReadTapeWordNext() {
1516   FBD8             readtapewordnext: 
1517   FBD8             ; 950     ReadTapeWord(a = READ_TAPE_NEXT_BYTE);
1518   FBD8 3E 08       	ld a, 8
1519   FBDA             ; 951 }
1520   FBDA             ; 952 
1521   FBDA             ; 953 void ReadTapeWord(...) {
1522   FBDA             readtapeword: 
1523   FBDA             ; 954     ReadTapeByte(a);
1524   FBDA CD 74 FC    	call readtapebyte
1525   FBDD             ; 955     b = a;
1526   FBDD 47          	ld b, a
1527   FBDE             ; 956     ReadTapeByte(a = READ_TAPE_NEXT_BYTE);
1528   FBDE 3E 08       	ld a, 8
1529   FBE0 CD 74 FC    	call readtapebyte
1530   FBE3             ; 957     c = a;
1531   FBE3 4F          	ld c, a
1532   FBE4 C9          	ret
1533   FBE5             ; 958 }
1534   FBE5             ; 959 
1535   FBE5             ; 960 void ReadTapeBlock(...) {
1536   FBE5             readtapeblock: 
1537   FBE5             ; 961     for (;;) {
1538   FBE5             l_74: 
1539   FBE5             ; 962         ReadTapeByte(a = READ_TAPE_NEXT_BYTE);
1540   FBE5 3E 08       	ld a, 8
1541   FBE7 CD 74 FC    	call readtapebyte
1542   FBEA             ; 963         *hl = a;
1543   FBEA 77          	ld (hl), a
1544   FBEB             ; 964         Loop();
1545   FBEB CD BF F9    	call loop
1546   FBEE C3 E5 FB    	jp l_74
1547   FBF1             ; 965     }
1548   FBF1             ; 966 }
1549   FBF1             ; 967 
1550   FBF1             ; 968 // Функция для пользовательской программы.
1551   FBF1             ; 969 // Вычистить 16-битную сумму всех байт по адресам hl..de.
1552   FBF1             ; 970 // Параметры: hl - начальный адрес, de - конечный адрес. Результат: bc - сумма. Сохраяет: de.
1553   FBF1             ; 971 
1554   FBF1             ; 972 void CalculateCheckSum(...) {
1555   FBF1             calculatechecksum: 
1556   FBF1             ; 973     bc = 0;
1557   FBF1 01 00 00    	ld bc, 0
1558   FBF4             ; 974     for (;;) {
1559   FBF4             l_77: 
1560   FBF4             ; 975         c = ((a = *hl) += c);
1561   FBF4 7E          	ld a, (hl)
1562   FBF5 81          	add c
1563   FBF6 4F          	ld c, a
1564   FBF7             ; 976         push_pop(a) {
1565   FBF7 F5          	push af
1566   FBF8             ; 977             CompareHlDe(hl, de);
1567   FBF8 CD B6 F9    	call comparehlde
1568   FBFB             ; 978             if (flag_z)
1569   FBFB             ; 979                 return PopRet();
1570   FBFB CA C5 F9    	jp z, popret
1571   FBFE F1          	pop af
1572   FBFF             ; 980         }
1573   FBFF             ; 981         a = b;
1574   FBFF 78          	ld a, b
1575   FC00             ; 982         carry_add(a, *hl);
1576   FC00 8E          	adc (hl)
1577   FC01             ; 983         b = a;
1578   FC01 47          	ld b, a
1579   FC02             ; 984         Loop();
1580   FC02 CD BF F9    	call loop
1581   FC05 C3 F4 FB    	jp l_77
1582   FC08             ; 985     }
1583   FC08             ; 986 }
1584   FC08             ; 987 
1585   FC08             ; 988 // Команда O <начальный адрес> <конечный адрес> <скорость>
1586   FC08             ; 989 // Сохранить блок данных на магнитную ленту
1587   FC08             ; 990 
1588   FC08             ; 991 void CmdO(...) {
1589   FC08             cmdo: 
1590   FC08             ; 992     if ((a = c) != 0)
1591   FC08 79          	ld a, c
1592   FC09 B7          	or a
1593   FC0A             ; 993         tapeWriteSpeed = a;
1594   FC0A CA 10 FC    	jp z, l_79
1595   FC0D 32 5D F7    	ld (tapewritespeed), a
1596   FC10             l_79: 
1597   FC10             ; 994     push_pop(hl) {
1598   FC10 E5          	push hl
1599   FC11             ; 995         CalculateCheckSum(hl, de);
1600   FC11 CD F1 FB    	call calculatechecksum
1601   FC14 E1          	pop hl
1602   FC15             ; 996     }
1603   FC15             ; 997     PrintCrLfTabHexWordSpace(hl);
1604   FC15 CD 51 FC    	call printcrlftabhexwordspace
1605   FC18             ; 998     swap(hl, de);
1606   FC18 EB          	ex hl, de
1607   FC19             ; 999     PrintCrLfTabHexWordSpace(hl);
1608   FC19 CD 51 FC    	call printcrlftabhexwordspace
1609   FC1C             ; 1000     swap(hl, de);
1610   FC1C EB          	ex hl, de
1611   FC1D             ; 1001     push_pop(hl) {
1612   FC1D E5          	push hl
1613   FC1E             ; 1002         h = b;
1614   FC1E 60          	ld h, b
1615   FC1F             ; 1003         l = c;
1616   FC1F 69          	ld l, c
1617   FC20             ; 1004         PrintCrLfTabHexWordSpace(hl);
1618   FC20 CD 51 FC    	call printcrlftabhexwordspace
1619   FC23 E1          	pop hl
1620   FC24             ; 1005     }
1621   FC24             ; 1006     WriteTapeFile(hl, de);
1622   FC24             ; 1007 }
1623   FC24             ; 1008 
1624   FC24             ; 1009 // Функция для пользовательской программы.
1625   FC24             ; 1010 // Запись файла на магнитную ленту.
1626   FC24             ; 1011 // Параметры: de - начальный адрес, hl - конечный адрес, bc - контрольная сумма. Результат: нет.
1627   FC24             ; 1012 
1628   FC24             ; 1013 void WriteTapeFile(...) {
1629   FC24             writetapefile: 
1630   FC24             ; 1014     push(bc);
1631   FC24 C5          	push bc
1632   FC25             ; 1015     bc = 0;
1633   FC25 01 00 00    	ld bc, 0
1634   FC28             ; 1016     do {
1635   FC28             l_81: 
1636   FC28             ; 1017         WriteTapeByte(c);
1637   FC28 CD DD FC    	call writetapebyte
1638   FC2B             ; 1018         b--;
1639   FC2B 05          	dec b
1640   FC2C             ; 1019         swap(hl, *sp);
1641   FC2C E3          	ex (sp), hl
1642   FC2D             ; 1020         swap(hl, *sp);
1643   FC2D E3          	ex (sp), hl
1644   FC2E             l_82: 
1645   FC2E C2 28 FC    	jp nz, l_81
1646   FC31             ; 1021     } while (flag_nz);
1647   FC31             ; 1022     WriteTapeByte(c = TAPE_START);
1648   FC31 0E E6       	ld c, 230
1649   FC33 CD DD FC    	call writetapebyte
1650   FC36             ; 1023     WriteTapeWord(hl);
1651   FC36 CD 6C FC    	call writetapeword
1652   FC39             ; 1024     swap(hl, de);
1653   FC39 EB          	ex hl, de
1654   FC3A             ; 1025     WriteTapeWord(hl);
1655   FC3A CD 6C FC    	call writetapeword
1656   FC3D             ; 1026     swap(hl, de);
1657   FC3D EB          	ex hl, de
1658   FC3E             ; 1027     WriteTapeBlock(hl, de);
1659   FC3E CD 62 FC    	call writetapeblock
1660   FC41             ; 1028     WriteTapeWord(hl = 0);
1661   FC41 21 00 00    	ld hl, 0
1662   FC44 CD 6C FC    	call writetapeword
1663   FC47             ; 1029     WriteTapeByte(c = TAPE_START);
1664   FC47 0E E6       	ld c, 230
1665   FC49 CD DD FC    	call writetapebyte
1666   FC4C             ; 1030     pop(hl);
1667   FC4C E1          	pop hl
1668   FC4D             ; 1031     WriteTapeWord(hl);
1669   FC4D CD 6C FC    	call writetapeword
1670   FC50             ; 1032     return;
1671   FC50 C9          	ret
1672   FC51             ; 1033 }
1673   FC51             ; 1034 
1674   FC51             ; 1035 void PrintCrLfTabHexWordSpace(...) {
1675   FC51             printcrlftabhexwordspace: 
1676   FC51             ; 1036     push_pop(bc) {
1677   FC51 C5          	push bc
1678   FC52             ; 1037         PrintCrLfTab();
1679   FC52 CD D3 F9    	call printcrlftab
1680   FC55             ; 1038         PrintHexWordSpace(hl);
1681   FC55 CD 5A FC    	call printhexwordspace
1682   FC58 C1          	pop bc
1683   FC59 C9          	ret
1684   FC5A             ; 1039     }
1685   FC5A             ; 1040 }
1686   FC5A             ; 1041 
1687   FC5A             ; 1042 void PrintHexWordSpace(...) {
1688   FC5A             printhexwordspace: 
1689   FC5A             ; 1043     PrintHexByte(a = h);
1690   FC5A 7C          	ld a, h
1691   FC5B CD 0E FD    	call printhexbyte
1692   FC5E             ; 1044     PrintHexByteSpace(a = l);
1693   FC5E 7D          	ld a, l
1694   FC5F C3 DD F9    	jp printhexbytespace
1695   FC62             ; 1045 }
1696   FC62             ; 1046 
1697   FC62             ; 1047 void WriteTapeBlock(...) {
1698   FC62             writetapeblock: 
1699   FC62             ; 1048     for (;;) {
1700   FC62             l_85: 
1701   FC62             ; 1049         WriteTapeByte(c = *hl);
1702   FC62 4E          	ld c, (hl)
1703   FC63 CD DD FC    	call writetapebyte
1704   FC66             ; 1050         Loop();
1705   FC66 CD BF F9    	call loop
1706   FC69 C3 62 FC    	jp l_85
1707   FC6C             ; 1051     }
1708   FC6C             ; 1052 }
1709   FC6C             ; 1053 
1710   FC6C             ; 1054 void WriteTapeWord(...) {
1711   FC6C             writetapeword: 
1712   FC6C             ; 1055     WriteTapeByte(c = h);
1713   FC6C 4C          	ld c, h
1714   FC6D CD DD FC    	call writetapebyte
1715   FC70             ; 1056     WriteTapeByte(c = l);
1716   FC70 4D          	ld c, l
1717   FC71 C3 DD FC    	jp writetapebyte
1718   FC74             ; 1057 }
1719   FC74             ; 1058 
1720   FC74             ; 1059 // Загрузка байта с магнитной ленты.
1721   FC74             ; 1060 // Параметры: a = 0xFF с синхронизацией, = 8 без синхронизации.
1722   FC74             ; 1061 // Результат: a = прочитанный байт.
1723   FC74             ; 1062 
1724   FC74             ; 1063 void ReadTapeByte(...) {
1725   FC74             readtapebyte: 
1726   FC74             ; 1064     push(hl, bc, de);
1727   FC74 E5          	push hl
1728   FC75 C5          	push bc
1729   FC76 D5          	push de
1730   FC77             ; 1065     d = a;
1731   FC77 57          	ld d, a
1732   FC78             ; 1066     ReadTapeByteInternal(d);
1733   FC78             ; 1067 }
1734   FC78             ; 1068 
1735   FC78             ; 1069 void ReadTapeByteInternal(...) {
1736   FC78             readtapebyteinternal: 
1737   FC78             ; 1070     c = 0;
1738   FC78 0E 00       	ld c, 0
1739   FC7A             ; 1071     e = ((a = in(PORT_TAPE)) &= PORT_TAPE_BIT);
1740   FC7A DB 01       	in a, (1)
1741   FC7C E6 01       	and 1
1742   FC7E 5F          	ld e, a
1743   FC7F             ; 1072     do {
1744   FC7F             l_87: 
1745   FC7F             ; 1073     retry:  // Сдвиг результата
1746   FC7F             retry: 
1747   FC7F             ; 1074         (a = c) &= 0x7F;
1748   FC7F 79          	ld a, c
1749   FC80 E6 7F       	and 127
1750   FC82             ; 1075         cyclic_rotate_left(a, 1);
1751   FC82 07          	rlca
1752   FC83             ; 1076         c = a;
1753   FC83 4F          	ld c, a
1754   FC84             ; 1077 
1755   FC84             ; 1078         // Ожидание изменения бита
1756   FC84             ; 1079         h = 0;
1757   FC84 26 00       	ld h, 0
1758   FC86             ; 1080         do {
1759   FC86             l_90: 
1760   FC86             ; 1081             h--;
1761   FC86 25          	dec h
1762   FC87             ; 1082             if (flag_z)
1763   FC87             ; 1083                 return ReadTapeByteTimeout(d);
1764   FC87 CA D2 FC    	jp z, readtapebytetimeout
1765   FC8A             l_91: 
1766   FC8A             ; 1084         } while (((a = in(PORT_TAPE)) &= PORT_TAPE_BIT) == e);
1767   FC8A DB 01       	in a, (1)
1768   FC8C E6 01       	and 1
1769   FC8E BB          	cp e
1770   FC8F CA 86 FC    	jp z, l_90
1771   FC92             ; 1085 
1772   FC92             ; 1086         // Сохранение бита
1773   FC92             ; 1087         c = (a |= c);
1774   FC92 B1          	or c
1775   FC93 4F          	ld c, a
1776   FC94             ; 1088 
1777   FC94             ; 1089         // Задержка
1778   FC94             ; 1090         d--;
1779   FC94 15          	dec d
1780   FC95             ; 1091         a = tapeReadSpeed;
1781   FC95 3A 5C F7    	ld a, (tapereadspeed)
1782   FC98             ; 1092         if (flag_z)
1783   FC98             ; 1093             a -= 18;
1784   FC98 C2 9D FC    	jp nz, l_93
1785   FC9B D6 12       	sub 18
1786   FC9D             l_93: 
1787   FC9D             ; 1094         b = a;
1788   FC9D 47          	ld b, a
1789   FC9E             ; 1095         do {
1790   FC9E             l_95: 
1791   FC9E             l_96: 
1792   FC9E             ; 1096         } while (flag_nz(b--));
1793   FC9E 05          	dec b
1794   FC9F C2 9E FC    	jp nz, l_95
1795   FCA2             ; 1097         d++;
1796   FCA2 14          	inc d
1797   FCA3             ; 1098 
1798   FCA3             ; 1099         // Новое значение бита
1799   FCA3             ; 1100         e = ((a = in(PORT_TAPE)) &= PORT_TAPE_BIT);
1800   FCA3 DB 01       	in a, (1)
1801   FCA5 E6 01       	and 1
1802   FCA7 5F          	ld e, a
1803   FCA8             ; 1101 
1804   FCA8             ; 1102         // Режим поиска синхробайта
1805   FCA8             ; 1103         if (flag_m((a = d) |= a)) {
1806   FCA8 7A          	ld a, d
1807   FCA9 B7          	or a
1808   FCAA F2 C6 FC    	jp p, l_98
1809   FCAD             ; 1104             if ((a = c) == TAPE_START) {
1810   FCAD 79          	ld a, c
1811   FCAE FE E6       	cp 230
1812   FCB0 C2 BA FC    	jp nz, l_100
1813   FCB3             ; 1105                 tapePolarity = (a ^= a);
1814   FCB3 AF          	xor a
1815   FCB4 32 7C F7    	ld (tapepolarity), a
1816   FCB7 C3 C4 FC    	jp l_101
1817   FCBA             l_100: 
1818   FCBA             ; 1106             } else {
1819   FCBA             ; 1107                 if (a != ~TAPE_START)
1820   FCBA FE 19       	cp 65305
1821   FCBC             ; 1108                     goto retry;
1822   FCBC C2 7F FC    	jp nz, retry
1823   FCBF             ; 1109                 tapePolarity = a = 255;
1824   FCBF 3E FF       	ld a, 255
1825   FCC1 32 7C F7    	ld (tapepolarity), a
1826   FCC4             l_101: 
1827   FCC4             ; 1110             }
1828   FCC4             ; 1111             d = 8 + 1;
1829   FCC4 16 09       	ld d, 9
1830   FCC6             l_98: 
1831   FCC6             l_88: 
1832   FCC6             ; 1112         }
1833   FCC6             ; 1113     } while (flag_nz(d--));
1834   FCC6 15          	dec d
1835   FCC7 C2 7F FC    	jp nz, l_87
1836   FCCA             ; 1114     (a = tapePolarity) ^= c;
1837   FCCA 3A 7C F7    	ld a, (tapepolarity)
1838   FCCD A9          	xor c
1839   FCCE             ; 1115     pop(hl, bc, de);
1840   FCCE D1          	pop de
1841   FCCF C1          	pop bc
1842   FCD0 E1          	pop hl
1843   FCD1 C9          	ret
1844   FCD2             ; 1116 }
1845   FCD2             ; 1117 
1846   FCD2             ; 1118 void ReadTapeByteTimeout(...) {
1847   FCD2             readtapebytetimeout: 
1848   FCD2             ; 1119     if (flag_p((a = d) |= a))
1849   FCD2 7A          	ld a, d
1850   FCD3 B7          	or a
1851   FCD4             ; 1120         return MonitorError();
1852   FCD4 F2 B2 FB    	jp p, monitorerror
1853   FCD7             ; 1121     CtrlC();
1854   FCD7 CD CA F9    	call ctrlc
1855   FCDA             ; 1122     return ReadTapeByteInternal();
1856   FCDA C3 78 FC    	jp readtapebyteinternal
1857   FCDD             ; 1123 }
1858   FCDD             ; 1124 
1859   FCDD             ; 1125 // Функция для пользовательской программы.
1860   FCDD             ; 1126 // Запись байта на магнитную ленту.
1861   FCDD             ; 1127 // Параметры: c = байт. Результат: нет. Сохрнаяет: a, bc, de, hl.
1862   FCDD             ; 1128 
1863   FCDD             ; 1129 void WriteTapeByte(...) {
1864   FCDD             writetapebyte: 
1865   FCDD             ; 1130     push_pop(bc, de, a) {
1866   FCDD C5          	push bc
1867   FCDE D5          	push de
1868   FCDF F5          	push af
1869   FCE0             ; 1131         d = 8;
1870   FCE0 16 08       	ld d, 8
1871   FCE2             ; 1132         do {
1872   FCE2             l_102: 
1873   FCE2             ; 1133             // Сдвиг исходного байта
1874   FCE2             ; 1134             a = c;
1875   FCE2 79          	ld a, c
1876   FCE3             ; 1135             cyclic_rotate_left(a, 1);
1877   FCE3 07          	rlca
1878   FCE4             ; 1136             c = a;
1879   FCE4 4F          	ld c, a
1880   FCE5             ; 1137 
1881   FCE5             ; 1138             // Вывод
1882   FCE5             ; 1139             (a = PORT_TAPE_BIT) ^= c;
1883   FCE5 3E 01       	ld a, 1
1884   FCE7 A9          	xor c
1885   FCE8             ; 1140             out(PORT_TAPE, a);
1886   FCE8 D3 01       	out (1), a
1887   FCEA             ; 1141 
1888   FCEA             ; 1142             // Задержка
1889   FCEA             ; 1143             b = a = tapeWriteSpeed;
1890   FCEA 3A 5D F7    	ld a, (tapewritespeed)
1891   FCED 47          	ld b, a
1892   FCEE             ; 1144             do {
1893   FCEE             l_105: 
1894   FCEE             ; 1145                 b--;
1895   FCEE 05          	dec b
1896   FCEF             l_106: 
1897   FCEF C2 EE FC    	jp nz, l_105
1898   FCF2             ; 1146             } while (flag_nz);
1899   FCF2             ; 1147 
1900   FCF2             ; 1148             // Вывод
1901   FCF2             ; 1149             (a = 0) ^= c;
1902   FCF2 3E 00       	ld a, 0
1903   FCF4 A9          	xor c
1904   FCF5             ; 1150             out(PORT_TAPE, a);
1905   FCF5 D3 01       	out (1), a
1906   FCF7             ; 1151 
1907   FCF7             ; 1152             // Задержка
1908   FCF7             ; 1153             d--;
1909   FCF7 15          	dec d
1910   FCF8             ; 1154             a = tapeWriteSpeed;
1911   FCF8 3A 5D F7    	ld a, (tapewritespeed)
1912   FCFB             ; 1155             if (flag_z)
1913   FCFB             ; 1156                 a -= 14;
1914   FCFB C2 00 FD    	jp nz, l_108
1915   FCFE D6 0E       	sub 14
1916   FD00             l_108: 
1917   FD00             ; 1157             b = a;
1918   FD00 47          	ld b, a
1919   FD01             ; 1158             do {
1920   FD01             l_110: 
1921   FD01             ; 1159                 b--;
1922   FD01 05          	dec b
1923   FD02             l_111: 
1924   FD02 C2 01 FD    	jp nz, l_110
1925   FD05             ; 1160             } while (flag_nz);
1926   FD05             ; 1161             d++;
1927   FD05 14          	inc d
1928   FD06             l_103: 
1929   FD06             ; 1162         } while (flag_nz(d--));
1930   FD06 15          	dec d
1931   FD07 C2 E2 FC    	jp nz, l_102
1932   FD0A F1          	pop af
1933   FD0B D1          	pop de
1934   FD0C C1          	pop bc
1935   FD0D C9          	ret
1936   FD0E             ; 1163     }
1937   FD0E             ; 1164 }
1938   FD0E             ; 1165 
1939   FD0E             ; 1166 // Функция для пользовательской программы.
1940   FD0E             ; 1167 // Вывод 8 битного числа на экран.
1941   FD0E             ; 1168 // Параметры: а - число. Результат: нет. Сохраняет: bc, de, hl.
1942   FD0E             ; 1169 
1943   FD0E             ; 1170 void PrintHexByte(...) {
1944   FD0E             printhexbyte: 
1945   FD0E             ; 1171     push_pop(a) {
1946   FD0E F5          	push af
1947   FD0F             ; 1172         cyclic_rotate_right(a, 4);
1948   FD0F 0F          	rrca
1949   FD10 0F          	rrca
1950   FD11 0F          	rrca
1951   FD12 0F          	rrca
1952   FD13             ; 1173         PrintHexNibble(a);
1953   FD13 CD 17 FD    	call printhexnibble
1954   FD16 F1          	pop af
1955   FD17             ; 1174     }
1956   FD17             ; 1175     PrintHexNibble(a);
1957   FD17             ; 1176 }
1958   FD17             ; 1177 
1959   FD17             ; 1178 void PrintHexNibble(...) {
1960   FD17             printhexnibble: 
1961   FD17             ; 1179     a &= 0x0F;
1962   FD17 E6 0F       	and 15
1963   FD19             ; 1180     if (flag_p(compare(a, 10)))
1964   FD19 FE 0A       	cp 10
1965   FD1B             ; 1181         a += 'A' - '0' - 10;
1966   FD1B FA 20 FD    	jp m, l_113
1967   FD1E C6 07       	add 7
1968   FD20             l_113: 
1969   FD20             ; 1182     a += '0';
1970   FD20 C6 30       	add 48
1971   FD22             ; 1183     PrintCharA(a);
1972   FD22             ; 1184 }
1973   FD22             ; 1185 
1974   FD22             ; 1186 // Вывод символа на экран.
1975   FD22             ; 1187 // Параметры: а - символ. Результат: a и c - символ. Сохраняет: a, b, de, hl.
1976   FD22             ; 1188 
1977   FD22             ; 1189 void PrintCharA(...) {
1978   FD22             printchara: 
1979   FD22             ; 1190     PrintChar(c = a);
1980   FD22 4F          	ld c, a
1981   FD23             ; 1191 }
1982   FD23             ; 1192 
1983   FD23             ; 1193 // Функция для пользовательской программы.
1984   FD23             ; 1194 // Вывод символа на экран.
1985   FD23             ; 1195 // Параметры: c - символ. Результат: нет. Сохраняет: a, b, de, hl.
1986   FD23             ; 1196 
1987   FD23             ; 1197 void PrintChar(...) {
1988   FD23             printchar: 
1989   FD23             ; 1198     push(a, bc, de, hl);
1990   FD23 F5          	push af
1991   FD24 C5          	push bc
1992   FD25 D5          	push de
1993   FD26 E5          	push hl
1994   FD27             ; 1199     IsAnyKeyPressed();
1995   FD27 CD B7 FE    	call isanykeypressed
1996   FD2A             ; 1200     DrawCursor(b = 0);
1997   FD2A 06 00       	ld b, 0
1998   FD2C CD 77 FD    	call drawcursor
1999   FD2F             ; 1201     hl = cursor;
2000   FD2F 2A 5A F7    	ld hl, (cursor)
2001   FD32             ; 1202     a = escState;
2002   FD32 3A 5F F7    	ld a, (escstate)
2003   FD35             ; 1203     a--;
2004   FD35 3D          	dec a
2005   FD36             ; 1204     if (flag_m)
2006   FD36             ; 1205         return PrintCharNoEsc();
2007   FD36 FA BF FD    	jp m, printcharnoesc
2008   FD39             ; 1206     if (flag_z)
2009   FD39             ; 1207         return PrintCharEsc();
2010   FD39 CA A0 FD    	jp z, printcharesc
2011   FD3C             ; 1208     a--;
2012   FD3C 3D          	dec a
2013   FD3D             ; 1209     if (flag_nz)
2014   FD3D             ; 1210         return PrintCharEscY2();
2015   FD3D C2 85 FD    	jp nz, printcharescy2
2016   FD40             ; 1211 
2017   FD40             ; 1212     // Первый параметр ESC Y
2018   FD40             ; 1213     a = c;
2019   FD40 79          	ld a, c
2020   FD41             ; 1214     a -= ' ';
2021   FD41 D6 20       	sub 32
2022   FD43             ; 1215     if (flag_m) {
2023   FD43 F2 4A FD    	jp p, l_115
2024   FD46             ; 1216         a ^= a;
2025   FD46 AF          	xor a
2026   FD47 C3 51 FD    	jp l_116
2027   FD4A             l_115: 
2028   FD4A             ; 1217     } else {
2029   FD4A             ; 1218         if (flag_p(compare(a, SCREEN_HEIGHT)))
2030   FD4A FE 20       	cp 32
2031   FD4C             ; 1219             a = SCREEN_HEIGHT - 1;
2032   FD4C FA 51 FD    	jp m, l_117
2033   FD4F 3E 1F       	ld a, 31
2034   FD51             l_117: 
2035   FD51             l_116: 
2036   FD51             ; 1220     }
2037   FD51             ; 1221     cyclic_rotate_right(a, 2);
2038   FD51 0F          	rrca
2039   FD52 0F          	rrca
2040   FD53             ; 1222     c = a;
2041   FD53 4F          	ld c, a
2042   FD54             ; 1223     b = (a &= 192);
2043   FD54 E6 C0       	and 192
2044   FD56 47          	ld b, a
2045   FD57             ; 1224     l = (((a = l) &= 63) |= b);
2046   FD57 7D          	ld a, l
2047   FD58 E6 3F       	and 63
2048   FD5A B0          	or b
2049   FD5B 6F          	ld l, a
2050   FD5C             ; 1225     b = ((a = c) &= 7);
2051   FD5C 79          	ld a, c
2052   FD5D E6 07       	and 7
2053   FD5F 47          	ld b, a
2054   FD60             ; 1226     h = (((a = h) &= 248) |= b);
2055   FD60 7C          	ld a, h
2056   FD61 E6 F8       	and 248
2057   FD63 B0          	or b
2058   FD64 67          	ld h, a
2059   FD65             ; 1227     PrintCharSetEscState(hl, a = 3);
2060   FD65 3E 03       	ld a, 3
2061   FD67             ; 1228 }
2062   FD67             ; 1229 
2063   FD67             ; 1230 void PrintCharSetEscState(...) {
2064   FD67             printcharsetescstate: 
2065   FD67             ; 1231     escState = a;
2066   FD67 32 5F F7    	ld (escstate), a
2067   FD6A             ; 1232     PrintCharSaveCursor(hl);
2068   FD6A             ; 1233 }
2069   FD6A             ; 1234 
2070   FD6A             ; 1235 void PrintCharSaveCursor(...) {
2071   FD6A             printcharsavecursor: 
2072   FD6A             ; 1236     cursor = hl;
2073   FD6A 22 5A F7    	ld (cursor), hl
2074   FD6D             ; 1237     PrintCharExit();
2075   FD6D             ; 1238 }
2076   FD6D             ; 1239 
2077   FD6D             ; 1240 void PrintCharExit(...) {
2078   FD6D             printcharexit: 
2079   FD6D             ; 1241     DrawCursor(b = 0xFF);
2080   FD6D 06 FF       	ld b, 255
2081   FD6F CD 77 FD    	call drawcursor
2082   FD72             ; 1242     pop(a, bc, de, hl);
2083   FD72 E1          	pop hl
2084   FD73 D1          	pop de
2085   FD74 C1          	pop bc
2086   FD75 F1          	pop af
2087   FD76 C9          	ret
2088   FD77             ; 1243 }
2089   FD77             ; 1244 
2090   FD77             ; 1245 void DrawCursor(...) {
2091   FD77             drawcursor: 
2092   FD77             ; 1246     if ((a = cursorVisible) == 0)
2093   FD77 3A 5E F7    	ld a, (cursorvisible)
2094   FD7A B7          	or a
2095   FD7B             ; 1247         return;
2096   FD7B C8          	ret z
2097   FD7C             ; 1248     hl = cursor;
2098   FD7C 2A 5A F7    	ld hl, (cursor)
2099   FD7F             ; 1249     hl += (de = -SCREEN_SIZE + 1);
2100   FD7F 11 01 F8    	ld de, 63489
2101   FD82 19          	add hl, de
2102   FD83             ; 1250     *hl = b;
2103   FD83 70          	ld (hl), b
2104   FD84 C9          	ret
2105   FD85             ; 1251 }
2106   FD85             ; 1252 
2107   FD85             ; 1253 void PrintCharEscY2(...) {
2108   FD85             printcharescy2: 
2109   FD85             ; 1254     a = c;
2110   FD85 79          	ld a, c
2111   FD86             ; 1255     a -= ' ';
2112   FD86 D6 20       	sub 32
2113   FD88             ; 1256     if (flag_m) {
2114   FD88 F2 8F FD    	jp p, l_119
2115   FD8B             ; 1257         a ^= a;
2116   FD8B AF          	xor a
2117   FD8C C3 96 FD    	jp l_120
2118   FD8F             l_119: 
2119   FD8F             ; 1258     } else {
2120   FD8F             ; 1259         if (flag_p(compare(a, SCREEN_WIDTH)))
2121   FD8F FE 40       	cp 64
2122   FD91             ; 1260             a = SCREEN_WIDTH - 1;
2123   FD91 FA 96 FD    	jp m, l_121
2124   FD94 3E 3F       	ld a, 63
2125   FD96             l_121: 
2126   FD96             l_120: 
2127   FD96             ; 1261     }
2128   FD96             ; 1262     b = a;
2129   FD96 47          	ld b, a
2130   FD97             ; 1263     l = (((a = l) &= 192) |= b);
2131   FD97 7D          	ld a, l
2132   FD98 E6 C0       	and 192
2133   FD9A B0          	or b
2134   FD9B 6F          	ld l, a
2135   FD9C             ; 1264     PrintCharResetEscState();
2136   FD9C             ; 1265 }
2137   FD9C             ; 1266 
2138   FD9C             ; 1267 void PrintCharResetEscState(...) {
2139   FD9C             printcharresetescstate: 
2140   FD9C             ; 1268     a ^= a;
2141   FD9C AF          	xor a
2142   FD9D             ; 1269     return PrintCharSetEscState();
2143   FD9D C3 67 FD    	jp printcharsetescstate
2144   FDA0             ; 1270 }
2145   FDA0             ; 1271 
2146   FDA0             ; 1272 void PrintCharEsc(...) {
2147   FDA0             printcharesc: 
2148   FDA0             ; 1273     a = c;
2149   FDA0 79          	ld a, c
2150   FDA1             ; 1274     if (a == 'Y') {
2151   FDA1 FE 59       	cp 89
2152   FDA3 C2 AB FD    	jp nz, l_123
2153   FDA6             ; 1275         a = 2;
2154   FDA6 3E 02       	ld a, 2
2155   FDA8             ; 1276         return PrintCharSetEscState();
2156   FDA8 C3 67 FD    	jp printcharsetescstate
2157   FDAB             l_123: 
2158   FDAB             ; 1277     }
2159   FDAB             ; 1278     if (a == 97) {
2160   FDAB FE 61       	cp 97
2161   FDAD C2 B4 FD    	jp nz, l_125
2162   FDB0             ; 1279         a ^= a;
2163   FDB0 AF          	xor a
2164   FDB1             ; 1280         return SetCursorVisible();
2165   FDB1 C3 B9 FD    	jp setcursorvisible
2166   FDB4             l_125: 
2167   FDB4             ; 1281     }
2168   FDB4             ; 1282     if (a != 98)
2169   FDB4 FE 62       	cp 98
2170   FDB6             ; 1283         return PrintCharResetEscState();
2171   FDB6 C2 9C FD    	jp nz, printcharresetescstate
2172   FDB9             ; 1284     SetCursorVisible();
2173   FDB9             ; 1285 }
2174   FDB9             ; 1286 
2175   FDB9             ; 1287 void SetCursorVisible(...) {
2176   FDB9             setcursorvisible: 
2177   FDB9             ; 1288     cursorVisible = a;
2178   FDB9 32 5E F7    	ld (cursorvisible), a
2179   FDBC             ; 1289     return PrintCharResetEscState();
2180   FDBC C3 9C FD    	jp printcharresetescstate
2181   FDBF             ; 1290 }
2182   FDBF             ; 1291 
2183   FDBF             ; 1292 void PrintCharNoEsc(...) {
2184   FDBF             printcharnoesc: 
2185   FDBF             ; 1293     // Остановка вывода нажатием УС + Шифт
2186   FDBF             ; 1294     do {
2187   FDBF             l_127: 
2188   FDBF             ; 1295         a = in(PORT_KEYBOARD_MODS);
2189   FDBF DB 05       	in a, (5)
2190   FDC1             l_128: 
2191   FDC1             ; 1296     } while (flag_z(a &= (KEYBOARD_US_MOD | KEYBOARD_SHIFT_MOD)));
2192   FDC1 E6 06       	and 6
2193   FDC3 CA BF FD    	jp z, l_127
2194   FDC6             ; 1297 
2195   FDC6             ; 1298     compare(a = 16, c);
2196   FDC6 3E 10       	ld a, 16
2197   FDC8 B9          	cp c
2198   FDC9             ; 1299     a = translateCodeEnabled;
2199   FDC9 3A 7D F7    	ld a, (translatecodeenabled)
2200   FDCC             ; 1300     if (flag_z) {
2201   FDCC C2 D6 FD    	jp nz, l_130
2202   FDCF             ; 1301         invert(a);
2203   FDCF 2F          	cpl
2204   FDD0             ; 1302         translateCodeEnabled = a;
2205   FDD0 32 7D F7    	ld (translatecodeenabled), a
2206   FDD3             ; 1303         return PrintCharSaveCursor();
2207   FDD3 C3 6A FD    	jp printcharsavecursor
2208   FDD6             l_130: 
2209   FDD6             ; 1304     }
2210   FDD6             ; 1305     if (a != 0)
2211   FDD6 B7          	or a
2212   FDD7             ; 1306         TranslateCodePage(c);
2213   FDD7 C4 7E F7    	call nz, translatecodepage
2214   FDDA             ; 1307     a = c;
2215   FDDA 79          	ld a, c
2216   FDDB             ; 1308     if (a == 31)
2217   FDDB FE 1F       	cp 31
2218   FDDD             ; 1309         return ClearScreen();
2219   FDDD CA F1 FD    	jp z, clearscreen
2220   FDE0             ; 1310     if (flag_m)
2221   FDE0             ; 1311         return PrintChar3(a);
2222   FDE0 FA 06 FE    	jp m, printchar3
2223   FDE3             ; 1312     PrintChar4(a);
2224   FDE3             ; 1313 }
2225   FDE3             ; 1314 
2226   FDE3             ; 1315 void PrintChar4(...) {
2227   FDE3             printchar4: 
2228   FDE3             ; 1316     *hl = a;
2229   FDE3 77          	ld (hl), a
2230   FDE4             ; 1317     hl++;
2231   FDE4 23          	inc hl
2232   FDE5             ; 1318     if (flag_m(compare(a = h, SCREEN_END >> 8)))
2233   FDE5 7C          	ld a, h
2234   FDE6 FE F0       	cp 240
2235   FDE8             ; 1319         return PrintCharSaveCursor(hl);
2236   FDE8 FA 6A FD    	jp m, printcharsavecursor
2237   FDEB             ; 1320     PrintCrLf();
2238   FDEB CD AD FE    	call printcrlf
2239   FDEE             ; 1321     PrintCharExit();
2240   FDEE C3 6D FD    	jp printcharexit
2241   FDF1             ; 1322 }
2242   FDF1             ; 1323 
2243   FDF1             ; 1324 void ClearScreen(...) {
2244   FDF1             clearscreen: 
2245   FDF1             ; 1325     b = ' ';
2246   FDF1 06 20       	ld b, 32
2247   FDF3             ; 1326     a = SCREEN_END >> 8;
2248   FDF3 3E F0       	ld a, 240
2249   FDF5             ; 1327     hl = SCREEN_ATTRIB_BEGIN;
2250   FDF5 21 00 E0    	ld hl, 57344
2251   FDF8             ; 1328     do {
2252   FDF8             l_132: 
2253   FDF8             ; 1329         *hl = b;
2254   FDF8 70          	ld (hl), b
2255   FDF9             ; 1330         hl++;
2256   FDF9 23          	inc hl
2257   FDFA             ; 1331         *hl = b;
2258   FDFA 70          	ld (hl), b
2259   FDFB             ; 1332         hl++;
2260   FDFB 23          	inc hl
2261   FDFC             l_133: 
2262   FDFC             ; 1333     } while (a != h);
2263   FDFC BC          	cp h
2264   FDFD C2 F8 FD    	jp nz, l_132
2265   FE00             ; 1334     MoveCursorHome();
2266   FE00             ; 1335 }
2267   FE00             ; 1336 
2268   FE00             ; 1337 void MoveCursorHome(...) {
2269   FE00             movecursorhome: 
2270   FE00             ; 1338     return PrintCharSaveCursor(hl = SCREEN_BEGIN);
2271   FE00 21 00 E8    	ld hl, 59392
2272   FE03 C3 6A FD    	jp printcharsavecursor
2273   FE06             ; 1339 }
2274   FE06             ; 1340 
2275   FE06             ; 1341 void PrintChar3(...) {
2276   FE06             printchar3: 
2277   FE06             ; 1342     if (a == 12)
2278   FE06 FE 0C       	cp 12
2279   FE08             ; 1343         return MoveCursorHome();
2280   FE08 CA 00 FE    	jp z, movecursorhome
2281   FE0B             ; 1344     if (a == 13)
2282   FE0B FE 0D       	cp 13
2283   FE0D             ; 1345         return MoveCursorCr(hl);
2284   FE0D CA 55 FE    	jp z, movecursorcr
2285   FE10             ; 1346     if (a == 10)
2286   FE10 FE 0A       	cp 10
2287   FE12             ; 1347         return MoveCursorLf(hl);
2288   FE12 CA 6A FE    	jp z, movecursorlf
2289   FE15             ; 1348     if (a == 8)
2290   FE15 FE 08       	cp 8
2291   FE17             ; 1349         return MoveCursorLeft(hl);
2292   FE17 CA 66 FE    	jp z, movecursorleft
2293   FE1A             ; 1350     if (a == 24)
2294   FE1A FE 18       	cp 24
2295   FE1C             ; 1351         return MoveCursorRight(hl);
2296   FE1C CA 5C FE    	jp z, movecursorright
2297   FE1F             ; 1352     if (a == 25)
2298   FE1F FE 19       	cp 25
2299   FE21             ; 1353         return MoveCursorUp(hl);
2300   FE21 CA A0 FE    	jp z, movecursorup
2301   FE24             ; 1354     if (a == 7)
2302   FE24 FE 07       	cp 7
2303   FE26             ; 1355         return PrintCharBeep();
2304   FE26 CA 38 FE    	jp z, printcharbeep
2305   FE29             ; 1356     if (a == 26)
2306   FE29 FE 1A       	cp 26
2307   FE2B             ; 1357         return MoveCursorDown();
2308   FE2B CA A7 FE    	jp z, movecursordown
2309   FE2E             ; 1358     if (a != 27)
2310   FE2E FE 1B       	cp 27
2311   FE30             ; 1359         return PrintChar4(hl, a);
2312   FE30 C2 E3 FD    	jp nz, printchar4
2313   FE33             ; 1360     a = 1;
2314   FE33 3E 01       	ld a, 1
2315   FE35             ; 1361     PrintCharSetEscState();
2316   FE35 C3 67 FD    	jp printcharsetescstate
2317   FE38             ; 1362 }
2318   FE38             ; 1363 
2319   FE38             ; 1364 void PrintCharBeep(...) {
2320   FE38             printcharbeep: 
2321   FE38             ; 1365     c = 128;  // Длительность
2322   FE38 0E 80       	ld c, 128
2323   FE3A             ; 1366     e = 32;   // Частота
2324   FE3A 1E 20       	ld e, 32
2325   FE3C             ; 1367     do {
2326   FE3C             l_135: 
2327   FE3C             ; 1368         d = e;
2328   FE3C 53          	ld d, e
2329   FE3D             ; 1369         do {
2330   FE3D             l_138: 
2331   FE3D             ; 1370             out(PORT_KEYBOARD_MODE, a = 1 | (7 << 1));
2332   FE3D 3E 0F       	ld a, 15
2333   FE3F D3 04       	out (4), a
2334   FE41             l_139: 
2335   FE41             ; 1371         } while (flag_nz(e--));
2336   FE41 1D          	dec e
2337   FE42 C2 3D FE    	jp nz, l_138
2338   FE45             ; 1372         e = d;
2339   FE45 5A          	ld e, d
2340   FE46             ; 1373         do {
2341   FE46             l_141: 
2342   FE46             ; 1374             out(PORT_KEYBOARD_MODE, a = (7 << 1));
2343   FE46 3E 0E       	ld a, 14
2344   FE48 D3 04       	out (4), a
2345   FE4A             l_142: 
2346   FE4A             ; 1375         } while (flag_nz(d--));
2347   FE4A 15          	dec d
2348   FE4B C2 46 FE    	jp nz, l_141
2349   FE4E             l_136: 
2350   FE4E             ; 1376     } while (flag_nz(c--));
2351   FE4E 0D          	dec c
2352   FE4F C2 3C FE    	jp nz, l_135
2353   FE52             ; 1377 
2354   FE52             ; 1378     PrintCharExit();
2355   FE52 C3 6D FD    	jp printcharexit
2356   FE55             ; 1379 }
2357   FE55             ; 1380 
2358   FE55             ; 1381 void MoveCursorCr(...) {
2359   FE55             movecursorcr: 
2360   FE55             ; 1382     l = ((a = l) &= ~(SCREEN_WIDTH - 1));
2361   FE55 7D          	ld a, l
2362   FE56 E6 C0       	and 192
2363   FE58 6F          	ld l, a
2364   FE59             ; 1383     PrintCharSaveCursor(hl);
2365   FE59 C3 6A FD    	jp printcharsavecursor
2366   FE5C             ; 1384 }
2367   FE5C             ; 1385 
2368   FE5C             ; 1386 void MoveCursorRight(...) {
2369   FE5C             movecursorright: 
2370   FE5C             ; 1387     hl++;
2371   FE5C 23          	inc hl
2372   FE5D             ; 1388     MoveCursorBoundary(hl);
2373   FE5D             ; 1389 }
2374   FE5D             ; 1390 
2375   FE5D             ; 1391 void MoveCursorBoundary(...) {
2376   FE5D             movecursorboundary: 
2377   FE5D             ; 1392     a = h;
2378   FE5D 7C          	ld a, h
2379   FE5E             ; 1393     a &= 7;
2380   FE5E E6 07       	and 7
2381   FE60             ; 1394     a |= SCREEN_BEGIN >> 8;
2382   FE60 F6 E8       	or 232
2383   FE62             ; 1395     h = a;
2384   FE62 67          	ld h, a
2385   FE63             ; 1396     PrintCharSaveCursor(hl);
2386   FE63 C3 6A FD    	jp printcharsavecursor
2387   FE66             ; 1397 }
2388   FE66             ; 1398 
2389   FE66             ; 1399 void MoveCursorLeft(...) {
2390   FE66             movecursorleft: 
2391   FE66             ; 1400     hl--;
2392   FE66 2B          	dec hl
2393   FE67             ; 1401     MoveCursorBoundary(hl);
2394   FE67 C3 5D FE    	jp movecursorboundary
2395   FE6A             ; 1402 }
2396   FE6A             ; 1403 
2397   FE6A             ; 1404 void MoveCursorLf(...) {
2398   FE6A             movecursorlf: 
2399   FE6A             ; 1405     hl += (bc = SCREEN_WIDTH);
2400   FE6A 01 40 00    	ld bc, 64
2401   FE6D 09          	add hl, bc
2402   FE6E             ; 1406     TryScrollUp(hl);
2403   FE6E             ; 1407 }
2404   FE6E             ; 1408 
2405   FE6E             ; 1409 void TryScrollUp(...) {
2406   FE6E             tryscrollup: 
2407   FE6E             ; 1410     if (flag_m(compare(a = h, SCREEN_END >> 8)))
2408   FE6E 7C          	ld a, h
2409   FE6F FE F0       	cp 240
2410   FE71             ; 1411         return PrintCharSaveCursor(hl);
2411   FE71 FA 6A FD    	jp m, printcharsavecursor
2412   FE74             ; 1412 
2413   FE74             ; 1413     hl = SCREEN_BEGIN;
2414   FE74 21 00 E8    	ld hl, 59392
2415   FE77             ; 1414     bc = (SCREEN_BEGIN + SCREEN_WIDTH);
2416   FE77 01 40 E8    	ld bc, 59456
2417   FE7A             ; 1415     do {
2418   FE7A             l_144: 
2419   FE7A             ; 1416         *hl = a = *bc;
2420   FE7A 0A          	ld a, (bc)
2421   FE7B 77          	ld (hl), a
2422   FE7C             ; 1417         hl++;
2423   FE7C 23          	inc hl
2424   FE7D             ; 1418         bc++;
2425   FE7D 03          	inc bc
2426   FE7E             ; 1419         *hl = a = *bc;
2427   FE7E 0A          	ld a, (bc)
2428   FE7F 77          	ld (hl), a
2429   FE80             ; 1420         hl++;
2430   FE80 23          	inc hl
2431   FE81             ; 1421         bc++;
2432   FE81 03          	inc bc
2433   FE82             l_145: 
2434   FE82             ; 1422     } while (flag_m(compare(a = b, SCREEN_END >> 8)));
2435   FE82 78          	ld a, b
2436   FE83 FE F0       	cp 240
2437   FE85 FA 7A FE    	jp m, l_144
2438   FE88             ; 1423     a = SCREEN_END >> 8;
2439   FE88 3E F0       	ld a, 240
2440   FE8A             ; 1424     c = ' ';
2441   FE8A 0E 20       	ld c, 32
2442   FE8C             ; 1425     do {
2443   FE8C             l_147: 
2444   FE8C             ; 1426         *hl = c;
2445   FE8C 71          	ld (hl), c
2446   FE8D             ; 1427         hl++;
2447   FE8D 23          	inc hl
2448   FE8E             ; 1428         *hl = c;
2449   FE8E 71          	ld (hl), c
2450   FE8F             ; 1429         hl++;
2451   FE8F 23          	inc hl
2452   FE90             l_148: 
2453   FE90             ; 1430     } while (a != h);
2454   FE90 BC          	cp h
2455   FE91 C2 8C FE    	jp nz, l_147
2456   FE94             ; 1431     hl = cursor;
2457   FE94 2A 5A F7    	ld hl, (cursor)
2458   FE97             ; 1432     h = ((SCREEN_END >> 8) - 1);
2459   FE97 26 EF       	ld h, 239
2460   FE99             ; 1433     l = ((a = l) |= 192);
2461   FE99 7D          	ld a, l
2462   FE9A F6 C0       	or 192
2463   FE9C 6F          	ld l, a
2464   FE9D             ; 1434     PrintCharSaveCursor(hl);
2465   FE9D C3 6A FD    	jp printcharsavecursor
2466   FEA0             ; 1435 }
2467   FEA0             ; 1436 
2468   FEA0             ; 1437 void MoveCursorUp(...) {
2469   FEA0             movecursorup: 
2470   FEA0             ; 1438     MoveCursor(hl, bc = -SCREEN_WIDTH);
2471   FEA0 01 C0 FF    	ld bc, 65472
2472   FEA3             ; 1439 }
2473   FEA3             ; 1440 
2474   FEA3             ; 1441 void MoveCursor(...) {
2475   FEA3             movecursor: 
2476   FEA3             ; 1442     hl += bc;
2477   FEA3 09          	add hl, bc
2478   FEA4             ; 1443     MoveCursorBoundary(hl);
2479   FEA4 C3 5D FE    	jp movecursorboundary
2480   FEA7             ; 1444 }
2481   FEA7             ; 1445 
2482   FEA7             ; 1446 void MoveCursorDown(...) {
2483   FEA7             movecursordown: 
2484   FEA7             ; 1447     MoveCursor(hl, bc = SCREEN_WIDTH);
2485   FEA7 01 40 00    	ld bc, 64
2486   FEAA C3 A3 FE    	jp movecursor
2487   FEAD             ; 1448 }
2488   FEAD             ; 1449 
2489   FEAD             ; 1450 void PrintCrLf() {
2490   FEAD             printcrlf: 
2491   FEAD             ; 1451     PrintChar(c = 13);
2492   FEAD 0E 0D       	ld c, 13
2493   FEAF CD 23 FD    	call printchar
2494   FEB2             ; 1452     PrintChar(c = 10);
2495   FEB2 0E 0A       	ld c, 10
2496   FEB4 C3 23 FD    	jp printchar
2497   FEB7             ; 1453 }
2498   FEB7             ; 1454 
2499   FEB7             ; 1455 // Функция для пользовательской программы.
2500   FEB7             ; 1456 // Нажата ли хотя бы одна клавиша на клавиатуре?
2501   FEB7             ; 1457 // Параметры: нет. Результат:  a - 0xFF если клавиша нажата, 0 если нет. Сохраняет: bc, de, hl.
2502   FEB7             ; 1458 
2503   FEB7             ; 1459 void IsAnyKeyPressed() {
2504   FEB7             isanykeypressed: 
2505   FEB7             ; 1460     out(PORT_KEYBOARD_COLUMN, a ^= a);
2506   FEB7 AF          	xor a
2507   FEB8 D3 07       	out (7), a
2508   FEBA             ; 1461     a = in(PORT_KEYBOARD_ROW);
2509   FEBA DB 06       	in a, (6)
2510   FEBC             ; 1462     a &= KEYBOARD_ROW_MASK;
2511   FEBC E6 7F       	and 127
2512   FEBE             ; 1463     if (a == KEYBOARD_ROW_MASK) {
2513   FEBE FE 7F       	cp 127
2514   FEC0 C2 C5 FE    	jp nz, l_150
2515   FEC3             ; 1464         a ^= a;
2516   FEC3 AF          	xor a
2517   FEC4             ; 1465         return;
2518   FEC4 C9          	ret
2519   FEC5             l_150: 
2520   FEC5             ; 1466     }
2521   FEC5             ; 1467     a = 0xFF;
2522   FEC5 3E FF       	ld a, 255
2523   FEC7 C9          	ret
2524   FEC8             ; 1468 }
2525   FEC8             ; 1469 
2526   FEC8             ; 1470 // Функция для пользовательской программы.
2527   FEC8             ; 1471 // Получить код нажатой клавиши на клавиатуре.
2528   FEC8             ; 1472 // В отличии от функции ScanKey, в этой функции есть задержка повтора.
2529   FEC8             ; 1473 // Параметры: нет. Результат: a. Сохраняет: bc, de, hl.
2530   FEC8             ; 1474 
2531   FEC8             ; 1475 void ReadKey() {
2532   FEC8             readkey: 
2533   FEC8             ; 1476     push_pop(hl) {
2534   FEC8 E5          	push hl
2535   FEC9             ; 1477         hl = keyDelay;
2536   FEC9 2A 60 F7    	ld hl, (keydelay)
2537   FECC             ; 1478         ReadKeyInternal(hl);
2538   FECC CD E8 FE    	call readkeyinternal
2539   FECF             ; 1479         l = 32;         // Задержка повтора нажатия клавиши
2540   FECF 2E 20       	ld l, 32
2541   FED1             ; 1480         if (flag_nz) {  // Не таймаут
2542   FED1 CA E3 FE    	jp z, l_152
2543   FED4             ; 1481             do {
2544   FED4             l_154: 
2545   FED4             ; 1482                 do {
2546   FED4             l_157: 
2547   FED4             ; 1483                     l = 2;
2548   FED4 2E 02       	ld l, 2
2549   FED6             ; 1484                     ReadKeyInternal(hl);
2550   FED6 CD E8 FE    	call readkeyinternal
2551   FED9             l_158: 
2552   FED9 C2 D4 FE    	jp nz, l_157
2553   FEDC             l_155: 
2554   FEDC             ; 1485                 } while (flag_nz);  // Цикл длится, пока не наступит таймаут
2555   FEDC             ; 1486             } while (a >= 128);     // Цикл длится, пока не нажата клавиша
2556   FEDC FE 80       	cp 128
2557   FEDE D2 D4 FE    	jp nc, l_154
2558   FEE1             ; 1487             l = 128;                // Задержка повтора первого нажатия клавиши
2559   FEE1 2E 80       	ld l, 128
2560   FEE3             l_152: 
2561   FEE3             ; 1488         }
2562   FEE3             ; 1489         keyDelay = hl;
2563   FEE3 22 60 F7    	ld (keydelay), hl
2564   FEE6 E1          	pop hl
2565   FEE7 C9          	ret
2566   FEE8             ; 1490     }
2567   FEE8             ; 1491 }
2568   FEE8             ; 1492 
2569   FEE8             ; 1493 void ReadKeyInternal(...) {
2570   FEE8             readkeyinternal: 
2571   FEE8             ; 1494     do {
2572   FEE8             l_160: 
2573   FEE8             ; 1495         ScanKey();
2574   FEE8 CD FE FE    	call scankey
2575   FEEB             ; 1496         if (a != h)
2576   FEEB BC          	cp h
2577   FEEC             ; 1497             break;
2578   FEEC C2 FC FE    	jp nz, l_162
2579   FEEF             ; 1498 
2580   FEEF             ; 1499         // Задержка
2581   FEEF             ; 1500         push_pop(a) {
2582   FEEF F5          	push af
2583   FEF0             ; 1501             a ^= a;
2584   FEF0 AF          	xor a
2585   FEF1             ; 1502             do {
2586   FEF1             l_163: 
2587   FEF1             ; 1503                 swap(hl, de);
2588   FEF1 EB          	ex hl, de
2589   FEF2             ; 1504                 swap(hl, de);
2590   FEF2 EB          	ex hl, de
2591   FEF3             l_164: 
2592   FEF3             ; 1505             } while (flag_nz(a--));
2593   FEF3 3D          	dec a
2594   FEF4 C2 F1 FE    	jp nz, l_163
2595   FEF7 F1          	pop af
2596   FEF8             l_161: 
2597   FEF8             ; 1506         }
2598   FEF8             ; 1507     } while (flag_nz(l--));
2599   FEF8 2D          	dec l
2600   FEF9 C2 E8 FE    	jp nz, l_160
2601   FEFC             l_162: 
2602   FEFC             ; 1508     h = a;
2603   FEFC 67          	ld h, a
2604   FEFD C9          	ret
2605   FEFE             ; 1509 }
2606   FEFE             ; 1510 
2607   FEFE             ; 1511 // Функция для пользовательской программы.
2608   FEFE             ; 1512 // Получить код нажатой клавиши на клавиатуре.
2609   FEFE             ; 1513 // Параметры: нет. Результат: a. Сохраняет: bc, de, hl.
2610   FEFE             ; 1514 
2611   FEFE             ; 1515 void ScanKey() {
2612   FEFE             scankey: 
2613   FEFE             ; 1516     push(bc, de, hl);
2614   FEFE C5          	push bc
2615   FEFF D5          	push de
2616   FF00 E5          	push hl
2617   FF01             ; 1517 
2618   FF01             ; 1518     bc = 0x00FE;
2619   FF01 01 FE 00    	ld bc, 254
2620   FF04             ; 1519     d = KEYBOARD_COLUMN_COUNT;
2621   FF04 16 08       	ld d, 8
2622   FF06             ; 1520     do {
2623   FF06             l_166: 
2624   FF06             ; 1521         a = c;
2625   FF06 79          	ld a, c
2626   FF07             ; 1522         out(PORT_KEYBOARD_COLUMN, a);
2627   FF07 D3 07       	out (7), a
2628   FF09             ; 1523         cyclic_rotate_left(a, 1);
2629   FF09 07          	rlca
2630   FF0A             ; 1524         c = a;
2631   FF0A 4F          	ld c, a
2632   FF0B             ; 1525         a = in(PORT_KEYBOARD_ROW);
2633   FF0B DB 06       	in a, (6)
2634   FF0D             ; 1526         a &= KEYBOARD_ROW_MASK;
2635   FF0D E6 7F       	and 127
2636   FF0F             ; 1527         if (a != KEYBOARD_ROW_MASK)
2637   FF0F FE 7F       	cp 127
2638   FF11             ; 1528             return ScanKey2(a);
2639   FF11 C2 28 FF    	jp nz, scankey2
2640   FF14             ; 1529         b = ((a = b) += KEYBOARD_ROW_COUNT);
2641   FF14 78          	ld a, b
2642   FF15 C6 07       	add 7
2643   FF17 47          	ld b, a
2644   FF18             l_167: 
2645   FF18             ; 1530     } while (flag_nz(d--));
2646   FF18 15          	dec d
2647   FF19 C2 06 FF    	jp nz, l_166
2648   FF1C             ; 1531 
2649   FF1C             ; 1532     a = in(PORT_KEYBOARD_MODS);
2650   FF1C DB 05       	in a, (5)
2651   FF1E             ; 1533     carry_rotate_right(a, 1);
2652   FF1E 1F          	rra
2653   FF1F             ; 1534     a = 0xFF;  // Клавиша не нажата
2654   FF1F 3E FF       	ld a, 255
2655   FF21             ; 1535     if (flag_c)
2656   FF21             ; 1536         return ScanKeyExit(a);
2657   FF21 DA 64 FF    	jp c, scankeyexit
2658   FF24             ; 1537     a--;  // Рус/Лат
2659   FF24 3D          	dec a
2660   FF25             ; 1538     ScanKeyExit(a);
2661   FF25 C3 64 FF    	jp scankeyexit
2662   FF28             ; 1539 }
2663   FF28             ; 1540 
2664   FF28             ; 1541 void ScanKey2(...) {
2665   FF28             scankey2: 
2666   FF28             ; 1542     for (;;) {
2667   FF28             l_170: 
2668   FF28             ; 1543         carry_rotate_right(a, 1);
2669   FF28 1F          	rra
2670   FF29             ; 1544         if (flag_nc)
2671   FF29             ; 1545             break;
2672   FF29 D2 30 FF    	jp nc, l_171
2673   FF2C             ; 1546         b++;
2674   FF2C 04          	inc b
2675   FF2D C3 28 FF    	jp l_170
2676   FF30             l_171: 
2677   FF30             ; 1547     }
2678   FF30             ; 1548 
2679   FF30             ; 1549     /* b - key number */
2680   FF30             ; 1550 
2681   FF30             ; 1551     /*  0    0    1 !   2 "   3 #   4 $   5 %   6 &   7 ,
2682   FF30             ; 1552      *  8   8 (   9 )   : *   ; +   , <   - =   . >   / ?
2683   FF30             ; 1553      * 16   @ Ю   A А   B Б   C Ц   D Д   E Е   F Ф   G Г
2684   FF30             ; 1554      * 24   H Х   I И   J Й   K К   L Л   M М   N Н   O О
2685   FF30             ; 1555      * 32   P П   Q Я   R Р   S С   T Т   U У   V Ж   W В
2686   FF30             ; 1556      * 40   X Ь   Y Ы   Z З   [ Ш   \ Э   ] Щ   ^ Ч    _
2687   FF30             ; 1557      * 48   Space Right Left  Up    Down  Vk    Str   Home */
2688   FF30             ; 1558 
2689   FF30             ; 1559     a = b;
2690   FF30 78          	ld a, b
2691   FF31             ; 1560     if (a >= 48)
2692   FF31 FE 30       	cp 48
2693   FF33             ; 1561         return ScanKeySpecial(a);
2694   FF33 D2 8A FF    	jp nc, scankeyspecial
2695   FF36             ; 1562     a += 48;
2696   FF36 C6 30       	add 48
2697   FF38             ; 1563     if (a >= 60)
2698   FF38 FE 3C       	cp 60
2699   FF3A             ; 1564         if (a < 64)
2700   FF3A DA 44 FF    	jp c, l_172
2701   FF3D FE 40       	cp 64
2702   FF3F             ; 1565             a &= 47;
2703   FF3F D2 44 FF    	jp nc, l_174
2704   FF42 E6 2F       	and 47
2705   FF44             l_174: 
2706   FF44             l_172: 
2707   FF44             ; 1566 
2708   FF44             ; 1567     if (a == 95)
2709   FF44 FE 5F       	cp 95
2710   FF46             ; 1568         a = 127;
2711   FF46 C2 4B FF    	jp nz, l_176
2712   FF49 3E 7F       	ld a, 127
2713   FF4B             l_176: 
2714   FF4B             ; 1569 
2715   FF4B             ; 1570     c = a;
2716   FF4B 4F          	ld c, a
2717   FF4C             ; 1571     a = in(PORT_KEYBOARD_MODS);
2718   FF4C DB 05       	in a, (5)
2719   FF4E             ; 1572     a &= KEYBOARD_MODS_MASK;
2720   FF4E E6 07       	and 7
2721   FF50             ; 1573     compare(a, KEYBOARD_MODS_MASK);
2722   FF50 FE 07       	cp 7
2723   FF52             ; 1574     b = a;
2724   FF52 47          	ld b, a
2725   FF53             ; 1575     a = c;
2726   FF53 79          	ld a, c
2727   FF54             ; 1576     if (flag_z)
2728   FF54             ; 1577         return ScanKeyExit(a);
2729   FF54 CA 64 FF    	jp z, scankeyexit
2730   FF57             ; 1578     a = b;
2731   FF57 78          	ld a, b
2732   FF58             ; 1579     carry_rotate_right(a, 2);
2733   FF58 1F          	rra
2734   FF59 1F          	rra
2735   FF5A             ; 1580     if (flag_nc)
2736   FF5A             ; 1581         return ScanKeyControl(c);
2737   FF5A D2 68 FF    	jp nc, scankeycontrol
2738   FF5D             ; 1582     carry_rotate_right(a, 1);
2739   FF5D 1F          	rra
2740   FF5E             ; 1583     if (flag_nc)
2741   FF5E             ; 1584         return ScanKeyShift();
2742   FF5E D2 6E FF    	jp nc, scankeyshift
2743   FF61             ; 1585     (a = c) |= 0x20;
2744   FF61 79          	ld a, c
2745   FF62 F6 20       	or 32
2746   FF64             ; 1586     ScanKeyExit(a);
2747   FF64             ; 1587 }
2748   FF64             ; 1588 
2749   FF64             ; 1589 void ScanKeyExit(...) {
2750   FF64             scankeyexit: 
2751   FF64             ; 1590     pop(bc, de, hl);
2752   FF64 E1          	pop hl
2753   FF65 D1          	pop de
2754   FF66 C1          	pop bc
2755   FF67 C9          	ret
2756   FF68             ; 1591 }
2757   FF68             ; 1592 
2758   FF68             ; 1593 void ScanKeyControl(...) {
2759   FF68             scankeycontrol: 
2760   FF68             ; 1594     a = c;
2761   FF68 79          	ld a, c
2762   FF69             ; 1595     a &= 0x1F;
2763   FF69 E6 1F       	and 31
2764   FF6B             ; 1596     return ScanKeyExit(a);
2765   FF6B C3 64 FF    	jp scankeyexit
2766   FF6E             ; 1597 }
2767   FF6E             ; 1598 
2768   FF6E             ; 1599 void ScanKeyShift(...) {
2769   FF6E             scankeyshift: 
2770   FF6E             ; 1600     a = c;
2771   FF6E 79          	ld a, c
2772   FF6F             ; 1601     if (a == 127)
2773   FF6F FE 7F       	cp 127
2774   FF71             ; 1602         a = 95;
2775   FF71 C2 76 FF    	jp nz, l_178
2776   FF74 3E 5F       	ld a, 95
2777   FF76             l_178: 
2778   FF76             ; 1603     if (a >= 64)
2779   FF76 FE 40       	cp 64
2780   FF78             ; 1604         return ScanKeyExit(a);
2781   FF78 D2 64 FF    	jp nc, scankeyexit
2782   FF7B             ; 1605     if (a < 48) {
2783   FF7B FE 30       	cp 48
2784   FF7D D2 85 FF    	jp nc, l_180
2785   FF80             ; 1606         a |= 16;
2786   FF80 F6 10       	or 16
2787   FF82             ; 1607         return ScanKeyExit(a);
2788   FF82 C3 64 FF    	jp scankeyexit
2789   FF85             l_180: 
2790   FF85             ; 1608     }
2791   FF85             ; 1609     a &= 47;
2792   FF85 E6 2F       	and 47
2793   FF87             ; 1610     ScanKeyExit();
2794   FF87 C3 64 FF    	jp scankeyexit
2795   FF8A             ; 1611 }
2796   FF8A             ; 1612 
2797   FF8A             ; 1613 void ScanKeySpecial(...) {
2798   FF8A             scankeyspecial: 
2799   FF8A             ; 1614     hl = specialKeyTable;
2800   FF8A 21 97 FF    	ld hl, 0FFFFh & (specialkeytable)
2801   FF8D             ; 1615     c = (a -= 48);
2802   FF8D D6 30       	sub 48
2803   FF8F 4F          	ld c, a
2804   FF90             ; 1616     b = 0;
2805   FF90 06 00       	ld b, 0
2806   FF92             ; 1617     hl += bc;
2807   FF92 09          	add hl, bc
2808   FF93             ; 1618     a = *hl;
2809   FF93 7E          	ld a, (hl)
2810   FF94             ; 1619     ScanKeyExit(a);
2811   FF94 C3 64 FF    	jp scankeyexit
2812   FF97             ; 1620 }
2813   FF97             ; 1621 
2814   FF97             ; 1622 uint8_t specialKeyTable[] = {
2815   FF97             specialkeytable: 
2816   FF97 20          	db 32
2817   FF98 18          	db 24
2818   FF99 08          	db 8
2819   FF9A 19          	db 25
2820   FF9B 1A          	db 26
2821   FF9C 0D          	db 13
2822   FF9D 1F          	db 31
2823   FF9E 0C          	db 12
2824   FF9F             ; 1633  aPrompt[] = "\r\n-->";
2825   FF9F             aprompt: 
2826   FF9F 0D          	db 13
2827   FFA0 0A          	db 10
2828   FFA1 2D          	db 45
2829   FFA2 2D          	db 45
2830   FFA3 3E          	db 62
2831   FFA4 00          	ds 1
2832   FFA5             ; 1634  aCrLfTab[] = "\r\n\x18\x18\x18";
2833   FFA5             acrlftab: 
2834   FFA5 0D          	db 13
2835   FFA6 0A          	db 10
2836   FFA7 18          	db 24
2837   FFA8 18          	db 24
2838   FFA9 18          	db 24
2839   FFAA 00          	ds 1
2840   FFAB             ; 1635  aRegisters[] = "\r\nPC-\r\nHL-\r\nBC-\r\nDE-\r\nSP-\r\nAF-\x19\x19\x19\x19\x19\x19";
2841   FFAB             aregisters: 
2842   FFAB 0D          	db 13
2843   FFAC 0A          	db 10
2844   FFAD 50          	db 80
2845   FFAE 43          	db 67
2846   FFAF 2D          	db 45
2847   FFB0 0D          	db 13
2848   FFB1 0A          	db 10
2849   FFB2 48          	db 72
2850   FFB3 4C          	db 76
2851   FFB4 2D          	db 45
2852   FFB5 0D          	db 13
2853   FFB6 0A          	db 10
2854   FFB7 42          	db 66
2855   FFB8 43          	db 67
2856   FFB9 2D          	db 45
2857   FFBA 0D          	db 13
2858   FFBB 0A          	db 10
2859   FFBC 44          	db 68
2860   FFBD 45          	db 69
2861   FFBE 2D          	db 45
2862   FFBF 0D          	db 13
2863   FFC0 0A          	db 10
2864   FFC1 53          	db 83
2865   FFC2 50          	db 80
2866   FFC3 2D          	db 45
2867   FFC4 0D          	db 13
2868   FFC5 0A          	db 10
2869   FFC6 41          	db 65
2870   FFC7 46          	db 70
2871   FFC8 2D          	db 45
2872   FFC9 19          	db 25
2873   FFCA 19          	db 25
2874   FFCB 19          	db 25
2875   FFCC 19          	db 25
2876   FFCD 19          	db 25
2877   FFCE 19          	db 25
2878   FFCF 00          	ds 1
2879   FFD0             ; 1636  aBackspace[] = "\x08 \x08";
2880   FFD0             abackspace: 
2881   FFD0 08          	db 8
2882   FFD1 20          	db 32
2883   FFD2 08          	db 8
2884   FFD3 00          	ds 1
2885   FFD4             ; 1637  aHello[] = "\x1F\nМ/80К ";
2886   FFD4             ahello: 
2887   FFD4 1F          	db 31
2888   FFD5 0A          	db 10
2889   FFD6 6D          	db 109
2890   FFD7 2F          	db 47
2891   FFD8 38          	db 56
2892   FFD9 30          	db 48
2893   FFDA 6B          	db 107
2894   FFDB 20          	db 32
2895   FFDC 00          	ds 1
2896   FFDD             ; 1639  TranslateCodePageDefault(...) {
2897   FFDD             translatecodepagedefault: 
2898   FFDD C9          	ret
2899   FFDE             ; 1640 }
2900   FFDE             ; 1641 
2901   FFDE             ; 1642 uint8_t padding[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
2902   FFDE             padding: 
2903   FFDE FF          	db 255
2904   FFDF FF          	db 255
2905   FFE0 FF          	db 255
2906   FFE1 FF          	db 255
2907   FFE2 FF          	db 255
2908   FFE3 FF          	db 255
2909   FFE4 FF          	db 255
2910   FFE5 FF          	db 255
2911   FFE6 FF          	db 255
2912   FFE7 FF          	db 255
2913   FFE8 FF          	db 255
2914   FFE9 FF          	db 255
2915   FFEA FF          	db 255
2916   FFEB FF          	db 255
2917   FFEC FF          	db 255
2918   FFED FF          	db 255
2919   FFEE FF          	db 255
2920   FFEF FF          	db 255
2921   FFF0 FF          	db 255
2922   FFF1 FF          	db 255
2923   FFF2 FF          	db 255
2924   FFF3 FF          	db 255
2925   FFF4 FF          	db 255
2926   FFF5 FF          	db 255
2927   FFF6 FF          	db 255
2928   FFF7 FF          	db 255
2929   FFF8 FF          	db 255
2930   FFF9 FF          	db 255
2931   FFFA FF          	db 255
2932   FFFB FF          	db 255
2933   FFFC FF          	db 255
2934   FFFD FF          	db 255
2935   FFFE FF          	db 255
2936   FFFF FF          	db 255
2937   0000              savebin "micro80.bin", 0xF800, 0x10000
2938   0000             
