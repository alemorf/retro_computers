0001   0000                 device zxspectrum48 ; It has nothing to do with ZX Spectrum 48K, it is needed for the sjasmplus compiler.
0002   0000             rst30opcode equ 48
0003   0000             rst30address equ 49
0004   0000             rst38opcode equ 56
0005   0000             rst38address equ 57
0006   0000             pressedkey equ 63321
0007   0000             cursor equ 63322
0008   0000             tapereadspeed equ 63324
0009   0000             tapewritespeed equ 63325
0010   0000             cursorvisible equ 63326
0011   0000             escstate equ 63327
0012   0000             keydelay equ 63328
0013   0000             regpc equ 63330
0014   0000             reghl equ 63332
0015   0000             regbc equ 63334
0016   0000             regde equ 63336
0017   0000             regsp equ 63338
0018   0000             regaf equ 63340
0019   0000             breakpointaddress equ 63345
0020   0000             breakpointvalue equ 63347
0021   0000             jmpparam1opcode equ 63348
0022   0000             param1 equ 63349
0023   0000             param2 equ 63351
0024   0000             param3 equ 63353
0025   0000             param2exists equ 63355
0026   0000             tapepolarity equ 63356
0027   0000             translatecodeenabled equ 63357
0028   0000             translatecodepagejump equ 63358
0029   0000             translatecodepageaddress equ 63359
0030   0000             ramtop equ 63361
0031   0000             inputbuffer equ 63363
0032   0000             jmpparam1 equ 63348
0033   0000             translatecodepage equ 63358
0034   0000              .org 0xF800
0035   F800             ; 52  uint8_t rst30Opcode __address(0x30);
0036   F800             ; 53 extern uint16_t rst30Address __address(0x31);
0037   F800             ; 54 extern uint8_t rst38Opcode __address(0x38);
0038   F800             ; 55 extern uint16_t rst38Address __address(0x39);
0039   F800             ; 56 
0040   F800             ; 57 // Прототипы
0041   F800             ; 58 void Reboot(...);
0042   F800             ; 59 void EntryF86C_Monitor(...);
0043   F800             ; 60 void Reboot2(...);
0044   F800             ; 61 void Monitor(...);
0045   F800             ; 62 void Monitor2();
0046   F800             ; 63 void ReadStringBackspace(...);
0047   F800             ; 64 void ReadString(...);
0048   F800             ; 65 void ReadStringBegin(...);
0049   F800             ; 66 void ReadStringLoop(...);
0050   F800             ; 67 void ReadStringExit(...);
0051   F800             ; 68 void PrintString(...);
0052   F800             ; 69 void ParseParams(...);
0053   F800             ; 70 void ParseWord(...);
0054   F800             ; 71 void ParseWordReturnCf(...);
0055   F800             ; 72 void CompareHlDe(...);
0056   F800             ; 73 void LoopWithBreak(...);
0057   F800             ; 74 void Loop(...);
0058   F800             ; 75 void PopRet();
0059   F800             ; 76 void IncHl(...);
0060   F800             ; 77 void CtrlC(...);
0061   F800             ; 78 void PrintCrLfTab();
0062   F800             ; 79 void PrintHexByteFromHlSpace(...);
0063   F800             ; 80 void PrintHexByteSpace(...);
0064   F800             ; 81 void CmdR(...);
0065   F800             ; 82 void GetRamTop(...);
0066   F800             ; 83 void SetRamTop(...);
0067   F800             ; 84 void CmdA(...);
0068   F800             ; 85 void CmdD(...);
0069   F800             ; 86 void PrintSpacesTo(...);
0070   F800             ; 87 void PrintSpace();
0071   F800             ; 88 void CmdC(...);
0072   F800             ; 89 void CmdF(...);
0073   F800             ; 90 void CmdS(...);
0074   F800             ; 91 void CmdW(...);
0075   F800             ; 92 void CmdT(...);
0076   F800             ; 93 void CmdM(...);
0077   F800             ; 94 void CmdG(...);
0078   F800             ; 95 void BreakPointHandler(...);
0079   F800             ; 96 void CmdX(...);
0080   F800             ; 97 void GetCursor();
0081   F800             ; 98 void GetCursorChar();
0082   F800             ; 99 void CmdH(...);
0083   F800             ; 100 void CmdI(...);
0084   F800             ; 101 void MonitorError();
0085   F800             ; 102 void ReadTapeFile(...);
0086   F800             ; 103 void ReadTapeWordNext();
0087   F800             ; 104 void ReadTapeWord(...);
0088   F800             ; 105 void ReadTapeBlock(...);
0089   F800             ; 106 void CalculateCheckSum(...);
0090   F800             ; 107 void CmdO(...);
0091   F800             ; 108 void WriteTapeFile(...);
0092   F800             ; 109 void PrintCrLfTabHexWordSpace(...);
0093   F800             ; 110 void PrintHexWordSpace(...);
0094   F800             ; 111 void WriteTapeBlock(...);
0095   F800             ; 112 void WriteTapeWord(...);
0096   F800             ; 113 void ReadTapeByte(...);
0097   F800             ; 114 void ReadTapeByteInternal(...);
0098   F800             ; 115 void ReadTapeByteTimeout(...);
0099   F800             ; 116 void WriteTapeByte(...);
0100   F800             ; 117 void PrintHexByte(...);
0101   F800             ; 118 void PrintHexNibble(...);
0102   F800             ; 119 void PrintCharA(...);
0103   F800             ; 120 void PrintChar(...);
0104   F800             ; 121 void PrintCharSetEscState(...);
0105   F800             ; 122 void PrintCharSaveCursor(...);
0106   F800             ; 123 void PrintCharExit(...);
0107   F800             ; 124 void DrawCursor(...);
0108   F800             ; 125 void PrintCharEscY2(...);
0109   F800             ; 126 void PrintCharResetEscState(...);
0110   F800             ; 127 void PrintCharEsc(...);
0111   F800             ; 128 void SetCursorVisible(...);
0112   F800             ; 129 void PrintCharNoEsc(...);
0113   F800             ; 130 void PrintChar4(...);
0114   F800             ; 131 void ClearScreen(...);
0115   F800             ; 132 void MoveCursorHome(...);
0116   F800             ; 133 void PrintChar3(...);
0117   F800             ; 134 void PrintCharBeep(...);
0118   F800             ; 135 void MoveCursorCr(...);
0119   F800             ; 136 void MoveCursorRight(...);
0120   F800             ; 137 void MoveCursorBoundary(...);
0121   F800             ; 138 void MoveCursorLeft(...);
0122   F800             ; 139 void MoveCursorLf(...);
0123   F800             ; 140 void MoveCursorUp(...);
0124   F800             ; 141 void MoveCursor(...);
0125   F800             ; 142 void MoveCursorDown(...);
0126   F800             ; 143 void PrintCrLf();
0127   F800             ; 144 void IsAnyKeyPressed();
0128   F800             ; 145 void ReadKey();
0129   F800             ; 146 void ReadKeyInternal(...);
0130   F800             ; 147 void ScanKey();
0131   F800             ; 148 void ScanKey2(...);
0132   F800             ; 149 void ScanKeyExit(...);
0133   F800             ; 150 void ScanKeyControl(...);
0134   F800             ; 151 void ScanKeyShift(...);
0135   F800             ; 152 void ScanKeySpecial(...);
0136   F800             ; 153 void TranslateCodePageDefault(...);
0137   F800             ; 154 
0138   F800             ; 155 // Переменные Монитора
0139   F800             ; 156 
0140   F800             ; 157 extern uint8_t pressedKey __address(0xF759);
0141   F800             ; 158 extern uint16_t cursor __address(0xF75A);
0142   F800             ; 159 extern uint8_t tapeReadSpeed __address(0xF75C);
0143   F800             ; 160 extern uint8_t tapeWriteSpeed __address(0xF75D);
0144   F800             ; 161 extern uint8_t cursorVisible __address(0xF75E);
0145   F800             ; 162 extern uint8_t escState __address(0xF75F);
0146   F800             ; 163 extern uint16_t keyDelay __address(0xF760);
0147   F800             ; 164 extern uint16_t regPC __address(0xF762);
0148   F800             ; 165 extern uint16_t regHL __address(0xF764);
0149   F800             ; 166 extern uint16_t regBC __address(0xF766);
0150   F800             ; 167 extern uint16_t regDE __address(0xF768);
0151   F800             ; 168 extern uint16_t regSP __address(0xF76A);
0152   F800             ; 169 extern uint16_t regAF __address(0xF76C);
0153   F800             ; 170 extern uint16_t breakPointAddress __address(0xF771);
0154   F800             ; 171 extern uint8_t breakPointValue __address(0xF773);
0155   F800             ; 172 extern uint8_t jmpParam1Opcode __address(0xF774);
0156   F800             ; 173 extern uint16_t param1 __address(0xF775);
0157   F800             ; 174 extern uint16_t param2 __address(0xF777);
0158   F800             ; 175 extern uint16_t param3 __address(0xF779);
0159   F800             ; 176 extern uint8_t param2Exists __address(0xF77B);
0160   F800             ; 177 extern uint8_t tapePolarity __address(0xF77C);
0161   F800             ; 178 extern uint8_t translateCodeEnabled __address(0xF77D);
0162   F800             ; 179 extern uint8_t translateCodePageJump __address(0xF77E);
0163   F800             ; 180 extern uint16_t translateCodePageAddress __address(0xF77F);
0164   F800             ; 181 extern uint16_t ramTop __address(0xF781);
0165   F800             ; 182 extern uint8_t inputBuffer[32] __address(0xF783);
0166   F800             ; 183 
0167   F800             ; 184 extern uint8_t specialKeyTable[8];
0168   F800             ; 185 extern uint8_t aPrompt[6];
0169   F800             ; 186 extern uint8_t aCrLfTab[6];
0170   F800             ; 187 extern uint8_t aRegisters[37];
0171   F800             ; 188 extern uint8_t aBackspace[4];
0172   F800             ; 189 extern uint8_t aHello[9];
0173   F800             ; 190 
0174   F800             ; 191 // Для удобства
0175   F800             ; 192 
0176   F800             ; 193 void JmpParam1() __address(0xF774);
0177   F800             ; 194 void TranslateCodePage() __address(0xF77E);
0178   F800             ; 195 
0179   F800             ; 196 // Точки входа
0180   F800             ; 197 
0181   F800             ; 198 void EntryF800_Reboot() {
0182   F800             entryf800_reboot: 
0183   F800             ; 199     Reboot();
0184   F800 C3 36 F8    	jp reboot
0185   F803             ; 200 }
0186   F803             ; 201 
0187   F803             ; 202 void EntryF803_ReadKey() {
0188   F803             entryf803_readkey: 
0189   F803             ; 203     ReadKey();
0190   F803 C3 C8 FE    	jp readkey
0191   F806             ; 204 }
0192   F806             ; 205 
0193   F806             ; 206 void EntryF806_ReadTapeByte(...) {
0194   F806             entryf806_readtapebyte: 
0195   F806             ; 207     ReadTapeByte(a);
0196   F806 C3 74 FC    	jp readtapebyte
0197   F809             ; 208 }
0198   F809             ; 209 
0199   F809             ; 210 void EntryF809_PrintChar(...) {
0200   F809             entryf809_printchar: 
0201   F809             ; 211     PrintChar(c);
0202   F809 C3 23 FD    	jp printchar
0203   F80C             ; 212 }
0204   F80C             ; 213 
0205   F80C             ; 214 void EntryF80C_WriteTapeByte(...) {
0206   F80C             entryf80c_writetapebyte: 
0207   F80C             ; 215     WriteTapeByte(c);
0208   F80C C3 DD FC    	jp writetapebyte
0209   F80F             ; 216 }
0210   F80F             ; 217 
0211   F80F             ; 218 void EntryF80F_TranslateCodePage(...) {
0212   F80F             entryf80f_translatecodepage: 
0213   F80F             ; 219     TranslateCodePage(c);
0214   F80F C3 7E F7    	jp translatecodepage
0215   F812             ; 220 }
0216   F812             ; 221 
0217   F812             ; 222 void EntryF812_IsAnyKeyPressed() {
0218   F812             entryf812_isanykeypressed: 
0219   F812             ; 223     IsAnyKeyPressed();
0220   F812 C3 B7 FE    	jp isanykeypressed
0221   F815             ; 224 }
0222   F815             ; 225 
0223   F815             ; 226 void EntryF815_PrintHexByte(...) {
0224   F815             entryf815_printhexbyte: 
0225   F815             ; 227     PrintHexByte(a);
0226   F815 C3 0E FD    	jp printhexbyte
0227   F818             ; 228 }
0228   F818             ; 229 
0229   F818             ; 230 void EntryF818_PrintString(...) {
0230   F818             entryf818_printstring: 
0231   F818             ; 231     PrintString(hl);
0232   F818 C3 48 F9    	jp printstring
0233   F81B             ; 232 }
0234   F81B             ; 233 
0235   F81B             ; 234 void EntryF81B_ScanKey() {
0236   F81B             entryf81b_scankey: 
0237   F81B             ; 235     ScanKey();
0238   F81B C3 FE FE    	jp scankey
0239   F81E             ; 236 }
0240   F81E             ; 237 
0241   F81E             ; 238 void EntryF81E_GetCursor() {
0242   F81E             entryf81e_getcursor: 
0243   F81E             ; 239     GetCursor();
0244   F81E C3 49 FB    	jp getcursor
0245   F821             ; 240 }
0246   F821             ; 241 
0247   F821             ; 242 void EntryF821_GetCursorChar() {
0248   F821             entryf821_getcursorchar: 
0249   F821             ; 243     GetCursorChar();
0250   F821 C3 5E FB    	jp getcursorchar
0251   F824             ; 244 }
0252   F824             ; 245 
0253   F824             ; 246 void EntryF824_ReadTapeFile(...) {
0254   F824             entryf824_readtapefile: 
0255   F824             ; 247     ReadTapeFile(hl);
0256   F824 C3 BA FB    	jp readtapefile
0257   F827             ; 248 }
0258   F827             ; 249 
0259   F827             ; 250 void EntryF827_WriteTapeFile(...) {
0260   F827             entryf827_writetapefile: 
0261   F827             ; 251     WriteTapeFile(bc, de, hl);
0262   F827 C3 24 FC    	jp writetapefile
0263   F82A             ; 252 }
0264   F82A             ; 253 
0265   F82A             ; 254 void EntryF82A_CalculateCheckSum(...) {
0266   F82A             entryf82a_calculatechecksum: 
0267   F82A             ; 255     CalculateCheckSum(hl, de);
0268   F82A C3 F1 FB    	jp calculatechecksum
0269   F82D             ; 256 }
0270   F82D             ; 257 
0271   F82D             ; 258 void EntryF82D_EnableScreen() {
0272   F82D             entryf82d_enablescreen: 
0273   F82D C9          	ret
0274   F82E             ; 259 }
0275   F82E             ; 260 
0276   F82E             ; 261 uint16_t empty = 0;
0277   F82E             empty: 
0278   F82E 00 00       	dw 0
0279   F830             ; 263  EntryF830_GetRamTop() {
0280   F830             entryf830_getramtop: 
0281   F830             ; 264     GetRamTop();
0282   F830 C3 FA F9    	jp getramtop
0283   F833             ; 265 }
0284   F833             ; 266 
0285   F833             ; 267 void EntryF833_SetRamTop(...) {
0286   F833             entryf833_setramtop: 
0287   F833             ; 268     SetRamTop(hl);
0288   F833 C3 FE F9    	jp setramtop
0289   F836             ; 269 }
0290   F836             ; 270 
0291   F836             ; 271 // Инициализация. Выполняется после перезагрузки или пользовательской программой.
0292   F836             ; 272 // Параметры: нет. Функция никогда не завершается.
0293   F836             ; 273 
0294   F836             ; 274 void Reboot(...) {
0295   F836             reboot: 
0296   F836             ; 275     sp = STACK_TOP;
0297   F836 31 00 F8    	ld sp, 63488
0298   F839             ; 276 
0299   F839             ; 277     // Очистка памяти
0300   F839             ; 278     hl = &tapeWriteSpeed;
0301   F839 21 5D F7    	ld hl, 0FFFFh & (tapewritespeed)
0302   F83C             ; 279     de = inputBuffer + sizeof(inputBuffer) - 1;
0303   F83C 11 A2 F7    	ld de, 0FFFFh & (((inputbuffer) + (32)) - (1))
0304   F83F             ; 280     bc = 0;
0305   F83F 01 00 00    	ld bc, 0
0306   F842             ; 281     CmdF();
0307   F842 CD 82 FA    	call cmdf
0308   F845             ; 282 
0309   F845             ; 283     translateCodePageJump = a = OPCODE_JMP;
0310   F845 3E C3       	ld a, 195
0311   F847 32 7E F7    	ld (translatecodepagejump), a
0312   F84A             ; 284 
0313   F84A             ; 285     PrintString(hl = aHello);
0314   F84A 21 D4 FF    	ld hl, 0FFFFh & (ahello)
0315   F84D CD 48 F9    	call printstring
0316   F850             ; 286 
0317   F850             ; 287     // Проверка ОЗУ
0318   F850             ; 288     hl = 0;
0319   F850 21 00 00    	ld hl, 0
0320   F853             ; 289     for (;;) {
0321   F853             l_1: 
0322   F853             ; 290         c = *hl;
0323   F853 4E          	ld c, (hl)
0324   F854             ; 291         a = 0x55;
0325   F854 3E 55       	ld a, 85
0326   F856             ; 292         *hl = a;
0327   F856 77          	ld (hl), a
0328   F857             ; 293         a ^= *hl;
0329   F857 AE          	xor (hl)
0330   F858             ; 294         b = a;
0331   F858 47          	ld b, a
0332   F859             ; 295         a = 0xAA;
0333   F859 3E AA       	ld a, 170
0334   F85B             ; 296         *hl = a;
0335   F85B 77          	ld (hl), a
0336   F85C             ; 297         a ^= *hl;
0337   F85C AE          	xor (hl)
0338   F85D             ; 298         a |= b;
0339   F85D B0          	or b
0340   F85E             ; 299         if (flag_nz)
0341   F85E             ; 300             return Reboot2();
0342   F85E C2 6F F8    	jp nz, reboot2
0343   F861             ; 301         *hl = c;
0344   F861 71          	ld (hl), c
0345   F862             ; 302         hl++;
0346   F862 23          	inc hl
0347   F863             ; 303         if ((a = h) == SCREEN_ATTRIB_BEGIN >> 8)
0348   F863 7C          	ld a, h
0349   F864 FE E0       	cp 65504
0350   F866             ; 304             return Reboot2();
0351   F866 CA 6F F8    	jp z, reboot2
0352   F869 C3 53 F8    	jp l_1
0353   F86C             ; 305     }
0354   F86C             ; 306 
0355   F86C             ; 307     Reboot2();
0356   F86C C3 6F F8    	jp reboot2
0357   F86F              .org 0xF86C
0358   F86C             ; 308 }
0359   F86C             ; 309 
0360   F86C             ; 310 asm(" .org 0xF86C");
0361   F86C             ; 311 
0362   F86C             ; 312 void EntryF86C_Monitor() {
0363   F86C             entryf86c_monitor: 
0364   F86C             ; 313     return Monitor();
0365   F86C C3 88 F8    	jp monitor
0366   F86F             ; 314 }
0367   F86F             ; 315 
0368   F86F             ; 316 void Reboot2(...) {
0369   F86F             reboot2: 
0370   F86F             ; 317     hl--;
0371   F86F 2B          	dec hl
0372   F870             ; 318     ramTop = hl;
0373   F870 22 81 F7    	ld (ramtop), hl
0374   F873             ; 319     PrintHexWordSpace(hl);
0375   F873 CD 5A FC    	call printhexwordspace
0376   F876             ; 320     tapeReadSpeed = hl = TAPE_SPEED;
0377   F876 21 54 38    	ld hl, 14420
0378   F879 22 5C F7    	ld (tapereadspeed), hl
0379   F87C             ; 321     translateCodePageAddress = hl = &TranslateCodePageDefault;
0380   F87C 21 DD FF    	ld hl, 0FFFFh & (translatecodepagedefault)
0381   F87F 22 7F F7    	ld (translatecodepageaddress), hl
0382   F882             ; 322     regSP = hl = 0xF7FE;
0383   F882 21 FE F7    	ld hl, 63486
0384   F885 22 6A F7    	ld (regsp), hl
0385   F888             ; 323     Monitor();
0386   F888             ; 324 }
0387   F888             ; 325 
0388   F888             ; 326 void Monitor() {
0389   F888             monitor: 
0390   F888             ; 327     out(PORT_KEYBOARD_MODE, a = 0x83);
0391   F888 3E 83       	ld a, 131
0392   F88A D3 04       	out (4), a
0393   F88C             ; 328     cursorVisible = a;
0394   F88C 32 5E F7    	ld (cursorvisible), a
0395   F88F             ; 329     jmpParam1Opcode = a = OPCODE_JMP;
0396   F88F 3E C3       	ld a, 195
0397   F891 32 74 F7    	ld (jmpparam1opcode), a
0398   F894             ; 330     Monitor2();
0399   F894             ; 331 }
0400   F894             ; 332 
0401   F894             ; 333 void Monitor2() {
0402   F894             monitor2: 
0403   F894             ; 334     sp = STACK_TOP;
0404   F894 31 00 F8    	ld sp, 63488
0405   F897             ; 335     PrintString(hl = aPrompt);
0406   F897 21 9F FF    	ld hl, 0FFFFh & (aprompt)
0407   F89A CD 48 F9    	call printstring
0408   F89D             ; 336     ReadString();
0409   F89D CD 14 F9    	call readstring
0410   F8A0             ; 337 
0411   F8A0             ; 338     push(hl = &EntryF86C_Monitor);
0412   F8A0 21 6C F8    	ld hl, 0FFFFh & (entryf86c_monitor)
0413   F8A3 E5          	push hl
0414   F8A4             ; 339 
0415   F8A4             ; 340     hl = inputBuffer;
0416   F8A4 21 83 F7    	ld hl, 0FFFFh & (inputbuffer)
0417   F8A7             ; 341     a = *hl;
0418   F8A7 7E          	ld a, (hl)
0419   F8A8             ; 342 
0420   F8A8             ; 343     if (a == 'X')
0421   F8A8 FE 58       	cp 88
0422   F8AA             ; 344         return CmdX();
0423   F8AA CA 1C FB    	jp z, cmdx
0424   F8AD             ; 345 
0425   F8AD             ; 346     push_pop(a) {
0426   F8AD F5          	push af
0427   F8AE             ; 347         ParseParams();
0428   F8AE CD 52 F9    	call parseparams
0429   F8B1             ; 348         hl = param3;
0430   F8B1 2A 79 F7    	ld hl, (param3)
0431   F8B4             ; 349         c = l;
0432   F8B4 4D          	ld c, l
0433   F8B5             ; 350         b = h;
0434   F8B5 44          	ld b, h
0435   F8B6             ; 351         hl = param2;
0436   F8B6 2A 77 F7    	ld hl, (param2)
0437   F8B9             ; 352         swap(hl, de);
0438   F8B9 EB          	ex hl, de
0439   F8BA             ; 353         hl = param1;
0440   F8BA 2A 75 F7    	ld hl, (param1)
0441   F8BD F1          	pop af
0442   F8BE             ; 354     }
0443   F8BE             ; 355 
0444   F8BE             ; 356     if (a == 'D')
0445   F8BE FE 44       	cp 68
0446   F8C0             ; 357         return CmdD();
0447   F8C0 CA 06 FA    	jp z, cmdd
0448   F8C3             ; 358     if (a == 'C')
0449   F8C3 FE 43       	cp 67
0450   F8C5             ; 359         return CmdC();
0451   F8C5 CA 6C FA    	jp z, cmdc
0452   F8C8             ; 360     if (a == 'F')
0453   F8C8 FE 46       	cp 70
0454   F8CA             ; 361         return CmdF();
0455   F8CA CA 82 FA    	jp z, cmdf
0456   F8CD             ; 362     if (a == 'S')
0457   F8CD FE 53       	cp 83
0458   F8CF             ; 363         return CmdS();
0459   F8CF CA 89 FA    	jp z, cmds
0460   F8D2             ; 364     if (a == 'T')
0461   F8D2 FE 54       	cp 84
0462   F8D4             ; 365         return CmdT();
0463   F8D4 CA A6 FA    	jp z, cmdt
0464   F8D7             ; 366     if (a == 'M')
0465   F8D7 FE 4D       	cp 77
0466   F8D9             ; 367         return CmdM();
0467   F8D9 CA AF FA    	jp z, cmdm
0468   F8DC             ; 368     if (a == 'G')
0469   F8DC FE 47       	cp 71
0470   F8DE             ; 369         return CmdG();
0471   F8DE CA C8 FA    	jp z, cmdg
0472   F8E1             ; 370     if (a == 'I')
0473   F8E1 FE 49       	cp 73
0474   F8E3             ; 371         return CmdI();
0475   F8E3 CA 8A FB    	jp z, cmdi
0476   F8E6             ; 372     if (a == 'O')
0477   F8E6 FE 4F       	cp 79
0478   F8E8             ; 373         return CmdO();
0479   F8E8 CA 08 FC    	jp z, cmdo
0480   F8EB             ; 374     if (a == 'W')
0481   F8EB FE 57       	cp 87
0482   F8ED             ; 375         return CmdW();
0483   F8ED CA 94 FA    	jp z, cmdw
0484   F8F0             ; 376     if (a == 'A')
0485   F8F0 FE 41       	cp 65
0486   F8F2             ; 377         return CmdA();
0487   F8F2 CA 02 FA    	jp z, cmda
0488   F8F5             ; 378     if (a == 'H')
0489   F8F5 FE 48       	cp 72
0490   F8F7             ; 379         return CmdH();
0491   F8F7 CA 65 FB    	jp z, cmdh
0492   F8FA             ; 380     if (a == 'R')
0493   F8FA FE 52       	cp 82
0494   F8FC             ; 381         return CmdR();
0495   F8FC CA E6 F9    	jp z, cmdr
0496   F8FF             ; 382     return MonitorError();
0497   F8FF C3 B2 FB    	jp monitorerror
0498   F902             ; 383 }
0499   F902             ; 384 
0500   F902             ; 385 void ReadStringBackspace(...) {
0501   F902             readstringbackspace: 
0502   F902             ; 386     if ((a = inputBuffer) == l)
0503   F902 3E 83       	ld a, 0FFh & (inputbuffer)
0504   F904 BD          	cp l
0505   F905             ; 387         return ReadStringBegin(hl);
0506   F905 CA 17 F9    	jp z, readstringbegin
0507   F908             ; 388     push_pop(hl) {
0508   F908 E5          	push hl
0509   F909             ; 389         PrintString(hl = aBackspace);
0510   F909 21 D0 FF    	ld hl, 0FFFFh & (abackspace)
0511   F90C CD 48 F9    	call printstring
0512   F90F E1          	pop hl
0513   F910             ; 390     }
0514   F910             ; 391     hl--;
0515   F910 2B          	dec hl
0516   F911             ; 392     return ReadStringLoop(b, hl);
0517   F911 C3 19 F9    	jp readstringloop
0518   F914             ; 393 }
0519   F914             ; 394 
0520   F914             ; 395 void ReadString() {
0521   F914             readstring: 
0522   F914             ; 396     hl = inputBuffer;
0523   F914 21 83 F7    	ld hl, 0FFFFh & (inputbuffer)
0524   F917             ; 397     ReadStringBegin(hl);
0525   F917             ; 398 }
0526   F917             ; 399 
0527   F917             ; 400 void ReadStringBegin(...) {
0528   F917             readstringbegin: 
0529   F917             ; 401     b = 0;
0530   F917 06 00       	ld b, 0
0531   F919             ; 402     ReadStringLoop(b, hl);
0532   F919             ; 403 }
0533   F919             ; 404 
0534   F919             ; 405 void ReadStringLoop(...) {
0535   F919             readstringloop: 
0536   F919             ; 406     for (;;) {
0537   F919             l_4: 
0538   F919             ; 407         ReadKey();
0539   F919 CD C8 FE    	call readkey
0540   F91C             ; 408         if (a == 127)
0541   F91C FE 7F       	cp 127
0542   F91E             ; 409             return ReadStringBackspace();
0543   F91E CA 02 F9    	jp z, readstringbackspace
0544   F921             ; 410         if (a == 8)
0545   F921 FE 08       	cp 8
0546   F923             ; 411             return ReadStringBackspace();
0547   F923 CA 02 F9    	jp z, readstringbackspace
0548   F926             ; 412         if (flag_nz)
0549   F926             ; 413             PrintCharA(a);
0550   F926 C4 22 FD    	call nz, printchara
0551   F929             ; 414         *hl = a;
0552   F929 77          	ld (hl), a
0553   F92A             ; 415         if (a == 13)
0554   F92A FE 0D       	cp 13
0555   F92C             ; 416             return ReadStringExit(b);
0556   F92C CA 40 F9    	jp z, readstringexit
0557   F92F             ; 417         if (a == '.')
0558   F92F FE 2E       	cp 46
0559   F931             ; 418             return Monitor2();
0560   F931 CA 94 F8    	jp z, monitor2
0561   F934             ; 419         b = 255;
0562   F934 06 FF       	ld b, 255
0563   F936             ; 420         if ((a = inputBuffer + sizeof(inputBuffer) - 1) == l)
0564   F936 3E A2       	ld a, 0FFh & (((inputbuffer) + (32)) - (1))
0565   F938 BD          	cp l
0566   F939             ; 421             return MonitorError();
0567   F939 CA B2 FB    	jp z, monitorerror
0568   F93C             ; 422         hl++;
0569   F93C 23          	inc hl
0570   F93D C3 19 F9    	jp l_4
0571   F940             ; 423     }
0572   F940             ; 424 }
0573   F940             ; 425 
0574   F940             ; 426 void ReadStringExit(...) {
0575   F940             readstringexit: 
0576   F940             ; 427     a = b;
0577   F940 78          	ld a, b
0578   F941             ; 428     carry_rotate_left(a, 1);
0579   F941 17          	rla
0580   F942             ; 429     de = inputBuffer;
0581   F942 11 83 F7    	ld de, 0FFFFh & (inputbuffer)
0582   F945             ; 430     b = 0;
0583   F945 06 00       	ld b, 0
0584   F947 C9          	ret
0585   F948             ; 431 }
0586   F948             ; 432 
0587   F948             ; 433 // Функция для пользовательской программы.
0588   F948             ; 434 // Вывод строки на экран.
0589   F948             ; 435 // Параметры: hl - адрес стороки. Результат: hl - следующий адрес за терминатором строки. Сохраняются: b, de.
0590   F948             ; 436 
0591   F948             ; 437 void PrintString(...) {
0592   F948             printstring: 
0593   F948             ; 438     for (;;) {
0594   F948             l_7: 
0595   F948             ; 439         a = *hl;
0596   F948 7E          	ld a, (hl)
0597   F949             ; 440         if (flag_z(a &= a))
0598   F949 A7          	and a
0599   F94A             ; 441             return;
0600   F94A C8          	ret z
0601   F94B             ; 442         PrintCharA(a);
0602   F94B CD 22 FD    	call printchara
0603   F94E             ; 443         hl++;
0604   F94E 23          	inc hl
0605   F94F C3 48 F9    	jp l_7
0606   F952             ; 444     }
0607   F952             ; 445 }
0608   F952             ; 446 
0609   F952             ; 447 void ParseParams(...) {
0610   F952             parseparams: 
0611   F952             ; 448     hl = &param1;
0612   F952 21 75 F7    	ld hl, 0FFFFh & (param1)
0613   F955             ; 449     de = &param2Exists;
0614   F955 11 7B F7    	ld de, 0FFFFh & (param2exists)
0615   F958             ; 450     c = 0;
0616   F958 0E 00       	ld c, 0
0617   F95A             ; 451     CmdF();
0618   F95A CD 82 FA    	call cmdf
0619   F95D             ; 452 
0620   F95D             ; 453     de = inputBuffer + 1;
0621   F95D 11 84 F7    	ld de, 0FFFFh & ((inputbuffer) + (1))
0622   F960             ; 454 
0623   F960             ; 455     ParseWord();
0624   F960 CD 80 F9    	call parseword
0625   F963             ; 456     param1 = hl;
0626   F963 22 75 F7    	ld (param1), hl
0627   F966             ; 457     param2 = hl;
0628   F966 22 77 F7    	ld (param2), hl
0629   F969             ; 458     if (flag_c)
0630   F969             ; 459         return;
0631   F969 D8          	ret c
0632   F96A             ; 460 
0633   F96A             ; 461     param2Exists = a = 0xFF;
0634   F96A 3E FF       	ld a, 255
0635   F96C 32 7B F7    	ld (param2exists), a
0636   F96F             ; 462     ParseWord();
0637   F96F CD 80 F9    	call parseword
0638   F972             ; 463     param2 = hl;
0639   F972 22 77 F7    	ld (param2), hl
0640   F975             ; 464     if (flag_c)
0641   F975             ; 465         return;
0642   F975 D8          	ret c
0643   F976             ; 466 
0644   F976             ; 467     ParseWord();
0645   F976 CD 80 F9    	call parseword
0646   F979             ; 468     param3 = hl;
0647   F979 22 79 F7    	ld (param3), hl
0648   F97C             ; 469     if (flag_c)
0649   F97C             ; 470         return;
0650   F97C D8          	ret c
0651   F97D             ; 471 
0652   F97D             ; 472     MonitorError();
0653   F97D C3 B2 FB    	jp monitorerror
0654   F980             ; 473 }
0655   F980             ; 474 
0656   F980             ; 475 void ParseWord(...) {
0657   F980             parseword: 
0658   F980             ; 476     hl = 0;
0659   F980 21 00 00    	ld hl, 0
0660   F983             ; 477     for (;;) {
0661   F983             l_10: 
0662   F983             ; 478         a = *de;
0663   F983 1A          	ld a, (de)
0664   F984             ; 479         de++;
0665   F984 13          	inc de
0666   F985             ; 480         if (a == 13)
0667   F985 FE 0D       	cp 13
0668   F987             ; 481             return ParseWordReturnCf(hl);
0669   F987 CA B4 F9    	jp z, parsewordreturncf
0670   F98A             ; 482         if (a == ',')
0671   F98A FE 2C       	cp 44
0672   F98C             ; 483             return;
0673   F98C C8          	ret z
0674   F98D             ; 484         if (a == ' ')
0675   F98D FE 20       	cp 32
0676   F98F             ; 485             continue;
0677   F98F CA 83 F9    	jp z, l_10
0678   F992             ; 486         a -= '0';
0679   F992 D6 30       	sub 48
0680   F994             ; 487         if (flag_m)
0681   F994             ; 488             return MonitorError();
0682   F994 FA B2 FB    	jp m, monitorerror
0683   F997             ; 489         if (flag_p(compare(a, 10))) {
0684   F997 FE 0A       	cp 10
0685   F999 FA A8 F9    	jp m, l_12
0686   F99C             ; 490             if (flag_m(compare(a, 17)))
0687   F99C FE 11       	cp 17
0688   F99E             ; 491                 return MonitorError();
0689   F99E FA B2 FB    	jp m, monitorerror
0690   F9A1             ; 492             if (flag_p(compare(a, 23)))
0691   F9A1 FE 17       	cp 23
0692   F9A3             ; 493                 return MonitorError();
0693   F9A3 F2 B2 FB    	jp p, monitorerror
0694   F9A6             ; 494             a -= 7;
0695   F9A6 D6 07       	sub 7
0696   F9A8             l_12: 
0697   F9A8             ; 495         }
0698   F9A8             ; 496         c = a;
0699   F9A8 4F          	ld c, a
0700   F9A9             ; 497         hl += hl;
0701   F9A9 29          	add hl, hl
0702   F9AA             ; 498         hl += hl;
0703   F9AA 29          	add hl, hl
0704   F9AB             ; 499         hl += hl;
0705   F9AB 29          	add hl, hl
0706   F9AC             ; 500         hl += hl;
0707   F9AC 29          	add hl, hl
0708   F9AD             ; 501         if (flag_c)
0709   F9AD             ; 502             return MonitorError();
0710   F9AD DA B2 FB    	jp c, monitorerror
0711   F9B0             ; 503         hl += bc;
0712   F9B0 09          	add hl, bc
0713   F9B1 C3 83 F9    	jp l_10
0714   F9B4             ; 504     }
0715   F9B4             ; 505 }
0716   F9B4             ; 506 
0717   F9B4             ; 507 void ParseWordReturnCf(...) {
0718   F9B4             parsewordreturncf: 
0719   F9B4             ; 508     set_flag_c();
0720   F9B4 37          	scf
0721   F9B5 C9          	ret
0722   F9B6             ; 509 }
0723   F9B6             ; 510 
0724   F9B6             ; 511 void CompareHlDe(...) {
0725   F9B6             comparehlde: 
0726   F9B6             ; 512     if ((a = h) != d)
0727   F9B6 7C          	ld a, h
0728   F9B7 BA          	cp d
0729   F9B8             ; 513         return;
0730   F9B8 C0          	ret nz
0731   F9B9             ; 514     compare(a = l, e);
0732   F9B9 7D          	ld a, l
0733   F9BA BB          	cp e
0734   F9BB C9          	ret
0735   F9BC             ; 515 }
0736   F9BC             ; 516 
0737   F9BC             ; 517 void LoopWithBreak(...) {
0738   F9BC             loopwithbreak: 
0739   F9BC             ; 518     CtrlC();
0740   F9BC CD CA F9    	call ctrlc
0741   F9BF             ; 519     Loop(hl, de);
0742   F9BF             ; 520 }
0743   F9BF             ; 521 
0744   F9BF             ; 522 void Loop(...) {
0745   F9BF             loop: 
0746   F9BF             ; 523     CompareHlDe(hl, de);
0747   F9BF CD B6 F9    	call comparehlde
0748   F9C2             ; 524     if (flag_nz)
0749   F9C2             ; 525         return IncHl(hl);
0750   F9C2 C2 C8 F9    	jp nz, inchl
0751   F9C5             ; 526     PopRet();
0752   F9C5             ; 527 }
0753   F9C5             ; 528 
0754   F9C5             ; 529 void PopRet() {
0755   F9C5             popret: 
0756   F9C5             ; 530     sp++;
0757   F9C5 33          	inc sp
0758   F9C6             ; 531     sp++;
0759   F9C6 33          	inc sp
0760   F9C7 C9          	ret
0761   F9C8             ; 532 }
0762   F9C8             ; 533 
0763   F9C8             ; 534 void IncHl(...) {
0764   F9C8             inchl: 
0765   F9C8             ; 535     hl++;
0766   F9C8 23          	inc hl
0767   F9C9 C9          	ret
0768   F9CA             ; 536 }
0769   F9CA             ; 537 
0770   F9CA             ; 538 void CtrlC() {
0771   F9CA             ctrlc: 
0772   F9CA             ; 539     ScanKey();
0773   F9CA CD FE FE    	call scankey
0774   F9CD             ; 540     if (a != 3)  // УПР + C
0775   F9CD FE 03       	cp 3
0776   F9CF             ; 541         return;
0777   F9CF C0          	ret nz
0778   F9D0             ; 542     MonitorError();
0779   F9D0 C3 B2 FB    	jp monitorerror
0780   F9D3             ; 543 }
0781   F9D3             ; 544 
0782   F9D3             ; 545 void PrintCrLfTab() {
0783   F9D3             printcrlftab: 
0784   F9D3             ; 546     push_pop(hl) {
0785   F9D3 E5          	push hl
0786   F9D4             ; 547         PrintString(hl = aCrLfTab);
0787   F9D4 21 A5 FF    	ld hl, 0FFFFh & (acrlftab)
0788   F9D7 CD 48 F9    	call printstring
0789   F9DA E1          	pop hl
0790   F9DB C9          	ret
0791   F9DC             ; 548     }
0792   F9DC             ; 549 }
0793   F9DC             ; 550 
0794   F9DC             ; 551 void PrintHexByteFromHlSpace(...) {
0795   F9DC             printhexbytefromhlspace: 
0796   F9DC             ; 552     PrintHexByteSpace(a = *hl);
0797   F9DC 7E          	ld a, (hl)
0798   F9DD             ; 553 }
0799   F9DD             ; 554 
0800   F9DD             ; 555 void PrintHexByteSpace(...) {
0801   F9DD             printhexbytespace: 
0802   F9DD             ; 556     push_pop(bc) {
0803   F9DD C5          	push bc
0804   F9DE             ; 557         PrintHexByte(a);
0805   F9DE CD 0E FD    	call printhexbyte
0806   F9E1             ; 558         PrintSpace();
0807   F9E1 CD 67 FA    	call printspace
0808   F9E4 C1          	pop bc
0809   F9E5 C9          	ret
0810   F9E6             ; 559     }
0811   F9E6             ; 560 }
0812   F9E6             ; 561 
0813   F9E6             ; 562 // Команда R <начальный адрес ПЗУ> <конечный адрес ПЗУ> <начальный адрес назаначения>
0814   F9E6             ; 563 // Скопировать блок из внешнего ПЗУ в адресное пространство процессора
0815   F9E6             ; 564 
0816   F9E6             ; 565 void CmdR(...) {
0817   F9E6             cmdr: 
0818   F9E6             ; 566     out(PORT_EXT_MODE, a = 0x90);
0819   F9E6 3E 90       	ld a, 144
0820   F9E8 D3 A3       	out (163), a
0821   F9EA             ; 567     for (;;) {
0822   F9EA             l_15: 
0823   F9EA             ; 568         out(PORT_EXT_ADDR_LOW, a = l);
0824   F9EA 7D          	ld a, l
0825   F9EB D3 A1       	out (161), a
0826   F9ED             ; 569         out(PORT_EXT_ADDR_HIGH, a = h);
0827   F9ED 7C          	ld a, h
0828   F9EE D3 A2       	out (162), a
0829   F9F0             ; 570         *bc = a = in(PORT_EXT_DATA);
0830   F9F0 DB A0       	in a, (160)
0831   F9F2 02          	ld (bc), a
0832   F9F3             ; 571         bc++;
0833   F9F3 03          	inc bc
0834   F9F4             ; 572         Loop();
0835   F9F4 CD BF F9    	call loop
0836   F9F7 C3 EA F9    	jp l_15
0837   F9FA             ; 573     }
0838   F9FA             ; 574 }
0839   F9FA             ; 575 
0840   F9FA             ; 576 // Функция для пользовательской программы.
0841   F9FA             ; 577 // Получить адрес последнего доступного байта оперативной памяти.
0842   F9FA             ; 578 // Параметры: нет. Результат: hl - адрес. Сохраняет: a, bc, de.
0843   F9FA             ; 579 
0844   F9FA             ; 580 void GetRamTop(...) {
0845   F9FA             getramtop: 
0846   F9FA             ; 581     hl = ramTop;
0847   F9FA 2A 81 F7    	ld hl, (ramtop)
0848   F9FD C9          	ret
0849   F9FE             ; 582 }
0850   F9FE             ; 583 
0851   F9FE             ; 584 // Функция для пользовательской программы.
0852   F9FE             ; 585 // Установить адрес последнего доступного байта оперативной памяти.
0853   F9FE             ; 586 // Параметры: hl - адрес. Результат: нет. Сохраняет: a, bc, de, hl.
0854   F9FE             ; 587 
0855   F9FE             ; 588 void SetRamTop(...) {
0856   F9FE             setramtop: 
0857   F9FE             ; 589     ramTop = hl;
0858   F9FE 22 81 F7    	ld (ramtop), hl
0859   FA01 C9          	ret
0860   FA02             ; 590 }
0861   FA02             ; 591 
0862   FA02             ; 592 // Команда A <адрес>
0863   FA02             ; 593 // Установить программу преобразования кодировки символов выводимых на экран
0864   FA02             ; 594 
0865   FA02             ; 595 void CmdA(...) {
0866   FA02             cmda: 
0867   FA02             ; 596     translateCodePageAddress = hl;
0868   FA02 22 7F F7    	ld (translatecodepageaddress), hl
0869   FA05 C9          	ret
0870   FA06             ; 597 }
0871   FA06             ; 598 
0872   FA06             ; 599 // Команда D <начальный адрес> <конечный адрес>
0873   FA06             ; 600 // Вывод блока данных из адресного пространства на экран в 16-ричном виде
0874   FA06             ; 601 
0875   FA06             ; 602 void CmdD(...) {
0876   FA06             cmdd: 
0877   FA06             ; 603     for (;;) {
0878   FA06             l_18: 
0879   FA06             ; 604         PrintCrLf();
0880   FA06 CD AD FE    	call printcrlf
0881   FA09             ; 605         PrintHexWordSpace(hl);
0882   FA09 CD 5A FC    	call printhexwordspace
0883   FA0C             ; 606         push_pop(hl) {
0884   FA0C E5          	push hl
0885   FA0D             ; 607             c = ((a = l) &= 0x0F);
0886   FA0D 7D          	ld a, l
0887   FA0E E6 0F       	and 15
0888   FA10 4F          	ld c, a
0889   FA11             ; 608             carry_rotate_right(a, 1);
0890   FA11 1F          	rra
0891   FA12             ; 609             b = (((a += c) += c) += 5);
0892   FA12 81          	add c
0893   FA13 81          	add c
0894   FA14 C6 05       	add 5
0895   FA16 47          	ld b, a
0896   FA17             ; 610             PrintSpacesTo();
0897   FA17 CD 5A FA    	call printspacesto
0898   FA1A             ; 611             do {
0899   FA1A             l_20: 
0900   FA1A             ; 612                 PrintHexByte(a = *hl);
0901   FA1A 7E          	ld a, (hl)
0902   FA1B CD 0E FD    	call printhexbyte
0903   FA1E             ; 613                 CompareHlDe(hl, de);
0904   FA1E CD B6 F9    	call comparehlde
0905   FA21             ; 614                 hl++;
0906   FA21 23          	inc hl
0907   FA22             ; 615                 if (flag_z)
0908   FA22             ; 616                     break;
0909   FA22 CA 32 FA    	jp z, l_22
0910   FA25             ; 617                 (a = l) &= 0x0F;
0911   FA25 7D          	ld a, l
0912   FA26 E6 0F       	and 15
0913   FA28             ; 618                 push_pop(a) {
0914   FA28 F5          	push af
0915   FA29             ; 619                     a &= 1;
0916   FA29 E6 01       	and 1
0917   FA2B             ; 620                     if (flag_z)
0918   FA2B             ; 621                         PrintSpace();
0919   FA2B CC 67 FA    	call z, printspace
0920   FA2E F1          	pop af
0921   FA2F             l_21: 
0922   FA2F C2 1A FA    	jp nz, l_20
0923   FA32             l_22: 
0924   FA32 E1          	pop hl
0925   FA33             ; 622                 }
0926   FA33             ; 623             } while (flag_nz);
0927   FA33             ; 624         }
0928   FA33             ; 625 
0929   FA33             ; 626         b = (((a = l) &= 0x0F) += 46);
0930   FA33 7D          	ld a, l
0931   FA34 E6 0F       	and 15
0932   FA36 C6 2E       	add 46
0933   FA38 47          	ld b, a
0934   FA39             ; 627         PrintSpacesTo(b);
0935   FA39 CD 5A FA    	call printspacesto
0936   FA3C             ; 628 
0937   FA3C             ; 629         do {
0938   FA3C             l_23: 
0939   FA3C             ; 630             a = *hl;
0940   FA3C 7E          	ld a, (hl)
0941   FA3D             ; 631             if (a < 127)
0942   FA3D FE 7F       	cp 127
0943   FA3F             ; 632                 if (a >= 32)
0944   FA3F D2 47 FA    	jp nc, l_26
0945   FA42 FE 20       	cp 32
0946   FA44             ; 633                     goto loc_fa49;
0947   FA44 D2 49 FA    	jp nc, loc_fa49
0948   FA47             l_26: 
0949   FA47             ; 634             a = '.';
0950   FA47 3E 2E       	ld a, 46
0951   FA49             ; 635         loc_fa49:
0952   FA49             loc_fa49: 
0953   FA49             ; 636             PrintCharA(a);
0954   FA49 CD 22 FD    	call printchara
0955   FA4C             ; 637             CompareHlDe(hl, de);
0956   FA4C CD B6 F9    	call comparehlde
0957   FA4F             ; 638             if (flag_z)
0958   FA4F             ; 639                 return;
0959   FA4F C8          	ret z
0960   FA50             ; 640             hl++;
0961   FA50 23          	inc hl
0962   FA51             ; 641             (a = l) &= 0x0F;
0963   FA51 7D          	ld a, l
0964   FA52 E6 0F       	and 15
0965   FA54             l_24: 
0966   FA54 C2 3C FA    	jp nz, l_23
0967   FA57 C3 06 FA    	jp l_18
0968   FA5A             ; 642         } while (flag_nz);
0969   FA5A             ; 643     }
0970   FA5A             ; 644 }
0971   FA5A             ; 645 
0972   FA5A             ; 646 void PrintSpacesTo(...) {
0973   FA5A             printspacesto: 
0974   FA5A             ; 647     for (;;) {
0975   FA5A             l_29: 
0976   FA5A             ; 648         if (((a = cursor) &= (SCREEN_WIDTH - 1)) >= b)
0977   FA5A 3A 5A F7    	ld a, (cursor)
0978   FA5D E6 3F       	and 63
0979   FA5F B8          	cp b
0980   FA60             ; 649             return;
0981   FA60 D0          	ret nc
0982   FA61             ; 650         PrintSpace();
0983   FA61 CD 67 FA    	call printspace
0984   FA64 C3 5A FA    	jp l_29
0985   FA67             ; 651     }
0986   FA67             ; 652 }
0987   FA67             ; 653 
0988   FA67             ; 654 void PrintSpace() {
0989   FA67             printspace: 
0990   FA67             ; 655     return PrintCharA(a = ' ');
0991   FA67 3E 20       	ld a, 32
0992   FA69 C3 22 FD    	jp printchara
0993   FA6C             ; 656 }
0994   FA6C             ; 657 
0995   FA6C             ; 658 // Команда С <начальный адрес 1> <конечный адрес 1> <начальный адрес 2>
0996   FA6C             ; 659 // Сравнить два блока адресного пространство
0997   FA6C             ; 660 
0998   FA6C             ; 661 void CmdC(...) {
0999   FA6C             cmdc: 
1000   FA6C             ; 662     for (;;) {
1001   FA6C             l_32: 
1002   FA6C             ; 663         if ((a = *bc) != *hl) {
1003   FA6C 0A          	ld a, (bc)
1004   FA6D BE          	cp (hl)
1005   FA6E CA 7B FA    	jp z, l_34
1006   FA71             ; 664             PrintCrLfTabHexWordSpace(hl);
1007   FA71 CD 51 FC    	call printcrlftabhexwordspace
1008   FA74             ; 665             PrintHexByteFromHlSpace(hl);
1009   FA74 CD DC F9    	call printhexbytefromhlspace
1010   FA77             ; 666             PrintHexByteSpace(a = *bc);
1011   FA77 0A          	ld a, (bc)
1012   FA78 CD DD F9    	call printhexbytespace
1013   FA7B             l_34: 
1014   FA7B             ; 667         }
1015   FA7B             ; 668         bc++;
1016   FA7B 03          	inc bc
1017   FA7C             ; 669         LoopWithBreak();
1018   FA7C CD BC F9    	call loopwithbreak
1019   FA7F C3 6C FA    	jp l_32
1020   FA82             ; 670     }
1021   FA82             ; 671 }
1022   FA82             ; 672 
1023   FA82             ; 673 // Команда F <начальный адрес> <конечный адрес> <байт>
1024   FA82             ; 674 // Заполнить блок в адресном пространстве одним байтом
1025   FA82             ; 675 
1026   FA82             ; 676 void CmdF(...) {
1027   FA82             cmdf: 
1028   FA82             ; 677     for (;;) {
1029   FA82             l_37: 
1030   FA82             ; 678         *hl = c;
1031   FA82 71          	ld (hl), c
1032   FA83             ; 679         Loop();
1033   FA83 CD BF F9    	call loop
1034   FA86 C3 82 FA    	jp l_37
1035   FA89             ; 680     }
1036   FA89             ; 681 }
1037   FA89             ; 682 
1038   FA89             ; 683 // Команда S <начальный адрес> <конечный адрес> <байт>
1039   FA89             ; 684 // Найти байт (8 битное значение) в адресном пространстве
1040   FA89             ; 685 
1041   FA89             ; 686 void CmdS(...) {
1042   FA89             cmds: 
1043   FA89             ; 687     for (;;) {
1044   FA89             l_40: 
1045   FA89             ; 688         if ((a = c) == *hl)
1046   FA89 79          	ld a, c
1047   FA8A BE          	cp (hl)
1048   FA8B             ; 689             PrintCrLfTabHexWordSpace(hl);
1049   FA8B CC 51 FC    	call z, printcrlftabhexwordspace
1050   FA8E             ; 690         LoopWithBreak();
1051   FA8E CD BC F9    	call loopwithbreak
1052   FA91 C3 89 FA    	jp l_40
1053   FA94             ; 691     }
1054   FA94             ; 692 }
1055   FA94             ; 693 
1056   FA94             ; 694 // Команда W <начальный адрес> <конечный адрес> <слово>
1057   FA94             ; 695 // Найти слово (16 битное значение) в адресном пространстве
1058   FA94             ; 696 
1059   FA94             ; 697 void CmdW(...) {
1060   FA94             cmdw: 
1061   FA94             ; 698     for (;;) {
1062   FA94             l_43: 
1063   FA94             ; 699         if ((a = *hl) == c) {
1064   FA94 7E          	ld a, (hl)
1065   FA95 B9          	cp c
1066   FA96 C2 A0 FA    	jp nz, l_45
1067   FA99             ; 700             hl++;
1068   FA99 23          	inc hl
1069   FA9A             ; 701             compare((a = *hl), b);
1070   FA9A 7E          	ld a, (hl)
1071   FA9B B8          	cp b
1072   FA9C             ; 702             hl--;
1073   FA9C 2B          	dec hl
1074   FA9D             ; 703             if (flag_z)
1075   FA9D             ; 704                 PrintCrLfTabHexWordSpace(hl);
1076   FA9D CC 51 FC    	call z, printcrlftabhexwordspace
1077   FAA0             l_45: 
1078   FAA0             ; 705         }
1079   FAA0             ; 706         LoopWithBreak();
1080   FAA0 CD BC F9    	call loopwithbreak
1081   FAA3 C3 94 FA    	jp l_43
1082   FAA6             ; 707     }
1083   FAA6             ; 708 }
1084   FAA6             ; 709 
1085   FAA6             ; 710 // Команда T <начальный адрес источника> <конечный адрес источника> <начальный адрес назначения>
1086   FAA6             ; 711 // Копировать блок в адресном пространстве
1087   FAA6             ; 712 
1088   FAA6             ; 713 void CmdT(...) {
1089   FAA6             cmdt: 
1090   FAA6             ; 714     for (;;) {
1091   FAA6             l_48: 
1092   FAA6             ; 715         *bc = a = *hl;
1093   FAA6 7E          	ld a, (hl)
1094   FAA7 02          	ld (bc), a
1095   FAA8             ; 716         bc++;
1096   FAA8 03          	inc bc
1097   FAA9             ; 717         Loop();
1098   FAA9 CD BF F9    	call loop
1099   FAAC C3 A6 FA    	jp l_48
1100   FAAF             ; 718     }
1101   FAAF             ; 719 }
1102   FAAF             ; 720 
1103   FAAF             ; 721 // Команда M <начальный адрес>
1104   FAAF             ; 722 // Вывести на экран адресное пространство побайтно с возможностью изменения
1105   FAAF             ; 723 
1106   FAAF             ; 724 void CmdM(...) {
1107   FAAF             cmdm: 
1108   FAAF             ; 725     for (;;) {
1109   FAAF             l_51: 
1110   FAAF             ; 726         PrintCrLfTabHexWordSpace(hl);
1111   FAAF CD 51 FC    	call printcrlftabhexwordspace
1112   FAB2             ; 727         PrintHexByteFromHlSpace();
1113   FAB2 CD DC F9    	call printhexbytefromhlspace
1114   FAB5             ; 728         push_pop(hl) {
1115   FAB5 E5          	push hl
1116   FAB6             ; 729             ReadString();
1117   FAB6 CD 14 F9    	call readstring
1118   FAB9 E1          	pop hl
1119   FABA             ; 730         }
1120   FABA             ; 731         if (flag_c) {
1121   FABA D2 C4 FA    	jp nc, l_53
1122   FABD             ; 732             push_pop(hl) {
1123   FABD E5          	push hl
1124   FABE             ; 733                 ParseWord();
1125   FABE CD 80 F9    	call parseword
1126   FAC1             ; 734                 a = l;
1127   FAC1 7D          	ld a, l
1128   FAC2 E1          	pop hl
1129   FAC3             ; 735             }
1130   FAC3             ; 736             *hl = a;
1131   FAC3 77          	ld (hl), a
1132   FAC4             l_53: 
1133   FAC4             ; 737         }
1134   FAC4             ; 738         hl++;
1135   FAC4 23          	inc hl
1136   FAC5 C3 AF FA    	jp l_51
1137   FAC8             ; 739     }
1138   FAC8             ; 740 }
1139   FAC8             ; 741 
1140   FAC8             ; 742 // Команда G <начальный адрес> <конечный адрес>
1141   FAC8             ; 743 // Запуск программы и возможным указанием точки останова.
1142   FAC8             ; 744 
1143   FAC8             ; 745 void CmdG(...) {
1144   FAC8             cmdg: 
1145   FAC8             ; 746     CompareHlDe(hl, de);
1146   FAC8 CD B6 F9    	call comparehlde
1147   FACB             ; 747     if (flag_nz) {
1148   FACB CA E3 FA    	jp z, l_55
1149   FACE             ; 748         swap(hl, de);
1150   FACE EB          	ex hl, de
1151   FACF             ; 749         breakPointAddress = hl;
1152   FACF 22 71 F7    	ld (breakpointaddress), hl
1153   FAD2             ; 750         breakPointValue = a = *hl;
1154   FAD2 7E          	ld a, (hl)
1155   FAD3 32 73 F7    	ld (breakpointvalue), a
1156   FAD6             ; 751         *hl = OPCODE_RST_30;
1157   FAD6 36 F7       	ld (hl), 247
1158   FAD8             ; 752         rst30Opcode = a = OPCODE_JMP;
1159   FAD8 3E C3       	ld a, 195
1160   FADA 32 30 00    	ld (rst30opcode), a
1161   FADD             ; 753         rst30Address = hl = &BreakPointHandler;
1162   FADD 21 F1 FA    	ld hl, 0FFFFh & (breakpointhandler)
1163   FAE0 22 31 00    	ld (rst30address), hl
1164   FAE3             l_55: 
1165   FAE3             ; 754     }
1166   FAE3             ; 755     sp = &regBC;
1167   FAE3 31 66 F7    	ld sp, 0FFFFh & (regbc)
1168   FAE6             ; 756     pop(bc);
1169   FAE6 C1          	pop bc
1170   FAE7             ; 757     pop(de);
1171   FAE7 D1          	pop de
1172   FAE8             ; 758     pop(hl);
1173   FAE8 E1          	pop hl
1174   FAE9             ; 759     pop(a);
1175   FAE9 F1          	pop af
1176   FAEA             ; 760     sp = hl;
1177   FAEA F9          	ld sp, hl
1178   FAEB             ; 761     hl = regHL;
1179   FAEB 2A 64 F7    	ld hl, (reghl)
1180   FAEE             ; 762     return JmpParam1();
1181   FAEE C3 74 F7    	jp jmpparam1
1182   FAF1             ; 763 }
1183   FAF1             ; 764 
1184   FAF1             ; 765 void BreakPointHandler(...) {
1185   FAF1             breakpointhandler: 
1186   FAF1             ; 766     regHL = hl;
1187   FAF1 22 64 F7    	ld (reghl), hl
1188   FAF4             ; 767     push(a);
1189   FAF4 F5          	push af
1190   FAF5             ; 768     pop(hl);
1191   FAF5 E1          	pop hl
1192   FAF6             ; 769     regAF = hl;
1193   FAF6 22 6C F7    	ld (regaf), hl
1194   FAF9             ; 770     pop(hl);
1195   FAF9 E1          	pop hl
1196   FAFA             ; 771     hl--;
1197   FAFA 2B          	dec hl
1198   FAFB             ; 772     regPC = hl;
1199   FAFB 22 62 F7    	ld (regpc), hl
1200   FAFE             ; 773     (hl = 0) += sp;
1201   FAFE 21 00 00    	ld hl, 0
1202   FB01 39          	add hl, sp
1203   FB02             ; 774     sp = &regAF;
1204   FB02 31 6C F7    	ld sp, 0FFFFh & (regaf)
1205   FB05             ; 775     push(hl);
1206   FB05 E5          	push hl
1207   FB06             ; 776     push(de);
1208   FB06 D5          	push de
1209   FB07             ; 777     push(bc);
1210   FB07 C5          	push bc
1211   FB08             ; 778     sp = STACK_TOP;
1212   FB08 31 00 F8    	ld sp, 63488
1213   FB0B             ; 779     hl = regPC;
1214   FB0B 2A 62 F7    	ld hl, (regpc)
1215   FB0E             ; 780     swap(hl, de);
1216   FB0E EB          	ex hl, de
1217   FB0F             ; 781     hl = breakPointAddress;
1218   FB0F 2A 71 F7    	ld hl, (breakpointaddress)
1219   FB12             ; 782     CompareHlDe(hl, de);
1220   FB12 CD B6 F9    	call comparehlde
1221   FB15             ; 783     if (flag_nz)
1222   FB15             ; 784         return CmdX();
1223   FB15 C2 1C FB    	jp nz, cmdx
1224   FB18             ; 785     *hl = a = breakPointValue;
1225   FB18 3A 73 F7    	ld a, (breakpointvalue)
1226   FB1B 77          	ld (hl), a
1227   FB1C             ; 786     CmdX();
1228   FB1C             ; 787 }
1229   FB1C             ; 788 
1230   FB1C             ; 789 // Команда X
1231   FB1C             ; 790 // Вывод на экран содержимого регистров микропроцессора с возможностью их изменения.
1232   FB1C             ; 791 
1233   FB1C             ; 792 void CmdX(...) {
1234   FB1C             cmdx: 
1235   FB1C             ; 793     PrintString(hl = aRegisters);
1236   FB1C 21 AB FF    	ld hl, 0FFFFh & (aregisters)
1237   FB1F CD 48 F9    	call printstring
1238   FB22             ; 794     hl = &regPC;
1239   FB22 21 62 F7    	ld hl, 0FFFFh & (regpc)
1240   FB25             ; 795     b = 6;
1241   FB25 06 06       	ld b, 6
1242   FB27             ; 796     do {
1243   FB27             l_57: 
1244   FB27             ; 797         e = *hl;
1245   FB27 5E          	ld e, (hl)
1246   FB28             ; 798         hl++;
1247   FB28 23          	inc hl
1248   FB29             ; 799         d = *hl;
1249   FB29 56          	ld d, (hl)
1250   FB2A             ; 800         push(bc);
1251   FB2A C5          	push bc
1252   FB2B             ; 801         push(hl);
1253   FB2B E5          	push hl
1254   FB2C             ; 802         swap(hl, de);
1255   FB2C EB          	ex hl, de
1256   FB2D             ; 803         PrintCrLfTabHexWordSpace(hl);
1257   FB2D CD 51 FC    	call printcrlftabhexwordspace
1258   FB30             ; 804         ReadString();
1259   FB30 CD 14 F9    	call readstring
1260   FB33             ; 805         if (flag_c) {
1261   FB33 D2 3F FB    	jp nc, l_60
1262   FB36             ; 806             ParseWord();
1263   FB36 CD 80 F9    	call parseword
1264   FB39             ; 807             pop(de);
1265   FB39 D1          	pop de
1266   FB3A             ; 808             push(de);
1267   FB3A D5          	push de
1268   FB3B             ; 809             swap(hl, de);
1269   FB3B EB          	ex hl, de
1270   FB3C             ; 810             *hl = d;
1271   FB3C 72          	ld (hl), d
1272   FB3D             ; 811             hl--;
1273   FB3D 2B          	dec hl
1274   FB3E             ; 812             *hl = e;
1275   FB3E 73          	ld (hl), e
1276   FB3F             l_60: 
1277   FB3F             ; 813         }
1278   FB3F             ; 814         pop(hl);
1279   FB3F E1          	pop hl
1280   FB40             ; 815         pop(bc);
1281   FB40 C1          	pop bc
1282   FB41             ; 816         b--;
1283   FB41 05          	dec b
1284   FB42             ; 817         hl++;
1285   FB42 23          	inc hl
1286   FB43             l_58: 
1287   FB43 C2 27 FB    	jp nz, l_57
1288   FB46             ; 818     } while (flag_nz);
1289   FB46             ; 819     EntryF86C_Monitor();
1290   FB46 C3 6C F8    	jp entryf86c_monitor
1291   FB49             ; 820 }
1292   FB49             ; 821 
1293   FB49             ; 822 // Функция для пользовательской программы.
1294   FB49             ; 823 // Получить координаты курсора.
1295   FB49             ; 824 // Параметры: нет. Результат: l = x + 8, h = y + 3. Сохраняет регистры: bc, de, hl.
1296   FB49             ; 825 
1297   FB49             ; 826 void GetCursor() {
1298   FB49             getcursor: 
1299   FB49             ; 827     push_pop(a) {
1300   FB49 F5          	push af
1301   FB4A             ; 828         hl = cursor;
1302   FB4A 2A 5A F7    	ld hl, (cursor)
1303   FB4D             ; 829         h = ((a = h) &= 7);
1304   FB4D 7C          	ld a, h
1305   FB4E E6 07       	and 7
1306   FB50 67          	ld h, a
1307   FB51             ; 830 
1308   FB51             ; 831         // Вычисление X
1309   FB51             ; 832         a = l;
1310   FB51 7D          	ld a, l
1311   FB52             ; 833         a &= (SCREEN_WIDTH - 1);
1312   FB52 E6 3F       	and 63
1313   FB54             ; 834         a += 8;  // Смещение Радио 86РК
1314   FB54 C6 08       	add 8
1315   FB56             ; 835 
1316   FB56             ; 836         // Вычисление Y
1317   FB56             ; 837         hl += hl;
1318   FB56 29          	add hl, hl
1319   FB57             ; 838         hl += hl;
1320   FB57 29          	add hl, hl
1321   FB58             ; 839         h++;  // Смещение Радио 86РК
1322   FB58 24          	inc h
1323   FB59             ; 840         h++;
1324   FB59 24          	inc h
1325   FB5A             ; 841         h++;
1326   FB5A 24          	inc h
1327   FB5B             ; 842 
1328   FB5B             ; 843         l = a;
1329   FB5B 6F          	ld l, a
1330   FB5C F1          	pop af
1331   FB5D C9          	ret
1332   FB5E             ; 844     }
1333   FB5E             ; 845 }
1334   FB5E             ; 846 
1335   FB5E             ; 847 // Функция для пользовательской программы.
1336   FB5E             ; 848 // Получить символ под курсором.
1337   FB5E             ; 849 // Параметры: нет. Результат: a - код символа. Сохраняет регистры: bc, de, hl.
1338   FB5E             ; 850 
1339   FB5E             ; 851 void GetCursorChar() {
1340   FB5E             getcursorchar: 
1341   FB5E             ; 852     push_pop(hl) {
1342   FB5E E5          	push hl
1343   FB5F             ; 853         hl = cursor;
1344   FB5F 2A 5A F7    	ld hl, (cursor)
1345   FB62             ; 854         a = *hl;
1346   FB62 7E          	ld a, (hl)
1347   FB63 E1          	pop hl
1348   FB64 C9          	ret
1349   FB65             ; 855     }
1350   FB65             ; 856 }
1351   FB65             ; 857 
1352   FB65             ; 858 // Команда H
1353   FB65             ; 859 // Определить скорости записанной программы.
1354   FB65             ; 860 // Выводит 4 цифры на экран.
1355   FB65             ; 861 // Первые две цифры - константа вывода для команды O
1356   FB65             ; 862 // Последние две цифры - константа вввода для команды I
1357   FB65             ; 863 
1358   FB65             ; 864 void CmdH(...) {
1359   FB65             cmdh: 
1360   FB65             ; 865     PrintCrLfTab();
1361   FB65 CD D3 F9    	call printcrlftab
1362   FB68             ; 866     hl = 65408;
1363   FB68 21 80 FF    	ld hl, 65408
1364   FB6B             ; 867     b = 123;
1365   FB6B 06 7B       	ld b, 123
1366   FB6D             ; 868 
1367   FB6D             ; 869     c = a = in(PORT_TAPE);
1368   FB6D DB 01       	in a, (1)
1369   FB6F 4F          	ld c, a
1370   FB70             ; 870 
1371   FB70             ; 871     do {
1372   FB70             l_62: 
1373   FB70             l_63: 
1374   FB70             ; 872     } while ((a = in(PORT_TAPE)) == c);
1375   FB70 DB 01       	in a, (1)
1376   FB72 B9          	cp c
1377   FB73 CA 70 FB    	jp z, l_62
1378   FB76             ; 873 
1379   FB76             ; 874     do {
1380   FB76             l_65: 
1381   FB76             ; 875         c = a;
1382   FB76 4F          	ld c, a
1383   FB77             ; 876         do {
1384   FB77             l_68: 
1385   FB77             ; 877             hl++;
1386   FB77 23          	inc hl
1387   FB78             l_69: 
1388   FB78             ; 878         } while ((a = in(PORT_TAPE)) == c);
1389   FB78 DB 01       	in a, (1)
1390   FB7A B9          	cp c
1391   FB7B CA 77 FB    	jp z, l_68
1392   FB7E             l_66: 
1393   FB7E             ; 879     } while (flag_nz(b--));
1394   FB7E 05          	dec b
1395   FB7F C2 76 FB    	jp nz, l_65
1396   FB82             ; 880 
1397   FB82             ; 881     hl += hl;
1398   FB82 29          	add hl, hl
1399   FB83             ; 882     a = h;
1400   FB83 7C          	ld a, h
1401   FB84             ; 883     hl += hl;
1402   FB84 29          	add hl, hl
1403   FB85             ; 884     l = (a += h);
1404   FB85 84          	add h
1405   FB86 6F          	ld l, a
1406   FB87             ; 885 
1407   FB87             ; 886     PrintHexWordSpace();
1408   FB87 C3 5A FC    	jp printhexwordspace
1409   FB8A             ; 887 }
1410   FB8A             ; 888 
1411   FB8A             ; 889 // Команда I <смещение> <скорость>
1412   FB8A             ; 890 // Загрузить файл с магнитной ленты
1413   FB8A             ; 891 
1414   FB8A             ; 892 void CmdI(...) {
1415   FB8A             cmdi: 
1416   FB8A             ; 893     if ((a = param2Exists) != 0)
1417   FB8A 3A 7B F7    	ld a, (param2exists)
1418   FB8D B7          	or a
1419   FB8E             ; 894         tapeReadSpeed = a = e;
1420   FB8E CA 95 FB    	jp z, l_71
1421   FB91 7B          	ld a, e
1422   FB92 32 5C F7    	ld (tapereadspeed), a
1423   FB95             l_71: 
1424   FB95             ; 895     ReadTapeFile();
1425   FB95 CD BA FB    	call readtapefile
1426   FB98             ; 896     PrintCrLfTabHexWordSpace(hl);
1427   FB98 CD 51 FC    	call printcrlftabhexwordspace
1428   FB9B             ; 897     swap(hl, de);
1429   FB9B EB          	ex hl, de
1430   FB9C             ; 898     PrintCrLfTabHexWordSpace(hl);
1431   FB9C CD 51 FC    	call printcrlftabhexwordspace
1432   FB9F             ; 899     swap(hl, de);
1433   FB9F EB          	ex hl, de
1434   FBA0             ; 900     push(bc);
1435   FBA0 C5          	push bc
1436   FBA1             ; 901     CalculateCheckSum();
1437   FBA1 CD F1 FB    	call calculatechecksum
1438   FBA4             ; 902     h = b;
1439   FBA4 60          	ld h, b
1440   FBA5             ; 903     l = c;
1441   FBA5 69          	ld l, c
1442   FBA6             ; 904     PrintCrLfTabHexWordSpace(hl);
1443   FBA6 CD 51 FC    	call printcrlftabhexwordspace
1444   FBA9             ; 905     pop(de);
1445   FBA9 D1          	pop de
1446   FBAA             ; 906     CompareHlDe(hl, de);
1447   FBAA CD B6 F9    	call comparehlde
1448   FBAD             ; 907     if (flag_z)
1449   FBAD             ; 908         return;
1450   FBAD C8          	ret z
1451   FBAE             ; 909     swap(hl, de);
1452   FBAE EB          	ex hl, de
1453   FBAF             ; 910     PrintCrLfTabHexWordSpace(hl);
1454   FBAF CD 51 FC    	call printcrlftabhexwordspace
1455   FBB2             ; 911     MonitorError();
1456   FBB2             ; 912 }
1457   FBB2             ; 913 
1458   FBB2             ; 914 void MonitorError() {
1459   FBB2             monitorerror: 
1460   FBB2             ; 915     PrintCharA(a = '?');
1461   FBB2 3E 3F       	ld a, 63
1462   FBB4 CD 22 FD    	call printchara
1463   FBB7             ; 916     Monitor2();
1464   FBB7 C3 94 F8    	jp monitor2
1465   FBBA             ; 917 }
1466   FBBA             ; 918 
1467   FBBA             ; 919 // Функция для пользовательской программы.
1468   FBBA             ; 920 // Загрузить файл с магнитной ленты.
1469   FBBA             ; 921 // Параметры: hl - смещение загрузки. Результат: bc - прочитанная КС, hl - адрес загрузки
1470   FBBA             ; 922 
1471   FBBA             ; 923 void ReadTapeFile(...) {
1472   FBBA             readtapefile: 
1473   FBBA             ; 924     ReadTapeWord(a = READ_TAPE_FIRST_BYTE);
1474   FBBA 3E FF       	ld a, 255
1475   FBBC CD DA FB    	call readtapeword
1476   FBBF             ; 925     push_pop(hl) {
1477   FBBF E5          	push hl
1478   FBC0             ; 926         hl += bc;
1479   FBC0 09          	add hl, bc
1480   FBC1             ; 927         swap(hl, de);
1481   FBC1 EB          	ex hl, de
1482   FBC2             ; 928         ReadTapeWordNext();
1483   FBC2 CD D8 FB    	call readtapewordnext
1484   FBC5 E1          	pop hl
1485   FBC6             ; 929     }
1486   FBC6             ; 930     hl += bc;
1487   FBC6 09          	add hl, bc
1488   FBC7             ; 931     swap(hl, de);
1489   FBC7 EB          	ex hl, de
1490   FBC8             ; 932 
1491   FBC8             ; 933     a = in(PORT_KEYBOARD_MODS);
1492   FBC8 DB 05       	in a, (5)
1493   FBCA             ; 934     a &= KEYBOARD_SHIFT_MOD;
1494   FBCA E6 04       	and 4
1495   FBCC             ; 935     if (flag_z)
1496   FBCC             ; 936         return;
1497   FBCC C8          	ret z
1498   FBCD             ; 937 
1499   FBCD             ; 938     push_pop(hl) {
1500   FBCD E5          	push hl
1501   FBCE             ; 939         ReadTapeBlock();
1502   FBCE CD E5 FB    	call readtapeblock
1503   FBD1             ; 940         ReadTapeWord(a = READ_TAPE_FIRST_BYTE);
1504   FBD1 3E FF       	ld a, 255
1505   FBD3 CD DA FB    	call readtapeword
1506   FBD6 E1          	pop hl
1507   FBD7 C9          	ret
1508   FBD8             ; 941     }
1509   FBD8             ; 942 }
1510   FBD8             ; 943 
1511   FBD8             ; 944 void ReadTapeWordNext() {
1512   FBD8             readtapewordnext: 
1513   FBD8             ; 945     ReadTapeWord(a = READ_TAPE_NEXT_BYTE);
1514   FBD8 3E 08       	ld a, 8
1515   FBDA             ; 946 }
1516   FBDA             ; 947 
1517   FBDA             ; 948 void ReadTapeWord(...) {
1518   FBDA             readtapeword: 
1519   FBDA             ; 949     ReadTapeByte(a);
1520   FBDA CD 74 FC    	call readtapebyte
1521   FBDD             ; 950     b = a;
1522   FBDD 47          	ld b, a
1523   FBDE             ; 951     ReadTapeByte(a = READ_TAPE_NEXT_BYTE);
1524   FBDE 3E 08       	ld a, 8
1525   FBE0 CD 74 FC    	call readtapebyte
1526   FBE3             ; 952     c = a;
1527   FBE3 4F          	ld c, a
1528   FBE4 C9          	ret
1529   FBE5             ; 953 }
1530   FBE5             ; 954 
1531   FBE5             ; 955 void ReadTapeBlock(...) {
1532   FBE5             readtapeblock: 
1533   FBE5             ; 956     for (;;) {
1534   FBE5             l_74: 
1535   FBE5             ; 957         ReadTapeByte(a = READ_TAPE_NEXT_BYTE);
1536   FBE5 3E 08       	ld a, 8
1537   FBE7 CD 74 FC    	call readtapebyte
1538   FBEA             ; 958         *hl = a;
1539   FBEA 77          	ld (hl), a
1540   FBEB             ; 959         Loop();
1541   FBEB CD BF F9    	call loop
1542   FBEE C3 E5 FB    	jp l_74
1543   FBF1             ; 960     }
1544   FBF1             ; 961 }
1545   FBF1             ; 962 
1546   FBF1             ; 963 // Функция для пользовательской программы.
1547   FBF1             ; 964 // Вычистить 16-битную сумму всех байт по адресам hl..de.
1548   FBF1             ; 965 // Параметры: hl - начальный адрес, de - конечный адрес. Результат: bc - сумма. Сохраяет: de.
1549   FBF1             ; 966 
1550   FBF1             ; 967 void CalculateCheckSum(...) {
1551   FBF1             calculatechecksum: 
1552   FBF1             ; 968     bc = 0;
1553   FBF1 01 00 00    	ld bc, 0
1554   FBF4             ; 969     for (;;) {
1555   FBF4             l_77: 
1556   FBF4             ; 970         c = ((a = *hl) += c);
1557   FBF4 7E          	ld a, (hl)
1558   FBF5 81          	add c
1559   FBF6 4F          	ld c, a
1560   FBF7             ; 971         push_pop(a) {
1561   FBF7 F5          	push af
1562   FBF8             ; 972             CompareHlDe(hl, de);
1563   FBF8 CD B6 F9    	call comparehlde
1564   FBFB             ; 973             if (flag_z)
1565   FBFB             ; 974                 return PopRet();
1566   FBFB CA C5 F9    	jp z, popret
1567   FBFE F1          	pop af
1568   FBFF             ; 975         }
1569   FBFF             ; 976         a = b;
1570   FBFF 78          	ld a, b
1571   FC00             ; 977         carry_add(a, *hl);
1572   FC00 8E          	adc (hl)
1573   FC01             ; 978         b = a;
1574   FC01 47          	ld b, a
1575   FC02             ; 979         Loop();
1576   FC02 CD BF F9    	call loop
1577   FC05 C3 F4 FB    	jp l_77
1578   FC08             ; 980     }
1579   FC08             ; 981 }
1580   FC08             ; 982 
1581   FC08             ; 983 // Команда O <начальный адрес> <конечный адрес> <скорость>
1582   FC08             ; 984 // Сохранить блок данных на магнитную ленту
1583   FC08             ; 985 
1584   FC08             ; 986 void CmdO(...) {
1585   FC08             cmdo: 
1586   FC08             ; 987     if ((a = c) != 0)
1587   FC08 79          	ld a, c
1588   FC09 B7          	or a
1589   FC0A             ; 988         tapeWriteSpeed = a;
1590   FC0A CA 10 FC    	jp z, l_79
1591   FC0D 32 5D F7    	ld (tapewritespeed), a
1592   FC10             l_79: 
1593   FC10             ; 989     push_pop(hl) {
1594   FC10 E5          	push hl
1595   FC11             ; 990         CalculateCheckSum(hl, de);
1596   FC11 CD F1 FB    	call calculatechecksum
1597   FC14 E1          	pop hl
1598   FC15             ; 991     }
1599   FC15             ; 992     PrintCrLfTabHexWordSpace(hl);
1600   FC15 CD 51 FC    	call printcrlftabhexwordspace
1601   FC18             ; 993     swap(hl, de);
1602   FC18 EB          	ex hl, de
1603   FC19             ; 994     PrintCrLfTabHexWordSpace(hl);
1604   FC19 CD 51 FC    	call printcrlftabhexwordspace
1605   FC1C             ; 995     swap(hl, de);
1606   FC1C EB          	ex hl, de
1607   FC1D             ; 996     push_pop(hl) {
1608   FC1D E5          	push hl
1609   FC1E             ; 997         h = b;
1610   FC1E 60          	ld h, b
1611   FC1F             ; 998         l = c;
1612   FC1F 69          	ld l, c
1613   FC20             ; 999         PrintCrLfTabHexWordSpace(hl);
1614   FC20 CD 51 FC    	call printcrlftabhexwordspace
1615   FC23 E1          	pop hl
1616   FC24             ; 1000     }
1617   FC24             ; 1001     WriteTapeFile(hl, de);
1618   FC24             ; 1002 }
1619   FC24             ; 1003 
1620   FC24             ; 1004 // Функция для пользовательской программы.
1621   FC24             ; 1005 // Запись файла на магнитную ленту.
1622   FC24             ; 1006 // Параметры: de - начальный адрес, hl - конечный адрес, bc - контрольная сумма. Результат: нет.
1623   FC24             ; 1007 
1624   FC24             ; 1008 void WriteTapeFile(...) {
1625   FC24             writetapefile: 
1626   FC24             ; 1009     push(bc);
1627   FC24 C5          	push bc
1628   FC25             ; 1010     bc = 0;
1629   FC25 01 00 00    	ld bc, 0
1630   FC28             ; 1011     do {
1631   FC28             l_81: 
1632   FC28             ; 1012         WriteTapeByte(c);
1633   FC28 CD DD FC    	call writetapebyte
1634   FC2B             ; 1013         b--;
1635   FC2B 05          	dec b
1636   FC2C             ; 1014         swap(hl, *sp);
1637   FC2C E3          	ex (sp), hl
1638   FC2D             ; 1015         swap(hl, *sp);
1639   FC2D E3          	ex (sp), hl
1640   FC2E             l_82: 
1641   FC2E C2 28 FC    	jp nz, l_81
1642   FC31             ; 1016     } while (flag_nz);
1643   FC31             ; 1017     WriteTapeByte(c = TAPE_START);
1644   FC31 0E E6       	ld c, 230
1645   FC33 CD DD FC    	call writetapebyte
1646   FC36             ; 1018     WriteTapeWord(hl);
1647   FC36 CD 6C FC    	call writetapeword
1648   FC39             ; 1019     swap(hl, de);
1649   FC39 EB          	ex hl, de
1650   FC3A             ; 1020     WriteTapeWord(hl);
1651   FC3A CD 6C FC    	call writetapeword
1652   FC3D             ; 1021     swap(hl, de);
1653   FC3D EB          	ex hl, de
1654   FC3E             ; 1022     WriteTapeBlock(hl, de);
1655   FC3E CD 62 FC    	call writetapeblock
1656   FC41             ; 1023     WriteTapeWord(hl = 0);
1657   FC41 21 00 00    	ld hl, 0
1658   FC44 CD 6C FC    	call writetapeword
1659   FC47             ; 1024     WriteTapeByte(c = TAPE_START);
1660   FC47 0E E6       	ld c, 230
1661   FC49 CD DD FC    	call writetapebyte
1662   FC4C             ; 1025     pop(hl);
1663   FC4C E1          	pop hl
1664   FC4D             ; 1026     WriteTapeWord(hl);
1665   FC4D CD 6C FC    	call writetapeword
1666   FC50             ; 1027     return;
1667   FC50 C9          	ret
1668   FC51             ; 1028 }
1669   FC51             ; 1029 
1670   FC51             ; 1030 void PrintCrLfTabHexWordSpace(...) {
1671   FC51             printcrlftabhexwordspace: 
1672   FC51             ; 1031     push_pop(bc) {
1673   FC51 C5          	push bc
1674   FC52             ; 1032         PrintCrLfTab();
1675   FC52 CD D3 F9    	call printcrlftab
1676   FC55             ; 1033         PrintHexWordSpace(hl);
1677   FC55 CD 5A FC    	call printhexwordspace
1678   FC58 C1          	pop bc
1679   FC59 C9          	ret
1680   FC5A             ; 1034     }
1681   FC5A             ; 1035 }
1682   FC5A             ; 1036 
1683   FC5A             ; 1037 void PrintHexWordSpace(...) {
1684   FC5A             printhexwordspace: 
1685   FC5A             ; 1038     PrintHexByte(a = h);
1686   FC5A 7C          	ld a, h
1687   FC5B CD 0E FD    	call printhexbyte
1688   FC5E             ; 1039     PrintHexByteSpace(a = l);
1689   FC5E 7D          	ld a, l
1690   FC5F C3 DD F9    	jp printhexbytespace
1691   FC62             ; 1040 }
1692   FC62             ; 1041 
1693   FC62             ; 1042 void WriteTapeBlock(...) {
1694   FC62             writetapeblock: 
1695   FC62             ; 1043     for (;;) {
1696   FC62             l_85: 
1697   FC62             ; 1044         WriteTapeByte(c = *hl);
1698   FC62 4E          	ld c, (hl)
1699   FC63 CD DD FC    	call writetapebyte
1700   FC66             ; 1045         Loop();
1701   FC66 CD BF F9    	call loop
1702   FC69 C3 62 FC    	jp l_85
1703   FC6C             ; 1046     }
1704   FC6C             ; 1047 }
1705   FC6C             ; 1048 
1706   FC6C             ; 1049 void WriteTapeWord(...) {
1707   FC6C             writetapeword: 
1708   FC6C             ; 1050     WriteTapeByte(c = h);
1709   FC6C 4C          	ld c, h
1710   FC6D CD DD FC    	call writetapebyte
1711   FC70             ; 1051     WriteTapeByte(c = l);
1712   FC70 4D          	ld c, l
1713   FC71 C3 DD FC    	jp writetapebyte
1714   FC74             ; 1052 }
1715   FC74             ; 1053 
1716   FC74             ; 1054 // Загрузка байта с магнитной ленты.
1717   FC74             ; 1055 // Параметры: a = 0xFF с синхронизацией, = 8 без синхронизации.
1718   FC74             ; 1056 // Результат: a = прочитанный байт.
1719   FC74             ; 1057 
1720   FC74             ; 1058 void ReadTapeByte(...) {
1721   FC74             readtapebyte: 
1722   FC74             ; 1059     push(hl, bc, de);
1723   FC74 E5          	push hl
1724   FC75 C5          	push bc
1725   FC76 D5          	push de
1726   FC77             ; 1060     d = a;
1727   FC77 57          	ld d, a
1728   FC78             ; 1061     ReadTapeByteInternal(d);
1729   FC78             ; 1062 }
1730   FC78             ; 1063 
1731   FC78             ; 1064 void ReadTapeByteInternal(...) {
1732   FC78             readtapebyteinternal: 
1733   FC78             ; 1065     c = 0;
1734   FC78 0E 00       	ld c, 0
1735   FC7A             ; 1066     e = ((a = in(PORT_TAPE)) &= PORT_TAPE_BIT);
1736   FC7A DB 01       	in a, (1)
1737   FC7C E6 01       	and 1
1738   FC7E 5F          	ld e, a
1739   FC7F             ; 1067     do {
1740   FC7F             l_87: 
1741   FC7F             ; 1068     retry:  // Сдвиг результата
1742   FC7F             retry: 
1743   FC7F             ; 1069         (a = c) &= 0x7F;
1744   FC7F 79          	ld a, c
1745   FC80 E6 7F       	and 127
1746   FC82             ; 1070         cyclic_rotate_left(a, 1);
1747   FC82 07          	rlca
1748   FC83             ; 1071         c = a;
1749   FC83 4F          	ld c, a
1750   FC84             ; 1072 
1751   FC84             ; 1073         // Ожидание изменения бита
1752   FC84             ; 1074         h = 0;
1753   FC84 26 00       	ld h, 0
1754   FC86             ; 1075         do {
1755   FC86             l_90: 
1756   FC86             ; 1076             h--;
1757   FC86 25          	dec h
1758   FC87             ; 1077             if (flag_z)
1759   FC87             ; 1078                 return ReadTapeByteTimeout(d);
1760   FC87 CA D2 FC    	jp z, readtapebytetimeout
1761   FC8A             l_91: 
1762   FC8A             ; 1079         } while (((a = in(PORT_TAPE)) &= PORT_TAPE_BIT) == e);
1763   FC8A DB 01       	in a, (1)
1764   FC8C E6 01       	and 1
1765   FC8E BB          	cp e
1766   FC8F CA 86 FC    	jp z, l_90
1767   FC92             ; 1080 
1768   FC92             ; 1081         // Сохранение бита
1769   FC92             ; 1082         c = (a |= c);
1770   FC92 B1          	or c
1771   FC93 4F          	ld c, a
1772   FC94             ; 1083 
1773   FC94             ; 1084         // Задержка
1774   FC94             ; 1085         d--;
1775   FC94 15          	dec d
1776   FC95             ; 1086         a = tapeReadSpeed;
1777   FC95 3A 5C F7    	ld a, (tapereadspeed)
1778   FC98             ; 1087         if (flag_z)
1779   FC98             ; 1088             a -= 18;
1780   FC98 C2 9D FC    	jp nz, l_93
1781   FC9B D6 12       	sub 18
1782   FC9D             l_93: 
1783   FC9D             ; 1089         b = a;
1784   FC9D 47          	ld b, a
1785   FC9E             ; 1090         do {
1786   FC9E             l_95: 
1787   FC9E             l_96: 
1788   FC9E             ; 1091         } while (flag_nz(b--));
1789   FC9E 05          	dec b
1790   FC9F C2 9E FC    	jp nz, l_95
1791   FCA2             ; 1092         d++;
1792   FCA2 14          	inc d
1793   FCA3             ; 1093 
1794   FCA3             ; 1094         // Новое значение бита
1795   FCA3             ; 1095         e = ((a = in(PORT_TAPE)) &= PORT_TAPE_BIT);
1796   FCA3 DB 01       	in a, (1)
1797   FCA5 E6 01       	and 1
1798   FCA7 5F          	ld e, a
1799   FCA8             ; 1096 
1800   FCA8             ; 1097         // Режим поиска синхробайта
1801   FCA8             ; 1098         if (flag_m((a = d) |= a)) {
1802   FCA8 7A          	ld a, d
1803   FCA9 B7          	or a
1804   FCAA F2 C6 FC    	jp p, l_98
1805   FCAD             ; 1099             if ((a = c) == TAPE_START) {
1806   FCAD 79          	ld a, c
1807   FCAE FE E6       	cp 230
1808   FCB0 C2 BA FC    	jp nz, l_100
1809   FCB3             ; 1100                 tapePolarity = (a ^= a);
1810   FCB3 AF          	xor a
1811   FCB4 32 7C F7    	ld (tapepolarity), a
1812   FCB7 C3 C4 FC    	jp l_101
1813   FCBA             l_100: 
1814   FCBA             ; 1101             } else {
1815   FCBA             ; 1102                 if (a != ~TAPE_START)
1816   FCBA FE 19       	cp 65305
1817   FCBC             ; 1103                     goto retry;
1818   FCBC C2 7F FC    	jp nz, retry
1819   FCBF             ; 1104                 tapePolarity = a = 255;
1820   FCBF 3E FF       	ld a, 255
1821   FCC1 32 7C F7    	ld (tapepolarity), a
1822   FCC4             l_101: 
1823   FCC4             ; 1105             }
1824   FCC4             ; 1106             d = 8 + 1;
1825   FCC4 16 09       	ld d, 9
1826   FCC6             l_98: 
1827   FCC6             l_88: 
1828   FCC6             ; 1107         }
1829   FCC6             ; 1108     } while (flag_nz(d--));
1830   FCC6 15          	dec d
1831   FCC7 C2 7F FC    	jp nz, l_87
1832   FCCA             ; 1109     (a = tapePolarity) ^= c;
1833   FCCA 3A 7C F7    	ld a, (tapepolarity)
1834   FCCD A9          	xor c
1835   FCCE             ; 1110     pop(hl, bc, de);
1836   FCCE D1          	pop de
1837   FCCF C1          	pop bc
1838   FCD0 E1          	pop hl
1839   FCD1 C9          	ret
1840   FCD2             ; 1111 }
1841   FCD2             ; 1112 
1842   FCD2             ; 1113 void ReadTapeByteTimeout(...) {
1843   FCD2             readtapebytetimeout: 
1844   FCD2             ; 1114     if (flag_p((a = d) |= a))
1845   FCD2 7A          	ld a, d
1846   FCD3 B7          	or a
1847   FCD4             ; 1115         return MonitorError();
1848   FCD4 F2 B2 FB    	jp p, monitorerror
1849   FCD7             ; 1116     CtrlC();
1850   FCD7 CD CA F9    	call ctrlc
1851   FCDA             ; 1117     return ReadTapeByteInternal();
1852   FCDA C3 78 FC    	jp readtapebyteinternal
1853   FCDD             ; 1118 }
1854   FCDD             ; 1119 
1855   FCDD             ; 1120 // Функция для пользовательской программы.
1856   FCDD             ; 1121 // Запись байта на магнитную ленту.
1857   FCDD             ; 1122 // Параметры: c = байт. Результат: нет. Сохрнаяет: a, bc, de, hl.
1858   FCDD             ; 1123 
1859   FCDD             ; 1124 void WriteTapeByte(...) {
1860   FCDD             writetapebyte: 
1861   FCDD             ; 1125     push_pop(bc, de, a) {
1862   FCDD C5          	push bc
1863   FCDE D5          	push de
1864   FCDF F5          	push af
1865   FCE0             ; 1126         d = 8;
1866   FCE0 16 08       	ld d, 8
1867   FCE2             ; 1127         do {
1868   FCE2             l_102: 
1869   FCE2             ; 1128             // Сдвиг исходного байта
1870   FCE2             ; 1129             a = c;
1871   FCE2 79          	ld a, c
1872   FCE3             ; 1130             cyclic_rotate_left(a, 1);
1873   FCE3 07          	rlca
1874   FCE4             ; 1131             c = a;
1875   FCE4 4F          	ld c, a
1876   FCE5             ; 1132 
1877   FCE5             ; 1133             // Вывод
1878   FCE5             ; 1134             (a = PORT_TAPE_BIT) ^= c;
1879   FCE5 3E 01       	ld a, 1
1880   FCE7 A9          	xor c
1881   FCE8             ; 1135             out(PORT_TAPE, a);
1882   FCE8 D3 01       	out (1), a
1883   FCEA             ; 1136 
1884   FCEA             ; 1137             // Задержка
1885   FCEA             ; 1138             b = a = tapeWriteSpeed;
1886   FCEA 3A 5D F7    	ld a, (tapewritespeed)
1887   FCED 47          	ld b, a
1888   FCEE             ; 1139             do {
1889   FCEE             l_105: 
1890   FCEE             ; 1140                 b--;
1891   FCEE 05          	dec b
1892   FCEF             l_106: 
1893   FCEF C2 EE FC    	jp nz, l_105
1894   FCF2             ; 1141             } while (flag_nz);
1895   FCF2             ; 1142 
1896   FCF2             ; 1143             // Вывод
1897   FCF2             ; 1144             (a = 0) ^= c;
1898   FCF2 3E 00       	ld a, 0
1899   FCF4 A9          	xor c
1900   FCF5             ; 1145             out(PORT_TAPE, a);
1901   FCF5 D3 01       	out (1), a
1902   FCF7             ; 1146 
1903   FCF7             ; 1147             // Задержка
1904   FCF7             ; 1148             d--;
1905   FCF7 15          	dec d
1906   FCF8             ; 1149             a = tapeWriteSpeed;
1907   FCF8 3A 5D F7    	ld a, (tapewritespeed)
1908   FCFB             ; 1150             if (flag_z)
1909   FCFB             ; 1151                 a -= 14;
1910   FCFB C2 00 FD    	jp nz, l_108
1911   FCFE D6 0E       	sub 14
1912   FD00             l_108: 
1913   FD00             ; 1152             b = a;
1914   FD00 47          	ld b, a
1915   FD01             ; 1153             do {
1916   FD01             l_110: 
1917   FD01             ; 1154                 b--;
1918   FD01 05          	dec b
1919   FD02             l_111: 
1920   FD02 C2 01 FD    	jp nz, l_110
1921   FD05             ; 1155             } while (flag_nz);
1922   FD05             ; 1156             d++;
1923   FD05 14          	inc d
1924   FD06             l_103: 
1925   FD06             ; 1157         } while (flag_nz(d--));
1926   FD06 15          	dec d
1927   FD07 C2 E2 FC    	jp nz, l_102
1928   FD0A F1          	pop af
1929   FD0B D1          	pop de
1930   FD0C C1          	pop bc
1931   FD0D C9          	ret
1932   FD0E             ; 1158     }
1933   FD0E             ; 1159 }
1934   FD0E             ; 1160 
1935   FD0E             ; 1161 // Функция для пользовательской программы.
1936   FD0E             ; 1162 // Вывод 8 битного числа на экран.
1937   FD0E             ; 1163 // Параметры: а - число. Результат: нет. Сохраняет: bc, de, hl.
1938   FD0E             ; 1164 
1939   FD0E             ; 1165 void PrintHexByte(...) {
1940   FD0E             printhexbyte: 
1941   FD0E             ; 1166     push_pop(a) {
1942   FD0E F5          	push af
1943   FD0F             ; 1167         cyclic_rotate_right(a, 4);
1944   FD0F 0F          	rrca
1945   FD10 0F          	rrca
1946   FD11 0F          	rrca
1947   FD12 0F          	rrca
1948   FD13             ; 1168         PrintHexNibble(a);
1949   FD13 CD 17 FD    	call printhexnibble
1950   FD16 F1          	pop af
1951   FD17             ; 1169     }
1952   FD17             ; 1170     PrintHexNibble(a);
1953   FD17             ; 1171 }
1954   FD17             ; 1172 
1955   FD17             ; 1173 void PrintHexNibble(...) {
1956   FD17             printhexnibble: 
1957   FD17             ; 1174     a &= 0x0F;
1958   FD17 E6 0F       	and 15
1959   FD19             ; 1175     if (flag_p(compare(a, 10)))
1960   FD19 FE 0A       	cp 10
1961   FD1B             ; 1176         a += 'A' - '0' - 10;
1962   FD1B FA 20 FD    	jp m, l_113
1963   FD1E C6 07       	add 7
1964   FD20             l_113: 
1965   FD20             ; 1177     a += '0';
1966   FD20 C6 30       	add 48
1967   FD22             ; 1178     PrintCharA(a);
1968   FD22             ; 1179 }
1969   FD22             ; 1180 
1970   FD22             ; 1181 // Вывод символа на экран.
1971   FD22             ; 1182 // Параметры: а - символ. Результат: a и c - символ. Сохраняет: a, b, de, hl.
1972   FD22             ; 1183 
1973   FD22             ; 1184 void PrintCharA(...) {
1974   FD22             printchara: 
1975   FD22             ; 1185     PrintChar(c = a);
1976   FD22 4F          	ld c, a
1977   FD23             ; 1186 }
1978   FD23             ; 1187 
1979   FD23             ; 1188 // Функция для пользовательской программы.
1980   FD23             ; 1189 // Вывод символа на экран.
1981   FD23             ; 1190 // Параметры: c - символ. Результат: нет. Сохраняет: a, b, de, hl.
1982   FD23             ; 1191 
1983   FD23             ; 1192 void PrintChar(...) {
1984   FD23             printchar: 
1985   FD23             ; 1193     push(a, bc, de, hl);
1986   FD23 F5          	push af
1987   FD24 C5          	push bc
1988   FD25 D5          	push de
1989   FD26 E5          	push hl
1990   FD27             ; 1194     IsAnyKeyPressed();
1991   FD27 CD B7 FE    	call isanykeypressed
1992   FD2A             ; 1195     DrawCursor(b = 0);
1993   FD2A 06 00       	ld b, 0
1994   FD2C CD 77 FD    	call drawcursor
1995   FD2F             ; 1196     hl = cursor;
1996   FD2F 2A 5A F7    	ld hl, (cursor)
1997   FD32             ; 1197     a = escState;
1998   FD32 3A 5F F7    	ld a, (escstate)
1999   FD35             ; 1198     a--;
2000   FD35 3D          	dec a
2001   FD36             ; 1199     if (flag_m)
2002   FD36             ; 1200         return PrintCharNoEsc();
2003   FD36 FA BF FD    	jp m, printcharnoesc
2004   FD39             ; 1201     if (flag_z)
2005   FD39             ; 1202         return PrintCharEsc();
2006   FD39 CA A0 FD    	jp z, printcharesc
2007   FD3C             ; 1203     a--;
2008   FD3C 3D          	dec a
2009   FD3D             ; 1204     if (flag_nz)
2010   FD3D             ; 1205         return PrintCharEscY2();
2011   FD3D C2 85 FD    	jp nz, printcharescy2
2012   FD40             ; 1206 
2013   FD40             ; 1207     // Первый параметр ESC Y
2014   FD40             ; 1208     a = c;
2015   FD40 79          	ld a, c
2016   FD41             ; 1209     a -= ' ';
2017   FD41 D6 20       	sub 32
2018   FD43             ; 1210     if (flag_m) {
2019   FD43 F2 4A FD    	jp p, l_115
2020   FD46             ; 1211         a ^= a;
2021   FD46 AF          	xor a
2022   FD47 C3 51 FD    	jp l_116
2023   FD4A             l_115: 
2024   FD4A             ; 1212     } else {
2025   FD4A             ; 1213         if (flag_p(compare(a, SCREEN_HEIGHT)))
2026   FD4A FE 20       	cp 32
2027   FD4C             ; 1214             a = SCREEN_HEIGHT - 1;
2028   FD4C FA 51 FD    	jp m, l_117
2029   FD4F 3E 1F       	ld a, 31
2030   FD51             l_117: 
2031   FD51             l_116: 
2032   FD51             ; 1215     }
2033   FD51             ; 1216     cyclic_rotate_right(a, 2);
2034   FD51 0F          	rrca
2035   FD52 0F          	rrca
2036   FD53             ; 1217     c = a;
2037   FD53 4F          	ld c, a
2038   FD54             ; 1218     b = (a &= 192);
2039   FD54 E6 C0       	and 192
2040   FD56 47          	ld b, a
2041   FD57             ; 1219     l = (((a = l) &= 63) |= b);
2042   FD57 7D          	ld a, l
2043   FD58 E6 3F       	and 63
2044   FD5A B0          	or b
2045   FD5B 6F          	ld l, a
2046   FD5C             ; 1220     b = ((a = c) &= 7);
2047   FD5C 79          	ld a, c
2048   FD5D E6 07       	and 7
2049   FD5F 47          	ld b, a
2050   FD60             ; 1221     h = (((a = h) &= 248) |= b);
2051   FD60 7C          	ld a, h
2052   FD61 E6 F8       	and 248
2053   FD63 B0          	or b
2054   FD64 67          	ld h, a
2055   FD65             ; 1222     PrintCharSetEscState(hl, a = 3);
2056   FD65 3E 03       	ld a, 3
2057   FD67             ; 1223 }
2058   FD67             ; 1224 
2059   FD67             ; 1225 void PrintCharSetEscState(...) {
2060   FD67             printcharsetescstate: 
2061   FD67             ; 1226     escState = a;
2062   FD67 32 5F F7    	ld (escstate), a
2063   FD6A             ; 1227     PrintCharSaveCursor(hl);
2064   FD6A             ; 1228 }
2065   FD6A             ; 1229 
2066   FD6A             ; 1230 void PrintCharSaveCursor(...) {
2067   FD6A             printcharsavecursor: 
2068   FD6A             ; 1231     cursor = hl;
2069   FD6A 22 5A F7    	ld (cursor), hl
2070   FD6D             ; 1232     PrintCharExit();
2071   FD6D             ; 1233 }
2072   FD6D             ; 1234 
2073   FD6D             ; 1235 void PrintCharExit(...) {
2074   FD6D             printcharexit: 
2075   FD6D             ; 1236     DrawCursor(b = 0xFF);
2076   FD6D 06 FF       	ld b, 255
2077   FD6F CD 77 FD    	call drawcursor
2078   FD72             ; 1237     pop(a, bc, de, hl);
2079   FD72 E1          	pop hl
2080   FD73 D1          	pop de
2081   FD74 C1          	pop bc
2082   FD75 F1          	pop af
2083   FD76 C9          	ret
2084   FD77             ; 1238 }
2085   FD77             ; 1239 
2086   FD77             ; 1240 void DrawCursor(...) {
2087   FD77             drawcursor: 
2088   FD77             ; 1241     if ((a = cursorVisible) == 0)
2089   FD77 3A 5E F7    	ld a, (cursorvisible)
2090   FD7A B7          	or a
2091   FD7B             ; 1242         return;
2092   FD7B C8          	ret z
2093   FD7C             ; 1243     hl = cursor;
2094   FD7C 2A 5A F7    	ld hl, (cursor)
2095   FD7F             ; 1244     hl += (de = -SCREEN_SIZE + 1);
2096   FD7F 11 01 F8    	ld de, 63489
2097   FD82 19          	add hl, de
2098   FD83             ; 1245     *hl = b;
2099   FD83 70          	ld (hl), b
2100   FD84 C9          	ret
2101   FD85             ; 1246 }
2102   FD85             ; 1247 
2103   FD85             ; 1248 void PrintCharEscY2(...) {
2104   FD85             printcharescy2: 
2105   FD85             ; 1249     a = c;
2106   FD85 79          	ld a, c
2107   FD86             ; 1250     a -= ' ';
2108   FD86 D6 20       	sub 32
2109   FD88             ; 1251     if (flag_m) {
2110   FD88 F2 8F FD    	jp p, l_119
2111   FD8B             ; 1252         a ^= a;
2112   FD8B AF          	xor a
2113   FD8C C3 96 FD    	jp l_120
2114   FD8F             l_119: 
2115   FD8F             ; 1253     } else {
2116   FD8F             ; 1254         if (flag_p(compare(a, SCREEN_WIDTH)))
2117   FD8F FE 40       	cp 64
2118   FD91             ; 1255             a = SCREEN_WIDTH - 1;
2119   FD91 FA 96 FD    	jp m, l_121
2120   FD94 3E 3F       	ld a, 63
2121   FD96             l_121: 
2122   FD96             l_120: 
2123   FD96             ; 1256     }
2124   FD96             ; 1257     b = a;
2125   FD96 47          	ld b, a
2126   FD97             ; 1258     l = (((a = l) &= 192) |= b);
2127   FD97 7D          	ld a, l
2128   FD98 E6 C0       	and 192
2129   FD9A B0          	or b
2130   FD9B 6F          	ld l, a
2131   FD9C             ; 1259     PrintCharResetEscState();
2132   FD9C             ; 1260 }
2133   FD9C             ; 1261 
2134   FD9C             ; 1262 void PrintCharResetEscState(...) {
2135   FD9C             printcharresetescstate: 
2136   FD9C             ; 1263     a ^= a;
2137   FD9C AF          	xor a
2138   FD9D             ; 1264     return PrintCharSetEscState();
2139   FD9D C3 67 FD    	jp printcharsetescstate
2140   FDA0             ; 1265 }
2141   FDA0             ; 1266 
2142   FDA0             ; 1267 void PrintCharEsc(...) {
2143   FDA0             printcharesc: 
2144   FDA0             ; 1268     a = c;
2145   FDA0 79          	ld a, c
2146   FDA1             ; 1269     if (a == 'Y') {
2147   FDA1 FE 59       	cp 89
2148   FDA3 C2 AB FD    	jp nz, l_123
2149   FDA6             ; 1270         a = 2;
2150   FDA6 3E 02       	ld a, 2
2151   FDA8             ; 1271         return PrintCharSetEscState();
2152   FDA8 C3 67 FD    	jp printcharsetescstate
2153   FDAB             l_123: 
2154   FDAB             ; 1272     }
2155   FDAB             ; 1273     if (a == 97) {
2156   FDAB FE 61       	cp 97
2157   FDAD C2 B4 FD    	jp nz, l_125
2158   FDB0             ; 1274         a ^= a;
2159   FDB0 AF          	xor a
2160   FDB1             ; 1275         return SetCursorVisible();
2161   FDB1 C3 B9 FD    	jp setcursorvisible
2162   FDB4             l_125: 
2163   FDB4             ; 1276     }
2164   FDB4             ; 1277     if (a != 98)
2165   FDB4 FE 62       	cp 98
2166   FDB6             ; 1278         return PrintCharResetEscState();
2167   FDB6 C2 9C FD    	jp nz, printcharresetescstate
2168   FDB9             ; 1279     SetCursorVisible();
2169   FDB9             ; 1280 }
2170   FDB9             ; 1281 
2171   FDB9             ; 1282 void SetCursorVisible(...) {
2172   FDB9             setcursorvisible: 
2173   FDB9             ; 1283     cursorVisible = a;
2174   FDB9 32 5E F7    	ld (cursorvisible), a
2175   FDBC             ; 1284     return PrintCharResetEscState();
2176   FDBC C3 9C FD    	jp printcharresetescstate
2177   FDBF             ; 1285 }
2178   FDBF             ; 1286 
2179   FDBF             ; 1287 void PrintCharNoEsc(...) {
2180   FDBF             printcharnoesc: 
2181   FDBF             ; 1288     // Остановка вывода нажатием УС + Шифт
2182   FDBF             ; 1289     do {
2183   FDBF             l_127: 
2184   FDBF             ; 1290         a = in(PORT_KEYBOARD_MODS);
2185   FDBF DB 05       	in a, (5)
2186   FDC1             l_128: 
2187   FDC1             ; 1291     } while (flag_z(a &= (KEYBOARD_US_MOD | KEYBOARD_SHIFT_MOD)));
2188   FDC1 E6 06       	and 6
2189   FDC3 CA BF FD    	jp z, l_127
2190   FDC6             ; 1292 
2191   FDC6             ; 1293     compare(a = 16, c);
2192   FDC6 3E 10       	ld a, 16
2193   FDC8 B9          	cp c
2194   FDC9             ; 1294     a = translateCodeEnabled;
2195   FDC9 3A 7D F7    	ld a, (translatecodeenabled)
2196   FDCC             ; 1295     if (flag_z) {
2197   FDCC C2 D6 FD    	jp nz, l_130
2198   FDCF             ; 1296         invert(a);
2199   FDCF 2F          	cpl
2200   FDD0             ; 1297         translateCodeEnabled = a;
2201   FDD0 32 7D F7    	ld (translatecodeenabled), a
2202   FDD3             ; 1298         return PrintCharSaveCursor();
2203   FDD3 C3 6A FD    	jp printcharsavecursor
2204   FDD6             l_130: 
2205   FDD6             ; 1299     }
2206   FDD6             ; 1300     if (a != 0)
2207   FDD6 B7          	or a
2208   FDD7             ; 1301         TranslateCodePage(c);
2209   FDD7 C4 7E F7    	call nz, translatecodepage
2210   FDDA             ; 1302     a = c;
2211   FDDA 79          	ld a, c
2212   FDDB             ; 1303     if (a == 31)
2213   FDDB FE 1F       	cp 31
2214   FDDD             ; 1304         return ClearScreen();
2215   FDDD CA F1 FD    	jp z, clearscreen
2216   FDE0             ; 1305     if (flag_m)
2217   FDE0             ; 1306         return PrintChar3(a);
2218   FDE0 FA 06 FE    	jp m, printchar3
2219   FDE3             ; 1307     PrintChar4(a);
2220   FDE3             ; 1308 }
2221   FDE3             ; 1309 
2222   FDE3             ; 1310 void PrintChar4(...) {
2223   FDE3             printchar4: 
2224   FDE3             ; 1311     *hl = a;
2225   FDE3 77          	ld (hl), a
2226   FDE4             ; 1312     hl++;
2227   FDE4 23          	inc hl
2228   FDE5             ; 1313     if (flag_m(compare(a = h, SCREEN_END >> 8)))
2229   FDE5 7C          	ld a, h
2230   FDE6 FE F0       	cp 240
2231   FDE8             ; 1314         return PrintCharSaveCursor(hl);
2232   FDE8 FA 6A FD    	jp m, printcharsavecursor
2233   FDEB             ; 1315     PrintCrLf();
2234   FDEB CD AD FE    	call printcrlf
2235   FDEE             ; 1316     PrintCharExit();
2236   FDEE C3 6D FD    	jp printcharexit
2237   FDF1             ; 1317 }
2238   FDF1             ; 1318 
2239   FDF1             ; 1319 void ClearScreen(...) {
2240   FDF1             clearscreen: 
2241   FDF1             ; 1320     b = ' ';
2242   FDF1 06 20       	ld b, 32
2243   FDF3             ; 1321     a = SCREEN_END >> 8;
2244   FDF3 3E F0       	ld a, 240
2245   FDF5             ; 1322     hl = SCREEN_ATTRIB_BEGIN;
2246   FDF5 21 00 E0    	ld hl, 57344
2247   FDF8             ; 1323     do {
2248   FDF8             l_132: 
2249   FDF8             ; 1324         *hl = b;
2250   FDF8 70          	ld (hl), b
2251   FDF9             ; 1325         hl++;
2252   FDF9 23          	inc hl
2253   FDFA             ; 1326         *hl = b;
2254   FDFA 70          	ld (hl), b
2255   FDFB             ; 1327         hl++;
2256   FDFB 23          	inc hl
2257   FDFC             l_133: 
2258   FDFC             ; 1328     } while (a != h);
2259   FDFC BC          	cp h
2260   FDFD C2 F8 FD    	jp nz, l_132
2261   FE00             ; 1329     MoveCursorHome();
2262   FE00             ; 1330 }
2263   FE00             ; 1331 
2264   FE00             ; 1332 void MoveCursorHome(...) {
2265   FE00             movecursorhome: 
2266   FE00             ; 1333     return PrintCharSaveCursor(hl = SCREEN_BEGIN);
2267   FE00 21 00 E8    	ld hl, 59392
2268   FE03 C3 6A FD    	jp printcharsavecursor
2269   FE06             ; 1334 }
2270   FE06             ; 1335 
2271   FE06             ; 1336 void PrintChar3(...) {
2272   FE06             printchar3: 
2273   FE06             ; 1337     if (a == 12)
2274   FE06 FE 0C       	cp 12
2275   FE08             ; 1338         return MoveCursorHome();
2276   FE08 CA 00 FE    	jp z, movecursorhome
2277   FE0B             ; 1339     if (a == 13)
2278   FE0B FE 0D       	cp 13
2279   FE0D             ; 1340         return MoveCursorCr(hl);
2280   FE0D CA 55 FE    	jp z, movecursorcr
2281   FE10             ; 1341     if (a == 10)
2282   FE10 FE 0A       	cp 10
2283   FE12             ; 1342         return MoveCursorLf(hl);
2284   FE12 CA 6A FE    	jp z, movecursorlf
2285   FE15             ; 1343     if (a == 8)
2286   FE15 FE 08       	cp 8
2287   FE17             ; 1344         return MoveCursorLeft(hl);
2288   FE17 CA 66 FE    	jp z, movecursorleft
2289   FE1A             ; 1345     if (a == 24)
2290   FE1A FE 18       	cp 24
2291   FE1C             ; 1346         return MoveCursorRight(hl);
2292   FE1C CA 5C FE    	jp z, movecursorright
2293   FE1F             ; 1347     if (a == 25)
2294   FE1F FE 19       	cp 25
2295   FE21             ; 1348         return MoveCursorUp(hl);
2296   FE21 CA A0 FE    	jp z, movecursorup
2297   FE24             ; 1349     if (a == 7)
2298   FE24 FE 07       	cp 7
2299   FE26             ; 1350         return PrintCharBeep();
2300   FE26 CA 38 FE    	jp z, printcharbeep
2301   FE29             ; 1351     if (a == 26)
2302   FE29 FE 1A       	cp 26
2303   FE2B             ; 1352         return MoveCursorDown();
2304   FE2B CA A7 FE    	jp z, movecursordown
2305   FE2E             ; 1353     if (a != 27)
2306   FE2E FE 1B       	cp 27
2307   FE30             ; 1354         return PrintChar4(hl, a);
2308   FE30 C2 E3 FD    	jp nz, printchar4
2309   FE33             ; 1355     a = 1;
2310   FE33 3E 01       	ld a, 1
2311   FE35             ; 1356     return PrintCharSetEscState();
2312   FE35 C3 67 FD    	jp printcharsetescstate
2313   FE38             ; 1357 }
2314   FE38             ; 1358 
2315   FE38             ; 1359 void PrintCharBeep(...) {
2316   FE38             printcharbeep: 
2317   FE38             ; 1360     c = 128;  // Длительность
2318   FE38 0E 80       	ld c, 128
2319   FE3A             ; 1361     e = 32;   // Частота
2320   FE3A 1E 20       	ld e, 32
2321   FE3C             ; 1362     do {
2322   FE3C             l_135: 
2323   FE3C             ; 1363         d = e;
2324   FE3C 53          	ld d, e
2325   FE3D             ; 1364         do {
2326   FE3D             l_138: 
2327   FE3D             ; 1365             out(PORT_KEYBOARD_MODE, a = 1 | (7 << 1));
2328   FE3D 3E 0F       	ld a, 15
2329   FE3F D3 04       	out (4), a
2330   FE41             l_139: 
2331   FE41             ; 1366         } while (flag_nz(e--));
2332   FE41 1D          	dec e
2333   FE42 C2 3D FE    	jp nz, l_138
2334   FE45             ; 1367         e = d;
2335   FE45 5A          	ld e, d
2336   FE46             ; 1368         do {
2337   FE46             l_141: 
2338   FE46             ; 1369             out(PORT_KEYBOARD_MODE, a = (7 << 1));
2339   FE46 3E 0E       	ld a, 14
2340   FE48 D3 04       	out (4), a
2341   FE4A             l_142: 
2342   FE4A             ; 1370         } while (flag_nz(d--));
2343   FE4A 15          	dec d
2344   FE4B C2 46 FE    	jp nz, l_141
2345   FE4E             l_136: 
2346   FE4E             ; 1371     } while (flag_nz(c--));
2347   FE4E 0D          	dec c
2348   FE4F C2 3C FE    	jp nz, l_135
2349   FE52             ; 1372 
2350   FE52             ; 1373     return PrintCharExit();
2351   FE52 C3 6D FD    	jp printcharexit
2352   FE55             ; 1374 }
2353   FE55             ; 1375 
2354   FE55             ; 1376 void MoveCursorCr(...) {
2355   FE55             movecursorcr: 
2356   FE55             ; 1377     l = ((a = l) &= ~(SCREEN_WIDTH - 1));
2357   FE55 7D          	ld a, l
2358   FE56 E6 C0       	and 192
2359   FE58 6F          	ld l, a
2360   FE59             ; 1378     return PrintCharSaveCursor(hl);
2361   FE59 C3 6A FD    	jp printcharsavecursor
2362   FE5C             ; 1379 }
2363   FE5C             ; 1380 
2364   FE5C             ; 1381 void MoveCursorRight(...) {
2365   FE5C             movecursorright: 
2366   FE5C             ; 1382     hl++;
2367   FE5C 23          	inc hl
2368   FE5D             ; 1383     MoveCursorBoundary(hl);
2369   FE5D             ; 1384 }
2370   FE5D             ; 1385 
2371   FE5D             ; 1386 void MoveCursorBoundary(...) {
2372   FE5D             movecursorboundary: 
2373   FE5D             ; 1387     a = h;
2374   FE5D 7C          	ld a, h
2375   FE5E             ; 1388     a &= 7;
2376   FE5E E6 07       	and 7
2377   FE60             ; 1389     a |= SCREEN_BEGIN >> 8;
2378   FE60 F6 E8       	or 232
2379   FE62             ; 1390     h = a;
2380   FE62 67          	ld h, a
2381   FE63             ; 1391     return PrintCharSaveCursor(hl);
2382   FE63 C3 6A FD    	jp printcharsavecursor
2383   FE66             ; 1392 }
2384   FE66             ; 1393 
2385   FE66             ; 1394 void MoveCursorLeft(...) {
2386   FE66             movecursorleft: 
2387   FE66             ; 1395     hl--;
2388   FE66 2B          	dec hl
2389   FE67             ; 1396     return MoveCursorBoundary(hl);
2390   FE67 C3 5D FE    	jp movecursorboundary
2391   FE6A             ; 1397 }
2392   FE6A             ; 1398 
2393   FE6A             ; 1399 void MoveCursorLf(...) {
2394   FE6A             movecursorlf: 
2395   FE6A             ; 1400     hl += (bc = SCREEN_WIDTH);
2396   FE6A 01 40 00    	ld bc, 64
2397   FE6D 09          	add hl, bc
2398   FE6E             ; 1401     if (flag_m(compare(a = h, SCREEN_END >> 8)))
2399   FE6E 7C          	ld a, h
2400   FE6F FE F0       	cp 240
2401   FE71             ; 1402         return PrintCharSaveCursor(hl);
2402   FE71 FA 6A FD    	jp m, printcharsavecursor
2403   FE74             ; 1403 
2404   FE74             ; 1404     hl = SCREEN_BEGIN;
2405   FE74 21 00 E8    	ld hl, 59392
2406   FE77             ; 1405     bc = (SCREEN_BEGIN + SCREEN_WIDTH);
2407   FE77 01 40 E8    	ld bc, 59456
2408   FE7A             ; 1406     do {
2409   FE7A             l_144: 
2410   FE7A             ; 1407         *hl = (a = *bc);
2411   FE7A 0A          	ld a, (bc)
2412   FE7B 77          	ld (hl), a
2413   FE7C             ; 1408         hl++;
2414   FE7C 23          	inc hl
2415   FE7D             ; 1409         bc++;
2416   FE7D 03          	inc bc
2417   FE7E             ; 1410         *hl = (a = *bc);
2418   FE7E 0A          	ld a, (bc)
2419   FE7F 77          	ld (hl), a
2420   FE80             ; 1411         hl++;
2421   FE80 23          	inc hl
2422   FE81             ; 1412         bc++;
2423   FE81 03          	inc bc
2424   FE82             l_145: 
2425   FE82             ; 1413     } while (flag_m(compare(a = b, SCREEN_END >> 8)));
2426   FE82 78          	ld a, b
2427   FE83 FE F0       	cp 240
2428   FE85 FA 7A FE    	jp m, l_144
2429   FE88             ; 1414     a = SCREEN_END >> 8;
2430   FE88 3E F0       	ld a, 240
2431   FE8A             ; 1415     c = ' ';
2432   FE8A 0E 20       	ld c, 32
2433   FE8C             ; 1416     do {
2434   FE8C             l_147: 
2435   FE8C             ; 1417         *hl = c;
2436   FE8C 71          	ld (hl), c
2437   FE8D             ; 1418         hl++;
2438   FE8D 23          	inc hl
2439   FE8E             ; 1419         *hl = c;
2440   FE8E 71          	ld (hl), c
2441   FE8F             ; 1420         hl++;
2442   FE8F 23          	inc hl
2443   FE90             l_148: 
2444   FE90             ; 1421     } while (a != h);
2445   FE90 BC          	cp h
2446   FE91 C2 8C FE    	jp nz, l_147
2447   FE94             ; 1422     hl = cursor;
2448   FE94 2A 5A F7    	ld hl, (cursor)
2449   FE97             ; 1423     h = ((SCREEN_END >> 8) - 1);
2450   FE97 26 EF       	ld h, 239
2451   FE99             ; 1424     l = ((a = l) |= 192);
2452   FE99 7D          	ld a, l
2453   FE9A F6 C0       	or 192
2454   FE9C 6F          	ld l, a
2455   FE9D             ; 1425     return PrintCharSaveCursor(hl);
2456   FE9D C3 6A FD    	jp printcharsavecursor
2457   FEA0             ; 1426 }
2458   FEA0             ; 1427 
2459   FEA0             ; 1428 void MoveCursorUp(...) {
2460   FEA0             movecursorup: 
2461   FEA0             ; 1429     MoveCursor(hl, bc = -SCREEN_WIDTH);
2462   FEA0 01 C0 FF    	ld bc, 65472
2463   FEA3             ; 1430 }
2464   FEA3             ; 1431 
2465   FEA3             ; 1432 void MoveCursor(...) {
2466   FEA3             movecursor: 
2467   FEA3             ; 1433     hl += bc;
2468   FEA3 09          	add hl, bc
2469   FEA4             ; 1434     return MoveCursorBoundary(hl);
2470   FEA4 C3 5D FE    	jp movecursorboundary
2471   FEA7             ; 1435 }
2472   FEA7             ; 1436 
2473   FEA7             ; 1437 void MoveCursorDown(...) {
2474   FEA7             movecursordown: 
2475   FEA7             ; 1438     return MoveCursor(hl, bc = SCREEN_WIDTH);
2476   FEA7 01 40 00    	ld bc, 64
2477   FEAA C3 A3 FE    	jp movecursor
2478   FEAD             ; 1439 }
2479   FEAD             ; 1440 
2480   FEAD             ; 1441 void PrintCrLf() {
2481   FEAD             printcrlf: 
2482   FEAD             ; 1442     PrintChar(c = 13);
2483   FEAD 0E 0D       	ld c, 13
2484   FEAF CD 23 FD    	call printchar
2485   FEB2             ; 1443     PrintChar(c = 10);
2486   FEB2 0E 0A       	ld c, 10
2487   FEB4 C3 23 FD    	jp printchar
2488   FEB7             ; 1444 }
2489   FEB7             ; 1445 
2490   FEB7             ; 1446 // Функция для пользовательской программы.
2491   FEB7             ; 1447 // Нажата ли хотя бы одна клавиша на клавиатуре?
2492   FEB7             ; 1448 // Параметры: нет. Результат:  a - 0xFF если клавиша нажата, 0 если нет. Сохраняет: bc, de, hl.
2493   FEB7             ; 1449 
2494   FEB7             ; 1450 void IsAnyKeyPressed() {
2495   FEB7             isanykeypressed: 
2496   FEB7             ; 1451     out(PORT_KEYBOARD_COLUMN, a ^= a);
2497   FEB7 AF          	xor a
2498   FEB8 D3 07       	out (7), a
2499   FEBA             ; 1452     a = in(PORT_KEYBOARD_ROW);
2500   FEBA DB 06       	in a, (6)
2501   FEBC             ; 1453     a &= KEYBOARD_ROW_MASK;
2502   FEBC E6 7F       	and 127
2503   FEBE             ; 1454     if (a == KEYBOARD_ROW_MASK) {
2504   FEBE FE 7F       	cp 127
2505   FEC0 C2 C5 FE    	jp nz, l_150
2506   FEC3             ; 1455         a ^= a;
2507   FEC3 AF          	xor a
2508   FEC4             ; 1456         return;
2509   FEC4 C9          	ret
2510   FEC5             l_150: 
2511   FEC5             ; 1457     }
2512   FEC5             ; 1458     a = 0xFF;
2513   FEC5 3E FF       	ld a, 255
2514   FEC7 C9          	ret
2515   FEC8             ; 1459 }
2516   FEC8             ; 1460 
2517   FEC8             ; 1461 // Функция для пользовательской программы.
2518   FEC8             ; 1462 // Получить код нажатой клавиши на клавиатуре.
2519   FEC8             ; 1463 // В отличии от функции ScanKey, в этой функции есть задержка повтора.
2520   FEC8             ; 1464 // Параметры: нет. Результат: a. Сохраняет: bc, de, hl.
2521   FEC8             ; 1465 
2522   FEC8             ; 1466 void ReadKey() {
2523   FEC8             readkey: 
2524   FEC8             ; 1467     push_pop(hl) {
2525   FEC8 E5          	push hl
2526   FEC9             ; 1468         hl = keyDelay;
2527   FEC9 2A 60 F7    	ld hl, (keydelay)
2528   FECC             ; 1469         ReadKeyInternal(hl);
2529   FECC CD E8 FE    	call readkeyinternal
2530   FECF             ; 1470         l = 32;         // Задержка повтора нажатия клавиши
2531   FECF 2E 20       	ld l, 32
2532   FED1             ; 1471         if (flag_nz) {  // Не таймаут
2533   FED1 CA E3 FE    	jp z, l_152
2534   FED4             ; 1472             do {
2535   FED4             l_154: 
2536   FED4             ; 1473                 do {
2537   FED4             l_157: 
2538   FED4             ; 1474                     l = 2;
2539   FED4 2E 02       	ld l, 2
2540   FED6             ; 1475                     ReadKeyInternal(hl);
2541   FED6 CD E8 FE    	call readkeyinternal
2542   FED9             l_158: 
2543   FED9 C2 D4 FE    	jp nz, l_157
2544   FEDC             l_155: 
2545   FEDC             ; 1476                 } while (flag_nz);  // Цикл длится, пока не наступит таймаут
2546   FEDC             ; 1477             } while (a >= 128);     // Цикл длится, пока не нажата клавиша
2547   FEDC FE 80       	cp 128
2548   FEDE D2 D4 FE    	jp nc, l_154
2549   FEE1             ; 1478             l = 128;                // Задержка повтора первого нажатия клавиши
2550   FEE1 2E 80       	ld l, 128
2551   FEE3             l_152: 
2552   FEE3             ; 1479         }
2553   FEE3             ; 1480         keyDelay = hl;
2554   FEE3 22 60 F7    	ld (keydelay), hl
2555   FEE6 E1          	pop hl
2556   FEE7 C9          	ret
2557   FEE8             ; 1481     }
2558   FEE8             ; 1482 }
2559   FEE8             ; 1483 
2560   FEE8             ; 1484 void ReadKeyInternal(...) {
2561   FEE8             readkeyinternal: 
2562   FEE8             ; 1485     do {
2563   FEE8             l_160: 
2564   FEE8             ; 1486         ScanKey();
2565   FEE8 CD FE FE    	call scankey
2566   FEEB             ; 1487         if (a != h)
2567   FEEB BC          	cp h
2568   FEEC             ; 1488             break;
2569   FEEC C2 FC FE    	jp nz, l_162
2570   FEEF             ; 1489 
2571   FEEF             ; 1490         // Задержка
2572   FEEF             ; 1491         push_pop(a) {
2573   FEEF F5          	push af
2574   FEF0             ; 1492             a ^= a;
2575   FEF0 AF          	xor a
2576   FEF1             ; 1493             do {
2577   FEF1             l_163: 
2578   FEF1             ; 1494                 swap(hl, de);
2579   FEF1 EB          	ex hl, de
2580   FEF2             ; 1495                 swap(hl, de);
2581   FEF2 EB          	ex hl, de
2582   FEF3             l_164: 
2583   FEF3             ; 1496             } while (flag_nz(a--));
2584   FEF3 3D          	dec a
2585   FEF4 C2 F1 FE    	jp nz, l_163
2586   FEF7 F1          	pop af
2587   FEF8             l_161: 
2588   FEF8             ; 1497         }
2589   FEF8             ; 1498     } while (flag_nz(l--));
2590   FEF8 2D          	dec l
2591   FEF9 C2 E8 FE    	jp nz, l_160
2592   FEFC             l_162: 
2593   FEFC             ; 1499     h = a;
2594   FEFC 67          	ld h, a
2595   FEFD C9          	ret
2596   FEFE             ; 1500 }
2597   FEFE             ; 1501 
2598   FEFE             ; 1502 // Функция для пользовательской программы.
2599   FEFE             ; 1503 // Получить код нажатой клавиши на клавиатуре.
2600   FEFE             ; 1504 // Параметры: нет. Результат: a. Сохраняет: bc, de, hl.
2601   FEFE             ; 1505 
2602   FEFE             ; 1506 void ScanKey() {
2603   FEFE             scankey: 
2604   FEFE             ; 1507     push(bc, de, hl);
2605   FEFE C5          	push bc
2606   FEFF D5          	push de
2607   FF00 E5          	push hl
2608   FF01             ; 1508 
2609   FF01             ; 1509     bc = 0x00FE;
2610   FF01 01 FE 00    	ld bc, 254
2611   FF04             ; 1510     d = KEYBOARD_COLUMN_COUNT;
2612   FF04 16 08       	ld d, 8
2613   FF06             ; 1511     do {
2614   FF06             l_166: 
2615   FF06             ; 1512         a = c;
2616   FF06 79          	ld a, c
2617   FF07             ; 1513         out(PORT_KEYBOARD_COLUMN, a);
2618   FF07 D3 07       	out (7), a
2619   FF09             ; 1514         cyclic_rotate_left(a, 1);
2620   FF09 07          	rlca
2621   FF0A             ; 1515         c = a;
2622   FF0A 4F          	ld c, a
2623   FF0B             ; 1516         a = in(PORT_KEYBOARD_ROW);
2624   FF0B DB 06       	in a, (6)
2625   FF0D             ; 1517         a &= KEYBOARD_ROW_MASK;
2626   FF0D E6 7F       	and 127
2627   FF0F             ; 1518         if (a != KEYBOARD_ROW_MASK)
2628   FF0F FE 7F       	cp 127
2629   FF11             ; 1519             return ScanKey2(a);
2630   FF11 C2 28 FF    	jp nz, scankey2
2631   FF14             ; 1520         b = ((a = b) += KEYBOARD_ROW_COUNT);
2632   FF14 78          	ld a, b
2633   FF15 C6 07       	add 7
2634   FF17 47          	ld b, a
2635   FF18             l_167: 
2636   FF18             ; 1521     } while (flag_nz(d--));
2637   FF18 15          	dec d
2638   FF19 C2 06 FF    	jp nz, l_166
2639   FF1C             ; 1522 
2640   FF1C             ; 1523     a = in(PORT_KEYBOARD_MODS);
2641   FF1C DB 05       	in a, (5)
2642   FF1E             ; 1524     carry_rotate_right(a, 1);
2643   FF1E 1F          	rra
2644   FF1F             ; 1525     a = 0xFF;  // No key
2645   FF1F 3E FF       	ld a, 255
2646   FF21             ; 1526     if (flag_c)
2647   FF21             ; 1527         return ScanKeyExit(a);
2648   FF21 DA 64 FF    	jp c, scankeyexit
2649   FF24             ; 1528     a--;  // Rus key
2650   FF24 3D          	dec a
2651   FF25             ; 1529     return ScanKeyExit(a);
2652   FF25 C3 64 FF    	jp scankeyexit
2653   FF28             ; 1530 }
2654   FF28             ; 1531 
2655   FF28             ; 1532 void ScanKey2(...) {
2656   FF28             scankey2: 
2657   FF28             ; 1533     for (;;) {
2658   FF28             l_170: 
2659   FF28             ; 1534         carry_rotate_right(a, 1);
2660   FF28 1F          	rra
2661   FF29             ; 1535         if (flag_nc)
2662   FF29             ; 1536             break;
2663   FF29 D2 30 FF    	jp nc, l_171
2664   FF2C             ; 1537         b++;
2665   FF2C 04          	inc b
2666   FF2D C3 28 FF    	jp l_170
2667   FF30             l_171: 
2668   FF30             ; 1538     }
2669   FF30             ; 1539     a = b;
2670   FF30 78          	ld a, b
2671   FF31             ; 1540     if (a >= 48)
2672   FF31 FE 30       	cp 48
2673   FF33             ; 1541         return ScanKeySpecial(a);
2674   FF33 D2 8A FF    	jp nc, scankeyspecial
2675   FF36             ; 1542     a += 48;
2676   FF36 C6 30       	add 48
2677   FF38             ; 1543     if (a >= 60)
2678   FF38 FE 3C       	cp 60
2679   FF3A             ; 1544         if (a < 64)
2680   FF3A DA 44 FF    	jp c, l_172
2681   FF3D FE 40       	cp 64
2682   FF3F             ; 1545             a &= 47;
2683   FF3F D2 44 FF    	jp nc, l_174
2684   FF42 E6 2F       	and 47
2685   FF44             l_174: 
2686   FF44             l_172: 
2687   FF44             ; 1546 
2688   FF44             ; 1547     if (a == 95)
2689   FF44 FE 5F       	cp 95
2690   FF46             ; 1548         a = 127;
2691   FF46 C2 4B FF    	jp nz, l_176
2692   FF49 3E 7F       	ld a, 127
2693   FF4B             l_176: 
2694   FF4B             ; 1549 
2695   FF4B             ; 1550     c = a;
2696   FF4B 4F          	ld c, a
2697   FF4C             ; 1551     a = in(PORT_KEYBOARD_MODS);
2698   FF4C DB 05       	in a, (5)
2699   FF4E             ; 1552     a &= KEYBOARD_MODS_MASK;
2700   FF4E E6 07       	and 7
2701   FF50             ; 1553     compare(a, KEYBOARD_MODS_MASK);
2702   FF50 FE 07       	cp 7
2703   FF52             ; 1554     b = a;
2704   FF52 47          	ld b, a
2705   FF53             ; 1555     a = c;
2706   FF53 79          	ld a, c
2707   FF54             ; 1556     if (flag_z)
2708   FF54             ; 1557         return ScanKeyExit(a);
2709   FF54 CA 64 FF    	jp z, scankeyexit
2710   FF57             ; 1558     a = b;
2711   FF57 78          	ld a, b
2712   FF58             ; 1559     carry_rotate_right(a, 2);
2713   FF58 1F          	rra
2714   FF59 1F          	rra
2715   FF5A             ; 1560     if (flag_nc)
2716   FF5A             ; 1561         return ScanKeyControl(c);
2717   FF5A D2 68 FF    	jp nc, scankeycontrol
2718   FF5D             ; 1562     carry_rotate_right(a, 1);
2719   FF5D 1F          	rra
2720   FF5E             ; 1563     if (flag_nc)
2721   FF5E             ; 1564         return ScanKeyShift();
2722   FF5E D2 6E FF    	jp nc, scankeyshift
2723   FF61             ; 1565     (a = c) |= 0x20;
2724   FF61 79          	ld a, c
2725   FF62 F6 20       	or 32
2726   FF64             ; 1566     ScanKeyExit(a);
2727   FF64             ; 1567 }
2728   FF64             ; 1568 
2729   FF64             ; 1569 void ScanKeyExit(...) {
2730   FF64             scankeyexit: 
2731   FF64             ; 1570     pop(bc, de, hl);
2732   FF64 E1          	pop hl
2733   FF65 D1          	pop de
2734   FF66 C1          	pop bc
2735   FF67 C9          	ret
2736   FF68             ; 1571 }
2737   FF68             ; 1572 
2738   FF68             ; 1573 void ScanKeyControl(...) {
2739   FF68             scankeycontrol: 
2740   FF68             ; 1574     a = c;
2741   FF68 79          	ld a, c
2742   FF69             ; 1575     a &= 0x1F;
2743   FF69 E6 1F       	and 31
2744   FF6B             ; 1576     return ScanKeyExit(a);
2745   FF6B C3 64 FF    	jp scankeyexit
2746   FF6E             ; 1577 }
2747   FF6E             ; 1578 
2748   FF6E             ; 1579 void ScanKeyShift(...) {
2749   FF6E             scankeyshift: 
2750   FF6E             ; 1580     if ((a = c) == 127)
2751   FF6E 79          	ld a, c
2752   FF6F FE 7F       	cp 127
2753   FF71             ; 1581         a = 95;
2754   FF71 C2 76 FF    	jp nz, l_178
2755   FF74 3E 5F       	ld a, 95
2756   FF76             l_178: 
2757   FF76             ; 1582     if (a >= 64)
2758   FF76 FE 40       	cp 64
2759   FF78             ; 1583         return ScanKeyExit();
2760   FF78 D2 64 FF    	jp nc, scankeyexit
2761   FF7B             ; 1584     if (a < 48) {
2762   FF7B FE 30       	cp 48
2763   FF7D D2 85 FF    	jp nc, l_180
2764   FF80             ; 1585         a |= 16;
2765   FF80 F6 10       	or 16
2766   FF82             ; 1586         return ScanKeyExit();
2767   FF82 C3 64 FF    	jp scankeyexit
2768   FF85             l_180: 
2769   FF85             ; 1587     }
2770   FF85             ; 1588     a &= 47;
2771   FF85 E6 2F       	and 47
2772   FF87             ; 1589     return ScanKeyExit();
2773   FF87 C3 64 FF    	jp scankeyexit
2774   FF8A             ; 1590 }
2775   FF8A             ; 1591 
2776   FF8A             ; 1592 void ScanKeySpecial(...) {
2777   FF8A             scankeyspecial: 
2778   FF8A             ; 1593     hl = specialKeyTable;
2779   FF8A 21 97 FF    	ld hl, 0FFFFh & (specialkeytable)
2780   FF8D             ; 1594     c = (a -= 48);
2781   FF8D D6 30       	sub 48
2782   FF8F 4F          	ld c, a
2783   FF90             ; 1595     b = 0;
2784   FF90 06 00       	ld b, 0
2785   FF92             ; 1596     hl += bc;
2786   FF92 09          	add hl, bc
2787   FF93             ; 1597     a = *hl;
2788   FF93 7E          	ld a, (hl)
2789   FF94             ; 1598     return ScanKeyExit(a);
2790   FF94 C3 64 FF    	jp scankeyexit
2791   FF97             ; 1599 }
2792   FF97             ; 1600 
2793   FF97             ; 1601 uint8_t specialKeyTable[] = {
2794   FF97             specialkeytable: 
2795   FF97 20          	db 32
2796   FF98 18          	db 24
2797   FF99 08          	db 8
2798   FF9A 19          	db 25
2799   FF9B 1A          	db 26
2800   FF9C 0D          	db 13
2801   FF9D 1F          	db 31
2802   FF9E 0C          	db 12
2803   FF9F             ; 1612  aPrompt[6] = "\r\n-->";
2804   FF9F             aprompt: 
2805   FF9F 0D          	db 13
2806   FFA0 0A          	db 10
2807   FFA1 2D          	db 45
2808   FFA2 2D          	db 45
2809   FFA3 3E          	db 62
2810   FFA4 00          	ds 1
2811   FFA5             ; 1613  aCrLfTab[6] = "\r\n\x18\x18\x18";
2812   FFA5             acrlftab: 
2813   FFA5 0D          	db 13
2814   FFA6 0A          	db 10
2815   FFA7 18          	db 24
2816   FFA8 18          	db 24
2817   FFA9 18          	db 24
2818   FFAA 00          	ds 1
2819   FFAB             ; 1614  aRegisters[] = "\r\nPC-\r\nHL-\r\nBC-\r\nDE-\r\nSP-\r\nAF-\x19\x19\x19\x19\x19\x19";
2820   FFAB             aregisters: 
2821   FFAB 0D          	db 13
2822   FFAC 0A          	db 10
2823   FFAD 50          	db 80
2824   FFAE 43          	db 67
2825   FFAF 2D          	db 45
2826   FFB0 0D          	db 13
2827   FFB1 0A          	db 10
2828   FFB2 48          	db 72
2829   FFB3 4C          	db 76
2830   FFB4 2D          	db 45
2831   FFB5 0D          	db 13
2832   FFB6 0A          	db 10
2833   FFB7 42          	db 66
2834   FFB8 43          	db 67
2835   FFB9 2D          	db 45
2836   FFBA 0D          	db 13
2837   FFBB 0A          	db 10
2838   FFBC 44          	db 68
2839   FFBD 45          	db 69
2840   FFBE 2D          	db 45
2841   FFBF 0D          	db 13
2842   FFC0 0A          	db 10
2843   FFC1 53          	db 83
2844   FFC2 50          	db 80
2845   FFC3 2D          	db 45
2846   FFC4 0D          	db 13
2847   FFC5 0A          	db 10
2848   FFC6 41          	db 65
2849   FFC7 46          	db 70
2850   FFC8 2D          	db 45
2851   FFC9 19          	db 25
2852   FFCA 19          	db 25
2853   FFCB 19          	db 25
2854   FFCC 19          	db 25
2855   FFCD 19          	db 25
2856   FFCE 19          	db 25
2857   FFCF 00          	ds 1
2858   FFD0             ; 1615  aBackspace[4] = "\x08 \x08";
2859   FFD0             abackspace: 
2860   FFD0 08          	db 8
2861   FFD1 20          	db 32
2862   FFD2 08          	db 8
2863   FFD3 00          	ds 1
2864   FFD4             ; 1616  aHello[] = "\x1F\nm/80k ";
2865   FFD4             ahello: 
2866   FFD4 1F          	db 31
2867   FFD5 0A          	db 10
2868   FFD6 6D          	db 109
2869   FFD7 2F          	db 47
2870   FFD8 38          	db 56
2871   FFD9 30          	db 48
2872   FFDA 6B          	db 107
2873   FFDB 20          	db 32
2874   FFDC 00          	ds 1
2875   FFDD             ; 1618  TranslateCodePageDefault(...) {
2876   FFDD             translatecodepagedefault: 
2877   FFDD C9          	ret
2878   FFDE             ; 1619 }
2879   FFDE             ; 1620 
2880   FFDE             ; 1621 uint8_t padding[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
2881   FFDE             padding: 
2882   FFDE FF          	db 255
2883   FFDF FF          	db 255
2884   FFE0 FF          	db 255
2885   FFE1 FF          	db 255
2886   FFE2 FF          	db 255
2887   FFE3 FF          	db 255
2888   FFE4 FF          	db 255
2889   FFE5 FF          	db 255
2890   FFE6 FF          	db 255
2891   FFE7 FF          	db 255
2892   FFE8 FF          	db 255
2893   FFE9 FF          	db 255
2894   FFEA FF          	db 255
2895   FFEB FF          	db 255
2896   FFEC FF          	db 255
2897   FFED FF          	db 255
2898   FFEE FF          	db 255
2899   FFEF FF          	db 255
2900   FFF0 FF          	db 255
2901   FFF1 FF          	db 255
2902   FFF2 FF          	db 255
2903   FFF3 FF          	db 255
2904   FFF4 FF          	db 255
2905   FFF5 FF          	db 255
2906   FFF6 FF          	db 255
2907   FFF7 FF          	db 255
2908   FFF8 FF          	db 255
2909   FFF9 FF          	db 255
2910   FFFA FF          	db 255
2911   FFFB FF          	db 255
2912   FFFC FF          	db 255
2913   FFFD FF          	db 255
2914   FFFE FF          	db 255
2915   FFFF FF          	db 255
2916   0000              savebin "micro80.bin", 0xF800, 0x10000
2917   0000             
