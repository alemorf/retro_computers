DATA	segment	at 40
	org	06ch
TIMER_LOW	label	word
	org	06eh
TIMER_HIGH	label	word
	org	070h
TIMER_OFL       label   byte
DATA	ends

code	segment
tsr     proc    far
	assume  cs:code,ds:DATA

;------------------------------------------------------------------
;	 THIS ROUTINE INITIALIZES THE TIMER DATA AREA IN THE
;	 ROM BIOS DATA AREA. IT IS CALLED BY THE POWER ON ROUTINES.
;	 IT CONVERTS HR:MIN:SEC FROM CMOS TO TIMER TICS.
;	 IF CMOS IS INVALID, TIMER DATA IS SET TO ZERO
; INPUT  NONE PASSED TO ROUTINE BY CALLER
; CMOS BYTES USED FOR SETUP
;	 00 SECONDS
;	 02 MINUTES
;	 04 HOURS
;	 0A REGISTER A (UPDATE IN PROGRESS)
;	 0E CMOS VALID IF ZERO
; OUTPUT
;	 TIMER_LOW
;	 TIMER_HIGH
;	 TIMER_OFL
;	 ALL REGISTERS UNCHANGED
;-----------------------------------------------------------------------
COUNTS_SEC	EQU	18
COUNTS_MIN	EQU	1092
COUNTS_HOUR	EQU	7
CMOS_ADR	EQU	70H
CMOS_DATA	EQU	71H
CMOS_VALID	EQU	0EH
CMOS_SECONDS	EQU	00H
CMOS_MINUTES	EQU	02H
CMOS_HOURS	EQU	04H
CMOS_REGA	EQU	0AH
CMOS_PORT	EQU	70H
UPDATE_TIMER	EQU	80H
DIAG_STATUS	EQU	08EH
CMOS_CLK_FAIL	EQU	004H


SET_TOD  PROC  NEAR
  PUSH	 AX
  PUSH	 BX
  PUSH	 CX
  PUSH	 DX
  PUSH	 SI
  PUSH	 DI
  PUSH	 BP
  PUSH	 SP
  PUSH	 DS
  MOV	 AX,40H		;ESTABLISH SEGMENT
  MOV	 DS,AX
  SUB	 AX,AX
  MOV	 TIMER_OFL,AL		;RESET TIMER ROLL OVER INDICATOR
  MOV	 TIMER_LOW,AX		; AND TIMER COUNT
  MOV	 TIMER_HIGH,AX
  MOV	 AL,CMOS_VALID
  OUT	 CMOS_ADR,AL		;CHECK CMOS VALIDITY
  JMP	 SHORT $+2
  IN	 AL,CMOS_DATA
  AND	 AL,0C4H		;BAD BATTERY, CHKSUM ERROR OR CLOCK ERROR
  JNZ	 I_POD_DONE		;CMOS NOT VALID--TIMER SET TO ZERO
  SUB	 CX,CX
tUIP:
  MOV	 AL,CMOS_REGA
  OUT	 CMOS_ADR,AL		;ACCESS REGISTER A
  JMP	 SHORT $+2
  IN	 AL,CMOS_DATA
  TEST	 AL,UPDATE_TIMER
  JZ	 READ_SEC
  LOOP	 tUIP
  JMP	 I_POD_DONE
READ_SEC:
  MOV	 AL,CMOS_SECONDS
  OUT	 CMOS_ADR,AL		;ACCESS SECONDS VALUE IN CMOS
  JMP	 SHORT $+2
  IN	 AL,CMOS_DATA
  CMP	 AL,59H 		;ARE THE SECONDS WITHIN LIMITS?
  JA	 TOD_ERROR		;GO IF NOT
  CALL	 CVT_BINARY		;CONVERT IT TO BINARY
  MOV	 BL,COUNTS_SEC
  MUL	 BL			;COUNT FOR SECONDS
  MOV	 CX,AX
  MOV	 AL,CMOS_MINUTES
  OUT	 CMOS_ADR,AL		;ACCESS MINUTES VALUE IN CMOS
  JMP	 SHORT $+2
  IN	 AL,CMOS_DATA
  CMP	 AL,59H 		;ARE THE MINUTES WITHIN LIMITS?
  JA	 TOD_ERROR		;GO IF NOT
  CALL	 CVT_BINARY		;CONVERT IT TO BINARY
  MOV	 BX,COUNTS_MIN
  MUL	 BX			;COUNT FOR MINUTES
  ADD	 AX,CX
  MOV	 CX,AX
  MOV	 AL,CMOS_HOURS
  OUT	 CMOS_ADR,AL		;ACCESS HOURS VALUE IN CMOS
  JMP	 SHORT $+2
  IN	 AL,CMOS_DATA
  CMP	 AL,23H 		;ARE THE HOURS WITHIN LIMITS?
  JA	 TOD_ERROR		;GO IF NOT
  CALL	 CVT_BINARY		;CONVERT IT TO BINARY
  MOV	 DX,AX
  MOV	 BL,COUNTS_HOUR
  MUL	 BL			;COUNT FOR HOURS
  ADD	 AX,CX
  ADC	 DX,0000H
  MOV	 TIMER_HIGH,DX
  MOV	 TIMER_LOW,AX
I_POD_DONE:
  CLI				;**IO DELAY NOT REQUIRED**
  IN	 AL,021H		;BE SURE TIMER IS ENABLED
  AND	 AL,0FEH
  OUT	 021H,AL
  STI
  POP	 DS
  POP	 SP
  POP	 BP
  POP	 DI
  POP	 SI
  POP	 DX
  POP	 CX
  POP    BX
  POP    AX
;  RET
	MOV	AH,4CH
	INT	21H
TOD_ERROR:
  POP	 DS			;RESTORE SEGMENT
  POP	 SP
  POP	 BP
  POP	 DI
  POP	 SI
  POP	 DX
  POP	 CX
  POP    BX
  POP    AX                     ;RESTORE REG
 ; MOV	 SI,OFFSET CM3		;DISPLAY CLOCK ERROR
  ;CALL	 E_MSG
  MOV	 AL,DIAG_STATUS 	;SET CLOCK ERROR
  OUT	 CMOS_PORT,AL
  XCHG	 AL,AH			;SAVE STATUS ADDRESS
  JMP	 SHORT $+2		;IO DELAY
  IN	 AL,CMOS_PORT+1 	;GET THE CURRENT STATUS
  OR	 AL,CMOS_CLK_FAIL	;SET NEW STATUS
  XCHG	 AL,AH			;GET STATUS ADDR AND SAVE NEW STATUS
  OUT	 CMOS_PORT,AL
  XCHG	 AL,AH
  JMP	 SHORT $+2		;IO DELAY
  OUT	 CMOS_PORT+1,AL
 ; RET
	MOV	AH,4CH
	INT	21H
SET_TOD  ENDP

CVT_BINARY  PROC  NEAR
  MOV	 AH,AL			;UNPACK 2 BCD DIGITS IN AL
  SHR	 AH,1
  SHR	 AH,1
  SHR	 AH,1
  SHR	 AH,1
  AND	 AL,0FH 		;RESULT IS IN AX
  AAD				;CONVERT UNPACKED BCD TO BINARY
  RET
CVT_BINARY  ENDP
CODE	ENDS
	END
