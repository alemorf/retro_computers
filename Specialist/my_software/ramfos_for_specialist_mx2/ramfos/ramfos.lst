0001   0000             ; ===========================================================================
0002   0000             ; ЌЂ‘’ђЋ‰ЉЂ
0003   0000             
0004   0000             STD_RAMFOS = 1				; ‘Є®¬ЇЁ«Ёа®ў вм бв ­¤ ав­л© RAMFOS
0005   0000             
0006   0000~            #if STD_RAMFOS==0
0007   0000~            
0008   0000~            DATE_IN_RAM		= 1		; 0      ђ §¬Ґй вм ¤ вг ў ®б­®ў­®© ®ЇҐа вЁў­®© Ї ¬пвЁ (ў®§¬®¦­  а Ў®в  ЎҐ§ „Ћ‡“)
0009   0000~            RKS_SHIFT_LOADER	= 1		; 0	 …б«Ё ­ ¦ вм SHIFT, в® RKS § ЇгбЄ Ґвбп ў аҐ¦Ё¬Ґ MX
0010   0000~            NO_ROM_ENTRY		= 1		; 0      ‘в ­¤ ав­лҐ Їа®Ја ¬¬л ў ўЁ¤Ґ д ©«®ў
0011   0000~            NO_PRINTER		= 1		; 0 	 ЋвЄ«озЁвм ЇаЁ­вҐа
0012   0000~            NO_MXDOS		= 1		; 0 	 ЋвЄ«озЁвм § Јаг§Єг б ¤ЁбЄҐвл (ў з бв­®cвЁ MXDOS)
0013   0000~            OPEN_ANY_FILE		= 1		; 0 	 ЋвЄалў вм д ©« б «оЎл¬ а биЁаҐ­ЁҐ¬ (Ђ ­Ґ в®«мЄ® TXT ў аҐ¤ Єв®аҐ)
0014   0000~            ALL_CHARS		= 1		; 0	 ЏҐз вм ўбҐе бЁ¬ў®«®ў §­ Є®ЈҐ­Ґа в®а  зҐаҐ§ ESC
0015   0000~            RKS_LOADER		= 1		; 0      ‡ ЇгбЄ вм RKS д ©«л
0016   0000~            BIG_ROM			= 1		; 0 	 €бЇ®«м§®ў вм ўбҐ 64 ЉЎ Џ‡“ ‘ЇҐжЁ «Ёбв  Њ•2 Ї®¤ ROM-¤ЁбЄ
0017   0000~            WORK_WITHOUT_ARAM	= 32		; 0      …б«Ё „Ћ‡“ ­Ґ ­ ©¤Ґ­®, в® ЁбЇ®«м§®ў вм ЎгдҐа ў Ћ‡“ а §¬Ґа®¬ б нвг ЇҐаҐ¬Ґ­­го
0018   0000~            ROM_PAGE_START		= 01880h	; 04000h ЏҐаўл© Ў ©в бва ­Ёжл Џ‡“
0019   0000~            ROM_PAGE_END		= 0FFFCh	; 0C000h Џ®б«Ґ¤­Ё© Ў ©в бва ­Ёжл Џ‡“ + 1
0020   0000~            CURSOR_BLINK_SPEED	= 767		; 767    ‡ ¤Ґа¦Є  ¬ЁЈ ­Ёп Єгаб®а 
0021   0000~            ARAM_MAX_PAGE           = 0Fh		; 6      Њ ЄбЁ¬ «м­®Ґ Є®«-ў® бва ­Ёж а биЁаҐ­­®© Ї ¬пвЁ (¬ ЄбЁ¬г¬ 0Fh)
0022   0000~            ARAM_PAGE_END		= 0FFBBh        ; 0FFBBh Љ®­Ґж бва ­Ёжл „Ћ‡“ (36 Ў ©в ­ҐЁбЇ®«м§гҐ¬®Ј® Ћ‡“ Ї®б«Ґ)
0023   0000~            DLG_START_PAGE		= 80h		; 0      ЏаЁ § ЇгбЄҐ Ї®Є § вм нвг бва ­Ёжг
0024   0000~            INIT_SCREEN_COLOR	= 0F1h		; 100h	 –ўҐв, Є®в®ал¬ § «Ёў Ґвбп нЄа ­ ЇаЁ Ё­ЁжЁ «Ё§ жЁЁ. 100h - § «Ёў Ґвбп вҐЄгйЁ¬ жўҐв®¬, Є®в®ал© ЇаЁ вҐЇ«®© ЇҐаҐ§ Јаг§ЄҐ ¬®¦Ґв Ўлвм «оЎл¬.
0025   0000~            FAST_PRINT		= 1		; 0      Ѓлбва п дг­ЄжЁп ўлў®¤  вҐЄбв . ’ Є ¦Ґ ўлў®¤Ёв вҐЄбв бва®ЄЁ ЎҐ§ а §алў®ў. € ­Ґ Ї®авЁв жўҐв  бЁ¬ў®«®ў Їа ўҐҐ.
0026   0000~            TRUE_CHECK_ARAM		= 1		; 0      €бЇЇа ў«Ґ­­ п дг­ЄжЁп ®ЇаҐ¤Ґ«Ґ­Ёп ®ЎмҐ¬  „Ћ‡“
0027   0000~            NICE			= 1		; 0	 Ќ®ўл© Ё­вҐадҐ©б
0028   0000~            COLOR_SUPPORT		= 1		; 0	 “бв ­®ўЄ  жўҐв  Ї® г¬®«з ­Ёо ЇаЁ ®зЁбвЄҐ б«г¦ҐЎ­ле бва®Є Ё нЄа ­ 
0029   0000~            NO_PRINT_STATUS_BUG	= 1		; 0	 €бЇа ўЁвм ®иЁЎЄг
0030   0000~            DLG_CURSOR_AT_TOP	= 0		; 0	 Љгаб®а ­  ЇҐаў®¬ д ©«Ґ
0031   0000~            NO_ROM_SWITCH_BUG	= 1		; 0	 Њ®¦­® Ўл«® ўлЎа вм ­Ґ ­г«Ґўго бва ­Ёжг Џ‡“
0032   0000~            RELOCATE_FILE_FUNCTIONS = 1		; 0      ЏҐаҐ­ҐбвЁ ­ҐЄ®в®алҐ дг­ЄжЁЁ Ё§ F800 ў C800, Ё­ зҐ Є®¤ ­Ґ ў«Ґ§ Ґв
0033   0000~            SIZE_OPTIMIZATION	= 1		; 0      Ѓ®«ҐҐ Є®¬Ї Єв­л© Є®¤
0034   0000~            
0035   0000             #else
0036   0000             
0037   0000             DATE_IN_RAM		= 0
0038   0000             RKS_SHIFT_LOADER	= 0
0039   0000             NO_ROM_ENTRY		= 0
0040   0000             NO_PRINTER		= 0
0041   0000             NO_MXDOS		= 0
0042   0000             OPEN_ANY_FILE		= 0
0043   0000             ALL_CHARS		= 0
0044   0000             RKS_LOADER		= 0
0045   0000             BIG_ROM			= 0
0046   0000             WORK_WITHOUT_ARAM	= 0
0047   0000             ROM_PAGE_START		= 04000h
0048   0000             ROM_PAGE_END		= 0C000h
0049   0000             CURSOR_BLINK_SPEED	= 767
0050   0000             ARAM_MAX_PAGE           = 6
0051   0000             ARAM_PAGE_END		= 0FFBBh
0052   0000             DLG_START_PAGE		= 0
0053   0000             INIT_SCREEN_COLOR	= 100h
0054   0000             FAST_PRINT		= 0
0055   0000             TRUE_CHECK_ARAM		= 0
0056   0000             NICE			= 0
0057   0000             COLOR_SUPPORT		= 0
0058   0000             NO_PRINT_STATUS_BUG	= 0
0059   0000             DLG_CURSOR_AT_TOP	= 0
0060   0000             NO_ROM_SWITCH_BUG	= 0
0061   0000             RELOCATE_FILE_FUNCTIONS = 0
0062   0000             SIZE_OPTIMIZATION	= 0
0063   0000             
0064   0000             #endif
0065   0000             
0066   0000             ; ===========================================================================
0067   0000             ; ЏЋђ’› ‚‚Ћ„Ђ-‚›‚Ћ„Ђ
0068   0000             
0069   0000             IO_KEYB_A		= 0FFE0h
0070   0000             IO_KEYB_B		= 0FFE1h
0071   0000             IO_KEYB_C		= 0FFE2h
0072   0000             IO_KEYB_MODE		= 0FFE3h
0073   0000             IO_EXT_A		= 0FFE4h
0074   0000             IO_EXT_B		= 0FFE5h
0075   0000             IO_EXT_C		= 0FFE6h
0076   0000             IO_EXT_MODE		= 0FFE7h
0077   0000             IO_FLOPPY_CMD		= 0FFE8h
0078   0000             IO_FLOPPY_SECTOR	= 0FFEAh
0079   0000             IO_FLOPPY_DATA		= 0FFEBh
0080   0000             IO_TIMER		= 0FFECh
0081   0000             IO_FLOPPY_TRIG		= 0FFF0h
0082   0000             IO_FLOPPY_HEAD		= 0FFF2h
0083   0000             IO_COLOR		= 0FFF8h
0084   0000             IO_PAGE_RAM		= 0FFFCh
0085   0000             IO_PAGE_ARAM		= 0FFFDh
0086   0000             IO_PAGE_ROM		= 0FFFEh
0087   0000             IO_PAGE_STD		= 0FFFFh
0088   0000             
0089   0000             ; ===========================================================================
0090   0000             ; ‘Џ…–€Ђ‹њЌ›… ЉЋ„› ‘€Њ‚Ћ‹Ћ‚
0091   0000             
0092   0000             C_BEEP		= 7
0093   0000             C_LEFT		= 8
0094   0000             C_CLEARSCREEN	= 1Fh
0095   0000             C_PUSHCOLOR	= 88h
0096   0000             C_POPCOLOR	= 89h
0097   0000             C_INVERSE	= 8Bh
0098   0000             C_NORMAL	= 8Ch
0099   0000             C_PUSHCURSORL	= 8Dh
0100   0000             C_TOPLINE	= 8Fh
0101   0000             C_POPCURSORL	= 8Eh
0102   0000             C_BOTTOMLINE	= 90h
0103   0000             C_PUSHCURSORS	= 93h
0104   0000             C_POPCURSORS	= 94h
0105   0000             C_SCROLLUPEX	= 9Ah
0106   0000             
0107   0000             ; ===========================================================================
0108   0000             ; ЉЋЌ‘’ЂЌ’› Ќ…‹њ‡џ Њ…Ќџ’њ
0109   0000             
0110   0000             CHAR_HEIGHT	  	= 8
0111   0000             LINE_HEIGHT	 	= 10
0112   0000             SCREEN_HEIGHT	 	= 250
0113   0000             FILE_HEADER_SIZE	= 30
0114   0000             STACK_TOP		= 0D2FFh
0115   0000             RAM_TOP			= 8FFFh
0116   0000             
0117   0000             ; ===========================================================================
0118   0000             ; Џ…ђ…Њ…ЌЌ›…
0119   0000             
0120   C000             .org 0C000h
0121   C000             
0122   C000             charGen:
0123   C000             
0124   C000             .include "chargen.inc"
0001+  C000             ;+---------------------------------------------------------------------------
0002+  C000             ; RAMFOS
0003+  C000             ; Знакогенератор
0004+  C000             ;
0005+  C000             ; 2013-11-01 Дизассемблировано и доработано vinxru
0006+  C000             ;----------------------------------------------------------------------------
0007+  C000             
0008+  C000             ; Новая функция вывода текста использует шрифты высотой в 10 пикселей
0009+  C000~            #if FAST_PRINT
0010+  C000~            #define DY 80h
0011+  C000             #else
0012+  C000             #define DY 0
0013+  C000             #endif
0014+  C000             
0015+  C000 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,000h ; 0
0015+  C004 00 00 00 00 
0016+  C008 38 38 38 38 	.db DY|038h,038h,038h,038h,000h,000h,000h,DY|000h ; 1
0016+  C00C 00 00 00 00 
0017+  C010 07 07 07 07 	.db DY|007h,007h,007h,007h,000h,000h,000h,DY|000h ; 2
0017+  C014 00 00 00 00 
0018+  C018 3F 3F 3F 3F 	.db DY|03Fh,03Fh,03Fh,03Fh,000h,000h,000h,DY|000h ; 3
0018+  C01C 00 00 00 00 
0019+  C020 00 00 00 00 	.db DY|000h,000h,000h,000h,007h,007h,007h,DY|007h ; 4
0019+  C024 07 07 07 07 
0020+  C028 38 38 38 38 	.db DY|038h,038h,038h,038h,007h,007h,007h,DY|007h ; 5
0020+  C02C 07 07 07 07 
0021+  C030 07 07 07 07 	.db DY|007h,007h,007h,007h,007h,007h,007h,DY|007h ; 6
0021+  C034 07 07 07 07 
0022+  C038 3F 3F 3F 3F 	.db DY|03Fh,03Fh,03Fh,03Fh,007h,007h,007h,DY|007h ; 7
0022+  C03C 07 07 07 07 
0023+  C040~            #if ALL_CHARS
0024+  C040~            	.db DY|030h,030h,030h,030h,030h,030h,030h,DY|030h ; 8+
0025+  C040             #else
0026+  C040 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,000h
0026+  C044 00 00 00 00 
0027+  C048             #endif
0028+  C048 0C 0C 3F 2D 	.db 00Ch,00Ch,03Fh,02Dh,00Ch,00Ch,012h,021h ; 9
0028+  C04C 0C 0C 12 21 
0029+  C050~            #if ALL_CHARS
0030+  C050~            	.db DY|003h,003h,003h,003h,003h,003h,003h,DY|003h ; 10+
0031+  C050             #else
0032+  C050 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,000h
0032+  C054 00 00 00 00 
0033+  C058             #endif
0034+  C058 0C 1E 3F 0C 	.db 00Ch,01Eh,03Fh,00Ch,00Ch,00Ch,00Ch,000h ; 11
0034+  C05C 0C 0C 0C 00 
0035+  C060~            #if ALL_CHARS
0036+  C060~            	.db DY|030h,030h,030h,030h,030h,030h,030h,DY|03Fh ; 12+
0037+  C060             #else
0038+  C060 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,000h
0038+  C064 00 00 00 00 
0039+  C068             #endif
0040+  C068~            #if ALL_CHARS
0041+  C068~            	.db 000h,000h,000h,000h,000h,000h,000h,DY|03Fh ; 13
0042+  C068             #else
0043+  C068 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,000h
0043+  C06C 00 00 00 00 
0044+  C070             #endif
0045+  C070 08 0C 3E 3F 	.db 008h,00Ch,03Eh,03Fh,03Eh,00Ch,008h,000h ; 14
0045+  C074 3E 0C 08 00 
0046+  C078 0C 0C 0C 0C 	.db 00Ch,00Ch,00Ch,00Ch,03Fh,01Eh,00Ch,000h ; 15
0046+  C07C 3F 1E 0C 00 
0047+  C080 00 00 00 00 	.db DY|000h,000h,000h,000h,038h,038h,038h,DY|038h ; 16
0047+  C084 38 38 38 38 
0048+  C088 38 38 38 38 	.db DY|038h,038h,038h,038h,038h,038h,038h,DY|038h ; 17
0048+  C08C 38 38 38 38 
0049+  C090 07 07 07 07 	.db DY|007h,007h,007h,007h,038h,038h,038h,DY|038h ; 18
0049+  C094 38 38 38 38 
0050+  C098 3F 3F 3F 3F 	.db DY|03Fh,03Fh,03Fh,03Fh,038h,038h,038h,DY|038h ; 19
0050+  C09C 38 38 38 38 
0051+  C0A0 00 00 00 00 	.db DY|000h,000h,000h,000h,03Fh,03Fh,03Fh,DY|03Fh ; 20
0051+  C0A4 3F 3F 3F 3F 
0052+  C0A8 38 38 38 38 	.db DY|038h,038h,038h,038h,03Fh,03Fh,03Fh,DY|03Fh ; 21
0052+  C0AC 3F 3F 3F 3F 
0053+  C0B0 07 07 07 07 	.db DY|007h,007h,007h,007h,03Fh,03Fh,03Fh,DY|03Fh ; 22
0053+  C0B4 3F 3F 3F 3F 
0054+  C0B8 3F 3F 3F 3F 	.db DY|03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,DY|03Fh ; 23
0054+  C0BC 3F 3F 3F 3F 
0055+  C0C0~            #if ALL_CHARS
0056+  C0C0~            	.db DY|003h,003h,003h,003h,003h,003h,003h,DY|03Fh ; 24+
0057+  C0C0             #else
0058+  C0C0 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,000h
0058+  C0C4 00 00 00 00 
0059+  C0C8             #endif
0060+  C0C8~            #if ALL_CHARS
0061+  C0C8~            	.db DY|020h,020h,020h,020h,020h,020h,020h,DY|020h ; 25+
0062+  C0C8             #else
0063+  C0C8 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,000h
0063+  C0CC 00 00 00 00 
0064+  C0D0             #endif
0065+  C0D0 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,000h ; 26
0065+  C0D4 00 00 00 00 
0066+  C0D8 0C 0C 0C 0C 	.db 00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch ; 27
0066+  C0DC 0C 0C 0C 0C 
0067+  C0E0 00 00 00 3F 	.db 000h,000h,000h,03Fh,03Fh,000h,000h,000h ; 28
0067+  C0E4 3F 00 00 00 
0068+  C0E8 04 0C 1F 3F 	.db 004h,00Ch,01Fh,03Fh,01Fh,00Ch,004h,000h ; 29
0068+  C0EC 1F 0C 04 00 
0069+  C0F0 00 3E 3C 3C 	.db 000h,03Eh,03Ch,03Ch,03Eh,027h,002h,000h ; 30
0069+  C0F4 3E 27 02 00 
0070+  C0F8 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,000h ; 31
0070+  C0FC 00 00 00 00 
0071+  C100 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,000h ; 32
0071+  C104 00 00 00 00 
0072+  C108 04 04 04 04 	.db 004h,004h,004h,004h,004h,000h,004h,000h ; 33
0072+  C10C 04 00 04 00 
0073+  C110 0A 0A 0A 00 	.db 00Ah,00Ah,00Ah,000h,000h,000h,000h,000h ; 34
0073+  C114 00 00 00 00 
0074+  C118 0A 0A 1F 0A 	.db 00Ah,00Ah,01Fh,00Ah,01Fh,00Ah,00Ah,000h ; 35
0074+  C11C 1F 0A 0A 00 
0075+  C120 00 11 0E 0A 	.db 000h,011h,00Eh,00Ah,00Eh,011h,000h,000h ; 36
0075+  C124 0E 11 00 00 
0076+  C128 18 19 02 04 	.db 018h,019h,002h,004h,008h,013h,003h,000h ; 37
0076+  C12C 08 13 03 00 
0077+  C130 04 0A 0A 0C 	.db 004h,00Ah,00Ah,00Ch,015h,012h,00Dh,000h ; 38
0077+  C134 15 12 0D 00 
0078+  C138 06 06 02 04 	.db 006h,006h,002h,004h,000h,000h,000h,000h ; 39
0078+  C13C 00 00 00 00 
0079+  C140 02 04 08 08 	.db 002h,004h,008h,008h,008h,004h,002h,000h ; 40
0079+  C144 08 04 02 00 
0080+  C148 08 04 02 02 	.db 008h,004h,002h,002h,002h,004h,008h,000h ; 41
0080+  C14C 02 04 08 00 
0081+  C150 00 04 15 0E 	.db 000h,004h,015h,00Eh,015h,004h,000h,000h ; 42
0081+  C154 15 04 00 00 
0082+  C158 00 04 04 1F 	.db 000h,004h,004h,01Fh,004h,004h,000h,000h ; 43
0082+  C15C 04 04 00 00 
0083+  C160 00 00 00 00 	.db 000h,000h,000h,000h,00Ch,00Ch,004h,008h ; 44
0083+  C164 0C 0C 04 08 
0084+  C168 00 00 00 1F 	.db 000h,000h,000h,01Fh,000h,000h,000h,000h ; 45
0084+  C16C 00 00 00 00 
0085+  C170 00 00 00 00 	.db 000h,000h,000h,000h,000h,00Ch,00Ch,000h ; 46
0085+  C174 00 0C 0C 00 
0086+  C178 00 01 02 04 	.db 000h,001h,002h,004h,008h,010h,000h,000h ; 47
0086+  C17C 08 10 00 00 
0087+  C180 0E 11 13 15 	.db 00Eh,011h,013h,015h,019h,011h,00Eh,000h ; 48
0087+  C184 19 11 0E 00 
0088+  C188 04 0C 04 04 	.db 004h,00Ch,004h,004h,004h,004h,00Eh,000h ; 49
0088+  C18C 04 04 0E 00 
0089+  C190 0E 11 01 06 	.db 00Eh,011h,001h,006h,008h,010h,01Fh,000h ; 50
0089+  C194 08 10 1F 00 
0090+  C198 1F 01 02 06 	.db 01Fh,001h,002h,006h,001h,011h,00Eh,000h ; 51
0090+  C19C 01 11 0E 00 
0091+  C1A0 02 06 0A 12 	.db 002h,006h,00Ah,012h,01Fh,002h,002h,000h ; 52
0091+  C1A4 1F 02 02 00 
0092+  C1A8 1F 10 1E 01 	.db 01Fh,010h,01Eh,001h,001h,011h,00Eh,000h ; 53
0092+  C1AC 01 11 0E 00 
0093+  C1B0 07 08 10 1E 	.db 007h,008h,010h,01Eh,011h,011h,00Eh,000h ; 54
0093+  C1B4 11 11 0E 00 
0094+  C1B8 1F 01 02 04 	.db 01Fh,001h,002h,004h,008h,008h,008h,000h ; 55
0094+  C1BC 08 08 08 00 
0095+  C1C0 0E 11 11 0E 	.db 00Eh,011h,011h,00Eh,011h,011h,00Eh,000h ; 56
0095+  C1C4 11 11 0E 00 
0096+  C1C8 0E 11 11 0F 	.db 00Eh,011h,011h,00Fh,001h,002h,01Ch,000h ; 57
0096+  C1CC 01 02 1C 00 
0097+  C1D0 00 0C 0C 00 	.db 000h,00Ch,00Ch,000h,000h,00Ch,00Ch,000h ; 58
0097+  C1D4 00 0C 0C 00 
0098+  C1D8 0C 0C 00 00 	.db 00Ch,00Ch,000h,000h,00Ch,00Ch,004h,008h ; 59
0098+  C1DC 0C 0C 04 08 
0099+  C1E0 02 04 08 10 	.db 002h,004h,008h,010h,008h,004h,002h,000h ; 60
0099+  C1E4 08 04 02 00 
0100+  C1E8 00 00 1F 00 	.db 000h,000h,01Fh,000h,01Fh,000h,000h,000h ; 61
0100+  C1EC 1F 00 00 00 
0101+  C1F0 08 04 02 01 	.db 008h,004h,002h,001h,002h,004h,008h,000h ; 62
0101+  C1F4 02 04 08 00 
0102+  C1F8 0E 11 01 02 	.db 00Eh,011h,001h,002h,004h,000h,004h,000h ; 63
0102+  C1FC 04 00 04 00 
0103+  C200 0E 11 13 15 	.db 00Eh,011h,013h,015h,017h,010h,00Eh,000h ; 64
0103+  C204 17 10 0E 00 
0104+  C208 04 0A 11 11 	.db 004h,00Ah,011h,011h,01Fh,011h,011h,000h ; 65
0104+  C20C 1F 11 11 00 
0105+  C210 1E 11 11 1E 	.db 01Eh,011h,011h,01Eh,011h,011h,01Eh,000h ; 66
0105+  C214 11 11 1E 00 
0106+  C218 0E 11 10 10 	.db 00Eh,011h,010h,010h,010h,011h,00Eh,000h ; 67
0106+  C21C 10 11 0E 00 
0107+  C220 1E 09 09 09 	.db 01Eh,009h,009h,009h,009h,009h,01Eh,000h ; 68
0107+  C224 09 09 1E 00 
0108+  C228 1F 10 10 1E 	.db 01Fh,010h,010h,01Eh,010h,010h,01Fh,000h ; 69
0108+  C22C 10 10 1F 00 
0109+  C230 1F 10 10 1E 	.db 01Fh,010h,010h,01Eh,010h,010h,010h,000h ; 70
0109+  C234 10 10 10 00 
0110+  C238 0E 11 10 10 	.db 00Eh,011h,010h,010h,013h,011h,00Fh,000h ; 71
0110+  C23C 13 11 0F 00 
0111+  C240 11 11 11 1F 	.db 011h,011h,011h,01Fh,011h,011h,011h,000h ; 72
0111+  C244 11 11 11 00 
0112+  C248 0E 04 04 04 	.db 00Eh,004h,004h,004h,004h,004h,00Eh,000h ; 73
0112+  C24C 04 04 0E 00 
0113+  C250 01 01 01 01 	.db 001h,001h,001h,001h,011h,011h,00Eh,000h ; 74
0113+  C254 11 11 0E 00 
0114+  C258 11 12 14 18 	.db 011h,012h,014h,018h,014h,012h,011h,000h ; 75
0114+  C25C 14 12 11 00 
0115+  C260 10 10 10 10 	.db 010h,010h,010h,010h,010h,011h,01Fh,000h ; 76
0115+  C264 10 11 1F 00 
0116+  C268 11 1B 15 15 	.db 011h,01Bh,015h,015h,011h,011h,011h,000h ; 77
0116+  C26C 11 11 11 00 
0117+  C270 11 11 19 15 	.db 011h,011h,019h,015h,013h,011h,011h,000h ; 78
0117+  C274 13 11 11 00 
0118+  C278 0E 11 11 11 	.db 00Eh,011h,011h,011h,011h,011h,00Eh,000h ; 79
0118+  C27C 11 11 0E 00 
0119+  C280 1E 11 11 1E 	.db 01Eh,011h,011h,01Eh,010h,010h,010h,000h ; 80
0119+  C284 10 10 10 00 
0120+  C288 0E 11 11 11 	.db 00Eh,011h,011h,011h,015h,012h,00Dh,000h ; 81
0120+  C28C 15 12 0D 00 
0121+  C290 1E 11 11 1E 	.db 01Eh,011h,011h,01Eh,014h,012h,011h,000h ; 82
0121+  C294 14 12 11 00 
0122+  C298 0E 11 10 0E 	.db 00Eh,011h,010h,00Eh,001h,011h,00Eh,000h ; 83
0122+  C29C 01 11 0E 00 
0123+  C2A0 1F 04 04 04 	.db 01Fh,004h,004h,004h,004h,004h,004h,000h ; 84
0123+  C2A4 04 04 04 00 
0124+  C2A8 11 11 11 11 	.db 011h,011h,011h,011h,011h,011h,00Eh,000h ; 85
0124+  C2AC 11 11 0E 00 
0125+  C2B0 11 11 11 0A 	.db 011h,011h,011h,00Ah,00Ah,004h,004h,000h ; 86
0125+  C2B4 0A 04 04 00 
0126+  C2B8 11 11 11 15 	.db 011h,011h,011h,015h,015h,015h,00Ah,000h ; 87
0126+  C2BC 15 15 0A 00 
0127+  C2C0 11 11 0A 04 	.db 011h,011h,00Ah,004h,00Ah,011h,011h,000h ; 88
0127+  C2C4 0A 11 11 00 
0128+  C2C8 11 11 0A 04 	.db 011h,011h,00Ah,004h,004h,004h,004h,000h ; 89
0128+  C2CC 04 04 04 00 
0129+  C2D0 1F 01 02 0E 	.db 01Fh,001h,002h,00Eh,008h,010h,01Fh,000h ; 90
0129+  C2D4 08 10 1F 00 
0130+  C2D8 0E 08 08 08 	.db 00Eh,008h,008h,008h,008h,008h,00Eh,000h ; 91
0130+  C2DC 08 08 0E 00 
0131+  C2E0 00 10 08 04 	.db 000h,010h,008h,004h,002h,001h,000h,000h ; 92
0131+  C2E4 02 01 00 00 
0132+  C2E8 0E 02 02 02 	.db 00Eh,002h,002h,002h,002h,002h,00Eh,000h ; 93
0132+  C2EC 02 02 0E 00 
0133+  C2F0 0E 11 00 00 	.db 00Eh,011h,000h,000h,000h,000h,000h,000h ; 94
0133+  C2F4 00 00 00 00 
0134+  C2F8 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,01Fh,000h ; 95
0134+  C2FC 00 00 1F 00 
0135+  C300 00 08 04 02 	.db 000h,008h,004h,002h,000h,000h,000h,000h ; 96
0135+  C304 00 00 00 00 
0136+  C308 00 00 0E 01 	.db 000h,000h,00Eh,001h,00Fh,011h,00Fh,000h ; 97
0136+  C30C 0F 11 0F 00 
0137+  C310 10 10 10 1E 	.db 010h,010h,010h,01Eh,011h,011h,01Eh,000h ; 98
0137+  C314 11 11 1E 00 
0138+  C318 00 00 0F 10 	.db 000h,000h,00Fh,010h,010h,010h,00Fh,000h ; 99
0138+  C31C 10 10 0F 00 
0139+  C320 01 01 01 0F 	.db 001h,001h,001h,00Fh,011h,011h,00Fh,000h ; 100
0139+  C324 11 11 0F 00 
0140+  C328 00 00 0E 11 	.db 000h,000h,00Eh,011h,01Fh,010h,00Fh,000h ; 101
0140+  C32C 1F 10 0F 00 
0141+  C330 03 04 04 1F 	.db 003h,004h,004h,01Fh,004h,004h,004h,000h ; 102
0141+  C334 04 04 04 00 
0142+  C338 00 00 0F 11 	.db 000h,000h,00Fh,011h,00Fh,001h,011h,00Eh ; 103
0142+  C33C 0F 01 11 0E 
0143+  C340 10 10 10 1E 	.db 010h,010h,010h,01Eh,011h,011h,011h,000h ; 104
0143+  C344 11 11 11 00 
0144+  C348 00 04 00 0C 	.db 000h,004h,000h,00Ch,004h,004h,00Eh,000h ; 105
0144+  C34C 04 04 0E 00 
0145+  C350 02 00 02 02 	.db 002h,000h,002h,002h,002h,012h,00Ch,000h ; 106
0145+  C354 02 12 0C 00 
0146+  C358 10 10 12 14 	.db 010h,010h,012h,014h,018h,014h,012h,000h ; 107
0146+  C35C 18 14 12 00 
0147+  C360 0C 04 04 04 	.db 00Ch,004h,004h,004h,004h,004h,00Eh,000h ; 108
0147+  C364 04 04 0E 00 
0148+  C368 00 00 15 1F 	.db 000h,000h,015h,01Fh,015h,015h,015h,000h ; 109
0148+  C36C 15 15 15 00 
0149+  C370 00 00 1E 11 	.db 000h,000h,01Eh,011h,011h,011h,011h,000h ; 110
0149+  C374 11 11 11 00 
0150+  C378 00 00 0E 11 	.db 000h,000h,00Eh,011h,011h,011h,00Eh,000h ; 111
0150+  C37C 11 11 0E 00 
0151+  C380 00 00 1E 11 	.db 000h,000h,01Eh,011h,011h,01Eh,010h,010h ; 112
0151+  C384 11 1E 10 10 
0152+  C388 00 00 0F 11 	.db 000h,000h,00Fh,011h,011h,00Fh,001h,001h ; 113
0152+  C38C 11 0F 01 01 
0153+  C390 00 00 17 18 	.db 000h,000h,017h,018h,010h,010h,010h,000h ; 114
0153+  C394 10 10 10 00 
0154+  C398 00 00 0F 10 	.db 000h,000h,00Fh,010h,00Eh,001h,01Eh,000h ; 115
0154+  C39C 0E 01 1E 00 
0155+  C3A0 08 08 1E 08 	.db 008h,008h,01Eh,008h,008h,008h,007h,000h ; 116
0155+  C3A4 08 08 07 00 
0156+  C3A8 00 00 11 11 	.db 000h,000h,011h,011h,011h,011h,00Fh,000h ; 117
0156+  C3AC 11 11 0F 00 
0157+  C3B0 00 00 11 11 	.db 000h,000h,011h,011h,00Ah,00Ah,004h,000h ; 118
0157+  C3B4 0A 0A 04 00 
0158+  C3B8 00 00 11 11 	.db 000h,000h,011h,011h,015h,015h,00Ah,000h ; 119
0158+  C3BC 15 15 0A 00 
0159+  C3C0 00 00 11 0A 	.db 000h,000h,011h,00Ah,004h,00Ah,011h,000h ; 120
0159+  C3C4 04 0A 11 00 
0160+  C3C8 00 00 11 0A 	.db 000h,000h,011h,00Ah,004h,004h,004h,000h ; 121
0160+  C3CC 04 04 04 00 
0161+  C3D0 00 00 1F 02 	.db 000h,000h,01Fh,002h,004h,008h,01Fh,000h ; 122
0161+  C3D4 04 08 1F 00 
0162+  C3D8 03 04 04 08 	.db 003h,004h,004h,008h,004h,004h,003h,000h ; 123
0162+  C3DC 04 04 03 00 
0163+  C3E0 04 04 04 04 	.db 004h,004h,004h,004h,004h,004h,004h,000h ; 124
0163+  C3E4 04 04 04 00 
0164+  C3E8 18 04 04 02 	.db 018h,004h,004h,002h,004h,004h,018h,000h ; 125
0164+  C3EC 04 04 18 00 
0165+  C3F0 1F 00 00 00 	.db 01Fh,000h,000h,000h,000h,000h,000h,000h ; 126
0165+  C3F4 00 00 00 00 
0166+  C3F8 1F 1F 1F 1F 	.db 01Fh,01Fh,01Fh,01Fh,01Fh,01Fh,01Fh,01Fh ; 127
0166+  C3FC 1F 1F 1F 1F 
0167+  C400 00 00 12 15 	.db 000h,000h,012h,015h,01Dh,015h,012h,000h ; 128
0167+  C404 1D 15 12 00 
0168+  C408 00 00 0C 02 	.db 000h,000h,00Ch,002h,00Eh,012h,00Fh,000h ; 129
0168+  C40C 0E 12 0F 00 
0169+  C410 01 0E 18 1E 	.db 001h,00Eh,018h,01Eh,011h,011h,00Eh,000h ; 130
0169+  C414 11 11 0E 00 
0170+  C418 00 00 12 12 	.db 000h,000h,012h,012h,012h,012h,01Fh,001h ; 131
0170+  C41C 12 12 1F 01 
0171+  C420 00 00 06 0A 	.db 000h,000h,006h,00Ah,00Ah,00Ah,01Fh,011h ; 132
0171+  C424 0A 0A 1F 11 
0172+  C428 00 00 0E 11 	.db 000h,000h,00Eh,011h,01Fh,010h,00Fh,000h ; 133
0172+  C42C 1F 10 0F 00 
0173+  C430 00 04 0E 15 	.db 000h,004h,00Eh,015h,015h,015h,00Eh,004h ; 134
0173+  C434 15 15 0E 04 
0174+  C438 00 00 1F 10 	.db 000h,000h,01Fh,010h,010h,010h,010h,000h ; 135
0174+  C43C 10 10 10 00 
0175+  C440 00 00 11 0A 	.db 000h,000h,011h,00Ah,004h,00Ah,011h,000h ; 136
0175+  C444 04 0A 11 00 
0176+  C448 00 00 11 13 	.db 000h,000h,011h,013h,015h,019h,011h,000h ; 137
0176+  C44C 15 19 11 00 
0177+  C450 00 04 11 13 	.db 000h,004h,011h,013h,015h,019h,011h,000h ; 138
0177+  C454 15 19 11 00 
0178+  C458 00 00 11 12 	.db 000h,000h,011h,012h,014h,01Ch,013h,000h ; 139
0178+  C45C 14 1C 13 00 
0179+  C460 00 00 07 09 	.db 000h,000h,007h,009h,009h,009h,019h,000h ; 140
0179+  C464 09 09 19 00 
0180+  C468 00 00 11 1B 	.db 000h,000h,011h,01Bh,015h,011h,011h,000h ; 141
0180+  C46C 15 11 11 00 
0181+  C470 00 00 11 11 	.db 000h,000h,011h,011h,01Fh,011h,011h,000h ; 142
0181+  C474 1F 11 11 00 
0182+  C478 00 00 0E 11 	.db 000h,000h,00Eh,011h,011h,011h,00Eh,000h ; 143
0182+  C47C 11 11 0E 00 
0183+  C480 00 00 1F 11 	.db 000h,000h,01Fh,011h,011h,011h,011h,000h ; 144
0183+  C484 11 11 11 00 
0184+  C488 00 00 0F 11 	.db 000h,000h,00Fh,011h,00Fh,009h,011h,000h ; 145
0184+  C48C 0F 09 11 00 
0185+  C490 00 00 1E 11 	.db 000h,000h,01Eh,011h,011h,01Eh,010h,010h ; 146
0185+  C494 11 1E 10 10 
0186+  C498 00 00 0E 11 	.db 000h,000h,00Eh,011h,010h,011h,00Eh,000h ; 147
0186+  C49C 10 11 0E 00 
0187+  C4A0 00 00 1F 04 	.db 000h,000h,01Fh,004h,004h,004h,004h,000h ; 148
0187+  C4A4 04 04 04 00 
0188+  C4A8 00 00 11 11 	.db 000h,000h,011h,011h,00Fh,001h,01Eh,000h ; 149
0188+  C4AC 0F 01 1E 00 
0189+  C4B0 00 00 15 15 	.db 000h,000h,015h,015h,00Eh,015h,015h,000h ; 150
0189+  C4B4 0E 15 15 00 
0190+  C4B8 00 00 1C 12 	.db 000h,000h,01Ch,012h,01Eh,011h,01Eh,000h ; 151
0190+  C4BC 1E 11 1E 00 
0191+  C4C0 00 00 10 10 	.db 000h,000h,010h,010h,01Eh,011h,01Eh,000h ; 152
0191+  C4C4 1E 11 1E 00 
0192+  C4C8 00 00 11 11 	.db 000h,000h,011h,011h,01Dh,015h,01Dh,000h ; 153
0192+  C4CC 1D 15 1D 00 
0193+  C4D0 00 00 0E 11 	.db 000h,000h,00Eh,011h,006h,011h,00Eh,000h ; 154
0193+  C4D4 06 11 0E 00 
0194+  C4D8 00 00 15 15 	.db 000h,000h,015h,015h,015h,015h,01Fh,000h ; 155
0194+  C4DC 15 15 1F 00 
0195+  C4E0 00 00 1E 01 	.db 000h,000h,01Eh,001h,00Fh,001h,01Eh,000h ; 156
0195+  C4E4 0F 01 1E 00 
0196+  C4E8 00 00 15 15 	.db 000h,000h,015h,015h,015h,015h,01Fh,001h ; 157
0196+  C4EC 15 15 1F 01 
0197+  C4F0 00 00 11 11 	.db 000h,000h,011h,011h,00Fh,001h,001h,000h ; 158
0197+  C4F4 0F 01 01 00 
0198+  C4F8 00 00 18 08 	.db 000h,000h,018h,008h,00Eh,009h,00Eh,000h ; 159
0198+  C4FC 0E 09 0E 00 
0199+  C500 12 15 15 1D 	.db 012h,015h,015h,01Dh,015h,015h,012h,000h ; 160
0199+  C504 15 15 12 00 
0200+  C508 04 0A 11 11 	.db 004h,00Ah,011h,011h,01Fh,011h,011h,000h ; 161
0200+  C50C 1F 11 11 00 
0201+  C510 1F 10 10 1E 	.db 01Fh,010h,010h,01Eh,011h,011h,01Eh,000h ; 162
0201+  C514 11 11 1E 00 
0202+  C518 12 12 12 12 	.db 012h,012h,012h,012h,012h,012h,01Fh,001h ; 163
0202+  C51C 12 12 1F 01 
0203+  C520 06 0A 0A 0A 	.db 006h,00Ah,00Ah,00Ah,00Ah,00Ah,01Fh,011h ; 164
0203+  C524 0A 0A 1F 11 
0204+  C528 1F 10 10 1E 	.db 01Fh,010h,010h,01Eh,010h,010h,01Fh,000h ; 165
0204+  C52C 10 10 1F 00 
0205+  C530 04 1F 15 15 	.db 004h,01Fh,015h,015h,01Fh,004h,004h,000h ; 166
0205+  C534 1F 04 04 00 
0206+  C538 1F 11 10 10 	.db 01Fh,011h,010h,010h,010h,010h,010h,000h ; 167
0206+  C53C 10 10 10 00 
0207+  C540 11 11 0A 04 	.db 011h,011h,00Ah,004h,00Ah,011h,011h,000h ; 168
0207+  C544 0A 11 11 00 
0208+  C548 11 11 13 15 	.db 011h,011h,013h,015h,019h,011h,011h,000h ; 169
0208+  C54C 19 11 11 00 
0209+  C550 15 11 13 15 	.db 015h,011h,013h,015h,019h,011h,011h,000h ; 170
0209+  C554 19 11 11 00 
0210+  C558 11 12 14 18 	.db 011h,012h,014h,018h,014h,012h,011h,000h ; 171
0210+  C55C 14 12 11 00 
0211+  C560 03 05 09 09 	.db 003h,005h,009h,009h,009h,009h,019h,000h ; 172
0211+  C564 09 09 19 00 
0212+  C568 11 1B 15 15 	.db 011h,01Bh,015h,015h,011h,011h,011h,000h ; 173
0212+  C56C 11 11 11 00 
0213+  C570 11 11 11 1F 	.db 011h,011h,011h,01Fh,011h,011h,011h,000h ; 174
0213+  C574 11 11 11 00 
0214+  C578 0E 11 11 11 	.db 00Eh,011h,011h,011h,011h,011h,00Eh,000h ; 175
0214+  C57C 11 11 0E 00 
0215+  C580 1F 11 11 11 	.db 01Fh,011h,011h,011h,011h,011h,011h,000h ; 176
0215+  C584 11 11 11 00 
0216+  C588 0F 11 11 0F 	.db 00Fh,011h,011h,00Fh,005h,009h,011h,000h ; 177
0216+  C58C 05 09 11 00 
0217+  C590 1E 11 11 1E 	.db 01Eh,011h,011h,01Eh,010h,010h,010h,000h ; 178
0217+  C594 10 10 10 00 
0218+  C598 0E 11 10 10 	.db 00Eh,011h,010h,010h,010h,011h,00Eh,000h ; 179
0218+  C59C 10 11 0E 00 
0219+  C5A0 1F 04 04 04 	.db 01Fh,004h,004h,004h,004h,004h,004h,000h ; 180
0219+  C5A4 04 04 04 00 
0220+  C5A8 11 11 11 0A 	.db 011h,011h,011h,00Ah,004h,008h,010h,000h ; 181
0220+  C5AC 04 08 10 00 
0221+  C5B0 11 15 15 0E 	.db 011h,015h,015h,00Eh,015h,015h,011h,000h ; 182
0221+  C5B4 15 15 11 00 
0222+  C5B8 1E 11 11 1E 	.db 01Eh,011h,011h,01Eh,011h,011h,01Eh,000h ; 183
0222+  C5BC 11 11 1E 00 
0223+  C5C0 10 10 10 1E 	.db 010h,010h,010h,01Eh,011h,011h,01Eh,000h ; 184
0223+  C5C4 11 11 1E 00 
0224+  C5C8 11 11 11 19 	.db 011h,011h,011h,019h,015h,015h,019h,000h ; 185
0224+  C5CC 15 15 19 00 
0225+  C5D0 0E 11 01 06 	.db 00Eh,011h,001h,006h,001h,011h,00Eh,000h ; 186
0225+  C5D4 01 11 0E 00 
0226+  C5D8 11 15 15 15 	.db 011h,015h,015h,015h,015h,015h,01Fh,000h ; 187
0226+  C5DC 15 15 1F 00 
0227+  C5E0 0E 11 01 07 	.db 00Eh,011h,001h,007h,001h,011h,00Eh,000h ; 188
0227+  C5E4 01 11 0E 00 
0228+  C5E8 15 15 15 15 	.db 015h,015h,015h,015h,015h,015h,01Fh,001h ; 189
0228+  C5EC 15 15 1F 01 
0229+  C5F0 11 11 11 1F 	.db 011h,011h,011h,01Fh,001h,001h,001h,000h ; 190
0229+  C5F4 01 01 01 00 
0230+  C5F8 3F 3F 3F 3F 	.db 03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh
0230+  C5FC 3F 3F 3F 3F 
0231+  C600             
0232+  C600             #undef DY0125   C600             
0126   C600 81 0C 19 1A keybMap:	.db 81h, 0ch, 19h, 1ah, 20h, 20h, 20h, 08h, 09h, 18h, 0ah, 0dh ; ЌЁ¦­пп бва®Є  Є« ўЁ вгал
0126   C604 20 20 20 08 
0126   C608 09 18 0A 0D 
0127   C60C 00 C0       v_charGenPtr:	.dw charGen
0128   C60E 00 C6       v_keybMap:	.dw keybMap
0129   C610 51 5E 53 4D 		.db 51h, 5Eh, 53h, 4Dh,	49h, 54h, 58h, 42h, 40h, 2Ch, 2Fh, 5Fh ; Q^SMITXB@,/_
0129   C614 49 54 58 42 
0129   C618 40 2C 2F 5F 
0130   C61C BB FF       v_aramPageEnd:	.dw ARAM_PAGE_END
0131   C61E 00 00       v_aramPageStart:.dw 0
0132   C620 46 59 57 41 		.db 46h, 59h, 57h, 41h,	50h, 52h, 4Fh, 4Ch, 44h, 56h, 5Ch, 2Eh; FYWAPROLDV\.
0132   C624 50 52 4F 4C 
0132   C628 44 56 5C 2E 
0133   C62C 00          v_koi8:		.db 0	; ЉЋ€-7=FF / ЉЋ€-8=00
0134   C62D 00          v_rusLat:	.db 0	; ђ“‘=FF / LAT=00
0135   C62E 00          v_capsLock:	.db 0	; BP=00 / HP=02
0136   C62F 00          v_printerEcho:	.db 0
0137   C630 4A 43 55 4B 		.db 4Ah, 43h, 55h, 4Bh, 45h, 4Eh, 47h, 5Bh, 5Dh, 5Ah, 48h, 3Ah ; JCUKENG[]ZH:
0137   C634 45 4E 47 5B 
0137   C638 5D 5A 48 3A 
0138   C63C B1          v_selColor:	.db 0B1h
0139   C63D 00          v_aramMaxPage:	.db 0			; Ќ®¬Ґа	Ї®б«Ґ¤­Ґ© бва ­Ёжл RAM-¤ЁбЄ 
0140   C63E 00 00       v_cursorPos:	.dw 0			; Џ®«®¦Ґ­ЁҐ Єгаб®а  ў ЇЁЄбҐ«пе
0141   C640 3B 31 32 33 		.db 3Bh, 31h, 32h, 33h,	34h, 35h, 36h, 37h, 38h, 39h, 30h, 2Dh ; ;1234567890-
0141   C644 34 35 36 37 
0141   C648 38 39 30 2D 
0142   C64C 05 0A       v_beepConfig:	.dw 0A05h
0143   C64E 00 00       v_oldBeep:	.dw 0
0144   C650 1B 8A 00 01 		.db 1Bh, 8Ah, 0, 1, 2, 3, 4, 5,	6, 8Bh,	8Ch, 1Fh ; ‚Ґае­пп бва®Є  Є« ўЁ вгал
0144   C654 02 03 04 05 
0144   C658 06 8B 8C 1F 
0145   C65C 00          v_inverse:	.db 0
0146   C65D 00          		.db 0
0147   C65E 06          v_aramMaxPageI:	.db ARAM_MAX_PAGE
0148   C65F 30          v_tapeMode:	.db '0'
0149   C660 2C 32       v_tapePulseB:	.dw 322Ch	; 1200 Ѓ®¤
0150   C662 12 18       v_tapePulseA:	.dw 1812h
0151   C664 1B 21       v_tapePulseB2:	.dw 211Bh	; 1800 Ѓ®¤
0152   C666 09 0F       v_tapePulseA2:	.dw 0F09h
0153   C668 12 18       v_tapePulseB3:	.dw 1812h	; 2400 Ѓ®¤
0154   C66A 05 0B       v_tapePulseA3:	.dw 0B05h
0155   C66C             v_tapePresets:
0156   C66C             
0157   C66C             ; ===========================================================================
0158   C66C             ; ЉЋ„
0159   C66C             
0160   C66C             .org 0C66Ch
0161   C66C             
0162   C66C             .include "tapeReadPilot.inc"
0001+  C66C             ;----------------------------------------------------------------------------
0002+  C66C             ; RAMFOS
0003+  C66C             ; Стандартная точка входа C824
0004+  C66C             ; Чтение пилот тона с ленты
0005+  C66C             ;
0006+  C66C             ; 2013-11-01 Дизассемблировано vinxru
0007+  C66C             ;----------------------------------------------------------------------------
0008+  C66C             
0009+  C66C E5          tapeReadPilot:	push	h
0010+  C66D D5          		push	d
0011+  C66E C5          		push	b
0012+  C66F             
0013+  C66F             		; Промежуточный адрес возврата
0014+  C66F 21 89 CB    		lxi	h, popa_ret
0015+  C672 E5          		push	h
0016+  C673             
0017+  C673             		; Порт магнитофона
0018+  C673 21 E1 FF    		lxi	h, IO_KEYB_B
0019+  C676             
0020+  C676 1E 01       		mvi	e, 1		
0021+  C678 16 00       loc_C678:	 mvi	d, 0
0022+  C67A 41          loc_C67A:	 mov	b, c
0023+  C67B CD AB C6    		 call	tapeWaitC3
0024+  C67E 79          		 mov	a, c
0025+  C67F 90          		 sub	b
0026+  C680 D2 84 C6    		 jnc	loc_C684
0027+  C683 2F          		  cma
0028+  C684 FE 03       loc_C684:	 cpi	3
0029+  C686 D2 78 C6    		jnc	loc_C678
0030+  C689 15          		dcr	d
0031+  C68A C2 7A C6    		jnz	loc_C67A
0032+  C68D             
0033+  C68D CD AB C6    		call	tapeWaitC3
0034+  C690             
0035+  C690             		; Повторить D раз
0036+  C690 01 00 01    		lxi	b, 100h		
0037+  C693 CD AD C6    loc_C693:	 call	tapeWait
0038+  C696 03          		 inx	b
0039+  C697 03          		 inx	b
0040+  C698 15          		 dcr	d
0041+  C699 C2 93 C6    		jnz	loc_C693
0042+  C69C             
0043+  C69C 69          		mov	l, c
0044+  C69D 60          		mov	h, b
0045+  C69E B7          		ora	a
0046+  C69F             
0047+  C69F             		; bc >>= 1
0048+  C69F 78          		mov	a, b
0049+  C6A0 1F          		rar
0050+  C6A1 47          		mov	b, a
0051+  C6A2 79          		mov	a, c
0052+  C6A3 1F          		rar
0053+  C6A4 4F          		mov	c, a
0054+  C6A5             
0055+  C6A5 09          		dad	b
0056+  C6A6 6B          		mov	l, e
0057+  C6A7 22 F0 D1    		shld	v_tape
0058+  C6AA C9          		ret
0163   C6AB             .include "tapeWait.inc"
0001+  C6AB             ;+---------------------------------------------------------------------------
0002+  C6AB             ; RAMFOS
0003+  C6AB             ; Ожидание изменения порта магнитофона и замер времени в bс
0004+  C6AB             ;
0005+  C6AB             ; 2013-11-01 Дизассемблировано vinxru
0006+  C6AB             ;----------------------------------------------------------------------------
0007+  C6AB             
0008+  C6AB 0E 03       tapeWaitC3:	mvi	c, 3
0009+  C6AD 7B          tapeWait:	mov	a, e
0010+  C6AE EE 01       		xri	1
0011+  C6B0 5F          		mov	e, a		
0012+  C6B1 03          tapeWait_0:	 inx	b
0013+  C6B2 7E          		 mov	a, m
0014+  C6B3 AB          		 xra	e
0015+  C6B4 E2 B1 C6    		jpo	tapeWait_0
0016+  C6B7 0F          		rrc
0017+  C6B8 0F          		rrc
0018+  C6B9 D8          		rc
0019+  C6BA E1          		pop	h
0020+  C6BB C3 0B C7    		jmp	tapeError0164   C6BE             .include "tapeRead.inc"
0001+  C6BE             ;----------------------------------------------------------------------------
0002+  C6BE             ; RAMFOS
0003+  C6BE             ; Стандартная точка входа C806
0004+  C6BE             ; Чтение байта с лента
0005+  C6BE             ;
0006+  C6BE             ; 2013-11-01 Дизассемблировано vinxru
0007+  C6BE             ;----------------------------------------------------------------------------
0008+  C6BE             
0009+  C6BE E5          tapeRead:	push	h
0010+  C6BF D5          		push	d
0011+  C6C0 C5          		push	b
0012+  C6C1             
0013+  C6C1             		; Промежуточный адрес возврата
0014+  C6C1 21 89 CB    		lxi	h, popa_ret
0015+  C6C4 E5          		push	h
0016+  C6C5             
0017+  C6C5 2A F0 D1    		lhld	v_tape
0018+  C6C8 EB          		xchg
0019+  C6C9 21 E1 FF    		lxi	h, 0FFE1h
0020+  C6CC             
0021+  C6CC 06 08       		mvi	b, 8
0022+  C6CE CD AB C6    tapeRead_0:	 call	tapeWaitC3
0023+  C6D1 79          		 mov	a, c
0024+  C6D2 BA          		 cmp	d
0025+  C6D3 DA CE C6    		 jc	tapeRead_0
0026+  C6D6 CD AB C6    		 call	tapeWaitC3
0027+  C6D9 79          		 mov	a, c
0028+  C6DA BA          		 cmp	d
0029+  C6DB DA CE C6    		jc	tapeRead_0
0030+  C6DE             
0031+  C6DE CD AB C6    tapeRead_1:	 call	tapeWaitC3
0032+  C6E1 3A F1 D1    		 lda	v_tape+1
0033+  C6E4 B9          		 cmp	c
0034+  C6E5 3F          		 cmc
0035+  C6E6 7A          		 mov	a, d
0036+  C6E7 1F          		 rar
0037+  C6E8 57          		 mov	d, a
0038+  C6E9 CD AB C6    		 call	tapeWaitC3
0039+  C6EC 05          		 dcr	b
0040+  C6ED C2 DE C6    		jnz	tapeRead_1
0041+  C6F0             
0042+  C6F0 CD AB C6    		call	tapeWaitC3
0043+  C6F3 7B          		mov	a, e
0044+  C6F4 EE 01       		xri	1
0045+  C6F6 32 F0 D1    		sta	v_tape
0046+  C6F9 3A F1 D1    		lda	v_tape+1
0047+  C6FC B9          		cmp	c
0048+  C6FD 3F          		cmc
0049+  C6FE 17          		ral
0050+  C6FF 4F          		mov	c, a
0051+  C700 7A          		mov	a, d
0052+  C701 B7          		ora	a
0053+  C702 F5          		push	psw
0054+  C703 D1          		pop	d
0055+  C704 7B          		mov	a, e
0056+  C705 1F          		rar
0057+  C706 1F          		rar
0058+  C707 A9          		xra	c
0059+  C708 1F          		rar
0060+  C709 7A          		mov	a, d
0061+  C70A D0          		rnc
0062+  C70B             
0063+  C70B 3E 3F       tapeError:	mvi	a, 3Fh
0064+  C70D 37          		stc
0065+  C70E C9          		ret
0165   C70F             .include "tapeWritePilot.inc"
0001+  C70F             ;+---------------------------------------------------------------------------
0002+  C70F             ; RAMFOS
0003+  C70F             ; Стандартная точка входа C827
0004+  C70F             ; Запись пилот тона на магнитофон
0005+  C70F             ;
0006+  C70F             ; Сохраняет регистры BC,DE,HL
0007+  C70F             ;
0008+  C70F             ; 2013-11-01 Дизассемблировано vinxru
0009+  C70F             ;----------------------------------------------------------------------------
0010+  C70F             
0011+  C70F             tapeWritePilot:	; Сохраняем BC, HL
0012+  C70F E5          		push	h
0013+  C710 C5          		push	b		
0014+  C711             
0015+  C711             		; Длительность пилот-тона BC. Странный кусок кода.
0016+  C711             		; bc = (40 - v_tapePulseAL)*514
0017+  C711 2A 62 C6    		lhld	v_tapePulseA
0018+  C714 3E 28       		mvi	a, 40
0019+  C716 94          		sub	h
0020+  C717 87          		add	a
0021+  C718 47          		mov	b, a
0022+  C719 4F          		mov	c, a		
0023+  C71A             
0024+  C71A             tapeWritePilot_0:
0025+  C71A             		 ; Уменьшаем BC 
0026+  C71A 0B          		 dcx	b
0027+  C71B             
0028+  C71B             		 ; Задержка, регистры ничего полезного не содержат
0029+  C71B 29          		 dad	h
0030+  C71C 78          		 mov	a, b
0031+  C71D             
0032+  C71D             		 ; Импульс А
0033+  C71D CD 66 C7    		 call	tapePulseA		 
0034+  C720             
0035+  C720             		 ; Повторять пока BC не нулевое
0036+  C720 78          		 mov	a, b
0037+  C721 B1          		 ora	c
0038+  C722 C2 1A C7    		jnz	tapeWritePilot_0
0039+  C725             
0040+  C725             		; Восстаналиваем BC, HL
0041+  C725 C1          		pop	b
0042+  C726 E1          		pop	h
0043+  C727 C9          		ret
0166   C728             .include "tapeWrite.inc"
0001+  C728             ;+---------------------------------------------------------------------------
0002+  C728             ; RAMFOS
0003+  C728             ; Стандартная точка входа C80С
0004+  C728             ; Запись байта на магнитофон
0005+  C728             ;
0006+  C728             ; На входе
0007+  C728             ;  С - байт
0008+  C728             ;  A - укорочение первого импульса *15 тактов
0009+  C728             ;
0010+  C728             ; Сохраняет регистры BC, DE, HL
0011+  C728             ;
0012+  C728             ; 2013-11-01 Дизассемблировано vinxru
0013+  C728             ;----------------------------------------------------------------------------
0014+  C728             
0015+  C728 E5          tapeWrite:	push	h
0016+  C729 C5          		push	b
0017+  C72A 2A 60 C6    		 lhld	v_tapePulseB
0018+  C72D C6 03       		 adi	3
0019+  C72F 2F          		 cma
0020+  C730 85          		 add	l
0021+  C731 6F          		 mov	l, a
0022+  C732 CD 6C C7    		 call	tapePulse
0023+  C735 B7          		 ora	a
0024+  C736 B7          		 ora	a
0025+  C737 06 08       		 mvi	b, 8				
0026+  C739 CD 4D C7    tapeWrite_0:	  call	tapePulseBit
0027+  C73C 05          		  dcr	b
0028+  C73D C2 39 C7    		 jnz	tapeWrite_0
0029+  C740 CD 59 C7    		 call	tapeWriteEnd
0030+  C743 E5          		 push	h
0031+  C744 E5          		 push	h
0032+  C745 CD 66 C7    		  call	tapePulseA
0033+  C748 E1          		 pop	h
0034+  C749 E1          		 pop	h
0035+  C74A C1          		pop	b
0036+  C74B E1          		pop	h
0037+  C74C C9          		ret
0038+  C74D             
0039+  C74D             ; ---------------------------------------------------------------------------
0040+  C74D             
0041+  C74D 79          tapePulseBit:	mov	a, c
0042+  C74E 0F          		rrc
0043+  C74F 4F          		mov	c, a
0044+  C750 DA 66 C7    		jc	tapePulseA
0045+  C753 2A 60 C6    tapePulseB:	lhld	v_tapePulseB
0046+  C756 C3 6C C7    		jmp	tapePulse
0047+  C759             
0048+  C759             ; ---------------------------------------------------------------------------
0049+  C759             
0050+  C759 79          tapeWriteEnd:	mov	a, c
0051+  C75A B7          		ora	a
0052+  C75B 4F          		mov	c, a
0053+  C75C E2 53 C7    		jpo	tapePulseB
0054+  C75F 2A 62 C6    		lhld	v_tapePulseA
0055+  C762 2D          		dcr	l
0056+  C763 CD 6C C7    		call	tapePulse
0057+  C766 2A 62 C6    tapePulseA:	lhld	v_tapePulseA
0058+  C769 C3 6C C7    		jmp	tapePulse0167   C76C             .include "tapePulse.inc"
0001+  C76C             ;----------------------------------------------------------------------------
0002+  C76C             ; RAMFOS
0003+  C76C             ; Запись бита на магнитофон
0004+  C76C             ;
0005+  C76C             ; 2013-11-01 Дизассемблировано vinxru
0006+  C76C             ;----------------------------------------------------------------------------
0007+  C76C             
0008+  C76C             tapePulse:	; Задержка на L
0009+  C76C 2D          		dcr	l		
0010+  C76D F2 6C C7    		jp	tapePulse
0011+  C770             
0012+  C770             		; Высокий уровень
0013+  C770 3E 0F       		mvi	a, 0Fh		
0014+  C772 32 E3 FF    		sta	IO_KEYB_MODE	
0015+  C775             
0016+  C775             		; Задержка на H	
0017+  C775 25          tapePulse_0:	dcr	h		
0018+  C776 F2 75 C7    		jp	tapePulse_0
0019+  C779             
0020+  C779             		; Низкий уровень
0021+  C779 3E 0E       		mvi	a, 0Eh		
0022+  C77B 32 E3 FF    		sta	IO_KEYB_MODE
0023+  C77E C9          		ret0168   C77F             .include "strToHex.inc"
0001+  C77F             ;+---------------------------------------------------------------------------
0002+  C77F             ; RAMFOS
0003+  C77F             ; Преобразвоние строки в 16-ричное число
0004+  C77F             ;
0005+  C77F             ; На входе
0006+  C77F             ;  de - Строка
0007+  C77F             ;
0008+  C77F             ; На выходе
0009+  C77F             ;  bc       - Сохраняется
0010+  C77F             ;  de       - Следующий символ за запятой или концом строки
0011+  C77F             ;  jz       - Ошибка
0012+  C77F             ;  jnz, jc  - Конец строки
0013+  C77F             ;  jnz, jnc - Пробел или запятая
0014+  C77F             ;  hl       - Число
0015+  C77F             ;
0016+  C77F             ; 2013-11-01 Дизассемблировано vinxru
0017+  C77F             ;----------------------------------------------------------------------------
0018+  C77F             
0019+  C77F             strToHex:
0020+  C77F             #if SIZE_OPTIMIZATION==0
0021+  C77F C5          		push	b
0022+  C780 CD 85 C7    		 call	strToHex2
0023+  C783 C1          		pop	b
0024+  C784 C9          		ret
0025+  C785             #endif
0026+  C785             
0027+  C785             ; ---------------------------------------------------------------------------
0028+  C785             
0029+  C785 21 00 00    strToHex2:	lxi	h, 0		
0030+  C788             #if SIZE_OPTIMIZATION==0
0031+  C788 06 00       		mvi	b, 0		
0032+  C78A             #endif
0033+  C78A             
0034+  C78A             strToHex2_loop:	; Чтение символа
0035+  C78A 1A          		ldax	d
0036+  C78B 13          		inx	d
0037+  C78C             
0038+  C78C             		; Если конец строки, выходим с флагами NZ, C
0039+  C78C FE 0D       		cpi	0Dh
0040+  C78E CA B0 C8    		jz	ora_a_stc_ret
0041+  C791             
0042+  C791             		; Если пробел или запятая, выходим с флагами NZ, NC
0043+  C791 FE 2C       		cpi	','
0044+  C793 CA 8B CE    		jz	ora_a_ret		
0045+  C796 FE 20       		cpi	' '
0046+  C798 CA 8B CE    		jz	ora_a_ret
0047+  C79B             
0048+  C79B             		; Если некорректный символ, выходим с флагами С,Z
0049+  C79B D6 30       		sui	'0'
0050+  C79D FA AA C8    		jm	xra_a_stc_ret		
0051+  C7A0             
0052+  C7A0             		; Если это цифра
0053+  C7A0 FE 0A       		cpi	10
0054+  C7A2 FA B1 C7    		jm	strToHex2_0
0055+  C7A5             
0056+  C7A5             		; Если некорректный символ, выходим с флагами С,Z
0057+  C7A5 FE 11       		cpi	11h
0058+  C7A7 FA AA C8    		jm	xra_a_stc_ret
0059+  C7AA FE 17       		cpi	17h
0060+  C7AC F2 AA C8    		jp	xra_a_stc_ret
0061+  C7AF             
0062+  C7AF             		; Это буквы A..F
0063+  C7AF D6 07       		sui	'A'-'0'-10
0064+  C7B1             
0065+  C7B1             strToHex2_0:	
0066+  C7B1             #if SIZE_OPTIMIZATION==0
0067+  C7B1 4F          		mov	c, a
0068+  C7B2             #endif
0069+  C7B2             		; hl *=	16
0070+  C7B2 29          		dad	h
0071+  C7B3 29          		dad	h
0072+  C7B4 29          		dad	h
0073+  C7B5 29          		dad	h
0074+  C7B6             
0075+  C7B6             		; Если переполнение, то	выйти c флагами С,Z
0076+  C7B6 DA AA C8    		jc	xra_a_stc_ret
0077+  C7B9             		
0078+  C7B9             		; hl += bc
0079+  C7B9~            #if SIZE_OPTIMIZATION
0080+  C7B9~            		push	b
0081+  C7B9~            		mvi	b, 0
0082+  C7B9~            		mov	c, a
0083+  C7B9             #endif
0084+  C7B9 09          		dad	b
0085+  C7BA~            #if SIZE_OPTIMIZATION
0086+  C7BA~            		pop	b
0087+  C7BA             #endif
0088+  C7BA C3 8A C7    		jmp	strToHex2_loop0169   C7BD             .include "calcCrc.inc"
0001+  C7BD             ;+---------------------------------------------------------------------------
0002+  C7BD             ; RAMFOS
0003+  C7BD             ; Стандартная точка входа C82A
0004+  C7BD             ; Расчет контрольной суммы
0005+  C7BD             ;
0006+  C7BD             ; На входе
0007+  C7BD             ;  hl - начальный адрес
0008+  C7BD             ;  de - конечный адрес
0009+  C7BD             ;
0010+  C7BD             ; На выходе
0011+  C7BD             ;  bc - сумма
0012+  C7BD             ;
0013+  C7BD             ; 2013-11-01 Дизассемблировано vinxru
0014+  C7BD             ;----------------------------------------------------------------------------
0015+  C7BD             
0016+  C7BD 01 00 00    calcCrc:	lxi	b, 0
0017+  C7C0 7E          calcCrc_0:	 mov	a, m
0018+  C7C1 81          		 add	c
0019+  C7C2 4F          		 mov	c, a
0020+  C7C3 F5          		 push	psw
0021+  C7C4 CD 5D C8    		  call	cmp_hl_de
0022+  C7C7 CA 7F CB    		  jz	pop_psw_ret
0023+  C7CA F1          		 pop	psw
0024+  C7CB 78          		 mov	a, b
0025+  C7CC 8E          		 adc	m
0026+  C7CD 47          		 mov	b, a
0027+  C7CE CD 5D C8    		 call	cmp_hl_de
0028+  C7D1 C8          		 rz
0029+  C7D2 23          		 inx	h
0030+  C7D3 C3 C0 C7    		jmp	calcCrc_0
0170   C7D6             .include "pushPopCursor.inc"
0001+  C7D6             ;+---------------------------------------------------------------------------
0002+  C7D6             ; RAMFOS
0003+  C7D6             ; Запоминание курсора строки
0004+  C7D6             ; Вызывается при выводе кода 8Dh 
0005+  C7D6             ;
0006+  C7D6             ; 2013-11-01 Дизассемблировано vinxru
0007+  C7D6             ;----------------------------------------------------------------------------
0008+  C7D6             
0009+  C7D6 2A 3E C6    pushCursorLine:	lhld	v_cursorPos
0010+  C7D9 22 20 D2    		shld	v_pushCursorLn
0011+  C7DC C9          		ret
0012+  C7DD              
0013+  C7DD             ;----------------------------------------------------------------------------
0014+  C7DD             ; RAMFOS
0015+  C7DD             ; Восстановние кода цвета из стека
0016+  C7DD             ; Вызывается при выводе кода 87h
0017+  C7DD             ;
0018+  C7DD             ; 2013-11-01 Дизассемблировано vinxru
0019+  C7DD             ;----------------------------------------------------------------------------
0020+  C7DD             
0021+  C7DD 2A 20 D2    popCursorLine:	lhld	v_pushCursorLn
0022+  C7E0 C3 ED C7    		jmp	setCursorPosPx
0023+  C7E3             		
0024+  C7E3             ;----------------------------------------------------------------------------
0025+  C7E3             ; RAMFOS
0026+  C7E3             ; Запоминание курсора экрана
0027+  C7E3             ; Вызывается при выводе кода 93h
0028+  C7E3             ;
0029+  C7E3             ; 2013-11-01 Дизассемблировано vinxru
0030+  C7E3             ;----------------------------------------------------------------------------
0031+  C7E3             
0032+  C7E3 2A 3E C6    pushCursor:	lhld	v_cursorPos
0033+  C7E6 22 22 D2    		shld	v_pushCursor
0034+  C7E9 C9          		ret
0035+  C7EA             
0036+  C7EA             ;----------------------------------------------------------------------------
0037+  C7EA             ; RAMFOS
0038+  C7EA             ; Восстановление курсора экрана
0039+  C7EA             ; Вызывается при выводе кода 94h 
0040+  C7EA             ;
0041+  C7EA             ; 2013-11-01 Дизассемблировано vinxru
0042+  C7EA             ;----------------------------------------------------------------------------
0043+  C7EA             
0044+  C7EA 2A 22 D2    popCursor:	lhld	v_pushCursor
0045+  C7ED 22 3E C6    setCursorPosPx:	shld	v_cursorPos
0046+  C7F0 C9          		ret
0047+  C7F1             
0171   C7F1             .include "setGetMemTop.inc"
0001+  C7F1             ;+---------------------------------------------------------------------------
0002+  C7F1             ; RAMFOS
0003+  C7F1             ; Стандартная точка входа C830
0004+  C7F1             ; Получение верхней границы ОЗУ
0005+  C7F1             ;
0006+  C7F1             ; 2013-11-01 Дизассемблировано vinxru
0007+  C7F1             ;----------------------------------------------------------------------------
0008+  C7F1             
0009+  C7F1 2A 27 D2    getMemTop:	lhld	v_memTop
0010+  C7F4 C9          		ret
0011+  C7F5             
0012+  C7F5             ;----------------------------------------------------------------------------
0013+  C7F5             ; RAMFOS
0014+  C7F5             ; Стандартная точка входа C833
0015+  C7F5             ; Устанока верхней границы ОЗУ
0016+  C7F5             ;
0017+  C7F5             ; 2013-11-01 Дизассемблировано vinxru
0018+  C7F5             ;----------------------------------------------------------------------------
0019+  C7F5             
0020+  C7F5             
0021+  C7F5 22 27 D2    setMemTop:	shld	v_memTop
0022+  C7F8 C9          		ret
0023+  C7F9             
0172   C7F9             .include "pushColor.inc"
0001+  C7F9             ;+---------------------------------------------------------------------------
0002+  C7F9             ; RAMFOS
0003+  C7F9             ; Запоминание кода цвета по принципу стека (глубина 2 цвета)
0004+  C7F9             ; Вызывается при выводе кода 88h
0005+  C7F9             ;
0006+  C7F9             ; 2013-11-01 Дизассемблировано vinxru
0007+  C7F9             ;----------------------------------------------------------------------------
0008+  C7F9             
0009+  C7F9 2A 35 D2    pushColor:	lhld	v_color
0010+  C7FC 22 36 D2    		shld	v_pushColor
0011+  C7FF C9          		ret0173   C800             
0174   C800~            #if $ > 0C800h
0175   C800~            ЋиЁЎЄ _з бвм_C000_­Ґ_ў«Ґ§« 
0176   C800             #endif
0177   C800             .org 0C800h
0178   C800             
0179   C800             .include "c800.inc"
0001+  C800             ;+---------------------------------------------------------------------------
0002+  C800             ; RAMFOS
0003+  C800             ; Точки входа
0004+  C800             ;
0005+  C800             ; 2013-11-01 Дизассемблировано vinxru
0006+  C800             ;----------------------------------------------------------------------------
0007+  C800             
0008+  C800 C3 E1 C8    j_biosInit:		jmp	biosInit
0009+  C803 C3 78 CE    j_keyWait:		jmp	keyWait
0010+  C806 C3 BE C6    j_tapeRead:		jmp	tapeRead
0011+  C809 C3 81 CB    j_printChar:		jmp     printChar
0012+  C80C C3 28 C7    j_tapeWrite:		jmp	tapeWrite
0013+  C80F C3 DA C8    j_printCharA:		jmp	printCharA
0014+  C812 C3 C4 CE    j_keyCheck:		jmp	keyCheck
0015+  C815 C3 67 CB    j_printHex:		jmp	printHex
0016+  C818 C3 2D C9    j_printString:		jmp	printString
0017+  C81B C3 08 CF    j_keyScan:		jmp	keyScan
0018+  C81E C3 32 CD    j_getCursorPos:		jmp	getCursorPos
0019+  C821 C3 E4 CA    j_getCharFromScr:	jmp	getCharFromScreen
0020+  C824 C3 6C C6    j_tapeReadPilot:	jmp	tapeReadPilot
0021+  C827 C3 0F C7    j_tapeWritePilot:	jmp     tapeWritePilot
0022+  C82A C3 BD C7    j_calcCrc:		jmp     calcCrc
0023+  C82D C3 4C CA    j_setBottomLine:	jmp     setBottomLine
0024+  C830 C3 F1 C7    j_getMemTop:		jmp	getMemTop
0025+  C833 C3 F5 C7    j_setMemTop:		jmp     setMemTop
0026+  C836 C3 7E CA    j_input:		jmp     input
0027+  C839 C3 7F C7    j_strToHex:		jmp	strToHex
0028+  C83C C3 15 CD    j_setCursorPos:		jmp	setCursorPos
0029+  C83F C3 16 D1    			jmp	printer
0030+  C842 C3 7B D0    			jmp	printerHex
0031+  C845 C3 63 C8    j_inputFileName:	jmp     inputFileName
0032+  C848 C3 16 D0    			jmp	beep
0033+  C84B C3 68 D1    			jmp	setColor
0034+  C84E C3 5E CB    			jmp	fullClearScreen
0035+  C851 C3 F2 CF    			jmp	oldBeep
0036+  C854 C3 5D C8    j_cmp_hl_de:		jmp     cmp_hl_de
0037+  C857 C3 6D D0    j_printerEchoMode:	jmp	printerEchoMode
0038+  C85A C3 45 D0    j_tapeMode:		jmp	tapeMode
0180   C85D             .include "cmp_hl_de.inc"
0001+  C85D             ;+---------------------------------------------------------------------------
0002+  C85D             ; RAMFOS
0003+  C85D             ; Сравнить регистры HL и DE
0004+  C85D             ;
0005+  C85D             ; 2013-11-01 Дизассемблировано vinxru
0006+  C85D             ;----------------------------------------------------------------------------
0007+  C85D             
0008+  C85D 7C          cmp_hl_de:	mov	a, h
0009+  C85E BA          		cmp	d
0010+  C85F C0          		rnz
0011+  C860 7D          		mov	a, l
0012+  C861 BB          		cmp	e
0013+  C862 C9          		ret0181   C863             .include "inputFileName.inc"
0001+  C863             ;+---------------------------------------------------------------------------
0002+  C863             ; RAMFOS
0003+  C863             ; Стандартная точка входа C845
0004+  C863             ; Ввовод имени файла с клавиатуры в v_header2_name
0005+  C863             ;
0006+  C863             ; 2013-11-01 vinxru
0007+  C863             ;----------------------------------------------------------------------------
0008+  C863             
0009+  C863 E5          inputFileName:	push	h
0010+  C864 D5          		push	d
0011+  C865 C5          		push	b
0012+  C866             
0013+  C866             		; Промежуточный адрес возврата
0014+  C866 21 89 CB    		lxi	h, popa_ret
0015+  C869 E5          		push	h
0016+  C86A             
0017+  C86A              		; Выводим сообщение на экран и сохраним курсор строки
0018+  C86A 21 C1 D1    		lxi	h, a_inputFileName
0019+  C86D CD 2D C9    		call	printString
0020+  C870             
0021+  C870             		; Удалим из имени файла все левые символы
0022+  C870 CD B8 C8    		call	printFileName2
0023+  C873             
0024+  C873             loc_C873:	; Восстановить курсор строки
0025+  C873 CD DD C7    		call	popCursorLine
0026+  C876             
0027+  C876             		; Ввод имени файла
0028+  C876 21 F5 D1    		lxi	h, v_header2_name
0029+  C879 11 FF 0C    		lxi	d, 0CFFh
0030+  C87C CD 7E CA    		call	input
0031+  C87F             
0032+  C87F             		; Нажат ESC
0033+  C87F C8          		rz
0034+  C880             
0035+  C880             		; Нажата левая клавиша, вывести знак вопроса и вернуться к вводу
0036+  C880 21 73 C8    		lxi	h, loc_C873
0037+  C883 E5          		push	h
0038+  C884 D2 AA C8    		jnc	xra_a_stc_ret
0039+  C887             
0040+  C887             		; Сдвинуть курсор
0041+  C887 2A 20 D2    		lhld	v_pushCursorLn
0042+  C88A 7C          		mov	a, h
0043+  C88B C6 18       		adi	3*8
0044+  C88D 67          		mov	h, a
0045+  C88E 22 3E C6    		shld	v_cursorPos
0046+  C891             
0047+  C891             		; Разделитель между именем и расширением должен быть пробелом
0048+  C891 21 FD D1    		lxi	h, v_header2_ext-1
0049+  C894 06 04       		mvi	b, 4
0050+  C896 7E          		mov	a, m
0051+  C897 FE 20       		cpi	20h
0052+  C899 C2 AA C8    		jnz	xra_a_stc_ret		
0053+  C89C             
0054+  C89C             		; Расширение
0055+  C89C 05          loc_C89C:	 dcr	b
0056+  C89D CD DA C8    		 call	printCharA
0057+  C8A0 CA 8A CE    		 jz	loc_CE8A	; Переход на pop h, ora a, ret
0058+  C8A3 23          		 inx	h
0059+  C8A4 7E          		 mov	a, m
0060+  C8A5 FE 20       		 cpi	20h
0061+  C8A7 C2 9C C8    		jnz	loc_C89C
0062+  C8AA             		
0063+  C8AA             xra_a_stc_ret:	; Вывод знака вопроса
0064+  C8AA 3E 3F       		mvi	a, '?'
0065+  C8AC CD DA C8    		call	printCharA
0066+  C8AF AF          		xra	a
0067+  C8B0             
0068+  C8B0 B7          ora_a_stc_ret:	ora	a
0069+  C8B1 37          		stc
0070+  C8B2 C9          		ret
0182   C8B3             .include "printFileName.inc"
0001+  C8B3             ;+---------------------------------------------------------------------------
0002+  C8B3             ; RAMFOS
0003+  C8B3             ; Вывести имя файла на экран и удалить из него все недопустимые символы
0004+  C8B3             ;
0005+  C8B3             ; 2013-11-01 Дизассемблировано vinxru
0006+  C8B3             ;----------------------------------------------------------------------------
0007+  C8B3             
0008+  C8B3             printFileName:	
0009+  C8B3             		; Разделитель
0010+  C8B3~            #if NICE
0011+  C8B3~            		mvi	c, ' '
0012+  C8B3             #else
0013+  C8B3             		; Разделитель
0014+  C8B3 0E 11       		mvi	c, 11h
0015+  C8B5             #endif
0016+  C8B5 CD 81 CB    		call	printChar
0017+  C8B8             
0018+  C8B8 21 F5 D1    printFileName2:lxi	h, v_header2_name	; Имя
0019+  C8BB 06 0C       		mvi	b, 12			; Длина имени
0020+  C8BD 7E          printFileNam_1:	 mov	a, m
0021+  C8BE             		 ; Символы меньше 0x20 заменяем на пробел
0022+  C8BE FE 20       		 cpi	20h
0023+  C8C0 DA CD C8    		 jc	printFileNam_2
0024+  C8C3             		 ; Символы от 0x20 до 0x7E допускаются
0025+  C8C3 FE 7F       		 cpi	7Fh
0026+  C8C5 DA D0 C8    		 jc	printFileNam_3
0027+  C8C8             		 ; Символы от 0xC0 до 0xFF допускаются
0028+  C8C8 FE C0       		 cpi	0C0h
0029+  C8CA D2 D0 C8    		 jnc	printFileNam_3		 
0030+  C8CD             printFileNam_2:	 ; Заменяем недопустимый символ на пробел
0031+  C8CD 36 20       		 mvi	m, 20h
0032+  C8CF 7E          		 mov	a, m
0033+  C8D0             printFileNam_3:	 ; Выводим символ на экран
0034+  C8D0 CD DA C8    		 call	printCharA
0035+  C8D3             		 ; Следующий символ
0036+  C8D3 23          		 inx	h
0037+  C8D4 05          		 dcr	b
0038+  C8D5 C2 BD C8    		jnz	printFileNam_1		
0039+  C8D8             
0040+  C8D8             		; Разделитель
0041+  C8D8~            #if NICE
0042+  C8D8~            		mvi	c, ' '
0043+  C8D8~            		jmp	printChar
0044+  C8D8             #endif
0045+  C8D8             		; Переход на printChar60183   C8D8             .include "printCharA.inc"
0001+  C8D8             ;+---------------------------------------------------------------------------
0002+  C8D8             ; RAMFOS
0003+  C8D8             ; Вывод символа с кодом 6 на экран
0004+  C8D8             ;
0005+  C8D8             ; 2013-11-01 Дизассемблировано vinxru
0006+  C8D8             ;----------------------------------------------------------------------------
0007+  C8D8             
0008+  C8D8 3E 06       printChar6:	mvi	a, 6
0009+  C8DA             
0010+  C8DA             ;----------------------------------------------------------------------------
0011+  C8DA             ; RAMFOS
0012+  C8DA             ; Стандартная точка входа C80F
0013+  C8DA             ; Вывод символа на экран
0014+  C8DA             ;
0015+  C8DA             ; На входе
0016+  C8DA             ;  A - число
0017+  C8DA             ;
0018+  C8DA             ; 2013-11-01 Дизассемблировано vinxru
0019+  C8DA             ;----------------------------------------------------------------------------
0020+  C8DA             
0021+  C8DA C5          printCharA:	push	b
0022+  C8DB 4F          		 mov	c, a
0023+  C8DC CD 81 CB    		 call	printChar
0024+  C8DF C1          		pop	b
0025+  C8E0 C9          		ret0184   C8E1             .include "biosInit.inc"
0001+  C8E1             ;+---------------------------------------------------------------------------
0002+  C8E1             ; RAMFOS
0003+  C8E1             ; Инициализация BIOS
0004+  C8E1             ; Вызывается только функцией init
0005+  C8E1             ;
0006+  C8E1             ; 2013-11-01 Дизассемблировано и доработано vinxru
0007+  C8E1             ;----------------------------------------------------------------------------
0008+  C8E1             
0009+  C8E1             biosInit:	; Очистка переменных начиная с v_dblClear
0010+  C8E1 21 10 D2    		lxi	h, v_dblClear
0011+  C8E4 06 2F       		mvi	b, 47
0012+  C8E6 AF          		xra	a
0013+  C8E7 32 5C C6    		sta	v_inverse
0014+  C8EA 77          loc_C8EA:	 mov	m, a
0015+  C8EB 23          		 inx	h
0016+  C8EC 05          		 dcr	b
0017+  C8ED C2 EA C8    		jnz	loc_C8EA
0018+  C8F0             
0019+  C8F0             		; Инициализация	контроллера цвета черным цветом для очистки экрана
0020+  C8F0             #if INIT_SCREEN_COLOR==100h
0021+  C8F0 3A 3C C6    		lda	v_selColor
0022+  C8F3~            #else
0023+  C8F3~            		mvi	a, INIT_SCREEN_COLOR
0024+  C8F3             #endif
0025+  C8F3 CD 68 D1    		call	setColor
0026+  C8F6             
0027+  C8F6             		; Инициализация	клавиатуры
0028+  C8F6 CD 12 CF    		call	keyMode82	
0029+  C8F9             
0030+  C8F9             		; Скрываем нижнюю строку
0031+  C8F9 CD 72 CA    		call	bottomLineHide
0032+  C8FC             
0033+  C8FC             		; Очищаем экран
0034+  C8FC CD 0A CE    		call	clearScreen
0035+  C8FF             		
0036+  C8FF             		; Настройка таймера
0037+  C8FF 21 EF FF    		lxi	h, IO_TIMER+3
0038+  C902 36 36       		mvi	m, 36h
0039+  C904 36 76       		mvi	m, 76h
0040+  C906 36 90       		mvi	m, 90h
0041+  C908 2B          		dcx	h
0042+  C909 36 10       		mvi	m, 10h
0043+  C90B 2B          		dcx	h
0044+  C90C 36 20       		mvi	m, 20h
0045+  C90E 36 4E       		mvi	m, 4Eh
0046+  C910 2B          		dcx	h
0047+  C911 36 10       		mvi	m, 10h
0048+  C913 36 15       		mvi	m, 15h
0049+  C915             		
0050+  C915             		; *** Определение размера ДОЗУ ***
0051+  C915             
0052+  C915~            #if WORK_WITHOUT_ARAM
0053+  C915~            		; Надо вернуть доступ к ДОЗУ, иначе проверка не работает
0054+  C915~            		mvi	a, 0FDh		; Порт выбора ДОЗУ		
0055+  C915~            		sta	disableARAM1+1
0056+  C915~            		sta	disableARAM2+1
0057+  C915             #endif
0058+  C915             
0059+  C915~            #if TRUE_CHECK_ARAM
0060+  C915~            		lxi	h, ARAM_PAGE_END
0061+  C915             #else
0062+  C915 2A 1C C6    		lhld	v_aramPageEnd	; Это не совсем правильно, так как при программном сбросе проверка будет работать не так, как при аппаратном
0063+  C918             #endif
0064+  C918 3A 5E C6    		lda	v_aramMaxPageI
0065+  C91B CD 54 C9    		call	checkARAM
0066+  C91E             		
0067+  C91E~            #if WORK_WITHOUT_ARAM
0068+  C91E~            		lxi	d, 0		; Начало ДОЗУ
0069+  C91E             #endif
0070+  C91E             		; Если ДОЗУ найдено
0071+  C91E~            #if TRUE_CHECK_ARAM
0072+  C91E~            		jnz	aramFounded	; Так короче код испрваленной функции
0073+  C91E             #else
0074+  C91E CA 24 C9    		jz	aramFounded		
0075+  C921             #endif
0076+  C921             
0077+  C921             		; ДОЗУ не найдено
0078+  C921~            #if WORK_WITHOUT_ARAM
0079+  C921~            		 ; Настраиваем небольшой диск в основном ОЗУ
0080+  C921~            		 lxi	d, miniPage
0081+  C921~            		 lxi	h, miniPageEnd
0082+  C921~            		 mvi	a, 0FCh		; Порт выбора ОЗУ
0083+  C921~            		 sta	disableARAM1+1
0084+  C921~            		 sta	disableARAM2+1
0085+  C921             #else
0086+  C921             		 ; Пытаемся работать с 48 Кб ДОЗУ
0087+  C921 21 FB BF    		 lxi	h, 0BFFBh
0088+  C924             #endif
0089+  C924             aramFounded:	
0090+  C924 22 1C C6    		shld	v_aramPageEnd
0091+  C927 22 3C D2    		shld	v_aramPageEnd2
0092+  C92A~            #if WORK_WITHOUT_ARAM
0093+  C92A~            		xchg
0094+  C92A~            		shld	v_aramPageStart
0095+  C92A             #endif
0096+  C92A             		; *** Инициализация экрана ***
0097+  C92A 21 D6 D1    		lxi	h, a_initScreen
0098+  C92D             		; Далее printString
0099+  C92D             
0100+  C92D             
0101+  C92D             		; Этот текст будет встроен в конец кода
0102+  C92D~            #if NICE
0103+  C92D~            #define A_INITSCREEN a_initScreen: .db C_INVERSE, C_TOPLINE, ' ', 0F3h, 0D0h, 0C5h, 0C3h, 0C9h, 0C1h, 0CCh, 0C9h, 0D3h, 0D4h, ' ','M','X','2',' ','R','A','M','F','O','S',C_NORMAL,0
0104+  C92D             #else                                                                                                                                                                  
0105+  C92D             #define A_INITSCREEN a_initScreen: .db C_INVERSE, C_TOPLINE, ' ', 0F3h, 0D0h, 0C5h, 0C3h, 0C9h, 0C1h, 0CCh, 0C9h, 0D3h, 0D4h, '_','M','X',92,'R','A','M','F','O','S',92,C_NORMAL,0
0106+  C92D             #endif
0185   C92D             .include "printString.inc"
0001+  C92D             ;+---------------------------------------------------------------------------
0002+  C92D             ; RAMFOS
0003+  C92D             ; Стандартная точка входа C818
0004+  C92D             ; Вывод строки на экран
0005+  C92D             ;
0006+  C92D             ; На входе
0007+  C92D             ;  hl - Строка
0008+  C92D             ;
0009+  C92D             ; 2013-11-01 Дизассемблировано vinxru
0010+  C92D             ;----------------------------------------------------------------------------
0011+  C92D             
0012+  C92D 7E          printString:	mov	a, m
0013+  C92E A7          		ana	a
0014+  C92F C8          		rz
0015+  C930 CD DA C8    		call	printCharA
0016+  C933 23          		inx	h
0017+  C934 C3 2D C9    		jmp	printString
0186   C937             .include "parseDate.inc"
0001+  C937             ;+---------------------------------------------------------------------------
0002+  C937             ; RAMFOS
0003+  C937             ; Преобразовать введенную строку с датой в числа
0004+  C937             ;
0005+  C937             ; На входе:
0006+  C937             ;  de - строка
0007+  C937             ;
0008+  C937             ; 2013-11-01 Доработано vinxru (короче и сохраняет в ОЗУ)
0009+  C937             ;----------------------------------------------------------------------------
0010+  C937             
0011+  C937~            #if DATE_IN_RAM
0012+  C937~            
0013+  C937~            parseDate:	lxi	b, v_header2_date ; 3
0014+  C937~            
0015+  C937~            parseDate_1:	; Преобразование строки в число. Ошибка не контроллируется.
0016+  C937~            		call	strToHex ; 6
0017+  C937~            
0018+  C937~            		; Сохранение
0019+  C937~            		mov	a, l ; 7
0020+  C937~            		stax	b ; 8
0021+  C937~            		inx	b ; 9
0022+  C937~            	
0023+  C937~            		; Если конец строки, выходим
0024+  C937~            		rc ; 10
0025+  C937~            
0026+  C937~            		; Цикл
0027+  C937~            		mvi	a, (v_header2_date + 3) & 0FFh ; 12
0028+  C937~            		cmp	c ; 13
0029+  C937~            		jnz	parseDate_1 ; 16
0030+  C937~            
0031+  C937~            		; Выходим с флагами Z, NC, что приведет к повтормому вводу даты
0032+  C937~            		ret ; 17
0033+  C937~            
0034+  C937             #else ;---------------------------------------------------------------------
0035+  C937             
0036+  C937             parseDate:	; День
0037+  C937 CD 7F C7    		call	strToHex ; 3
0038+  C93A 7D          		mov	a, l ; 4
0039+  C93B 32 92 C9    		sta	parseDate_r1+1 ; 7
0040+  C93E D8          		rc ; 8
0041+  C93F             		; Месяц
0042+  C93F CD 7F C7    		call	strToHex ; 11
0043+  C942 7D          		mov	a, l ; 12
0044+  C943 32 97 C9    		sta	parseDate_r2+1 ; 15
0045+  C946 D8          		rc ; 16
0046+  C947             		; Год
0047+  C947 CD 7F C7    		call	strToHex ; 19
0048+  C94A 7D          		mov	a, l ; 20
0049+  C94B 32 9C C9    		sta	parseDate_r3+1 ; 23
0050+  C94E D8          		rc ; 24
0051+  C94F             		; Слишком много параметров
0052+  C94F C3 AA C8    		jmp	xra_a_stc_ret ; 27
0053+  C952             
0054+  C952             #endif0187   C952~            #if TRUE_CHECK_ARAM
0188   C952~            .include "checkARAM_v2.inc"
0189   C952             #else
0190   C952             .include "checkARAM.inc"
0001+  C952             ;+---------------------------------------------------------------------------
0002+  C952             ; RAMFOS
0003+  C952             ; Определение размера ДОЗУ
0004+  C952             ;
0005+  C952             ; На входе
0006+  C952             ;  а - максимальный номер страницы, константа MAX_ARAM_PAGE
0007+  C952             ;
0008+  C952             ; На выходе
0009+  C952             ;   Z - ДОЗУ найдено
0010+  C952             ;  NZ - ДОЗУ не найдено
0011+  C952             ;
0012+  C952             ; 2013-11-01 Дизассемблировано vinxru
0013+  C952             ;----------------------------------------------------------------------------
0014+  C952             
0015+  C952             checkARAM_0:	; Уменьшаем счетчик страниц ДОЗУ
0016+  C952 3D          		dcr	a		
0017+  C953             
0018+  C953             		; Если это была	нуленвая страница, то выходим
0019+  C953 F8          		rm			
0020+  C954             
0021+  C954             checkARAM:	; Точка входа
0022+  C954             
0023+  C954             		; Сохраняем номер последней страницы RAM-диска
0024+  C954 32 3D C6    		sta	v_aramMaxPage
0025+  C957             
0026+  C957             		; Записываем на	диск номер страницы+1 и тут же читаем
0027+  C957 4F          		mov	c, a		
0028+  C958 0C          		inr	c
0029+  C959 CD 39 F8    		call	j_pageWriteAny
0030+  C95C CD 36 F8    		call	j_pageReadAny
0031+  C95F 0D          		dcr	c
0032+  C960 B9          		cmp	c
0033+  C961             
0034+  C961             		; Если запись не удалась, то значит нет такой страницы
0035+  C961 C2 52 C9    		jnz	checkARAM_0 
0036+  C964             
0037+  C964             		; Если это была	нулевая страница, то выходим
0038+  C964 B7          		ora	a		
0039+  C965 C8          		rz
0040+  C966             
0041+  C966             		; Читаем с диска -1 байт.
0042+  C966             		; Если на диске	-1 записан байт	+1 относительно	проверяемой страницы, то значит страницы нет
0043+  C966 3D          		dcr	a		
0044+  C967 CD 36 F8    		call	j_pageReadAny
0045+  C96A 0D          		dcr	c
0046+  C96B 3C          		inr	a
0047+  C96C B9          		cmp	c		
0048+  C96D CA 52 C9    		jz	checkARAM_0
0049+  C970             
0050+  C970             		; Выход с флагом Z
0051+  C970 BF          		cmp	a		
0052+  C971 C9          		ret0191   C972             #endif
0192   C972             .include "inputDate.inc"
0001+  C972             ;+---------------------------------------------------------------------------
0002+  C972             ; RAMFOS
0003+  C972             ; Ввод текущей даты
0004+  C972             ;
0005+  C972             ; 2013-11-01 Дизассемблировано vinxru
0006+  C972             ;----------------------------------------------------------------------------
0007+  C972             
0008+  C972             inputDate:	; Вывод приглашения "V3.1/дата:" или "дата:"
0009+  C972 21 CA D1    		lxi	h, a_inputDate
0010+  C975 CD 2D C9    		call	printString
0011+  C978             	
0012+  C978             		; Ввод даты
0013+  C978 21 95 D2    		lxi	h, buffer
0014+  C97B 11 FF 09    		lxi	d, 9FFh ; Максимум 9 символов
0015+  C97E CD 7E CA    		call	input
0016+  C981             
0017+  C981             		; Если была ошибка
0018+  C981 D2 72 C9    		jnc	inputDate
0019+  C984 77          		mov	m, a
0020+  C985             
0021+  C985             		; Преобразование введенной строки и числа
0022+  C985 FC 37 C9    		cm	parseDate
0023+  C988             
0024+  C988             		; Если преобразование не удалось вводим повторно
0025+  C988 CA 72 C9    		jz	inputDate
0026+  C98B             
0027+  C98B~            #if DATE_IN_RAM
0028+  C98B~            		; Сохраняем признак того, что дата введена
0029+  C98B~            		mvi	a, 8Bh 
0030+  C98B~            		sta	v_header2_saved
0031+  C98B~            
0032+  C98B~            		ret
0033+  C98B             #else
0034+  C98B             		; Извлекаем из стека адрес на диске
0035+  C98B E1          		pop	h
0036+  C98C             
0037+  C98C             		; Сохраняем 08Bh
0038+  C98C 0E 8B       		mvi	c, 8Bh 
0039+  C98E CD 9D C9    		call	inputDate_1
0040+  C991             		
0041+  C991             		; Сохраняем день на диск
0042+  C991 0E 22       parseDate_r1:	mvi	c, 22h
0043+  C993 CD 9D C9    		call	inputDate_1
0044+  C996             
0045+  C996             		; Сохраняем месяц на диск
0046+  C996 0E 09       parseDate_r2:	mvi	c, 09h
0047+  C998 CD 9D C9    		call	inputDate_1
0048+  C99B             
0049+  C99B             		; Сохраняем год на диск
0050+  C99B 0E 92       parseDate_r3:	mvi	c, 92h
0051+  C99D AF          inputDate_1:	xra	a
0052+  C99E CD 39 F8    		call	j_pageWriteAny
0053+  C9A1 23          		inx	h
0054+  C9A2 3C          		inr	a
0055+  C9A3 C9          		ret
0056+  C9A4             #endif
0057+  C9A4             
0058+  C9A4~            #if NICE
0059+  C9A4~            #define A_INPUTDATE a_inputDate: .db 0Dh, 0C4h, 0C1h, 0D4h, 0C1h, ':', 0 ; "дата:"
0060+  C9A4             #else
0061+  C9A4             #define A_INPUTDATE a_inputDate: .db 0Dh, 'V', '3', '.', '1', '/', 0C4h, 0C1h, 0D4h, 0C1h, ':', 0 ; "V3.1/дата:"
0062+  C9A4             #endif0193   C9A4             .include "topLine.inc"		; Їа®¤®«¦ Ґвбп ў inverse
0001+  C9A4             ;+---------------------------------------------------------------------------
0002+  C9A4             ; RAMFOS
0003+  C9A4             ; Вывод идникаторов в верхнюю строку
0004+  C9A4             ; Эта функция вызывается только из printIndicators и clearTopLine
0005+  C9A4             ;
0006+  C9A4             ; 2013-11-01 Дизассемблировано и доработано vinxru
0007+  C9A4             ;----------------------------------------------------------------------------
0008+  C9A4             
0009+  C9A4~            #if FAST_PRINT
0010+  C9A4~            INDCATORS_SEP = ' '
0011+  C9A4             #else
0012+  C9A4             INDCATORS_SEP = 11h
0013+  C9A4             #endif
0014+  C9A4             
0015+  C9A4             printIndicatorsInt:	
0016+  C9A4             		; Если дата хранится в ОЗУ, проверяется, введена ли дата
0017+  C9A4~            #if DATE_IN_RAM
0018+  C9A4~            		lda	v_header2_saved
0019+  C9A4~            		cpi	8Bh
0020+  C9A4~            		cnz	inputDate
0021+  C9A4             #endif
0022+  C9A4             		; Установка положения курсора (0 стока 45 столбец)
0023+  C9A4 21 08 87    		lxi	h, 8708h	
0024+  C9A7 22 3E C6    		shld	v_cursorPos
0025+  C9AA             
0026+  C9AA             		; Если дата хранится в ДОЗУ, проверяется, введена ли дата
0027+  C9AA             #if DATE_IN_RAM==0
0028+  C9AA             		; Читаем из нулевой страницы байт по адресу v_aramPageEnd+1
0029+  C9AA 2A 1C C6    		lhld	v_aramPageEnd
0030+  C9AD 23          		inx	h
0031+  C9AE AF          		xra	a
0032+  C9AF CD 36 F8    		call	j_pageReadAny
0033+  C9B2             		
0034+  C9B2             		; Если там записан не 8B, то переходим к вводу даты
0035+  C9B2 79          		mov	a, c
0036+  C9B3 FE 8B       		cpi	8Bh
0037+  C9B5 E5          		push	h		
0038+  C9B6 C2 72 C9    		jnz	inputDate
0039+  C9B9             #endif
0040+  C9B9             
0041+  C9B9             		; Разделитель
0042+  C9B9 3E 11       		mvi	a, INDCATORS_SEP
0043+  C9BB CD DA C8    		call	printCharA
0044+  C9BE             
0045+  C9BE             		; Выводим скорость записи на ленту
0046+  C9BE 3A 5F C6    		lda	v_tapeMode
0047+  C9C1 CD DA C8    		call	printCharA
0048+  C9C4             
0049+  C9C4             		; Выводим режим эхопечати
0050+  C9C4 3A 2F C6    		lda	v_printerEcho
0051+  C9C7 CD DA C8    		call	printCharA
0052+  C9CA             
0053+  C9CA             		; Выводим CAPS LOCK
0054+  C9CA 2A 2D C6    		lhld	v_rusLat
0055+  C9CD 25          		dcr	h
0056+  C9CE 3E 0B       		mvi	a, 0Bh
0057+  C9D0 FA D5 C9    		jm	loc_C9D5
0058+  C9D3 3E 0F       		 mvi	a, 0Fh		 
0059+  C9D5 CD DA C8    loc_C9D5:	call	printCharA
0060+  C9D8             
0061+  C9D8             		; Выводим РУС/LAT
0062+  C9D8 2C          		inr	l
0063+  C9D9 21 B9 D1    		lxi	h, a_lat
0064+  C9DC C2 E2 C9    		jnz	loc_C9E2
0065+  C9DF 21 BD D1    		  lxi	h, a_rus
0066+  C9E2 CD 2D C9    loc_C9E2:	call	printString
0067+  C9E5             
0068+  C9E5             		; Выводим KOI8/7
0069+  C9E5 3A 2C C6    		lda	v_koi8
0070+  C9E8 B7          		ora	a
0071+  C9E9 3E 38       		mvi	a, '8'
0072+  C9EB CA EF C9    		jz	loc_C9EF
0073+  C9EE 3D          		  dcr	a		  
0074+  C9EF CD DA C8    loc_C9EF:	call	printCharA
0075+  C9F2             
0076+  C9F2~            #if FAST_PRINT
0077+  C9F2~            		mvi	a, ' '
0078+  C9F2~            		call	printCharA
0079+  C9F2             #else
0080+  C9F2 CD D8 C8    		call	printChar6
0081+  C9F5             #endif
0082+  C9F5             
0083+  C9F5~            #if DATE_IN_RAM
0084+  C9F5~            		; Разделитель
0085+  C9F5~            		mvi	a, INDCATORS_SEP
0086+  C9F5~            		call	printCharA
0087+  C9F5~            
0088+  C9F5~            		; Вывод на экран даты
0089+  C9F5~            		lda v_header2_date
0090+  C9F5~            		call	printHex
0091+  C9F5~            
0092+  C9F5~            #if NICE
0093+  C9F5~            		mvi	a, '-'
0094+  C9F5~            		call	printCharA
0095+  C9F5~            #endif
0096+  C9F5~            		; Вывод на экран даты
0097+  C9F5~            		lda	v_header2_date+1
0098+  C9F5~            		call	printHex
0099+  C9F5~            #if NICE
0100+  C9F5~            		mvi	a, '-'
0101+  C9F5~            		call	printCharA
0102+  C9F5~            #endif
0103+  C9F5~            		; Вывод на экран даты
0104+  C9F5~            		lda v_header2_date+2
0105+  C9F5~            		call	printHex
0106+  C9F5             #else
0107+  C9F5 E1          		pop	h
0108+  C9F6             
0109+  C9F6             		; Адрес для сохранения даты
0110+  C9F6 11 01 D2    		lxi	d, v_header2_saved
0111+  C9F9             
0112+  C9F9             		; Сохраняем C в v_header2_saved <--- ????
0113+  C9F9 79          		mov	a, c
0114+  C9FA 12          		stax	d
0115+  C9FB             
0116+  C9FB             		; Разделитель
0117+  C9FB 3E 11       		mvi	a, INDCATORS_SEP
0118+  C9FD CD DA C8    		call	printCharA
0119+  CA00             
0120+  CA00             		; Вывод на экран даты
0121+  CA00 06 03       		mvi	b, 3		; 3 байта
0122+  CA02 23          loc_CA02:	 inx	h
0123+  CA03 13          		 inx	d
0124+  CA04             		 ; Читаем байт из нулевой страницы
0125+  CA04 AF          		 xra	a
0126+  CA05 CD 36 F8    		 call	j_pageReadAny
0127+  CA08             		 ; Запись в памяти
0128+  CA08 79          		 mov	a, c
0129+  CA09 12          		 stax	d
0130+  CA0A             		 ; Вывод на экран
0131+  CA0A CD 67 CB    		 call	printHex
0132+  CA0D             		 ; Цикл 3-1
0133+  CA0D 05          		 dcr	b
0134+  CA0E C2 02 CA    		jnz	loc_CA02
0135+  CA11             #endif
0136+  CA11             
0137+  CA11~            #if FAST_PRINT
0138+  CA11~            		ret
0139+  CA11             #else
0140+  CA11 C3 D8 C8    		jmp	printChar6
0141+  CA14             #endif
0142+  CA14             
0143+  CA14             ;----------------------------------------------------------------------------
0144+  CA14             ; RAMFOS
0145+  CA14             ; Лишний код
0146+  CA14             ;
0147+  CA14             ; 2013-11-01 Дизассемблировано vinxru
0148+  CA14             ;----------------------------------------------------------------------------
0149+  CA14             
0150+  CA14             #if NO_PRINT_STATUS_BUG==0
0151+  CA14             printIndicatorsEnd:
0152+  CA14 F1          		pop	psw
0153+  CA15 C4 44 CA    		cnz	changeInverse
0154+  CA18             #endif
0155+  CA18             
0156+  CA18             ;----------------------------------------------------------------------------
0157+  CA18             ; RAMFOS
0158+  CA18             ; Очистка верхней строки и перемещение туда курсора
0159+  CA18             ; Вызывается при печати символа 08Fh
0160+  CA18             ;
0161+  CA18             ; 2013-11-01 Дизассемблировано и доработано vinxru
0162+  CA18             ;----------------------------------------------------------------------------
0163+  CA18             
0164+  CA18             clearTopLine:	
0165+  CA18~            #if COLOR_SUPPORT
0166+  CA18~            		; Цвет по умолчанию
0167+  CA18~            		mvi	a, INIT_SCREEN_COLOR
0168+  CA18~            		call	setColor
0169+  CA18             #endif
0170+  CA18             
0171+  CA18             		; Реальная очистка верхней строки
0172+  CA18 CD 5D CE    		call	clearTopLine2
0173+  CA1B             
0174+  CA1B             		; Устанавливаем курсор в верхнюю строку
0175+  CA1B 21 08 00    		lxi	h, 8
0176+  CA1E 22 3E C6    		shld	v_cursorPos
0177+  CA21             
0178+  CA21             		; ?
0179+  CA21 21 0A 14    		lxi	h, 140Ah
0180+  CA24 22 30 D2    		shld	v_topLineHeight
0181+  CA27             
0182+  CA27             ;----------------------------------------------------------------------------
0183+  CA27             ; RAMFOS
0184+  CA27             ; Вывод идникаторов в верхнюю строку с сохранением курсора, цвета и инверсии
0185+  CA27             ; Эта функция вызывается только из keyScan
0186+  CA27             ;
0187+  CA27             ; 2013-11-01 Дизассемблировано и доработано vinxru
0188+  CA27             ;----------------------------------------------------------------------------
0189+  CA27             
0190+  CA27             printIndicators:
0191+  CA27             		; Не рисовать индикаторы
0192+  CA27 3A 30 D2    		lda	v_topLineHeight
0193+  CA2A B7          		ora	a
0194+  CA2B C8          		rz
0195+  CA2C             
0196+  CA2C             		; Запоминаем положение курсора
0197+  CA2C 2A 3E C6    		lhld	v_cursorPos
0198+  CA2F             
0199+  CA2F             		; Запоминаем инверсию в стеке
0200+  CA2F 3A 5C C6    		lda	v_inverse
0201+  CA32 B7          		ora	a
0202+  CA33 F5          		push	psw
0203+  CA34~            #if FAST_PRINT
0204+  CA34~            		; Если инверсия не была включена, включаем её.
0205+  CA34~            		cz	changeInverse
0206+  CA34             #else
0207+  CA34             		; Если инверсия была включена, выключаем её.
0208+  CA34 C4 44 CA    		cnz	changeInverse
0209+  CA37             #endif	
0210+  CA37             
0211+  CA37             		; Сохранение цвета и установка стандартного цвета
0212+  CA37~            #if COLOR_SUPPORT
0213+  CA37~            		lda	v_color
0214+  CA37~            		push	psw
0215+  CA37~            		mvi	a, 0F0h
0216+  CA37~            		call	setColor
0217+  CA37             #endif
0218+  CA37             
0219+  CA37             		; Вывод статусной строки
0220+  CA37 E5          		push	h
0221+  CA38 CD A4 C9    		 call	printIndicatorsInt
0222+  CA3B E1          		pop	h
0223+  CA3C             
0224+  CA3C             		; Восстановление цвета
0225+  CA3C~            #if COLOR_SUPPORT
0226+  CA3C~            		pop	psw
0227+  CA3C~            		call	setColor
0228+  CA3C             #endif
0229+  CA3C             	
0230+  CA3C             		;  Восстановление положения курсора
0231+  CA3C 22 3E C6    		shld	v_cursorPos
0232+  CA3F             		 
0233+  CA3F             #if NO_PRINT_STATUS_BUG==0
0234+  CA3F C2 14 CA    		jnz	printIndicatorsEnd
0235+  CA42             #endif
0236+  CA42             
0237+  CA42             		;  Восстановление инверсии
0238+  CA42 F1          		pop	psw
0239+  CA43~            #if FAST_PRINT
0240+  CA43~            		rnz
0241+  CA43             #else
0242+  CA43 C8          		rz
0243+  CA44             #endif	
0244+  CA44             		; продолжается в changeInverse0194   CA44             .include "inverse.inc"
0001+  CA44             ;+---------------------------------------------------------------------------
0002+  CA44             ; RAMFOS
0003+  CA44             ; Инверсия инверсии (Инверсия фона чернобелого экрана)
0004+  CA44             ; Вызывается при выводе кода 8Ah и просто так
0005+  CA44             ;
0006+  CA44             ; 2013-11-01 Дизассемблировано vinxru
0007+  CA44             ;----------------------------------------------------------------------------
0008+  CA44             
0009+  CA44 3A 5C C6    changeInverse:	lda	v_inverse
0010+  CA47             
0011+  CA47             ;----------------------------------------------------------------------------
0012+  CA47             ; RAMFOS
0013+  CA47             ; Включение/выключение инверсии
0014+  CA47             ;
0015+  CA47             ; На входе
0016+  CA47             ;  A=0    - Включить. (Вызывается при выводе кода 8Bh)
0017+  CA47             ;  A=0FFh - Выключить.
0018+  CA47             ;
0019+  CA47             ; 2013-11-01 Дизассемблировано vinxru
0020+  CA47             ;----------------------------------------------------------------------------
0021+  CA47             
0022+  CA47 2F          setInverseNeg:	cma
0023+  CA48             
0024+  CA48             ;----------------------------------------------------------------------------
0025+  CA48             ; RAMFOS
0026+  CA48             ; Включение/выключение инверсии
0027+  CA48             ;
0028+  CA48             ; На входе
0029+  CA48             ;  A=0FFh - Включить. (Вызывается при выводе кода 8Ch)
0030+  CA48             ;  A=0    - Выключить.
0031+  CA48             ;
0032+  CA48             ; 2013-11-01 Дизассемблировано vinxru
0033+  CA48             ;----------------------------------------------------------------------------
0034+  CA48             
0035+  CA48 32 5C C6    setInverse:	sta	v_inverse
0036+  CA4B C9          		ret0195   CA4C             .include "bottomLine.inc"
0001+  CA4C             ;+---------------------------------------------------------------------------
0002+  CA4C             ; RAMFOS
0003+  CA4C             ; Стандартная точка входа C82D
0004+  CA4C             ; Установка текста в нижнюю строку. 
0005+  CA4C             ; Необходимо предварительно включить строку с помощью clearBottomLine
0006+  CA4C             ;
0007+  CA4C             ; На входе
0008+  CA4C             ;  hl - текстовая строка. Первый байт строки - индертификатор. Если строка
0009+  CA4C             ;  с таким ид выводилась прошлый раз, то в этот раз она выводится не будет
0010+  CA4C             ;
0011+  CA4C             ; 2013-11-01 Дизассемблировано vinxru
0012+  CA4C             ;----------------------------------------------------------------------------
0013+  CA4C             
0014+  CA4C             setBottomLine:	; Первым байтом строки идет идентификатор. 
0015+  CA4C             		; Если эта строка уже устаналивалась, то выходим
0016+  CA4C 3A 34 D2    		lda	v_bottomLineId
0017+  CA4F BE          		cmp	m
0018+  CA50 C8          		rz
0019+  CA51 7E          		mov	a, m
0020+  CA52 23          		inx	h
0021+  CA53             
0022+  CA53             		; Далее идет текст, выводим его
0023+  CA53 F5          		push	psw
0024+  CA54 CD 2D C9    		 call	printString
0025+  CA57 F1          		pop	psw
0026+  CA58             
0027+  CA58             		; bottomLineId = a
0028+  CA58 C3 6E CA    		jmp	setBottomLineId
0029+  CA5B             
0030+  CA5B             ;----------------------------------------------------------------------------
0031+  CA5B             ; RAMFOS
0032+  CA5B             ; Включение и очистка нижней строки и перемещение туда курсора
0033+  CA5B             ; Вызывается при печати символа 090h
0034+  CA5B             ;
0035+  CA5B             ; 2013-11-01 Дизассемблировано и доработано vinxru
0036+  CA5B             ;----------------------------------------------------------------------------
0037+  CA5B             
0038+  CA5B             clearBottomLine:
0039+  CA5B~            #if COLOR_SUPPORT
0040+  CA5B~            		; Цвет по умолчанию
0041+  CA5B~            		mvi	a, INIT_SCREEN_COLOR
0042+  CA5B~            		call	setColor
0043+  CA5B             #endif	
0044+  CA5B             		; Очистить нижнюю строку (строка d=250, высота e=10)
0045+  CA5B 11 0A FA    		lxi	d, 0FA0Ah
0046+  CA5E CD 60 CE    		call	clearLine
0047+  CA61             
0048+  CA61             		; Положение курсора
0049+  CA61 21 F8 00    		lxi	h, 248
0050+  CA64 22 3E C6    		shld	v_cursorPos
0051+  CA67             
0052+  CA67             		; Размер экрана (230-240)
0053+  CA67 21 F0 E6    		lxi	h, 0E6F0h
0054+  CA6A             
0055+  CA6A 22 32 D2    setScreenHeight:shld	v_screenHeight
0056+  CA6D             
0057+  CA6D AF          		xra	a		
0058+  CA6E 32 34 D2    setBottomLineId:sta	v_bottomLineId
0059+  CA71 C9          		ret
0060+  CA72             
0061+  CA72             ;----------------------------------------------------------------------------
0062+  CA72             ; RAMFOS
0063+  CA72             ; Отключение нижней строки, строка при этом не стирается сама
0064+  CA72             ; Вызывается при выводе 1Fh, 1Fh (функцией clearScreen)
0065+  CA72             ;
0066+  CA72             ; 2013-11-01 Дизассемблировано vinxru
0067+  CA72             ;----------------------------------------------------------------------------
0068+  CA72             
0069+  CA72 21 00 0A    bottomLineHide:	lxi	h, 0A00h
0070+  CA75 22 30 D2    		shld	v_topLineHeight
0071+  CA78             		
0072+  CA78             		; Размер экрана (240-250)
0073+  CA78 21 FA F0    		lxi	h, 0F0FAh
0074+  CA7B C3 6A CA    		jmp	setScreenHeight
0196   CA7E             .include "input.inc"
0001+  CA7E             ;+---------------------------------------------------------------------------
0002+  CA7E             ; RAMFOS
0003+  CA7E             ; Стандартная точка входа C836
0004+  CA7E             ; Ввод командной строки
0005+  CA7E             ;
0006+  CA7E             ; На входе
0007+  CA7E             ;  hl   - адрес буфера
0008+  CA7E             ;  d    - длина буфера
0009+  CA7E             ;  e=XX - режим без очистки знакоместа, можно двигаться вправо
0010+  CA7E             ;  e=00 - с очисткой знакоместа, вправо двигаться нельзя
0011+  CA7E             ;
0012+  CA7E             ; На выходе
0013+  CA7E             ;  a        - Последняя нажатая клавиша
0014+  CA7E             ;  jz       - Нажат ESC
0015+  CA7E             ;  jc       - Нажат Enter
0016+  CA7E             ;  jnz, jnc - Остальные функциональные кнопки
0017+  CA7E             ;  jp       - Строка пустая
0018+  CA7E             ;
0019+  CA7E             ; 2013-11-01 Дизассемблировано vinxru
0020+  CA7E             ;----------------------------------------------------------------------------
0021+  CA7E             
0022+  CA7E             input:		; Сохраняем BC, HL
0023+  CA7E C5          		push	b
0024+  CA7F E5          		push	h
0025+  CA80             
0026+  CA80             		; Зачем, не понял
0027+  CA80 01 00 80    		lxi	b, 8000h
0028+  CA83             
0029+  CA83 0C          input_inrc:	inr	c		; Ниже мы уменьшим C
0030+  CA84 14          input_inrd:	inr	d		; Ниже мы уменьшим D
0031+  CA85 CD 78 CE    input_ignore:	call	keyWait
0032+  CA88 FE 7F       		cpi	7Fh
0033+  CA8A CA 85 CA    		jz	input_ignore
0034+  CA8D FE 08       		cpi	8
0035+  CA8F CA CB CA    		jz	input_del	; При переходе на удаление C и D больше на единицу
0036+  CA92 FE 0D       		cpi	0Dh
0037+  CA94 CA B6 CA    		jz	input_enter	; Выход с флагами nz, c
0038+  CA97 FE 1F       		cpi	1Fh
0039+  CA99 CA B9 CA    		jz	input_esc	; Выход с флагами z, nc
0040+  CA9C             		; Если не места для новых символов
0041+  CA9C 15          		dcr	d
0042+  CA9D CA 84 CA    		jz	input_inrd
0043+  CAA0             		; Вправо
0044+  CAA0 FE 18       		cpi	18h
0045+  CAA2 CA BC CA    		jz	input_right	; На входе С больше на единицу
0046+  CAA5             		; Остальные служебные клавиши - выход
0047+  CAA5 FE 20       		cpi	20h
0048+  CAA7 14          		inr	d		; Устанавливаем флаги nz
0049+  CAA8 DA B8 CA    		jc	input_cmc	; Выход с флагами nz, nc
0050+  CAAB 15          		dcr	d
0051+  CAAC             		; Увеличиваем B
0052+  CAAC 04          		inr	b
0053+  CAAD             input_chr:	; Вывод символа на экран
0054+  CAAD CD DA C8    		call	printCharA
0055+  CAB0             		; Сохранение символа в памяти
0056+  CAB0 77          		mov	m, a
0057+  CAB1 23          		inx	h
0058+  CAB2             		; Уменьшаем счетчик свободных байт
0059+  CAB2 15          		dcr	d
0060+  CAB3             		; Следующий символ
0061+  CAB3 C3 83 CA    		jmp	input_inrc
0062+  CAB6             
0063+  CAB6             ; ---------------------------------------------------------------------------
0064+  CAB6             
0065+  CAB6 B7          input_enter:	ora	a	; Устанавливаем флаг - не нуль
0066+  CAB7 05          		dcr	b       ; Если были введены символы, то флаг минус
0067+  CAB8 3F          input_cmc:	cmc		; Инвертируем CF
0068+  CAB9             input_esc:	; Восстанавливаем DE, BC
0069+  CAB9 D1          		pop	d
0070+  CABA C1          		pop	b
0071+  CABB C9          		ret
0072+  CABC             
0073+  CABC             ; ---------------------------------------------------------------------------
0074+  CABC             
0075+  CABC             input_right:	; Если режим 0, то вправо двигаться нельзя
0076+  CABC 1C          		inr	e
0077+  CABD 1D          		dcr	e
0078+  CABE CA 84 CA    		jz	input_inrd
0079+  CAC1             
0080+  CAC1             		; Если в буфере служебные символы, зменяем их на пробел и выводим
0081+  CAC1 3E 20       		mvi	a, ' ' 
0082+  CAC3 BE          		cmp	m
0083+  CAC4 D2 AD CA    		jnc	input_chr
0084+  CAC7             
0085+  CAC7             		; Если обычные символы, выводм
0086+  CAC7 7E          		mov	a, m
0087+  CAC8 C3 AD CA    		jmp	input_chr
0088+  CACB             
0089+  CACB             ; ---------------------------------------------------------------------------
0090+  CACB             
0091+  CACB             input_del:	; Перед вызовом D была увеличена на единицу, надо уменьшить
0092+  CACB 15          		dcr	d
0093+  CACC             
0094+  CACC             		; Если ни одного байта не введено, выходим и увеличиваем С обратно
0095+  CACC 0D          		dcr	c
0096+  CACD CA 83 CA    		jz	input_inrc
0097+  CAD0             
0098+  CAD0                             ; Если режим 0, то вместо удаленного символа ставим пробел
0099+  CAD0 1D          		dcr	e
0100+  CAD1 1C          		inr	e
0101+  CAD2 CC DA C8    		cz	printCharA	; На входе A=8
0102+  CAD5 3E 20       		mvi	a, ' '
0103+  CAD7 CC DA C8    		cz	printCharA
0104+  CADA             
0105+  CADA             		; Курсор влево
0106+  CADA 3E 08       		mvi	a, 8
0107+  CADC CD DA C8    		call	printCharA
0108+  CADF             
0109+  CADF             		; Уменьшаем указатель
0110+  CADF 2B          		dcx	h
0111+  CAE0             
0112+  CAE0             		; Увеличиваем длину
0113+  CAE0 14          		inr	d
0114+  CAE1 C3 84 CA    		jmp	input_inrd0197   CAE4             .include "getCharFromScreen.inc"
0001+  CAE4             ;----------------------------------------------------------------------------
0002+  CAE4             ; RAMFOS
0003+  CAE4             ; Получить код символа на экране
0004+  CAE4             ;
0005+  CAE4             ; 2013-11-01 vinxru
0006+  CAE4             ;----------------------------------------------------------------------------                   
0007+  CAE4             
0008+  CAE4             getCharFromScreen:
0009+  CAE4 E5          		push	h
0010+  CAE5 D5          		push	d
0011+  CAE6 C5          		push	b
0012+  CAE7             
0013+  CAE7             		; Адрес возврата
0014+  CAE7 21 89 CB    		lxi	h, popa_ret
0015+  CAEA E5          		push	h
0016+  CAEB             
0017+  CAEB             		; Положение курсора в пикселях
0018+  CAEB 2A 3E C6    		lhld	v_cursorPos	
0019+  CAEE             
0020+  CAEE             		; Расчет адреса
0021+  CAEE EB          		xchg
0022+  CAEF CD 76 CC    		call	calcCharAddr
0023+  CAF2 EB          		xchg
0024+  CAF3             		
0025+  CAF3             		; с - смещение в битах
0026+  CAF3             		; hl - адрес с видеопамяти
0027+  CAF3             
0028+  CAF3 06 08       		mvi	b, 8 ; Высота символа
0029+  CAF5 11 1A D2    		lxi	d, unk_D21A ; Сюда будет скопирован символ с экрана
0030+  CAF8 D5          		push	d		
0031+  CAF9 E5          loc_CAF9:	 push	h
0032+  CAFA             		  ; Загрузить в HL из памяти по адресу HL
0033+  CAFA 7E          		  mov	a, m		
0034+  CAFB 24          		  inr	h
0035+  CAFC 6E          		  mov	l, m
0036+  CAFD 67          		  mov	h, a
0037+  CAFE             		  ; Сдвигаем HL на c*2 бит
0038+  CAFE 79          		  mov	a, c
0039+  CAFF F5          loc_CAFF:	   push	psw
0040+  CB00 CD 55 CB    		    call	hl_div_2
0041+  CB03 CD 55 CB    		    call	hl_div_2
0042+  CB06 F1          		   pop 	psw
0043+  CB07 3D          		   dcr	a
0044+  CB08 C2 FF CA    		  jnz	loc_CAFF
0045+  CB0B             		  ; Сохраняем только нижние 6 бит по адресу de
0046+  CB0B 7D          		  mov	a, l
0047+  CB0C E6 3F       		  ani	3Fh
0048+  CB0E 12          		  stax	d
0049+  CB0F 1B          		  dcx	d
0050+  CB10 E1          		 pop	h
0051+  CB11 2D          		 dcr	l
0052+  CB12 05          		 dcr	b
0053+  CB13 C2 F9 CA    		jnz	loc_CAF9
0054+  CB16             
0055+  CB16             		; Если v_inverse не ноль
0056+  CB16 3A 5C C6    		lda	v_inverse
0057+  CB19 B7          		ora	a
0058+  CB1A CA 29 CB    		jz	loc_CB29
0059+  CB1D             		 ; Инвертируем байт по адресу de
0060+  CB1D 06 08       		 mvi	b, 8
0061+  CB1F             loc_CB1F:	  ; de++
0062+  CB1F 13          		  inx	d
0063+  CB20             		  ; *de = (*de ^ 0xFF) & 0x3F;
0064+  CB20 1A          		  ldax	d
0065+  CB21 2F          		  cma
0066+  CB22 E6 3F       		  ani	3Fh
0067+  CB24 12          		  stax	d
0068+  CB25             		  ; Цикл
0069+  CB25 05          		  dcr	b
0070+  CB26 C2 1F CB    		 jnz	loc_CB1F
0071+  CB29 D1          loc_CB29:	pop	d
0072+  CB2A             
0073+  CB2A             		; de - адрес на экране
0074+  CB2A             
0075+  CB2A             		; Сравниваем каждый символ из знакогенератора с экраном
0076+  CB2A             
0077+  CB2A 3E FF       		mvi	a, -1
0078+  CB2C 2A 0C C6    		lhld	v_charGenPtr	; Знакогенератор
0079+  CB2F 01 08 00    		lxi	b, 8		; высота символа
0080+  CB32             loc_CB32:	 ; Следующий символ
0081+  CB32 09          		 dad	b		
0082+  CB33 C5          		 push	b
0083+  CB34 D5          		 push	d
0084+  CB35 E5          		 push	h
0085+  CB36 47          		  mov	b, a
0086+  CB37 CD 47 CB    		  call	compareChar
0087+  CB3A 78          		  mov	a, b
0088+  CB3B E1          		 pop	h
0089+  CB3C D1          		 pop	d
0090+  CB3D C1          		 pop	b
0091+  CB3E C2 32 CB    		jnz	loc_CB32
0092+  CB41             
0093+  CB41             		; Знакогенератор не содержит символов 80-BF
0094+  CB41 FE 80       		cpi	80h
0095+  CB43 D8          		rc
0096+  CB44 C6 40       		adi	40h		
0097+  CB46 C9          		ret
0098+  CB47             
0099+  CB47             ; ---------------------------------------------------------------------------
0100+  CB47             
0101+  CB47             compareChar:	; if(a == 0xBF) return true;
0102+  CB47 FE BF       		cpi	0BFh
0103+  CB49 C8          		rz
0104+  CB4A             		; Увеличивае номер символа
0105+  CB4A 04          		inr	b
0106+  CB4B             		; Далее memcmp_hl1_de_c
0198   CB4B             .include "memcmp_hl1_de_c.inc"
0001+  CB4B             ;+---------------------------------------------------------------------------
0002+  CB4B             ; RAMFOS
0003+  CB4B             ; Сравнить ОЗУ в обратном направлении
0004+  CB4B             ;
0005+  CB4B             ; На входе
0006+  CB4B             ;  hl - адрес 1 (сравнение начинается с hl-1)
0007+  CB4B             ;  de - адрес 2 (сравнение начинается с de)
0008+  CB4B             ;  с  - размер
0009+  CB4B             ; 
0010+  CB4B             ; На выходе
0011+  CB4B             ;  z  - если блоки равны
0012+  CB4B             ; 
0013+  CB4B             ; 2013-11-01 Дизассемблировано vinxru
0014+  CB4B             ;----------------------------------------------------------------------------
0015+  CB4B             
0016+  CB4B             memcmp_hl1_de_c: ; if(*de-- != *--hl) return;
0017+  CB4B 1A          		 ldax	d
0018+  CB4C 1B          		 dcx	d
0019+  CB4D 2B          		 dcx	h
0020+  CB4E BE          		 cmp	m
0021+  CB4F C0          		 rnz
0022+  CB50             		 ; c--
0023+  CB50 0D          		 dcr	c
0024+  CB51 C8          		 rz
0025+  CB52 C3 4B CB    		jmp	memcmp_hl1_de_c
0199   CB55             .include "hl_div_2.inc"
0001+  CB55             ;+---------------------------------------------------------------------------
0002+  CB55             ; RAMFOS
0003+  CB55             ; Деление HL на два
0004+  CB55             ;
0005+  CB55             ; 2013-11-01 vinxru
0006+  CB55             ;----------------------------------------------------------------------------                   
0007+  CB55             
0008+  CB55             hl_div_2:	; Обнуляем флаг C
0009+  CB55 AF          		xra	a
0010+  CB56 0F          		rrc
0011+  CB57                             ; Сдвигаем H		
0012+  CB57 7C          		mov	a, h
0013+  CB58 1F          		rar
0014+  CB59 67          		mov	h, a
0015+  CB5A                             ; Сдвигаем L
0016+  CB5A 7D          		mov	a, l
0017+  CB5B 1F          		rar
0018+  CB5C 6F          		mov	l, a
0019+  CB5D C9          		ret0200   CB5E             .include "fullClearScreen.inc"
0001+  CB5E             ;+---------------------------------------------------------------------------
0002+  CB5E             ; RAMFOS
0003+  CB5E             ; Стандартная точка входа C84E
0004+  CB5E             ; Очистка всего экрана с отключением служебных строк
0005+  CB5E             ;
0006+  CB5E             ; Сохраняет все регистры
0007+  CB5E             ;
0008+  CB5E             ; 2013-11-01 Дизассемблировано vinxru
0009+  CB5E             ;----------------------------------------------------------------------------                   
0010+  CB5E             
0011+  CB5E             fullClearScreen:
0012+  CB5E F5          		push	psw
0013+  CB5F             
0014+  CB5F             		; Эта переменная включает очистку всего экрана
0015+  CB5F 3E 1F       		mvi	a, 1Fh
0016+  CB61 32 10 D2    		sta	v_dblClear
0017+  CB64             
0018+  CB64             		; Печать символа 1Fh и освобождение стека
0019+  CB64             		; call	printCharA
0020+  CB64             		; pop	psw
0021+  CB64             		; ret		
0022+  CB64 C3 7C CB    		jmp	printCharA_popret0201   CB67             .include "printHex.inc"
0001+  CB67             ;+---------------------------------------------------------------------------
0002+  CB67             ; RAMFOS
0003+  CB67             ; Стандартная точка входа C815
0004+  CB67             ; Вывод 16-ричного числа на экране
0005+  CB67             ;
0006+  CB67             ; На входе
0007+  CB67             ;  A - число
0008+  CB67             ;
0009+  CB67             ; 2013-11-01 Дизассемблировано vinxru
0010+  CB67             ;----------------------------------------------------------------------------
0011+  CB67             
0012+  CB67 F5          printHex:	push	psw
0013+  CB68 0F          		rrc
0014+  CB69 0F          		rrc
0015+  CB6A 0F          		rrc
0016+  CB6B 0F          		rrc
0017+  CB6C CD 70 CB    		call	printHex_1
0018+  CB6F F1          		pop	psw
0019+  CB70 F5          printHex_1:	push	psw
0020+  CB71 E6 0F       		ani	0Fh
0021+  CB73 FE 0A       		cpi	10
0022+  CB75 FA 7A CB    		jm	printHex_2
0023+  CB78 C6 07       		 adi	7
0024+  CB7A C6 30       printHex_2:	adi	'0'
0025+  CB7C             printCharA_popret:
0026+  CB7C CD DA C8    		call	printCharA
0027+  CB7F F1          pop_psw_ret:	pop	psw
0028+  CB80 C9          		ret
0202   CB81~            #if FAST_PRINT
0203   CB81~            .include "printChar_fast.inc"
0204   CB81             #else
0205   CB81             .include "printChar.inc"
0001+  CB81             ;----------------------------------------------------------------------------
0002+  CB81             ; RAMFOS
0003+  CB81             ; Вывод символа на экран
0004+  CB81             ;
0005+  CB81             ; На входе:
0006+  CB81             ;  с - символ
0007+  CB81             ;
0008+  CB81             ; 2013-11-01 Дизассемблировано vinxru
0009+  CB81             ;----------------------------------------------------------------------------
0010+  CB81             
0011+  CB81 E5          printChar:	push	h
0012+  CB82 D5          		push	d
0013+  CB83 C5          		push	b
0014+  CB84 F5          		push	psw
0015+  CB85 CD 8D CB    		 call	printChar_int
0016+  CB88 F1          		pop	psw
0017+  CB89 C1          popa_ret:	pop	b
0018+  CB8A D1          		pop	d
0019+  CB8B E1          		pop	h
0020+  CB8C C9          		ret
0021+  CB8D             
0022+  CB8D             ; ---------------------------------------------------------------------------
0023+  CB8D             
0024+  CB8D             printChar_int:	; Обработка ESC-последовательности
0025+  CB8D 3A 24 D2    		lda	v_escMode
0026+  CB90 B7          		ora	a
0027+  CB91 C2 01 CD    		jnz	printChar_esc
0028+  CB94             
0029+  CB94             		; de - положение курсора в пикселях
0030+  CB94 2A 3E C6    		lhld	v_cursorPos
0031+  CB97 EB          		xchg
0032+  CB98             
0033+  CB98             		; Эхопечать и обрабатываем нажатые клавиши во время вывода
0034+  CB98 C5          		push	b
0035+  CB99 CD B5 CE    		call	keyScanWhilePrint
0036+  CB9C C1          		pop	b
0037+  CB9D             
0038+  CB9D             		; Символ
0039+  CB9D 79          		mov	a, c
0040+  CB9E             
0041+  CB9E             		; hl - положение курсора в пикселях
0042+  CB9E EB          		xchg
0043+  CB9F             
0044+  CB9F             		; Спец символы
0045+  CB9F FE 1F       		cpi	1Fh
0046+  CBA1 CA 0A CE    		jz	clearScreen
0047+  CBA4 FE 18       		cpi	18h
0048+  CBA6 CA 89 CD    		jz	cursorRight
0049+  CBA9 FE 08       		cpi	8
0050+  CBAB CA A5 CD    		jz	cursorLeft
0051+  CBAE FE 19       		cpi	19h
0052+  CBB0 CA B1 CD    		jz	cursorUp
0053+  CBB3 FE 1A       		cpi	1Ah
0054+  CBB5 CA 97 CD    		jz	cursorDown
0055+  CBB8 FE 0C       		cpi	0Ch
0056+  CBBA CA 4B CE    		jz	loc_CE4B
0057+  CBBD FE 0A       		cpi	0Ah
0058+  CBBF CA 95 CD    		jz	cursorCrLf
0059+  CBC2 FE 1B       		cpi	1Bh
0060+  CBC4 CA FC CC    		jz	setEscMode1
0061+  CBC7 FE 07       		cpi	7
0062+  CBC9 CA D7 CF    		jz	keySound
0063+  CBCC FE 0D       		cpi	0Dh
0064+  CBCE CA 77 CD    		jz	saveCursorPosX0
0065+  CBD1             
0066+  CBD1             		; Символы меньше 0x80 
0067+  CBD1 FE 80       		cpi	80h
0068+  CBD3 DA E2 CB    		jc	printChar_high
0069+  CBD6             
0070+  CBD6             		; Промежуток C0-FF преобразовать в 80-BF
0071+  CBD6 D6 40       		sui	40h
0072+  CBD8 FA F1 CB    		jm	printChar_1
0073+  CBDB D6 3F       		sui	3Fh
0074+  CBDD             
0075+  CBDD             		; Теперь в A=1-40
0076+  CBDD             
0077+  CBDD             		; if(a >= 8) goto loc_CC87;
0078+  CBDD FE 08       		cpi	8
0079+  CBDF D2 87 CC    		jnc	printChar2
0080+  CBE2             		
0081+  CBE2             printChar_high:	; Если символы меньше 0x60
0082+  CBE2 FE 60       		cpi	60h
0083+  CBE4 DA F1 CB    		jc	printChar_1
0084+  CBE7             
0085+  CBE7             		; Преобразуем KOI-7 в KOI-8
0086+  CBE7 3A 2C C6    		lda	v_koi8
0087+  CBEA B7          		ora	a
0088+  CBEB 79          		mov	a, c
0089+  CBEC CA F1 CB    		jz	printChar_1
0090+  CBEF C6 40       		 adi	40h
0091+  CBF1 4F          printChar_1:	mov	c, a
0092+  CBF2             
0093+  CBF2 7C          printChar_0:	mov	a, h
0094+  CBF3 FE BE       		cpi	0BEh ; '-'
0095+  CBF5             
0096+  CBF5 C5          		push	b
0097+  CBF6 D4 95 CD    		cnc	cursorCrLf
0098+  CBF9 C1          		pop	b
0099+  CBFA             
0100+  CBFA 7C          		mov	a, h
0101+  CBFB C6 03       		adi	3
0102+  CBFD 32 3F C6    		sta	v_cursorPos+1	; Положение курсора в пикселях
0103+  CC00 EB          		xchg
0104+  CC01             
0105+  CC01 CD 65 CC    		call	calcCharAddr2	; Возможно адрес символа
0106+  CC04             
0107+  CC04 E5          		push	h
0108+  CC05             		 ; Исходный символ
0109+  CC05 21 3F 00    		 lxi	h, 3Fh		 
0110+  CC08             		 ; hl <<= c*2
0111+  CC08 79          		 mov	a, c		
0112+  CC09 29          loc_CC09:	  dad	h
0113+  CC0A 29          		  dad	h
0114+  CC0B 3D          		  dcr	a
0115+  CC0C C2 09 CC    		 jnz	loc_CC09		 
0116+  CC0F             		 ; Вывод на экран
0117+  CC0F C5          		 push	b
0118+  CC10 06 08       		  mvi	b, 8
0119+  CC12 CD 3C CC    		  call	clearChar
0120+  CC15 C1          		 pop	b		 
0121+  CC16 E1          		pop	h
0122+  CC17             
0123+  CC17             		; if(a == 0x7F) return;
0124+  CC17 78          		mov	a, b
0125+  CC18 FE 7F       		cpi	7Fh
0126+  CC1A C8          		rz
0127+  CC1B             
0128+  CC1B             		; if(a == 0x20) return;
0129+  CC1B FE 20       		cpi	20h
0130+  CC1D C8          		rz
0131+  CC1E             
0132+  CC1E             		; e++;
0133+  CC1E 1C          		inr	e
0134+  CC1F             
0135+  CC1F             		; Продолжение на drawChar
0136+  CC1F             ; Вывод	символа
0137+  CC1F             ; hl - символ
0138+  CC1F             ; de - адрес в видеопамяти
0139+  CC1F             ; с  - смещение в двойных пикселях
0140+  CC1F             
0141+  CC1F             drawChar:	; Высота символа
0142+  CC1F 06 08       		mvi	b, 8
0143+  CC21 E5          drawChar_0:	push	h
0144+  CC22             
0145+  CC22             		; Очередной байт из HL в HL
0146+  CC22 6E          		mov	l, m
0147+  CC23 26 00       		mvi	h, 0
0148+  CC25             
0149+  CC25             		; Сдвигаем HL на C*2 бит
0150+  CC25 79          		mov	a, c
0151+  CC26 29          drawChar_1:	dad	h
0152+  CC27 29          		dad	h
0153+  CC28 3D          		dcr	a
0154+  CC29 C2 26 CC    		jnz	drawChar_1
0155+  CC2C             
0156+  CC2C             		; Накладываем символ (*de++ ^= hl)
0157+  CC2C 1A          		ldax	d
0158+  CC2D AC          		xra	h
0159+  CC2E 12          		stax	d
0160+  CC2F 14          		inr	d
0161+  CC30 1A          		ldax	d
0162+  CC31 AD          		xra	l
0163+  CC32 12          		stax	d
0164+  CC33 15          		dcr	d		
0165+  CC34 1C          		inr	e
0166+  CC35             
0167+  CC35                             ; hl++
0168+  CC35 E1          		pop	h
0169+  CC36 23          		inx	h
0170+  CC37             
0171+  CC37             		; Конец цикла
0172+  CC37 05          		dcr	b
0173+  CC38 C2 21 CC    		jnz	drawChar_0
0174+  CC3B             
0175+  CC3B C9          		ret
0176+  CC3C             
0177+  CC3C             ; ---------------------------------------------------------------------------
0178+  CC3C             ; Очистка знакоместа.
0179+  CC3C             ;
0180+  CC3C             ; На входе
0181+  CC3C             ;  de - адрес в видеопамяти
0182+  CC3C             ;  hl - символ 
0183+  CC3C             ;  b - высота
0184+  CC3C             ; ---------------------------------------------------------------------------
0185+  CC3C             
0186+  CC3C             clearChar:	; Если включено инвертирование, то заполняем знакоместо белым
0187+  CC3C 3A 5C C6    		lda	v_inverse
0188+  CC3F B7          		ora	a
0189+  CC40 C2 57 CC    		jnz	clearChar_1
0190+  CC43             
0191+  CC43             		; Инвертируем HL
0192+  CC43 7C          		mov	a, h
0193+  CC44 2F          		cma
0194+  CC45 67          		mov	h, a
0195+  CC46 7D          		mov	a, l
0196+  CC47 2F          		cma
0197+  CC48 6F          		mov	l, a		
0198+  CC49             
0199+  CC49             		; Цикл b
0200+  CC49             clearChar_0:	 ; *de++ &= hl
0201+  CC49 1A          		 ldax	d
0202+  CC4A A4          		 ana	h
0203+  CC4B 12          		 stax	d		 
0204+  CC4C 14          		 inr	d		 
0205+  CC4D 1A          		 ldax	d
0206+  CC4E A5          		 ana	l
0207+  CC4F 12          		 stax	d
0208+  CC50 15          		 dcr	d
0209+  CC51 1D          		 dcr	e		
0210+  CC52             		 ; Цикл
0211+  CC52 05          		 dcr	b
0212+  CC53 C2 49 CC    		jnz	clearChar_0
0213+  CC56 C9          		ret
0214+  CC57             
0215+  CC57             ; ---------------------------------------------------------------------------
0216+  CC57             
0217+  CC57             clearChar_1:	 ; *de++ |= hl
0218+  CC57 1A          		 ldax	d
0219+  CC58 B4          		 ora	h
0220+  CC59 12          		 stax	d
0221+  CC5A 14          		 inr	d
0222+  CC5B 1A          		 ldax	d
0223+  CC5C B5          		 ora	l
0224+  CC5D 12          		 stax	d
0225+  CC5E 15          		 dcr	d
0226+  CC5F 1D          		 dcr	e		
0227+  CC60             		 ; Цикл
0228+  CC60 05          		 dcr	b
0229+  CC61 C2 57 CC    		jnz	clearChar_1
0230+  CC64 C9          		ret0206   CC65             #endif
0207   CC65             .include "calcCharAddr.inc"
0001+  CC65             ;----------------------------------------------------------------------------
0002+  CC65             ; RAMFOS
0003+  CC65             ; Расчет ареса символа в видеопамяти памяти и знакогенераторе
0004+  CC65             ;
0005+  CC65             ; 2013-11-01 Дизассемблировано vinxru
0006+  CC65             ;----------------------------------------------------------------------------
0007+  CC65             
0008+  CC65             calcCharAddr2:	; Какая то хрень
0009+  CC65 41          		mov	b, c
0010+  CC66 32 10 D2    calcCharAddr3:	sta	v_dblClear
0011+  CC69             
0012+  CC69             		; hl = charGen + c * 8
0013+  CC69 D5          		push	d
0014+  CC6A 2A 0C C6    		 lhld	v_charGenPtr
0015+  CC6D EB          		 xchg
0016+  CC6E 69          		 mov	l, c
0017+  CC6F 26 00       		 mvi	h, 0
0018+  CC71 29          		 dad	h
0019+  CC72 29          		 dad	h
0020+  CC73 29          		 dad	h
0021+  CC74 19          		 dad	d
0022+  CC75 D1          		pop	d
0023+  CC76             
0024+  CC76             ; Получить адрес и смещение символа на экране по координатам
0025+  CC76             ; Вход: de - координаты
0026+  CC76             ; Выход: de - адрес, c - смещение
0027+  CC76             		
0028+  CC76             calcCharAddr:	; c = (d & 3)
0029+  CC76 7A          		mov	a, d		
0030+  CC77 E6 03       		ani	3
0031+  CC79 4F          		mov	c, a
0032+  CC7A 3E 05       		mvi	a, 5
0033+  CC7C 91          		sub	c
0034+  CC7D 4F          		mov	c, a
0035+  CC7E             	
0036+  CC7E             		; d = d / 4 + 0x90		
0037+  CC7E 7A          		mov	a, d		
0038+  CC7F E6 FC       		ani	0FCh
0039+  CC81 0F          		rrc
0040+  CC82 0F          		rrc
0041+  CC83 C6 90       		adi	90h
0042+  CC85 57          		mov	d, a
0043+  CC86 C9          		ret
0208   CC87             .include "printChar2.inc"
0001+  CC87             ;+---------------------------------------------------------------------------
0002+  CC87             ; RAMFOS
0003+  CC87             ; Обработка специальных кодов символов
0004+  CC87             ;
0005+  CC87             ; 2013-11-01 Дизассемблировано vinxru
0006+  CC87             ;----------------------------------------------------------------------------
0007+  CC87             
0008+  CC87 D6 21       printChar2:	sui	21h
0009+  CC89 D2 44 D1    		jnc	setColorChar
0010+  CC8C C6 19       		adi	19h
0011+  CC8E CA 6F D1    		jz	popColor	; 87h Восстановние кода цвета из стека
0012+  CC91 3D          		dcr	a
0013+  CC92 CA F9 C7    		jz	pushColor	; 88h Запоминание кода цвета по принципу стека (глубина 2 цвета)
0014+  CC95 3D          		dcr	a
0015+  CC96 CA 64 D1    		jz	inverseColor	; 89h Инверсия кода цвета
0016+  CC99 3D          		dcr	a
0017+  CC9A CA 44 CA    		jz	changeInverse	; 8Ah Инверсия фона чернобелого экрана (инверсия инверсии)
0018+  CC9D 3D          		dcr	a
0019+  CC9E CA 47 CA    		jz	setInverseNeg	; 8Bh Установка светлого фона черно-белого экрана (потому что A=0 будет инвертировано)
0020+  CCA1 3D          		dcr	a
0021+  CCA2 CA 48 CA    		jz	setInverse	; 8Сh Установка темного фона черно-белого экрана (потому что A=0)
0022+  CCA5 3D          		dcr	a
0023+  CCA6 CA D6 C7    		jz	pushCursorLine	; 8Dh Запоминание курсора строки
0024+  CCA9 3D          		dcr	a
0025+  CCAA CA DD C7    		jz	popCursorLine	; 8Eh Восстановление курсора строки
0026+  CCAD 3D          		dcr	a
0027+  CCAE CA 18 CA    		jz	clearTopLine	; 8Fh Очистка верхней служебной строки
0028+  CCB1 3D          		dcr	a
0029+  CCB2 CA 5B CA    		jz	clearBottomLine	; 90h Очистка нижней служебной строки
0030+  CCB5 3D          		dcr	a
0031+  CCB6 CA C1 CD    		jz	scrollDown	; 91h Сдвииг экрана вних от курсора
0032+  CCB9 3D          		dcr	a
0033+  CCBA CA 4A CD    		jz	scrollUp	; 92h Сдвин экрана вверх от курсора
0034+  CCBD 3D          		dcr	a
0035+  CCBE CA E3 C7    		jz	pushCursor	; 93h Запоминание курсора экрана
0036+  CCC1 3D          		dcr	a
0037+  CCC2 CA EA C7    		jz	popCursor	; 94h Восстановление курсора экрана
0038+  CCC5 3D          		dcr	a
0039+  CCC6 CA B3 C8    		jz	printFileName	; 95h Вывод имени файла загруженного с диска
0040+  CCC9 3D          		dcr	a
0041+  CCCA EB          		xchg
0042+  CCCB 2A 2C C6    		lhld	v_koi8
0043+  CCCE 3D          		dcr	a
0044+  CCCF CA BD CF    		jz	c_koi7		; 97h Включение режиме KOI-7
0045+  CCD2 3D          		dcr	a
0046+  CCD3 CA B8 CF    		jz	c_koi8		; 98h Включение режиме KOI-8
0047+  CCD6 3D          		dcr	a
0048+  CCD7 3D          		dcr	a
0049+  CCD8 C0          		rnz			; Выход, а дальше 9Ah Сдвиг экрана вверх от нижней служеюной строки до текущей строки курсора
0050+  CCD9 EB          		xchg
0051+  CCDA E5          		push	h
0052+  CCDB 2C          		inr	l
0053+  CCDC 2C          		inr	l
0054+  CCDD 7D          		mov	a, l
0055+  CCDE C6 0A       		adi	10
0056+  CCE0 5F          		mov	e, a
0057+  CCE1 3A 32 D2    		lda	v_screenHeight
0058+  CCE4 C3 52 CD    		jmp	c_scrolUpEx0209   CCE7             #if FAST_PRINT!=1
0210   CCE7             .include "printChar3.inc"	; Їа®¤®«¦ Ґвбп ў setCursorPos
0001+  CCE7             ;----------------------------------------------------------------------------
0002+  CCE7             ; RAMFOS
0003+  CCE7             ; Вывод символа на экран. Продолжение printChar.inc
0004+  CCE7             ;
0005+  CCE7             ; 2013-11-01 Дизассемблировано vinxru
0006+  CCE7             ;----------------------------------------------------------------------------
0007+  CCE7             
0008+  CCE7             printChar_esc1:	; Обработка первого символа ESC-последовательности
0009+  CCE7             
0010+  CCE7             		; Если символ Y, перейти к обработке второго символа
0011+  CCE7 79          		mov	a, c
0012+  CCE8 FE 59       		cpi	'Y'
0013+  CCEA 3E 02       		mvi	a, 2
0014+  CCEC CA F0 CC    		jz	setEscMode
0015+  CCEF             
0016+  CCEF             		; Доработка для вывода всех символов знакогенератора
0017+  CCEF~            #if ALL_CHARS
0018+  CCEF~            printCharAll:
0019+  CCEF~            		xra	a
0020+  CCEF~            		sta	v_escMode
0021+  CCEF~            		lhld	v_cursorPos
0022+  CCEF~            		jmp	printChar_0
0023+  CCEF             #endif
0024+  CCEF             
0025+  CCEF             ; ---------------------------------------------------------------------------
0026+  CCEF             
0027+  CCEF AF          setEscMode0:	xra	a
0028+  CCF0 32 24 D2    setEscMode:	sta	v_escMode
0029+  CCF3 C9          		ret
0030+  CCF4             
0031+  CCF4             ; ---------------------------------------------------------------------------
0032+  CCF4             
0033+  CCF4 32 3E D2    printChar_esc2:	sta	v_escRow
0034+  CCF7 3E 03       		mvi	a, 3
0035+  CCF9 C3 F0 CC    		jmp	setEscMode
0036+  CCFC             
0037+  CCFC             ; ---------------------------------------------------------------------------
0038+  CCFC             
0039+  CCFC 3E 01       setEscMode1:	mvi	a, 1
0040+  CCFE C3 F0 CC    		jmp	setEscMode
0041+  CD01             		
0042+  CD01             ; ---------------------------------------------------------------------------
0043+  CD01             
0044+  CD01             printChar_esc:	; Обработка ESC последовательности
0045+  CD01             
0046+  CD01             		; Если printChar_esc1Mode=1
0047+  CD01 3D          		dcr	a
0048+  CD02 CA E7 CC    		jz	printChar_esc1
0049+  CD05 47          		mov	b, a
0050+  CD06             
0051+  CD06             		; Вычесть из буквы 20h
0052+  CD06 79          		mov	a, c
0053+  CD07 D6 20       		sui	20h
0054+  CD09             
0055+  CD09             		; Если printChar_esc1Mode=2, сохранить 
0056+  CD09 05          		dcr	b
0057+  CD0A CA F4 CC    		jz	printChar_esc2
0058+  CD0D             
0059+  CD0D 6F          		mov	l, a
0060+  CD0E 3A 3E D2    		lda	v_escRow
0061+  CD11 67          		mov	h, a
0062+  CD12 CD EF CC    		call	setEscMode0
0063+  CD15             
0064+  CD15             		; Продолжение setCursorPos0211   CD15             #endif
0212   CD15             .include "setCursorPos.inc"
0001+  CD15             ;+---------------------------------------------------------------------------
0002+  CD15             ; RAMFOS
0003+  CD15             ; Стандартная точка входа C83C
0004+  CD15             ; Устанвока/получения положения курсора. Координаты в символах.
0005+  CD15             ;
0006+  CD15             ; На входе
0007+  CD15             ;  H - номер строки
0008+  CD15             ;  L - номер колонки
0009+  CD15             ;
0010+  CD15             ; 2013-11-01 Дизассемблировано vinxru
0011+  CD15             ;----------------------------------------------------------------------------
0012+  CD15             
0013+  CD15 E5          setCursorPos:	push	h
0014+  CD16 F5          		push	psw
0015+  CD17             
0016+  CD17             		; Поменять H L местами
0017+  CD17 7D          		mov	a, l
0018+  CD18 6C          		mov	l, h
0019+  CD19 67          		mov	h, a
0020+  CD1A             
0021+  CD1A             		; l = l * 10 - 2
0022+  CD1A 3E FE       		mvi	a, -2
0023+  CD1C C6 0A       loc_CD1C:	 adi	10
0024+  CD1E 2D          		 dcr	l
0025+  CD1F F2 1C CD    		jp	loc_CD1C
0026+  CD22 6F          		mov	l, a
0027+  CD23             
0028+  CD23             		; h *= 3
0029+  CD23 3E FD       		mvi	a, -3
0030+  CD25 C6 03       loc_CD25:	 adi	3
0031+  CD27 25          		 dcr	h
0032+  CD28 F2 25 CD    		jp	loc_CD25
0033+  CD2B 67          		mov	h, a
0034+  CD2C             
0035+  CD2C             		; Сохранить положение курсора
0036+  CD2C 22 3E C6    		shld	v_cursorPos
0037+  CD2F             
0038+  CD2F F1          		pop	psw
0039+  CD30 E1          		pop	h
0040+  CD31 C9          		ret0213   CD32             .include "getCursorPos.inc"
0001+  CD32             ;+---------------------------------------------------------------------------
0002+  CD32             ; RAMFOS
0003+  CD32             ; Стандартная точка входа F81E	
0004+  CD32             ; Получить координаты курсора в символах
0005+  CD32             ;
0006+  CD32             ; На выходе
0007+  CD32             ;  h - строка (Y)
0008+  CD32             ;  l - столбец (X)
0009+  CD32             ;  Сохраняет остальные регистры
0010+  CD32             ;
0011+  CD32             ; 2013-11-01 vinxru
0012+  CD32             ;----------------------------------------------------------------------------                   
0013+  CD32             
0014+  CD32 F5          getCursorPos:	push	psw
0015+  CD33 21 FF FF    		lxi	h, -1
0016+  CD36             
0017+  CD36             		; h = v_cursorPosY / 10
0018+  CD36 3A 3E C6    		lda	v_cursorPos	
0019+  CD39 24          getCursorPos_0:	 inr	h
0020+  CD3A D6 0A       		 sui	0Ah
0021+  CD3C D2 39 CD    		jnc	getCursorPos_0
0022+  CD3F             
0023+  CD3F             		; l = v_cursorPosX / 3
0024+  CD3F 3A 3F C6    		lda	v_cursorPos+1			
0025+  CD42 2C          getCursorPos_1:  inr	l
0026+  CD43 D6 03       		 sui	3
0027+  CD45 D2 42 CD    		jnc	getCursorPos_1
0028+  CD48             
0029+  CD48 F1          		pop	psw
0030+  CD49 C9          		ret0214   CD4A             .include "scrollUp.inc"
0001+  CD4A             ;----------------------------------------------------------------------------
0002+  CD4A             ; RAMFOS
0003+  CD4A             ; Сдвиг экрана вверх
0004+  CD4A             ;
0005+  CD4A             ; 2013-11-01 Дизассемблировано vinxru
0006+  CD4A             ;----------------------------------------------------------------------------
0007+  CD4A             
0008+  CD4A E5          scrollUp:	push	h
0009+  CD4B 7D          		mov	a, l		; c =  (l + 2 -	word_D231)/2
0010+  CD4C             
0011+  CD4C 2A 30 D2    		lhld	v_topLineHeight
0012+  CD4F 5C          		mov	e, h		; e = word_D231
0013+  CD50 3C          		inr	a
0014+  CD51 3C          		inr	a
0015+  CD52 93          c_scrolUpEx:	sub	e
0016+  CD53 1F          		rar
0017+  CD54 4F          		mov	c, a
0018+  CD55             		; Адрес видео
0019+  CD55 26 90       		mvi	h, 90h
0020+  CD57 54          		mov	d, h
0021+  CD58             		; Колонки		
0022+  CD58 06 30       		mvi	b, 48
0023+  CD5A E5          loc_CD5A:	 push	h
0024+  CD5B D5          		 push	d
0025+  CD5C C5          		 push	b
0026+  CD5D             		  ; Копируем C байт
0027+  CD5D 0C          		  inr	c
0028+  CD5E 0D          		  dcr	c
0029+  CD5F C4 7C CD    		  cnz	memcpy_hl_de_c2
0030+  CD62             		  ; Очищаем последние 10 байт
0031+  CD62 3A 5C C6    		  lda	v_inverse
0032+  CD65 0E 0A       		  mvi	c, 10
0033+  CD67 77          loc_CD67:	   mov	m, a
0034+  CD68 2C          		   inr	l
0035+  CD69 0D          		   dcr	c
0036+  CD6A C2 67 CD    		  jnz	loc_CD67
0037+  CD6D C1          		 pop	b
0038+  CD6E D1          		 pop	d
0039+  CD6F E1          		 pop	h
0040+  CD70             		 ; Следующая колонка
0041+  CD70 24          		 inr	h
0042+  CD71 14          		 inr	d
0043+  CD72 05          		 dcr	b
0044+  CD73 C2 5A CD    		jnz	loc_CD5A
0045+  CD76 E1          		pop	h
0046+  CD77             		; Установка положения курсора	
0047+  CD77 26 00       saveCursorPosX0:mvi	h, 0
0048+  CD79 C3 53 CE    		jmp	saveCursorPos
0215   CD7C             .include "memcpy_hl_de_c2.inc"
0001+  CD7C             ;+---------------------------------------------------------------------------
0002+  CD7C             ; RAMFOS
0003+  CD7C             ; Копирование ОЗУ
0004+  CD7C             ;
0005+  CD7C             ; На входе
0006+  CD7C             ;  de - откуда
0007+  CD7C             ;  hl - куда
0008+  CD7C             ;  с  - размер / 2
0009+  CD7C             ; 
0010+  CD7C             ; 2013-11-01 Дизассемблировано vinxru
0011+  CD7C             ;----------------------------------------------------------------------------
0012+  CD7C             
0013+  CD7C 1A          memcpy_hl_de_c2:ldax	d
0014+  CD7D 77          		mov	m, a
0015+  CD7E 2C          		inr	l
0016+  CD7F 1C          		inr	e
0017+  CD80 1A          		ldax	d
0018+  CD81 77          		mov	m, a
0019+  CD82 2C          		inr	l
0020+  CD83 1C          		inr	e
0021+  CD84 0D          		dcr	c
0022+  CD85 C2 7C CD    		jnz	memcpy_hl_de_c2
0023+  CD88 C9          		ret
0216   CD89             .include "cursor.inc"
0001+  CD89             ;+---------------------------------------------------------------------------
0002+  CD89             ; RAMFOS
0003+  CD89             ; Функции перемещения курсора
0004+  CD89             ;
0005+  CD89             ; На входе в каждую функцию HL должен содержать v_cursorPos
0006+  CD89             ;
0007+  CD89             ; 2013-11-01 Дизассемблировано vinxru
0008+  CD89             ;----------------------------------------------------------------------------
0009+  CD89             
0010+  CD89             cursorRight:	; Если v_cursorX >= 190, то перейти на новую строку
0011+  CD89 7C          		mov	a, h
0012+  CD8A FE BE       		cpi	190
0013+  CD8C D2 95 CD    		jnc	cursorCrLf
0014+  CD8F             
0015+  CD8F             		; v_cursorX += 3
0016+  CD8F C6 03       		adi	3
0017+  CD91 67          		mov	h, a
0018+  CD92             
0019+  CD92             		; Сохранить новое положение курсора (shld v_cursorPos, ret)
0020+  CD92 C3 53 CE    		jmp	saveCursorPos
0021+  CD95             
0022+  CD95             ; ---------------------------------------------------------------------------
0023+  CD95             
0024+  CD95             cursorCrLf:	; v_cursorX = 0
0025+  CD95 26 00       		mvi	h, 0
0026+  CD97             
0027+  CD97             cursorDown:	; Если v_cursorY > screenHeight+10, сдвинуть экран вверх
0028+  CD97 3A 33 D2    		lda	v_screenHeight+1
0029+  CD9A BD          		cmp	l
0030+  CD9B DA 4A CD    		jc	scrollUp
0031+  CD9E             
0032+  CD9E             		; cursorY += 10
0033+  CD9E 7D          		mov	a, l
0034+  CD9F C6 0A       		adi	10
0035+  CDA1 6F          		mov	l, a
0036+  CDA2             
0037+  CDA2             		; Сохранить новое положение курсора (shld v_cursorPos, ret)
0038+  CDA2 C3 53 CE    		jmp	saveCursorPos
0039+  CDA5             
0040+  CDA5             ; ---------------------------------------------------------------------------
0041+  CDA5             
0042+  CDA5             cursorLeft:	; Если курсор у левого края экрана, ничего не делать
0043+  CDA5 7C          		mov	a, h
0044+  CDA6 FE 02       		cpi	2
0045+  CDA8 DA 53 CE    		jc	saveCursorPos
0046+  CDAB             
0047+  CDAB             		; v_cursorX -= 3
0048+  CDAB D6 03       		sui	3
0049+  CDAD 67          		mov	h, a
0050+  CDAE             
0051+  CDAE             		; Сохранить новое положение курсора (shld v_cursorPos, ret)
0052+  CDAE C3 53 CE    		jmp	saveCursorPos
0053+  CDB1             
0054+  CDB1             ; ---------------------------------------------------------------------------
0055+  CDB1             
0056+  CDB1             cursorUp:	; Если курсор не на верхней служебной строке, то сдвинуть экран вверх
0057+  CDB1 3A 31 D2    		lda	v_topLineHeight+1
0058+  CDB4 BD          		cmp	l
0059+  CDB5 D2 BF CD    		jnc	scrollDownX0
0060+  CDB8             
0061+  CDB8             		; v_cursorY -= 10
0062+  CDB8 7D          		mov	a, l
0063+  CDB9 D6 0A       		sui	10
0064+  CDBB 6F          		mov	l, a
0065+  CDBC             
0066+  CDBC             		; Сохранить новое положение курсора (shld v_cursorPos, ret)
0067+  CDBC C3 53 CE    		jmp	saveCursorPos0217   CDBF             .include "scrollDown.inc"
0001+  CDBF             ;----------------------------------------------------------------------------
0002+  CDBF             ; RAMFOS
0003+  CDBF             ; Сдвиг экрана вниз
0004+  CDBF             ;
0005+  CDBF             ; 2013-11-01 Дизассемблировано vinxru
0006+  CDBF             ;----------------------------------------------------------------------------
0007+  CDBF             
0008+  CDBF             scrollDownX0:	; x = 0
0009+  CDBF 26 00       		mvi	h, 0	; Влияет на расчет C, смотри ниже
0010+  CDC1             
0011+  CDC1 E5          scrollDown:	push	h
0012+  CDC2             		; c = cursorY - 8
0013+  CDC2 7D          		mov	a, l
0014+  CDC3 D6 08       		sui	8
0015+  CDC5             		; if(v_cursorX != 0) c += 10
0016+  CDC5 25          		dcr	h
0017+  CDC6 24          		inr	h
0018+  CDC7 CA CC CD    		jz	scrollDown_0
0019+  CDCA C6 0A       		  adi	10		  
0020+  CDCC 4F          scrollDown_0:	mov	c, a
0021+  CDCD             
0022+  CDCD             		; l = v_screenHeight, e = h = v_screenHeight-10
0023+  CDCD 2A 32 D2    		lhld	v_screenHeight
0024+  CDD0 5C          		mov	e, h
0025+  CDD1             
0026+  CDD1             		; if(v_screenHeight < c) goto CDF9
0027+  CDD1 7B          		mov	a, e
0028+  CDD2 91          		sub	c
0029+  CDD3 DA F9 CD    		jc	scrollDown_1
0030+  CDD6             
0031+  CDD6             		; с = (v_screenHeight - c) / 2
0032+  CDD6 1F          		rar
0033+  CDD7 4F          		mov	c, a
0034+  CDD8             
0035+  CDD8             		; Адрес на экране. Для DE, HL идентичный, поскольку будет отличаться E, L
0036+  CDD8 26 90       		mvi	h, 90h
0037+  CDDA 54          		mov	d, h
0038+  CDDB             
0039+  CDDB             		; 48 столбцов
0040+  CDDB 06 30       		mvi	b, 48
0041+  CDDD E5          scrollDown_2:	 push	h
0042+  CDDE D5          		 push	d
0043+  CDDF C5          		 push	b
0044+  CDE0             		  ; Копируем C линий
0045+  CDE0 0C          		  inr	c
0046+  CDE1 0D          		  dcr	c
0047+  CDE2 C4 FD CD    		  cnz	memcpyb_hl_de_c2
0048+  CDE5             		  ; Верхние 10 линий очищаем
0049+  CDE5 3A 5C C6    		  lda	v_inverse
0050+  CDE8 0E 0A       		  mvi	c, 10		
0051+  CDEA 2D          scrollDown_3:	   dcr	l
0052+  CDEB 77          		   mov	m, a
0053+  CDEC 0D          		   dcr	c
0054+  CDED C2 EA CD    		  jnz	scrollDown_3
0055+  CDF0 C1          		 pop	b
0056+  CDF1 D1          		 pop	d
0057+  CDF2 E1          		 pop	h
0058+  CDF3             		 ; Следующий столбец
0059+  CDF3 24          		 inr	h
0060+  CDF4 14          		 inr	d
0061+  CDF5 05          		 dcr	b
0062+  CDF6 C2 DD CD    		jnz	scrollDown_2
0063+  CDF9             
0064+  CDF9             scrollDown_1:	; Восстанавливам L, он же cursorY
0065+  CDF9             		; cursorX, он же H будет заменен 0 в функции saveCursorPosX0
0066+  CDF9 E1          		pop	h
0067+  CDFA C3 77 CD    		jmp	saveCursorPosX0
0218   CDFD             .include "memcpyb_hl_de_c2.inc"
0001+  CDFD             ;+---------------------------------------------------------------------------
0002+  CDFD             ; RAMFOS
0003+  CDFD             ; Копирование ОЗУ в обратном направлении
0004+  CDFD             ;
0005+  CDFD             ; На входе
0006+  CDFD             ;  de - откуда
0007+  CDFD             ;  hl - куда
0008+  CDFD             ;  с  - размер/2
0009+  CDFD             ; 
0010+  CDFD             ; 2013-11-01 Дизассемблировано vinxru
0011+  CDFD             ;----------------------------------------------------------------------------
0012+  CDFD             
0013+  CDFD             memcpyb_hl_de_c2:
0014+  CDFD 2D          		dcr	l
0015+  CDFE 1D          		dcr	e
0016+  CDFF 1A          		ldax	d
0017+  CE00 77          		mov	m, a
0018+  CE01             
0019+  CE01 2D          		dcr	l
0020+  CE02 1D          		dcr	e
0021+  CE03 1A          		ldax	d
0022+  CE04 77          		mov	m, a
0023+  CE05             
0024+  CE05 0D          		dcr	c
0025+  CE06 C2 FD CD    		jnz	memcpyb_hl_de_c2
0026+  CE09 C9          		ret
0219   CE0A             .include "clearScreen.inc"
0001+  CE0A             ;----------------------------------------------------------------------------
0002+  CE0A             ; RAMFOS
0003+  CE0A             ; Очистить экран
0004+  CE0A             ;
0005+  CE0A             ; 2013-11-01 Дизассемблировано vinxru
0006+  CE0A             ;----------------------------------------------------------------------------
0007+  CE0A             
0008+  CE0A             clearScreen:	
0009+  CE0A~            #if COLOR_SUPPORT
0010+  CE0A~            		; Цвет по умолчанию
0011+  CE0A~            		mvi	a, INIT_SCREEN_COLOR
0012+  CE0A~            		call	setColor
0013+  CE0A             #endif
0014+  CE0A             clearScreen2:
0015+  CE0A             		; Сохраняем SP
0016+  CE0A 21 00 00    		lxi	h, 0
0017+  CE0D 39          		dad	sp
0018+  CE0E 22 2D D2    		shld	v_oldSP
0019+  CE11             
0020+  CE11             		; Колонки
0021+  CE11 06 30       		mvi	b, 48
0022+  CE13             
0023+  CE13             		; Байт для заливки экрана
0024+  CE13 3A 5C C6    		lda	v_inverse
0025+  CE16 57          		mov	d, a
0026+  CE17 5F          		mov	e, a
0027+  CE18             
0028+  CE18             		; Заливаем экран. Начинаем с 383,240.
0029+  CE18 21 F0 BF    		lxi	h, 0BFF0h
0030+  CE1B F9          loc_CE1B:	 sphl
0031+  CE1C 0E 17       		 mvi	c, 23		; 230 строк
0032+  CE1E D5          loc_CE1E:	  push	d
0033+  CE1F D5          		  push	d
0034+  CE20 D5          		  push	d
0035+  CE21 D5          		  push	d
0036+  CE22 D5          		  push	d
0037+  CE23 0D          		  dcr	c
0038+  CE24 C2 1E CE    		 jnz	loc_CE1E
0039+  CE27 25          		dcr	h
0040+  CE28 05          		dcr	b
0041+  CE29 C2 1B CE    		jnz	loc_CE1B
0042+  CE2C             
0043+  CE2C             		; Восстаналиваем SP
0044+  CE2C 2A 2D D2    		lhld	v_oldSP
0045+  CE2F F9          		sphl
0046+  CE30             
0047+  CE30             		; Дальше магия с переменными и строками состояния
0048+  CE30             
0049+  CE30             		; При печати двойного символа 1F скрываем нижнюю строку
0050+  CE30 21 10 D2    		lxi	h, v_dblClear
0051+  CE33 3E 1F       		mvi	a, 1Fh
0052+  CE35 BE          		cmp	m
0053+  CE36 CC 72 CA    		cz	bottomLineHide	; Если вызвана, то на выходе A=0		
0054+  CE39 32 10 D2    		sta	v_dblClear
0055+  CE3C             
0056+  CE3C 3A 30 D2    		lda	v_topLineHeight
0057+  CE3F B7          		ora	a
0058+  CE40 CC 5D CE    		cz	clearTopLine2
0059+  CE43             
0060+  CE43 3A 32 D2    		lda	v_screenHeight
0061+  CE46 FE FA       		cpi	250
0062+  CE48 CC 57 CE    		cz	sub_CE57
0063+  CE4B             
0064+  CE4B             loc_CE4B:	; cursorX = 0
0065+  CE4B 26 00       		mvi	h, 0
0066+  CE4D             
0067+  CE4D             		; cursorY = byte_D231 - 2
0068+  CE4D 3A 31 D2    		lda	v_topLineHeight+1
0069+  CE50 3D          		dcr	a
0070+  CE51 3D          		dcr	a
0071+  CE52 6F          		mov	l, a
0072+  CE53             		
0073+  CE53             saveCursorPos:	; Сохранить положение курсора
0074+  CE53 22 3E C6    		shld	v_cursorPos
0075+  CE56 C9          		ret
0076+  CE57             
0077+  CE57             ; ---------------------------------------------------------------------------
0078+  CE57             
0079+  CE57 11 10 00    sub_CE57:	lxi	d, 10h
0080+  CE5A C3 60 CE    		jmp	clearLine	; d - строка, e	- высота
0081+  CE5D             
0082+  CE5D             ; ---------------------------------------------------------------------------
0220   CE5D             .include "clearLine.inc"
0001+  CE5D             ;+---------------------------------------------------------------------------
0002+  CE5D             ; RAMFOS
0003+  CE5D             ; Очистить верхнюю строку
0004+  CE5D             ;
0005+  CE5D             ; 2013-11-01 Дизассемблировано vinxru
0006+  CE5D             ;----------------------------------------------------------------------------
0007+  CE5D             
0008+  CE5D 11 0A 0A    clearTopLine2:	lxi	d, 0A0Ah	; строка 10, высота 10
0009+  CE60             
0010+  CE60             ;----------------------------------------------------------------------------
0011+  CE60             ; RAMFOS
0012+  CE60             ; Очистить произвольное кол-во строк
0013+  CE60             ;
0014+  CE60             ; На входе
0015+  CE60             ;  d - номер строки, выше которой строки будут очищены. Сама строка не очищается
0016+  CE60             ;  e - кол-во строк
0017+  CE60             ;
0018+  CE60             ; 2013-11-01 Дизассемблировано vinxru
0019+  CE60             ;----------------------------------------------------------------------------
0020+  CE60             
0021+  CE60 3A 5C C6    clearLine:	lda	v_inverse
0022+  CE63 26 90       		mvi	h, 90h			; Адрес
0023+  CE65 06 30       		mvi	b, 48			; Кол-во столбцов
0024+  CE67 6A          clearRect_0:	 mov	l, d
0025+  CE68 4B          		 mov	c, e		
0026+  CE69 2D          clearRect_1:	  dcr	l
0027+  CE6A 0D          		  dcr	c		
0028+  CE6B 77          		  mov	m, a
0029+  CE6C 2D          		  dcr	l
0030+  CE6D 0D          		  dcr	c
0031+  CE6E 77          		  mov	m, a
0032+  CE6F C2 69 CE    		 jnz	clearRect_1
0033+  CE72 24          		 inr	h
0034+  CE73 05          		 dcr	b
0035+  CE74 C2 67 CE    		jnz	clearRect_0
0036+  CE77 C9          		ret		0221   CE78             .include "keyWait.inc"
0001+  CE78             ;+---------------------------------------------------------------------------
0002+  CE78             ; RAMFOS
0003+  CE78             ; Ожидание нажатия клавиши с курсором
0004+  CE78             ;
0005+  CE78             ; 2013-11-01 Дизассемблировано vinxru
0006+  CE78             ;----------------------------------------------------------------------------
0007+  CE78             
0008+  CE78 E5          keyWait:	push	h
0009+  CE79 D5          		push	d
0010+  CE7A C5          		push	b
0011+  CE7B             		 ; Нажата ли клавиша
0012+  CE7B CD C4 CE    		 call	keyCheck
0013+  CE7E             		 ; Если клавиша не нажата, мигаем курсором, пока не нажмут
0014+  CE7E CC 8D CE    		 cz	keyCursor
0015+  CE81             		 ; Сбрасыаем флаг v_key2
0016+  CE81 AF          		 xra	a
0017+  CE82 32 25 D2    		 sta	v_key2
0018+  CE85             		 ; Нажатая клавиша в v_key1
0019+  CE85 3A 2B D2    		 lda	v_key1
0020+  CE88 C1          		pop	b		
0021+  CE89 D1          popa_ora_a_ret:	pop	d
0022+  CE8A E1          loc_CE8A:	pop	h
0023+  CE8B B7          ora_a_ret:	ora	a
0024+  CE8C C9          		ret
0222   CE8D             .include "keyCursor.inc"		
0001+  CE8D             ;+---------------------------------------------------------------------------
0002+  CE8D             ; RAMFOS
0003+  CE8D             ; Ожидание нажатия клавиши с курсором
0004+  CE8D             ;
0005+  CE8D             ; 2013-11-01 Дизассемблировано vinxru
0006+  CE8D             ;----------------------------------------------------------------------------
0007+  CE8D             
0008+  CE8D             keyCursor:	; Рисуем курсор XOR-ом
0009+  CE8D CD 97 CE    		call	keyCursor1
0010+  CE90             		; Стираем курсор XOR-ом
0011+  CE90 CD 97 CE    		call	keyCursor1
0012+  CE93             		; Если была нажата клавиаша, выходим
0013+  CE93 C0          		rnz
0014+  CE94             		; Бесконечное ожидание
0015+  CE94 C3 8D CE    		jmp	keyCursor
0016+  CE97             
0017+  CE97             ;----------------------------------------------------------------------------
0018+  CE97             
0019+  CE97             keyCursor1:	
0020+  CE97             #if FAST_PRINT != 1
0021+  CE97             		; Код символа курсора
0022+  CE97 0E 17       		mvi	c, 17h
0023+  CE99             
0024+  CE99             		; Положение курсора в пикселях 		
0025+  CE99 2A 3E C6    		lhld	v_cursorPos
0026+  CE9C EB          		xchg
0027+  CE9D             
0028+  CE9D             		; Получение изображения символа hl и адреса в видеопамяти de
0029+  CE9D CD 65 CC    		call	calcCharAddr2
0030+  CEA0             
0031+  CEA0             		; Корректировка адреса
0032+  CEA0 7B          		mov	a, e
0033+  CEA1 D6 07       		sui	7
0034+  CEA3 5F          		mov	e, a
0035+  CEA4             
0036+  CEA4             		; Рисование курсора
0037+  CEA4 CD 1F CC    		call	drawChar
0038+  CEA7~            #else ;----------------------------------------------------------------------
0039+  CEA7~            		; Положение курсора в пикселях 		
0040+  CEA7~            		lhld	v_cursorPos
0041+  CEA7~            		xchg
0042+  CEA7~            
0043+  CEA7~            		; Получение адреса в видеопамяти de
0044+  CEA7~            		call calcCharAddr
0045+  CEA7~            
0046+  CEA7~            		; Исходный символ
0047+  CEA7~            		lxi	h, 3Fh		 
0048+  CEA7~            
0049+  CEA7~            		; Сдвигаем
0050+  CEA7~            		mov	a, c		
0051+  CEA7~            drawCursor_0:	 dad	h
0052+  CEA7~            		 dad	h
0053+  CEA7~            		 dcr	a
0054+  CEA7~            		jnz	drawCursor_0
0055+  CEA7~            
0056+  CEA7~            		; Цикл b
0057+  CEA7~            		mvi	b, 8
0058+  CEA7~            drawCursor_1:	 ; *de++ ^= hl
0059+  CEA7~            		 ldax	d
0060+  CEA7~            		 xra	h
0061+  CEA7~            		 stax	d		 
0062+  CEA7~            		 inr	d		 
0063+  CEA7~            		 ldax	d
0064+  CEA7~            		 xra	l
0065+  CEA7~            		 stax	d
0066+  CEA7~            		 dcr	d
0067+  CEA7~            		 dcr	e		
0068+  CEA7~            		 ; Цикл
0069+  CEA7~            		 dcr	b
0070+  CEA7~            		jnz	drawCursor_1
0071+  CEA7             #endif ;---------------------------------------------------------------------
0072+  CEA7             		; Ждем нажатия клавиши
0073+  CEA7 21 FF 02    		lxi	h, CURSOR_BLINK_SPEED
0074+  CEAA CD C4 CE    keyCursor1_0:	 call	keyCheck
0075+  CEAD C0          		 rnz
0076+  CEAE 2B          		 dcx	h
0077+  CEAF 7C          		 mov	a, h
0078+  CEB0 B5          		 ora	l
0079+  CEB1 C2 AA CE    		jnz	keyCursor1_0
0080+  CEB4 C9          		ret0223   CEB5             .include "keyCheck.inc"
0001+  CEB5             ;----------------------------------------------------------------------------
0002+  CEB5             ; RAMFOS
0003+  CEB5             ; Автоповтор клавиатуры и эхопечать (обертка над сканирование клавиатуры)
0004+  CEB5             ;
0005+  CEB5             ; 2013-11-01 Дизассемблировано vinxru
0006+  CEB5             ;----------------------------------------------------------------------------
0007+  CEB5             
0008+  CEB5             #if FAST_PRINT==0
0009+  CEB5             keyScanWhilePrint:
0010+  CEB5             		; Обработка клавиш во время вывода и эхопечать
0011+  CEB5             
0012+  CEB5             		; Если v_cursorY=8 или 248, выходим 
0013+  CEB5 7B          		mov	a, e
0014+  CEB6 FE 08       		cpi	8
0015+  CEB8 C8          		rz
0016+  CEB9 FE F8       		cpi	248
0017+  CEBB C8          		rz
0018+  CEBC             
0019+  CEBC             		; Если включен эхо режим на принтер
0020+  CEBC 3A 2F C6    		lda	v_printerEcho
0021+  CEBF FE D2       		cpi	0D2h
0022+  CEC1 CA B8 D0    		jz	doPrinterEcho
0023+  CEC4             #endif
0024+  CEC4             		
0025+  CEC4             keyCheck:
0026+  CEC4             		; Какой то флаг
0027+  CEC4 3A 25 D2    		lda	v_key2
0028+  CEC7 B7          		ora	a
0029+  CEC8 C0          		rnz
0030+  CEC9             
0031+  CEC9             		; Что то считаем
0032+  CEC9 E5          		push	h
0033+  CECA D5          		push	d
0034+  CECB 2A 29 D2    		 lhld	v_key0
0035+  CECE EB          		 xchg
0036+  CECF 2A 2B D2    		 lhld	v_key1
0037+  CED2 CD E2 CE    		 call	sub_CEE2
0038+  CED5 22 2B D2    		 shld	v_key1	; Нажатая клавиша в L
0039+  CED8 EB          		 xchg
0040+  CED9 22 29 D2    		 shld	v_key0
0041+  CEDC 32 25 D2    		 sta	v_key2
0042+  CEDF             
0043+  CEDF             		; pop d
0044+  CEDF             		; pop h
0045+  CEDF             		; ora a
0046+  CEDF             		; ret
0047+  CEDF C3 89 CE    		jmp	popa_ora_a_ret
0048+  CEE2             
0049+  CEE2             ; ---------------------------------------------------------------------------
0050+  CEE2             
0051+  CEE2             sub_CEE2:	; Получить код нажатой клавиши
0052+  CEE2 CD 08 CF    		call	keyScan
0053+  CEE5             
0054+  CEE5             		; Если нажатая клавиша не L
0055+  CEE5 BD          		cmp	l
0056+  CEE6 6F          		mov	l, a
0057+  CEE7 C2 01 CF    		jnz	loc_CF01
0058+  CEEA             
0059+  CEEA             		; Если клавиша не была нажата, выходим с кодом 0
0060+  CEEA 3C          		inr	a
0061+  CEEB C8          		rz
0062+  CEEC             
0063+  CEEC             		; Уменьшаем DE, и если он не нулевой, выходим с кодом 0
0064+  CEEC 1B          		dcx	d
0065+  CEED 7A          		mov	a, d
0066+  CEEE B3          		ora	e
0067+  CEEF 3E 00       		mvi	a, 0
0068+  CEF1 C0          		rnz
0069+  CEF2             
0070+  CEF2             		; Звуковой сигнал
0071+  CEF2 CD D7 CF    		call	keySound
0072+  CEF5             
0073+  CEF5             		; Инициализируем счетчик
0074+  CEF5 11 7C 01    		lxi	d, 17Ch
0075+  CEF8             
0076+  CEF8             		; Если H=0, выходим с кодом 0FFh
0077+  CEF8 25          		dcr	h
0078+  CEF9 3E FF       		mvi	a, 0FFh
0079+  CEFB C8          		rz
0080+  CEFC             
0081+  CEFC             		; Возвращаем H
0082+  CEFC 24          		inr	h
0083+  CEFD             
0084+  CEFD             		; Инициализируем счетчик
0085+  CEFD 11 1C 00    		lxi	d, 1Ch
0086+  CF00 C9          		ret
0087+  CF01             ; ---------------------------------------------------------------------------
0088+  CF01             
0089+  CF01             loc_CF01:	; Записываем H=1
0090+  CF01 26 01       		mvi	h, 1
0091+  CF03             
0092+  CF03             		; Выходим с кодом 0
0093+  CF03 AF          		xra	a        	
0094+  CF04             
0095+  CF04             		; Инициализируем счетчик
0096+  CF04 11 30 00    		lxi	d, 30h
0097+  CF07 C9          		ret
0098+  CF08             
0099+  CF08             ; ---------------------------------------------------------------------------
0224   CF08             .include "keyScan.inc"		; Їа®¤®«¦ Ґвбп ў keySound
0001+  CF08             ;----------------------------------------------------------------------------
0002+  CF08             ; RAMFOS
0003+  CF08             ; Сканирование клавиатуры
0004+  CF08             ;
0005+  CF08             ; 2013-11-01 Дизассемблировано vinxru
0006+  CF08             ;----------------------------------------------------------------------------
0007+  CF08             
0008+  CF08             keyScan:		; Сохраняем регистры BC, DE, HL
0009+  CF08 E5          		push	h
0010+  CF09 D5          		push	d
0011+  CF0A C5          		push	b
0012+  CF0B CD 24 CF    		 call	keyScan_0
0013+  CF0E C1          		pop	b
0014+  CF0F D1          		pop	d
0015+  CF10 E1          		pop	h
0016+  CF11             
0017+  CF11             		; Флаг Z
0018+  CF11 B7          		ora	a
0019+  CF12             		
0020+  CF12             keyMode82:	; Восстаналиваем индикатор РУС/LAT
0021+  CF12             		; Вызывается из biosinit.inc
0022+  CF12             
0023+  CF12             		; Сохраняем результат
0024+  CF12 F5          		push	psw
0025+  CF13             		 ; Далее устаналиваем режим клавиатуры 82h
0026+  CF13 3E 82       		 mvi	a, 82h
0027+  CF15 32 E3 FF    		 sta	IO_KEYB_MODE
0028+  CF18             		 ; Устаналиваем светодиод РУС/ЛАТ
0029+  CF18 3A 2D C6    		 lda	v_rusLat
0030+  CF1B E6 01       		 ani	1
0031+  CF1D F6 0C       		 ori	0Ch
0032+  CF1F 32 E3 FF    		 sta	IO_KEYB_MODE
0033+  CF22 F1          		pop	psw
0034+  CF23             
0035+  CF23 C9          		ret
0036+  CF24             
0037+  CF24             ; ---------------------------------------------------------------------------
0038+  CF24             
0039+  CF24             keyScan_0:	; Получаем номер ряда нажатой клавиши в B
0040+  CF24 CD 12 CF    		call	keyMode82
0041+  CF27 3A E1 FF    		lda	IO_KEYB_B
0042+  CF2A 47          		mov	b, a
0043+  CF2B             
0044+  CF2B             		; Если ни одна клавиша не нажата, выходим
0045+  CF2B F6 03       		ori	3
0046+  CF2D FE FF       		cpi	0FFh
0047+  CF2F C8          		rz
0048+  CF30             
0049+  CF30             		; Получаем номер колонки нажатой клавиши в HL
0050+  CF30 3E 91       		mvi	a, 91h
0051+  CF32 32 E3 FF    		sta	IO_KEYB_MODE
0052+  CF35 3A E0 FF    		lda	IO_KEYB_A
0053+  CF38 6F          		mov	l, a		
0054+  CF39 3A E2 FF    		lda	IO_KEYB_C
0055+  CF3C F6 F0       		ori	0F0h
0056+  CF3E 67          		mov	h, a
0057+  CF3F             
0058+  CF3F             		; Если колонка не нажата или нажата особая комбинация, выходим.
0059+  CF3F             		; При этом может быть возвращена ерунда!
0060+  CF3F BD          		cmp	l
0061+  CF40 C8          		rz
0062+  CF41             		
0063+  CF41             		; Помещаем в L номер первого нулевого бита из HL
0064+  CF41 3E FB       		mvi	a, 0FBh
0065+  CF43 3C          keyScan_1:	 inr	a
0066+  CF44 29          		 dad	h
0067+  CF45 DA 43 CF    		 jc	keyScan_1
0068+  CF48 6F          		mov	l, a
0069+  CF49             
0070+  CF49             		; Помещаем в С номер первого нулевого бита из B
0071+  CF49 78          		mov	a, b
0072+  CF4A F6 03       		ori	3
0073+  CF4C 37          		stc
0074+  CF4D 0E FD       		mvi	c, 0FDh
0075+  CF4F 0C          keyScan_2:	 inr	c
0076+  CF50 1F          		 rar
0077+  CF51 DA 4F CF    		jc	keyScan_2
0078+  CF54             
0079+  CF54             		; Если нажато более одной кнопки
0080+  CF54 3C          		inr	a
0081+  CF55 C2 C6 CF    		jnz	specialKeysRet
0082+  CF58             
0083+  CF58             		; b = !b & 2
0084+  CF58 78          		mov	a, b
0085+  CF59 2F          		cma
0086+  CF5A E6 02       		ani	2
0087+  CF5C 47          		mov	b, a
0088+  CF5D             
0089+  CF5D 79          		mov	a, c
0090+  CF5E 07          		rlc
0091+  CF5F 07          		rlc
0092+  CF60 07          		rlc
0093+  CF61 07          		rlc
0094+  CF62 B5          		ora	l
0095+  CF63             
0096+  CF63             		; a = keybMap[a]
0097+  CF63 5F          		mov	e, a		
0098+  CF64 16 00       		mvi	d, 0
0099+  CF66 2A 0E C6    		lhld	v_keybMap
0100+  CF69 19          		dad	d
0101+  CF6A 7E          		mov	a, m
0102+  CF6B             
0103+  CF6B             		; Сохраняем на будущее
0104+  CF6B 4F          		mov	c, a		; c = a
0105+  CF6C             
0106+  CF6C             		; if(a < 0x21) return;
0107+  CF6C FE 21       		cpi	21h
0108+  CF6E D8          		rc
0109+  CF6F             
0110+  CF6F             		; Специальные клавиши
0111+  CF6F FE 8B       		cpi	8Bh
0112+  CF71 CA 5A C8    		jz	j_tapeMode
0113+  CF74 FE 8C       		cpi	8Ch
0114+  CF76 CA 57 C8    		jz	j_printerEchoMode
0115+  CF79             
0116+  CF79 2A 2C C6    		lhld	v_koi8
0117+  CF7C             
0118+  CF7C FE 81       		cpi	81h
0119+  CF7E CA 30 D0    		jz	capsLock
0120+  CF81 FE 8A       		cpi	8Ah
0121+  CF83 CA C0 CF    		jz	inverseVideo
0122+  CF86 FE 40       		cpi	40h
0123+  CF88 DA AE CF    		jc	pressed40
0124+  CF8B             
0125+  CF8B 3A 2E C6    		lda	v_capsLock
0126+  CF8E A8          		xra	b
0127+  CF8F 47          		mov	b, a
0128+  CF90 79          		mov	a, c
0129+  CF91 24          		inr	h
0130+  CF92 CA A3 CF    		jz	loc_CFA3
0131+  CF95 05          		dcr	b
0132+  CF96 F8          		rm
0133+  CF97 C6 20       		adi	20h ; ' '
0134+  CF99 2C          		inr	l
0135+  CF9A C0          		rnz
0136+  CF9B C6 A0       		adi	0A0h ; 'а'
0137+  CF9D FE 08       		cpi	8
0138+  CF9F D0          		rnc
0139+  CFA0 C6 7F       		adi	7Fh ; ''
0140+  CFA2 C9          		ret
0141+  CFA3             
0142+  CFA3             ; ---------------------------------------------------------------------------
0143+  CFA3             
0144+  CFA3 C6 20       loc_CFA3:	adi	20h ; ' '
0145+  CFA5 2C          		inr	l
0146+  CFA6 C8          		rz
0147+  CFA7 C6 60       		adi	60h ; '`'
0148+  CFA9 05          		dcr	b
0149+  CFAA F0          		rp
0150+  CFAB C6 20       		adi	20h ; ' '
0151+  CFAD C9          		ret
0152+  CFAE             
0153+  CFAE             ; ---------------------------------------------------------------------------
0154+  CFAE             
0155+  CFAE 05          pressed40:	dcr	b
0156+  CFAF F8          		rm
0157+  CFB0 D6 10       		sui	10h
0158+  CFB2 FE 20       		cpi	20h ; ' '
0159+  CFB4 D0          		rnc
0160+  CFB5 C6 20       		adi	20h ; ' '
0161+  CFB7 C9          		ret
0162+  CFB8             
0163+  CFB8             ; ---------------------------------------------------------------------------
0164+  CFB8             
0165+  CFB8             c_koi8:					; CODE XREF: ROM:CCD3j
0166+  CFB8 7D          		mov	a, l
0167+  CFB9 2F          		cma
0168+  CFBA C3 BE CF    		jmp	loc_CFBE
0169+  CFBD             ; ---------------------------------------------------------------------------
0170+  CFBD             
0171+  CFBD             c_koi7:					; CODE XREF: ROM:CCCFj
0172+  CFBD 7D          		mov	a, l
0173+  CFBE             
0174+  CFBE B7          loc_CFBE:	ora	a
0175+  CFBF C0          		rnz
0176+  CFC0             
0177+  CFC0 7D          inverseVideo:	mov	a, l		; l = ~l;
0178+  CFC1 2F          		cma
0179+  CFC2 6F          		mov	l, a
0180+  CFC3             
0181+  CFC3 22 2C C6    capsLockRet:    shld	v_koi8
0182+  CFC6             
0183+  CFC6             specialKeysRet:	; Если не не выводим в стркоу статуса, обновить её
0184+  CFC6 3A 3E C6    		lda	v_cursorPos
0185+  CFC9 FE 08       		cpi	8
0186+  CFCB C4 27 CA    		cnz	printIndicators
0187+  CFCE             
0188+  CFCE             		; Задежка
0189+  CFCE 21 00 40    		lxi	h, 4000h	
0190+  CFD1 2B          keyScan_delay:	 dcx	h
0191+  CFD2 7C          		 mov	a, h
0192+  CFD3 B5          		 ora	l
0193+  CFD4 C2 D1 CF    		jnz	keyScan_delay
0194+  CFD7             
0195+  CFD7             		; Переход на keySound
0225   CFD7             .include "keySound.inc"
0001+  CFD7             ;+---------------------------------------------------------------------------
0002+  CFD7             ; RAMFOS
0003+  CFD7             ; Звуковой сигнал при нажатии клавиши
0004+  CFD7             ;
0005+  CFD7             ; 2013-11-01 vinxru
0006+  CFD7             ;----------------------------------------------------------------------------
0007+  CFD7             
0008+  CFD7 C5          keySound:	push	b
0009+  CFD8             		 ; Частота
0010+  CFD8 EB          		 xchg
0011+  CFD9 2A 4C C6    		 lhld	v_beepConfig
0012+  CFDC EB          		 xchg
0013+  CFDD             
0014+  CFDD             		 ; Понижаем частоту в два раза, если нажата РУС/LAT
0015+  CFDD 3A 2D C6    		 lda	v_rusLat
0016+  CFE0 E6 01       		 ani	1
0017+  CFE2 7A          		 mov	a, d
0018+  CFE3 C2 E7 CF    		 jnz	keySound_0
0019+  CFE6 0F          		  rrc			; Интересно, а вдруг CF?
0020+  CFE7 57          keySound_0:	 mov	d, a
0021+  CFE8             
0022+  CFE8             		 ; Устаналиваем таймер (звук)
0023+  CFE8 43          		 mov	b, e
0024+  CFE9 4B          		 mov	c, e
0025+  CFEA B7          		 ora	a
0026+  CFEB CD 19 D0    		 call	setTimer
0027+  CFEE C1          		pop	b
0028+  CFEF             
0029+  CFEF             		; Для функции keyScan
0030+  CFEF 3E FF       		mvi	a, 0FFh
0031+  CFF1 C9          		ret
0226   CFF2             .include "oldbeep.inc"
0001+  CFF2             ;+---------------------------------------------------------------------------
0002+  CFF2             ; RAMFOS
0003+  CFF2             ; Стандартная точка входа C851
0004+  CFF2             ; Воспроизвести звуковой сигнал через ВВ55
0005+  CFF2             ;
0006+  CFF2             ; Частота задается в v_oldBeep
0007+  CFF2             ;
0008+  CFF2             ; 2013-11-01 Дизассемблировано vinxru
0009+  CFF2             ;----------------------------------------------------------------------------
0010+  CFF2             
0011+  CFF2 F5          oldBeep:	push	psw
0012+  CFF3 C5          		push	b
0013+  CFF4 E5          		push	h
0014+  CFF5 2A 4E C6    		 lhld	v_oldBeep
0015+  CFF8 3E 0B       oldBeep_0:	 mvi	a, 0Bh
0016+  CFFA 32 E3 FF    		  sta	IO_KEYB_MODE
0017+  CFFD CD 10 D0    		  call	delay_l
0018+  D000 3E 0A       		  mvi	a, 0Ah
0019+  D002 32 E3 FF    		  sta	IO_KEYB_MODE
0020+  D005 CD 10 D0    		  call	delay_l
0021+  D008 25          		  dcr	h
0022+  D009 C2 F8 CF    		 jnz	oldBeep_0
0023+  D00C E1          		pop	h
0024+  D00D C1          		pop	b
0025+  D00E F1          		pop	psw
0026+  D00F C9          		ret
0227   D010             .include "delay_l.inc"
0001+  D010             ;+---------------------------------------------------------------------------
0002+  D010             ; RAMFOS
0003+  D010             ; Задержка
0004+  D010             ;
0005+  D010             ; На входе
0006+  D010             ;  L - длительность
0007+  D010             ;
0008+  D010             ; На выходе
0009+  D010             ;  B - 0
0010+  D010             ;
0011+  D010             ; 2013-11-01 Дизассемблировано vinxru
0012+  D010             ;----------------------------------------------------------------------------
0013+  D010             
0014+  D010 45          delay_l:	mov	b, l
0015+  D011 05          delay_l_0:	 dcr	b
0016+  D012 C2 11 D0    		jnz	delay_l_0
0017+  D015 C9          		ret
0228   D016             .include "beep.inc"
0001+  D016             ;+---------------------------------------------------------------------------
0002+  D016             ; RAMFOS
0003+  D016             ; Стандартная точка входа C848
0004+  D016             ; Воспроизвести звуковой сигнал через ВИ53
0005+  D016             ;
0006+  D016             ; На входе:
0007+  D016             ;  de - частота
0008+  D016             ;  bс - длительность
0009+  D016             ;  с  - ждать завершения предыдущего звукового сигнала
0010+  D016             ;  z  - ждать завершения этого звукового сигнала
0011+  D016             ;
0012+  D016             ; 2013-11-01 Дизассемблировано vinxru
0013+  D016             ;----------------------------------------------------------------------------
0014+  D016             
0015+  D016             beep:		; Ожидание заверения прошлого звукового сигнала, если C
0016+  D016 DC 25 D0    		cc	waitBeep		
0017+  D019             
0018+  D019             		; de-частота, bс-длительность, z-ждать
0019+  D019 E5          setTimer:	push	h
0020+  D01A 21 EC FF    		 lxi	h, IO_TIMER
0021+  D01D 73          		 mov	m, e
0022+  D01E 72          		 mov	m, d
0023+  D01F 23          		 inx	h
0024+  D020 23          		 inx	h
0025+  D021 71          		 mov	m, c
0026+  D022 70          		 mov	m, b
0027+  D023 E1          		pop	h
0028+  D024             
0029+  D024             		; Ожидание заверения этого звукового сигнала, если Z
0030+  D024 C0          		rnz
0031+  D025             
0032+  D025             waitBeep:	; Ожидание заверения звукового сигнала
0033+  D025 F5          		push	psw		
0034+  D026 3A E4 FF    waitBeep_0:	 lda	IO_EXT_A
0035+  D029 E6 01       		 ani	1
0036+  D02B CA 26 D0    		jz	waitBeep_0
0037+  D02E F1          		pop	psw
0038+  D02F C9          		ret0229   D030             .include "capsLock.inc"
0001+  D030             ;+---------------------------------------------------------------------------
0002+  D030             ; RAMFOS
0003+  D030             ; Нажатие на клавишу CAPS LOCK
0004+  D030             ;
0005+  D030             ; 2013-11-01 Дизассемблировано vinxru
0006+  D030             ;----------------------------------------------------------------------------
0007+  D030             
0008+  D030 05          capsLock:	dcr	b
0009+  D031 F2 3A D0    		jp	capsLock1
0010+  D034 7C          		 mov	a, h
0011+  D035 2F          		 cma
0012+  D036 67          		 mov	h, a
0013+  D037 C3 C3 CF    		jmp	capsLockRet
0014+  D03A             
0015+  D03A             ; ---------------------------------------------------------------------------
0016+  D03A             
0017+  D03A 3A 2E C6    capsLock1:	lda	v_capsLock
0018+  D03D EE 02       		xri	2
0019+  D03F 32 2E C6    		sta	v_capsLock
0020+  D042 C3 C6 CF    		jmp	specialKeysRet
0230   D045             .include "tapeMode.inc"
0001+  D045             ;+---------------------------------------------------------------------------
0002+  D045             ; RAMFOS
0003+  D045             ; Переключение скорости записи на магнитофон и режима принтера
0004+  D045             ; Вызывается при нажатии на соответствующую клавишу
0005+  D045             ;
0006+  D045             ; 2013-11-01 Дизассемблировано vinxru
0007+  D045             ;----------------------------------------------------------------------------
0008+  D045             
0009+  D045             tapeMode:	; Эта хитрая программа просто обменивает местами
0010+  D045             		; v_tapePulseB,A -> v_tapePulseB1,A1 -> v_tapePulseB2,A2
0011+  D045 16 04       		mvi	d, 4			; Надо сдвинуть 4 байта
0012+  D047 1E 0B       tapeMode_0:	 mvi	e, 11			; Длина всего массива 12 байт
0013+  D049 21 6B C6    		 lxi	h, v_tapePresets-1	; Конец массива
0014+  D04C 3A 60 C6    		 lda	v_tapePulseB		; Загружаем первое значение, которое сразу же поместим в конец
0015+  D04F 4F          tapeMode_1:	  mov	c, a			; Сдвигаем 11 байт
0016+  D050 7E          		  mov	a, m
0017+  D051 71          		  mov	m, c
0018+  D052 2B          		  dcx	h
0019+  D053 1D          		  dcr	e
0020+  D054 C2 4F D0    		 jnz	tapeMode_1
0021+  D057 77          		 mov	m, a			; И сохраняем 12 байт. Прошлое значение мы уже поместили в начало массива
0022+  D058 15          		 dcr	d			; Повторяем это 4 раза
0023+  D059 C2 47 D0    		jnz	tapeMode_0
0024+  D05C             
0025+  D05C             		; Меняем переменную v_tapeMode '0'->'1'->'2'->'0'
0026+  D05C 3A 5F C6    		lda	v_tapeMode
0027+  D05F 3C          		inr	a
0028+  D060 FE 33       		cpi	'3'
0029+  D062 C2 67 D0    		jnz	tapeMode_2
0030+  D065 3E 30       		 mvi	a, '0'
0031+  D067 32 5F C6    tapeMode_2:	sta	v_tapeMode
0032+  D06A             
0033+  D06A             		; Возвращаемся в функцию опроса клавиатуры
0034+  D06A C3 C6 CF    		jmp	specialKeysRet
0231   D06D             .include "printerEchoMode.inc"
0001+  D06D             ;+---------------------------------------------------------------------------
0002+  D06D             ; RAMFOS
0003+  D06D             ; Включение/выключение эхопечати на принтер
0004+  D06D             ; Вызывается при нажатии на соответствующую клавишу
0005+  D06D             ;
0006+  D06D             ; 2013-11-01 Дизассемблировано vinxru
0007+  D06D             ;----------------------------------------------------------------------------
0008+  D06D             
0009+  D06D             #if NO_PRINTER==0
0010+  D06D             
0011+  D06D 21 2F C6    printerEchoMode:lxi	h, v_printerEcho
0012+  D070 3E D2       		mvi	a, 0D2h
0013+  D072 BE          		cmp	m
0014+  D073 C2 77 D0    		jnz	printerEchoMode_0
0015+  D076 AF          		 xra	a
0016+  D077             printerEchoMode_0:
0017+  D077 77          		mov	m, a
0018+  D078 C3 C6 CF    		jmp	specialKeysRet
0019+  D07B             #endif0232   D07B             .include "printerHex.inc"
0001+  D07B             ;+---------------------------------------------------------------------------
0002+  D07B             ; RAMFOS
0003+  D07B             ; Стандартная точка входа C842
0004+  D07B             ; Печать 16-ричного числа на принтере
0005+  D07B             ;
0006+  D07B             ; На входе
0007+  D07B             ;  A - число
0008+  D07B             ;
0009+  D07B             ; Все регистры сохраняются
0010+  D07B             ;
0011+  D07B             ; 2013-11-01 Дизассемблировано vinxru
0012+  D07B             ;----------------------------------------------------------------------------
0013+  D07B             
0014+  D07B             #if NO_PRINTER==0
0015+  D07B             
0016+  D07B F5          printerHex:	push	psw
0017+  D07C 0F          		 rrc
0018+  D07D 0F          		 rrc
0019+  D07E 0F          		 rrc
0020+  D07F 0F          		 rrc
0021+  D080 CD 84 D0    		 call	printerHex_1
0022+  D083 F1          		pop	psw
0023+  D084 F5          printerHex_1:	push	psw
0024+  D085 E6 0F       		 ani	0Fh
0025+  D087 FE 0A       		 cpi	10
0026+  D089 FA 8E D0    		 jm	printerHex_2
0027+  D08C C6 07       		  adi	'A'-'0'-10		  
0028+  D08E C6 30       printerHex_2:	 adi	'0'
0029+  D090 C5          		 push	b
0030+  D091 4F          		  mov	c, a
0031+  D092 CD 16 D1    		  call	printer
0032+  D095 C1          		 pop	b
0033+  D096 F1          		pop	psw
0034+  D097 C9          		ret
0035+  D098             
0036+  D098             #endif0233   D098             .include "printerEcho.inc"
0001+  D098             ;+---------------------------------------------------------------------------
0002+  D098             ; RAMFOS
0003+  D098             ; Эхопечать на принтере
0004+  D098             ;
0005+  D098             ; 2013-11-01 Дизассемблировано vinxru
0006+  D098             ;----------------------------------------------------------------------------
0007+  D098             
0008+  D098             #if NO_PRINTER==0
0009+  D098             
0010+  D098             printerEcho_crLf:
0011+  D098             		; В сумме код ниже заменяет 0A или 0D на пару 0A, 0D. 
0012+  D098             		; Но в случае "0A любые символы 0D", послений не дублируется
0013+  D098             
0014+  D098             		; Вместо 0A, то печатаем пару символов 0A, 0D.
0015+  D098 21 26 D2    		lxi	h, v_printerCrLf
0016+  D09B FE 0A       		cpi	0Ah
0017+  D09D CA A6 D0    		jz	printerEcho_0
0018+  D0A0             
0019+  D0A0             		; Вместо 0D, то печатаем пару символов 0A, 0D, только если прошлый перенос был 0D.
0020+  D0A0             		; Иначе выводим 0D как есть, без второго сивола.
0021+  D0A0 FE 0D       		cpi	0Dh
0022+  D0A2 C2 B6 D0    		jnz	printerEcho_spc
0023+  D0A5 BE          		cmp	m
0024+  D0A6             
0025+  D0A6 0E 0A       printerEcho_0:	mvi	c, 0Ah
0026+  D0A8 CC 16 D1    		cz	printer
0027+  D0AB 0E 0D       		mvi	c, 0Dh
0028+  D0AD 77          		mov	m, a
0029+  D0AE C3 16 D1    		jmp	printer
0030+  D0B1             
0031+  D0B1             ; ---------------------------------------------------------------------------
0032+  D0B1             
0033+  D0B1             loc_D0B1:	; Если символ >= 0x87
0034+  D0B1 FE 87       		cpi	87h ; 'З'
0035+  D0B3 D2 E1 D0    		jnc	printerEcho_1
0036+  D0B6             
0037+  D0B6             printerEcho_spc:; Заменяем символ на пробел
0038+  D0B6 0E 20       		mvi	c, ' '
0039+  D0B8             
0040+  D0B8             doPrinterEcho:	; Если это удаление, выходим
0041+  D0B8 79          		mov	a, c
0042+  D0B9 FE 08       		cpi	8
0043+  D0BB C8          		rz
0044+  D0BC             		; Перевод курсора в начало экрана - выходим
0045+  D0BC FE 0C       		cpi	0Ch
0046+  D0BE C8          		rz
0047+  D0BF             		; Если <= 0x18
0048+  D0BF FE 18       		cpi	18h
0049+  D0C1 DA 98 D0    		jc	printerEcho_crLf
0050+  D0C4             		; Если <= 0x1C выходим
0051+  D0C4 FE 1C       		cpi	1Ch
0052+  D0C6 D8          		rc
0053+  D0C7             		; Если очистка экрана - выходим
0054+  D0C7 FE 1F       		cpi	1Fh
0055+  D0C9 C8          		rz
0056+  D0CA             		; Остальные служебные коды заменяем на пробел
0057+  D0CA DA B6 D0    		jc	printerEcho_spc
0058+  D0CD             		; Если <= 0x60, печатаем
0059+  D0CD FE 60       		cpi	60h
0060+  D0CF DA 16 D1    		jc	printer
0061+  D0D2             		; ?
0062+  D0D2 2A 2C C6    		lhld	v_koi8
0063+  D0D5 FE 7F       		cpi	7Fh
0064+  D0D7 D2 B1 D0    		jnc	 loc_D0B1 ;+
0065+  D0DA 2C          		inr	l
0066+  D0DB C2 16 D1    		jnz	printer
0067+  D0DE F6 80       		ori	80h
0068+  D0E0 4F          		mov	c, a
0069+  D0E1             
0070+  D0E1             printerEcho_1:  ; Если символ меньше 0xC0, выходим
0071+  D0E1 FE C0       		cpi	0C0h
0072+  D0E3 D8          		rc
0073+  D0E4             
0074+  D0E4             		; Если v_tapeMode = '0', выводим символ без изменений
0075+  D0E4 3A 5F C6    		lda	v_tapeMode
0076+  D0E7 D6 30       		sui	'0'
0077+  D0E9 CA 16 D1    		jz	printer
0078+  D0EC             
0079+  D0EC             		; Если v_tapeMode = '1', выводим с преобразованим
0080+  D0EC 3D          		dcr	a
0081+  D0ED C2 0B D1    		jnz	printerXlat
0082+  D0F0             
0083+  D0F0             		; Иначе перед выводом каждого симовола выводим 27, 82, 1
0084+  D0F0             		; Из документациии к принтерам Epson
0085+  D0F0             		; Select International character set France
0086+  D0F0 21 52 1B    		lxi	h, 1B52h
0087+  D0F3 3E 01       		mvi	a, 1
0088+  D0F5 CD FC D0    		call	printerEsc
0089+  D0F8             
0090+  D0F8             		; Вывод C на принтер
0091+  D0F8 CD 16 D1    		call	printer		; Вывод	байта на принтер
0092+  D0FB             
0093+  D0FB             		; Выводим 27, 82, 0
0094+  D0FB             		; Select International character set USA
0095+  D0FB AF          		xra	a
0096+  D0FC             
0097+  D0FC C5          printerEsc:	push	b
0098+  D0FD 4C          		 mov	c, h
0099+  D0FE CD 16 D1    		 call	printer		; Вывод	байта на принтер
0100+  D101 4D          		 mov	c, l
0101+  D102 CD 16 D1    		 call	printer		; Вывод	байта на принтер
0102+  D105 4F          		 mov	c, a
0103+  D106 CD 16 D1    		 call	printer		; Вывод	байта на принтер
0104+  D109 C1          		pop	b
0105+  D10A C9          		ret
0106+  D10B             
0107+  D10B             #endif0234   D10B             .include "printer.inc"
0001+  D10B             ;+---------------------------------------------------------------------------
0002+  D10B             ; RAMFOS
0003+  D10B             ; Печать на принтере
0004+  D10B             ;
0005+  D10B             ; 2013-11-01 Дизассемблировано vinxru
0006+  D10B             ;----------------------------------------------------------------------------
0007+  D10B             
0008+  D10B             #if NO_PRINTER==0
0009+  D10B             
0010+  D10B             printerXlat:	; c = v_printerXlat[c % 64];
0011+  D10B 79          		mov	a, c		
0012+  D10C E6 3F       		ani	63
0013+  D10E 21 79 D1    		lxi	h, v_printerXlat
0014+  D111 4F          		mov	c, a
0015+  D112 06 00       		mvi	b, 0
0016+  D114 09          		dad	b
0017+  D115 4E          		mov	c, m
0018+  D116             
0019+  D116 F5          printer:	push	psw
0020+  D117             
0021+  D117             		; Режим КР580ВВ55
0022+  D117 3E 90       		mvi	a, 90h
0023+  D119 32 E7 FF    		sta	IO_EXT_MODE
0024+  D11C             
0025+  D11C             		; Инвертируем и записываем данные
0026+  D11C 79          		mov	a, c
0027+  D11D 2F          		cma
0028+  D11E 32 E5 FF    		sta	IO_EXT_B
0029+  D121             
0030+  D121             printer_0:	 ; Пользователь может прервать ожидание
0031+  D121 3A E1 FF    		 lda	IO_KEYB_B		
0032+  D124 E6 02       		 ani	2
0033+  D126 CA 41 D1    		 jz	printer_break
0034+  D129             
0035+  D129             		 ; Ждем пока 6-ой бит не нулевой
0036+  D129 3A E4 FF    		 lda	IO_EXT_A
0037+  D12C E6 40       		 ani	40h
0038+  D12E C2 21 D1    		jnz	printer_0
0039+  D131             
0040+  D131             		; Строб
0041+  D131 3E 03       		mvi	a, 3
0042+  D133 32 E6 FF    		sta	IO_EXT_C
0043+  D136             
0044+  D136             		; Пауза
0045+  D136 00          		nop
0046+  D137 00          		nop
0047+  D138 00          		nop
0048+  D139 00          		nop
0049+  D13A 00          		nop
0050+  D13B 00          		nop
0051+  D13C 00          		nop
0052+  D13D             
0053+  D13D             		; Строб
0054+  D13D AF          		xra	a
0055+  D13E 32 E6 FF    		sta	IO_EXT_C
0056+  D141             
0057+  D141 F1          printer_break:	pop	psw
0058+  D142 C9          		ret
0059+  D143             
0060+  D143 00          		.db    0
0061+  D144~            #else
0062+  D144~            
0063+  D144~            printer:
0064+  D144~            printerHex:
0065+  D144~            printerEchoMode: 
0066+  D144~            doPrinterEcho:
0067+  D144~            		ret
0068+  D144             #endif0235   D144             .include "setColorChar.inc"
0001+  D144             ;+---------------------------------------------------------------------------
0002+  D144             ; RAMFOS
0003+  D144             ; Устанвока цвета фона или символов
0004+  D144             ; Вызывается при выводе кодов A0-BFh
0005+  D144             ;
0006+  D144             ; 2013-11-01 Дизассемблировано vinxru
0007+  D144             ;----------------------------------------------------------------------------
0008+  D144             
0009+  D144             setColorChar:   ; Переходим, если это символы B0-BFh
0010+  D144 FE 10       		cpi	10h
0011+  D146 D2 58 D1    		jnc	setColorChar_1
0012+  D149             
0013+  D149             		; Это символы А0-АFh
0014+  D149             
0015+  D149             		; Младшие 4 бита будут цветом символов (B = A << 4)
0016+  D149 E6 0F       		ani	0Fh
0017+  D14B 07          		rlc
0018+  D14C 07          		rlc
0019+  D14D 07          		rlc
0020+  D14E 07          		rlc
0021+  D14F 47          		mov	b, a
0022+  D150             
0023+  D150             		; Оставляем цвет фона (A = v_color & 0xF)
0024+  D150 3A 35 D2    		lda	v_color
0025+  D153 E6 0F       		ani	0Fh
0026+  D155             
0027+  D155             		; Устаналвиаем цвет (A | B)
0028+  D155 C3 60 D1    		jmp	setColorChar_2
0029+  D158             
0030+  D158             ; ---------------------------------------------------------------------------
0031+  D158             
0032+  D158             setColorChar_1:	; Младшие 4 бита будут цветом фона (B = A & 0x0F)
0033+  D158 E6 0F       		ani	0Fh
0034+  D15A 47          		mov	b, a
0035+  D15B             
0036+  D15B             		; Оставляем цвет символов (A = v_color & 0xF0)
0037+  D15B 3A 35 D2    		lda	v_color
0038+  D15E E6 F0       		ani	0F0h
0039+  D160             
0040+  D160             setColorChar_2:	; Устаналвиаем цвет (A | B)
0041+  D160 B0          		ora	b
0042+  D161 C3 68 D1    		jmp	setColor		0236   D164             .include "setColor.inc"
0001+  D164             ;+---------------------------------------------------------------------------
0002+  D164             ; RAMFOS
0003+  D164             ; Инверсия кода цвета
0004+  D164             ; Вызывается при выводе кода 89
0005+  D164             ;
0006+  D164             ; 2013-11-01 Дизассемблировано vinxru
0007+  D164             ;----------------------------------------------------------------------------
0008+  D164             
0009+  D164 3A 35 D2    inverseColor:	lda	v_color
0010+  D167 2F          		cma
0011+  D168             
0012+  D168             ;+---------------------------------------------------------------------------
0013+  D168             ; RAMFOS
0014+  D168             ; Стандартная точка входа C84B
0015+  D168             ; Установка цвета фона и букв
0016+  D168             ;
0017+  D168             ; На входе
0018+  D168             ;  Младшие биты A - цвета фона
0019+  D168             ;  Старшие биты A - цвет букв
0020+  D168             ;
0021+  D168             ; 2013-11-01 Дизассемблировано vinxru
0022+  D168             ;----------------------------------------------------------------------------
0023+  D168             
0024+  D168 32 35 D2    setColor:	sta	v_color
0025+  D16B 32 F8 FF    		sta	IO_COLOR
0026+  D16E C9          		ret0237   D16F             .include "popColor.inc"
0001+  D16F             ;+---------------------------------------------------------------------------
0002+  D16F             ; RAMFOS
0003+  D16F             ; Восстановление цвета из стека
0004+  D16F             ; Вызывается при выводе кода 87h
0005+  D16F             ;
0006+  D16F             ; 2013-11-01 Дизассемблировано vinxru
0007+  D16F             ;----------------------------------------------------------------------------
0008+  D16F             
0009+  D16F 2A 36 D2    popColor:	lhld	v_pushColor
0010+  D172 22 35 D2    		shld	v_color
0011+  D175 7D          		mov	a, l
0012+  D176 C3 68 D1    		jmp	setColor0238   D179             .include "bigRom.inc"
0001+  D179             ;+---------------------------------------------------------------------------
0002+  D179             ; RAMFOS
0003+  D179             ; Чтение ПЗУ Специалиста MX
0004+  D179             ;
0005+  D179             ; 2013-11-01 Разработано vinxru
0006+  D179             ;----------------------------------------------------------------------------
0007+  D179             
0008+  D179~            #if BIG_ROM
0009+  D179~            bigRom:		push	psw
0010+  D179~            
0011+  D179~            		; Если в HL было число < 8000h, то переходим к чтению ПЗУ MX
0012+  D179~            		mov	a, h
0013+  D179~            		xri	80h
0014+  D179~            		jm	bigRom_0
0015+  D179~            
0016+  D179~            		; Сохраняем HL и вычитаем из него 8000h
0017+  D179~            		push	h
0018+  D179~            		 mov	h, a		 
0019+  D179~            		 ; Первые 4 байта в ПЗУ СТД это программа инициаизации
0020+  D179~            		 inx	h
0021+  D179~            		 inx	h
0022+  D179~            		 inx	h
0023+  D179~            		 inx	h
0024+  D179~            		 ; Включаем ПЗУ СТД
0025+  D179~            		 sta	IO_PAGE_STD
0026+  D179~            		 xra	a
0027+  D179~            		 sta	IO_COLOR-800h
0028+  D179~            		 ; Чтение байта
0029+  D179~            		 mov	c, m
0030+  D179~            		 ; Включение ОЗУ MX и восстановление цвета
0031+  D179~            		 sta	IO_PAGE_RAM-800h
0032+  D179~            		 lda	v_color
0033+  D179~            		 sta	IO_COLOR
0034+  D179~            		pop	h
0035+  D179~            		; Восстанавливаем в A значение
0036+  D179~            		pop	psw
0037+  D179~            		ret
0038+  D179~            		
0039+  D179~            bigRom_0:	; Включение ПЗУ MX
0040+  D179~            		sta	IO_PAGE_ROM
0041+  D179~            		; Чтение байта
0042+  D179~            		mov	c, m
0043+  D179~            		; Включение ОЗУ MX
0044+  D179~            		sta	IO_PAGE_RAM
0045+  D179~            		; Восстанавливаем в A значение
0046+  D179~            		pop	psw
0047+  D179~            		ret      
0048+  D179             #endif0239   D179~            #if RELOCATE_FILE_FUNCTIONS
0240   D179~            .include "fileSaveHeader.inc"	; Їа®¤®«¦Ґ­ЁҐ ў pageWriteBlock
0241   D179~            .include "pageWriteBlock.inc"
0242   D179~            .include "fileSetType.inc"
0243   D179             #endif
0244   D179             
0245   D179             .include "v_printerXlat.inc"
0001+  D179             ;+---------------------------------------------------------------------------
0002+  D179             ; RAMFOS
0003+  D179             ; Таблица преобразования кодировки символов для принтера
0004+  D179             ;
0005+  D179             ; 2013-11-01 Дизассемблировано vinxru
0006+  D179             ;----------------------------------------------------------------------------
0007+  D179             
0008+  D179             #if NO_PRINTER==0
0009+  D179             
0010+  D179 EE D0 D1 E6 v_printerXlat:	.db 0EEh, 0D0h, 0D1h, 0E6h, 0D4h, 0D5h, 0E4h, 0D3h 
0010+  D17D D4 D5 E4 D3 
0011+  D181 E5 D8 D9 DA 		.db 0E5h, 0D8h, 0D9h, 0DAh, 0DBh, 0DCh, 0DDh, 0DEh
0011+  D185 DB DC DD DE 
0012+  D189 DF EF E0 E1 		.db 0DFh, 0EFh, 0E0h, 0E1h, 0E2h, 0E3h, 0D6h, 0D2h
0012+  D18D E2 E3 D6 D2 
0013+  D191 EC EB D7 E8 		.db 0ECh, 0EBh, 0D7h, 0E8h, 0EDh, 0E9h, 0E7h, 0EAh
0013+  D195 ED E9 E7 EA 
0014+  D199 CE B0 B1 C6 		.db 0CEh, 0B0h, 0B1h, 0C6h, 0B4h, 0B5h, 0C4h, 0B3h 
0014+  D19D B4 B5 C4 B3 
0015+  D1A1 C5 B8 B9 BA 		.db 0C5h, 0B8h, 0B9h, 0BAh, 0BBh, 0BCh, 0BDh, 0BEh
0015+  D1A5 BB BC BD BE 
0016+  D1A9 BF CF C0 C1 		.db 0BFh, 0CFh, 0C0h, 0C1h, 0C2h, 0C3h, 0B6h, 0B2h
0016+  D1AD C2 C3 B6 B2 
0017+  D1B1 CC CB B7 C8 		.db 0CCh, 0CBh, 0B7h, 0C8h, 0CDh, 0C9h, 0C7h, 0CAh
0017+  D1B5 CD C9 C7 CA 
0018+  D1B9             
0019+  D1B9             #endif0246   D1B9             
0247   D1B9             ; …б«Ё ­Ґв „Ћ‡“, в® ЁбЇ®«м§гҐвбп нв®в ­ҐЎ®«ми®© ЎгдҐа, зв® Ўл е®вм зв® в®
0248   D1B9             ; а Ў®в «®.
0249   D1B9             
0250   D1B9~            #if WORK_WITHOUT_ARAM != 0
0251   D1B9~            miniPage:
0252   D1B9~            .org $ + FILE_HEADER_SIZE + WORK_WITHOUT_ARAM + 2	; ‘®еа ­Ґ­ЁҐ д ©«  ў WORK_WITHOUT_ARAM Ў ©в
0253   D1B9~            miniPageEnd:
0254   D1B9~            .db 8							; ‘о¤  § ЇЁблў Ґвбп Ў ©в вҐа¬Ё­ в®а.
0255   D1B9             #endif
0256   D1B9             
0257   D1B9 4C 41 54 00 a_lat:		.db 04Ch, 041h, 054h, 0 ; "LAT"
0258   D1BD F2 F5 F3 00 a_rus:		.db 0F2h, 0F5h,	0F3h, 0	; "ђ“‘"
0259   D1C1             
0260   D1C1~            #if NICE
0261   D1C1~            a_inputFileName:.db ' ', 0C6h, 0C1h, 0CAh, 0CCh, 3Ah, ' ', C_PUSHCURSORL, 0 ; "д ©«" + § Ї®¬Ё­ ­ЁҐ Єгаб®а  бва®ЄЁ
0262   D1C1             #else
0263   D1C1 11 C6 C1 CA a_inputFileName:.db 11h, 0C6h, 0C1h, 0CAh, 0CCh, 3Ah, C_PUSHCURSORL, C_BEEP, 0 ; "д ©«" + § Ї®¬Ё­ ­ЁҐ Єгаб®а  бва®ЄЁ
0263   D1C5 CC 3A 8D 07 
0263   D1C9 00 
0264   D1CA             #endif
0265   D1CA             
0266   D1CA 0D 56 33 2E A_INPUTDATE
0266   D1CE 31 2F C4 C1 
0266   D1D2 D4 C1 3A 00 
0267   D1D6 8B 8F 20 F3 A_INITSCREEN
0267   D1DA D0 C5 C3 C9 
0267   D1DE C1 CC C9 D3 
0267   D1E2 D4 5F 4D 58 
0267   D1E6 5C 52 41 4D 
0267   D1EA 46 4F 53 5C 
0267   D1EE 8C 00 
0268   D1F0             
0269   D1F0             ; ===========================================================================
0270   D1F0             ; Џ…ђ…Њ…ЌЌ›…
0271   D1F0             
0272   D1F0~            #if $ > 0D1F0h
0273   D1F0~            ЋиЁЎЄ _з бвм_C800_­Ґ_ў«Ґ§« 
0274   D1F0             #endif
0275   D1F0             .org 0D1F0h
0276   D1F0             
0277   D1F0 00 00       v_tape:		.dw 0
0278   D1F2             
0279   D1F2             ; ‡ Ј®«®ў®Є д ©«  2
0280   D1F2             
0281   D1F2 D3 D3 D3    v_header2:	.db 0D3h, 0D3h, 0D3h		; вгв ¤®«¦­® Ўлвм 0D3h, 0D3h, 0D3h, Ё­ зҐ дг­ЄжЁп § Јаг§ЄЁ д ©«  ­Ґ а Ў® вҐв. ЌЁЄв® ­Ґ Ё­ЁжЁ «Ё§йЁагҐв нвЁ ЇҐаҐ¬Ґ­­лҐ!
0282   D1F5 20 20 20 20 v_header2_name:	.db ' ',' ',' ',' ',' ',' ',' ',' ',' '
0282   D1F9 20 20 20 20 
0282   D1FD 20 
0283   D1FE 20 20 20    v_header2_ext:	.db ' ',' ',' '
0284   D201 8B          v_header2_saved:.db 8Bh			; ЏаЁ§­ Є ­Ґ б®еа ­Ґ­­®бвЁ 8B, 8C
0285   D202 01 11 13    v_header2_date:	.db 01h, 11h, 13h	; „ в 
0286   D205 00 00 00 00 		.db 0, 0, 0, 0, 0	; ђҐ§Ґаў MXDOS
0286   D209 00 
0287   D20A 00 00       v_header2_start:.dw 0
0288   D20C 00 00       v_header2_end:	.dw 0
0289   D20E 00 00       v_header2_crc:	.dw 0
0290   D210             
0291   D210             ; Љ®­Ґж § Ј®«®ўЄ  д ©« 
0292   D210             
0293   D210 00          v_dblClear:	.db 0
0294   D211 00 00 00 00 		.db 0,0,0,0,0,0,0,0,0
0294   D215 00 00 00 00 
0294   D219 00 
0295   D21A 00 00 00 00 unk_D21A:	.db 0,0,0,0,0,0
0295   D21E 00 00 
0296   D220 00 00       v_pushCursorLn:	.dw 0
0297   D222 00 00       v_pushCursor:	.dw 0
0298   D224 00          v_escMode:	.db 0
0299   D225 00          v_key2:		.db 0
0300   D226 00          v_printerCrLf:	.db 0		
0301   D227 00 00       v_memTop:	.dw 0
0302   D229 00 00       v_key0:		.dw 0
0303   D22B 00 00       v_key1:		.dw 0
0304   D22D 00 00       v_oldSP:	.dw 0
0305   D22F 00          		.db 0
0306   D230 00 00       v_topLineHeight:.dw 0
0307   D232 00          v_screenHeight:	.db 0		; ‚лб®в  нЄа ­ 
0308   D233 00          v_screenHeight1:.db 0		; ‚лб®в  нЄа ­  - 10
0309   D234 00          v_bottomLineId:	.db 0
0310   D235 00          v_color:	.db 0		; ’ҐЄгйЁ© жўҐв д®­  Ё ЎгЄў
0311   D236 00 00       v_pushColor:	.dw 0
0312   D238 00 00 00 00 		.db 0,0,0,0
0313   D23C 00 00       v_aramPageEnd2:	.dw 0
0314   D23E 00          v_escRow:	.db 0
0315   D23F 00          		.db 0
0316   D240 00          v_lastKey:	.db 0
0317   D241 00          		.db 0
0318   D242 00          		.db 0
0319   D243 00 00       v_pageStart:	.dw 0		; Ќ з «® вҐЄгйҐ© бва ­Ёжл
0320   D245 00          v_page:		.db 0		; ’ҐЄгй п бва ­Ёж 
0321   D246             
0322   D246 00 00 00 00 		.db 0,0,0,0, 0,0,0,0, 0,0,0,0
0322   D24A 00 00 00 00 
0322   D24E 00 00 00 00 
0323   D252             
0324   D252             ; ‡ Ј®«®ў®Є д ©« 
0325   D252             ; ЏҐаўлҐ 15 Ў ©в (v_header, v_header_name, v_header_ext) зЁв Ґвбп дг­ЄжЁҐ© fileFromTapeCom
0326   D252             ; ЏҐаўлҐ 30 Ў ©в зЁв овбп дг­ЄжЁҐ© fileLoadHeader
0327   D252             
0328   D252             
0329   D252 D3 D3 D3    v_header:	.db 0D3h, 0D3h, 0D3h	; €¤Ґ­вЁдЁЄ в®а, ¤®«¦Ґ­ Ўлвм 0D3h, 0D3h, 0D3h
0330   D255 20 20 20 20 v_header_name:	.db ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '
0330   D259 20 20 20 20 
0331   D25D 20          v_header_spc:	.db ' '
0332   D25E 20 20 20    v_header_ext:	.db ' ', ' ', ' '
0333   D261 00          v_header_saved:	.db 0
0334   D262 00 00 00    v_header_date:	.db 0, 0, 0
0335   D265 00 00 00 00 v_header_unused:.db 0, 0, 0, 0, 0
0335   D269 00 
0336   D26A 00 00       v_header_start:	.dw 0
0337   D26C 00 00       v_header_stop:	.dw 0
0338   D26E 00 00       v_header_crc:	.dw 0
0339   D270             
0340   D270             ; Љ®­Ґж § Ј®«®ўЄ  д ©« 
0341   D270             
0342   D270 00 00       v_curFile:	.dw 0
0343   D272 00 00       v_printedFile:	.dw 0
0344   D274 00 00       f_nextFile:	.dw 0
0345   D276 00 00       f_fileBodySize:	.dw 0
0346   D278 00 00       f_fileSize:	.dw 0
0347   D27A 00 00       v_pageFreeTotal:.dw 0
0348   D27C 00 00       v_pageFreePtr:	.dw 0
0349   D27E             
0350   D27E F0 77 23 1B 		.db 0F0h, 77h, 23h, 1Bh, 7Ah, 0B3h, 0CAh, 95h, 0D2h, 0Ch, 0C2h, 78h, 0D2h, 22h, 0, 8Fh, 0EBh, 22h, 2, 8Fh, 0C3h, 52h, 0D2h
0350   D282 7A B3 CA 95 
0350   D286 D2 0C C2 78 
0350   D28A D2 22 00 8F 
0350   D28E EB 22 02 8F 
0350   D292 C3 52 D2 
0351   D295             
0352   D295 00 00 00 00 buffer:		.db 0,0,0,0,0,0,0,0,0	; €бЇ®«м§гҐвбп ¬ ЄбЁ¬г¬ 9 бЁ¬ў®«®ў ¤«п ўў®¤  ¤ вл. Џ®б«Ґ¤­Ё© Ў ©в ¤«п Є®­ва®«п ЇҐаҐЇ®«­Ґ­Ёп
0352   D299 00 00 00 00 
0352   D29D 00 
0353   D29E             
0354   D29E             ; ===========================================================================
0355   D29E             ; ЉЋ„
0356   D29E             
0357   F800             .org 0F800h
0358   F800             
0359   F800             .include "f800.inc"
0001+  F800             ;+---------------------------------------------------------------------------
0002+  F800             ; RAMFOS
0003+  F800             ; Точки входа
0004+  F800             ;
0005+  F800             ; 2013-11-01 Дизассемблировано vinxru
0006+  F800             ;----------------------------------------------------------------------------
0007+  F800             
0008+  F800 C3 7B F9    			jmp	init
0009+  F803 C3 03 C8    			jmp	j_keyWait
0010+  F806 C3 06 C8    			jmp	j_tapeRead
0011+  F809 C3 09 C8    			jmp	j_printChar
0012+  F80C C3 0C C8    			jmp	j_tapeWrite
0013+  F80F C3 0F C8    			jmp	j_printCharA
0014+  F812 C3 12 C8    			jmp	j_keyCheck
0015+  F815 C3 15 C8    			jmp	j_printHex
0016+  F818 C3 18 C8    			jmp	j_printString
0017+  F81B C3 1B C8    			jmp	j_keyScan
0018+  F81E C3 1E C8    			jmp	j_getCursorPos
0019+  F821 C3 21 C8    			jmp	j_getCharFromScr
0020+  F824 C3 E4 F8    			jmp	dlg_loadFile
0021+  F827 C3 FF F8    			jmp	fileSaveDlg
0022+  F82A C3 2A C8    			jmp	j_calcCrc
0023+  F82D C3 58 FF    			jmp	fileSetType
0024+  F830 C3 30 C8    			jmp	j_getMemTop
0025+  F833 C3 33 C8    			jmp	j_setMemTop
0026+  F836 C3 C5 FF    j_pageReadAny:		jmp	pageReadAny
0027+  F839 C3 D4 FF    j_pageWriteAny:		jmp	pageWriteAny
0028+  F83C C3 3C C8    			jmp	j_setCursorPos
0029+  F83F C3 F8 F8    			jmp	fileSave
0030+  F842 C3 EF F8    			jmp	fileSetAddr
0031+  F845 C3 43 FF    			jmp	fileGetName
0032+  F848 C3 4D FF    			jmp	fileSetName
0033+  F84B C3 A9 F8    			jmp	fileFind
0034+  F84E C3 21 FB    			jmp	fileLoad
0035+  F851 C3 EA FD    			jmp	fileDelete
0036+  F854~            #if NO_ROM_ENTRY | RKS_LOADER
0037+  F854~            #if NO_MXDOS
0038+  F854~            			jmp	init
0039+  F854~            #else
0040+  F854~            			jmp	loadMxDos
0041+  F854~            #endif
0042+  F854~            			jmp	exec
0043+  F854             #endif0360   F854             .include "loadMXDOS.inc"
0001+  F854             ;+---------------------------------------------------------------------------
0002+  F854             ; RAMFOS
0003+  F854             ; Загрузка и запуск MXDOS с дискеты
0004+  F854             ; Вызывается при нажатии на F6 из файловой панели
0005+  F854             ;
0006+  F854             ; 2013-11-01 Дизассемблировано vinxru
0007+  F854             ;----------------------------------------------------------------------------
0008+  F854             
0009+  F854             #if NO_MXDOS==0
0010+  F854             
0011+  F854             MXDOS_ADDR = 0E400h
0012+  F854             
0013+  F854 47          loadMxDos:	mov	b, a
0014+  F855             
0015+  F855             		; Установка головки и сектора
0016+  F855 3E 01       		mvi	a, 1
0017+  F857 32 F2 FF    		sta	IO_FLOPPY_HEAD
0018+  F85A 32 EA FF    		sta	IO_FLOPPY_SECTOR
0019+  F85D             
0020+  F85D             		; Пауза
0021+  F85D 26 13       		mvi	h, 13h
0022+  F85F 2B          loadMxDos_0:	 dcx	h
0023+  F860 7D          		 mov	a, l
0024+  F861 B4          		 ora	h
0025+  F862 C2 5F F8    		jnz	loadMxDos_0
0026+  F865             
0027+  F865             		; Устанавливаем головку
0028+  F865 32 F2 FF    		sta	IO_FLOPPY_HEAD
0029+  F868             
0030+  F868             		; Адрес загрузки
0031+  F868 21 00 E4    		lxi	h, MXDOS_ADDR
0032+  F86B             
0033+  F86B             		; Чтения сектора
0034+  F86B 3E 90       		mvi	a, 90h
0035+  F86D 32 E8 FF    		sta	IO_FLOPPY_CMD
0036+  F870             
0037+  F870             		; Ожидание готовности и проверка наличия дисковода
0038+  F870 3A E8 FF    loadMxDos_1:	 lda	IO_FLOPPY_CMD ; Если нет дисковода читается слово состояния процессора 83h
0039+  F873 17          		 ral
0040+  F874 D8          		 rc    ; Если седьмой бит не нулевой, значит дисковода нет
0041+  F875 1F          		 rar
0042+  F876 1F          		 rar   ; Если первый бит не нулевой, значит дисковод не готов.
0043+  F877 D2 70 F8    		jnc	loadMxDos_1
0044+  F87A             
0045+  F87A             		; Получение данных
0046+  F87A 0E 13       		mvi	c, 13h 
0047+  F87C 32 F0 FF    loadMxDos_2:	  sta	IO_FLOPPY_TRIG
0048+  F87F 3A EB FF    		  lda	IO_FLOPPY_DATA
0049+  F882 77          		  mov	m, a
0050+  F883 2C          		  inr	l
0051+  F884 C2 7C F8    		 jnz	loadMxDos_2
0052+  F887 24          		 inr	h
0053+  F888 0D          		 dcr	c
0054+  F889 F2 7C F8    		jp	loadMxDos_2
0055+  F88C             
0056+  F88C             		; Проверка
0057+  F88C 3A E8 FF    		lda	IO_FLOPPY_CMD
0058+  F88F EE 01       		xri	1
0059+  F891 B7          		ora	a
0060+  F892 3E D0       		mvi	a, 0D0h
0061+  F894 32 E8 FF    		sta	IO_FLOPPY_CMD
0062+  F897 C2 8E FE    		jnz	dlg_error
0063+  F89A             
0064+  F89A             		; Проверка
0065+  F89A 2B          		dcx	h
0066+  F89B 7E          		mov	a, m
0067+  F89C 2B          		dcx	h
0068+  F89D 34          		inr	m
0069+  F89E BE          		cmp	m
0070+  F89F C2 8E FE    		jnz	dlg_error
0071+  F8A2             
0072+  F8A2             		; Запуск MXDOS
0073+  F8A2 78          		.db 078h
0074+  F8A3 CD 00 E4    		call	MXDOS_ADDR
0075+  F8A6             
0076+  F8A6             		; При выходе из MXDOS выбираем ROM-диск
0077+  F8A6 06 80       		mvi	b, 80h
0078+  F8A8 C9          		ret
0079+  F8A9             #endif0361   F8A9             .include "fileFind.inc"
0001+  F8A9             ;+---------------------------------------------------------------------------
0002+  F8A9             ; RAMFOS
0003+  F8A9             ; Стандартная точка входа F84B
0004+  F8A9             ; Поиск файла имя которого задано функцией fileSetName (F848)
0005+  F8A9             ;
0006+  F8A9             ; На входе
0007+  F8A9             ;   v_header2_name  - Имя файла для поиска
0008+  F8A9             ;
0009+  F8A9             ; На выходе
0010+  F8A9             ;   v_curFile       - Адрес текущего файла в ДОЗУ
0011+  F8A9             ;   v_header        - Заголовок файла
0012+  F8A9             ;   f_fileBodySize  - Длина файла без заголовка -1
0013+  F8A9             ;   f_fileSize      - Длина файла с заголовком
0014+  F8A9             ;   f_nextFile      - Адрес следующего файла в ДОЗУ
0015+  F8A9             ;   В ДОЗУ по адресу v_curFile + f_fileSize записывается v_curFile
0016+  F8A9             ;
0017+  F8A9             ; Изменяет переменные в случае ошибки в ДОЗУ. ДОЗУ не изменяется.
0018+  F8A9             ;   v_pageFreePtr   - Указатель на первый свободный байт
0019+  F8A9             ;   v_pageFreeTotal - Свободно байт
0020+  F8A9             ;
0021+  F8A9             ; 2013-11-01 Дизассемблировано vinxru
0022+  F8A9             ;----------------------------------------------------------------------------
0023+  F8A9             
0024+  F8A9             fileFind:	; Начальная страница
0025+  F8A9 06 00       		mvi	b, 0
0026+  F8AB             fileFindEx:	 ; Ищем файл в странице из регистра B
0027+  F8AB CD C7 F8    		 call	fileFind1
0028+  F8AE             
0029+  F8AE             		 ; ?
0030+  F8AE CA B0 FB    		 jz	fileLoadHeader2
0031+  F8B1             
0032+  F8B1             		 ; Следующая страница (регистр B), если есть
0033+  F8B1 CD B8 F8    		 call	pageNext
0034+  F8B4 D2 AB F8    		jnc	fileFindEx
0035+  F8B7 C9          		ret0362   F8B8             .include "pageNext.inc"
0001+  F8B8             ;+---------------------------------------------------------------------------
0002+  F8B8             ; RAMFOS
0003+  F8B8             ; Следующая страница
0004+  F8B8             ;
0005+  F8B8             ; На входе
0006+  F8B8             ;  b - страница
0007+  F8B8             ;
0008+  F8B8             ; На выходе
0009+  F8B8             ;  jc - ошибка
0010+  F8B8             ;  b  - страница
0011+  F8B8             ;
0012+  F8B8             ; 2013-11-01 Дизассемблировано vinxru
0013+  F8B8             ;----------------------------------------------------------------------------
0014+  F8B8             
0015+  F8B8             pageNext:	; У ROM-диска (код 0x80) может быть только одна страница, выходим с флагом C
0016+  F8B8 78          		mov	a, b
0017+  F8B9 17          		ral
0018+  F8BA D8          		rc
0019+  F8BB 1F          		rar
0020+  F8BC             
0021+  F8BC             		; Отфильтровываем флаги
0022+  F8BC             #if ARAM_MAX_PAGE <= 7
0023+  F8BC E6 07       		ani	7
0024+  F8BE~            #else
0025+  F8BE~            		ani	0Fh
0026+  F8BE             #endif
0027+  F8BE             		; Максимум страниц
0028+  F8BE 4F          		mov	c, a
0029+  F8BF 0C          		inr	c
0030+  F8C0 3A 3D C6    		lda	v_aramMaxPage
0031+  F8C3 B9          		cmp	c
0032+  F8C4 D8          		rc
0033+  F8C5             
0034+  F8C5             		; Увеличиваем страницу
0035+  F8C5 04          		inr	b
0036+  F8C6 C9          		ret0363   F8C7             .include "fileFind1.inc"
0001+  F8C7             ;----------------------------------------------------------------------------
0002+  F8C7             ; RAMFOS
0003+  F8C7             ; Поиск файла в странице имя которого задано функцией F848
0004+  F8C7             ;
0005+  F8C7             ; На входе
0006+  F8C7             ;   v_header2_name  - Имя файла для поиска
0007+  F8C7             ;   b, v_page       - Номер текущей страницы
0008+  F8C7             ;
0009+  F8C7             ; На выходе
0010+  F8C7             ;   v_curFile       - Адрес текущего файла в ДОЗУ
0011+  F8C7             ;   v_header        - Заголовок файла
0012+  F8C7             ;   f_fileBodySize  - Длина файла без заголовка - 1
0013+  F8C7             ;   f_fileSize      - Длина файла с заголовком
0014+  F8C7             ;   f_nextFile      - Адрес следующего файла в ДОЗУ
0015+  F8C7             ;   В ДОЗУ по адресу v_curFile + f_fileSize записывается v_curFile
0016+  F8C7             ;   v_pageFreePtr   - Указатель на первый свободный байт
0017+  F8C7             ;   v_pageFreeTotal - Свободно байт
0018+  F8C7             ;
0019+  F8C7             ; 2013-11-01 Дизассемблировано vinxru
0020+  F8C7             ;----------------------------------------------------------------------------
0021+  F8C7             
0022+  F8C7             fileFind1:      ; Поиск происходит в два этапа
0023+  F8C7             		; Сначала мы расчитываем v_pageFreePtr, v_pageFreeTotal
0024+  F8C7 C5          		push	b
0025+  F8C8 78          		 mov	a, b
0026+  F8C9 F6 10       		 ori	10h
0027+  F8CB 47          		 mov	b, a
0028+  F8CC CD D0 F8    		 call	fileFind1_0
0029+  F8CF C1          		pop	b
0030+  F8D0             
0031+  F8D0             		; А при втором проходе сравниваем имя файла
0032+  F8D0             
0033+  F8D0             fileFind1_0:	; Получаем B - текущая страница, HL - начало страницы
0034+  F8D0 CD 9E FC    		call	fileSetPage
0035+  F8D3             fileFind2_1:	 ; Загружаем следующий заголовок файла
0036+  F8D3 CD 5E FB    		 call	fileLoadHeader
0037+  F8D6             		 ; Нет файлов, выходим с флагом NZ
0038+  F8D6 C0          		 rnz
0039+  F8D7             		 ; Во втором проходе (b & 0x10 == 0) сравниваем имя файла
0040+  F8D7 78          		 mov	a, b
0041+  F8D8 E6 10       		 ani	10h
0042+  F8DA CC DA FD    		 cz	compareFileName
0043+  F8DD             		 ; Если файл найден, выходим с флагом Z
0044+  F8DD C8          		 rz
0045+  F8DE             		 ; Продолжаем поиск со следующего файла
0046+  F8DE 2A 74 D2    		 lhld	f_nextFile
0047+  F8E1 C3 D3 F8    		jmp	fileFind2_1
0364   F8E4             .include "dialog.inc"		; Їа®¤®«¦Ґ­ЁҐ ў fileSaveHeader
0001+  F8E4             ;----------------------------------------------------------------------------
0002+  F8E4             ; RAMFOS
0003+  F8E4             ; Файловая панель
0004+  F8E4             ;
0005+  F8E4             ; 2013-11-01 Дизассемблировано vinxru
0006+  F8E4             ;----------------------------------------------------------------------------
0007+  F8E4             
0008+  F8E4~            #if ALL_CHARS
0009+  F8E4~            #define BORDER_BL  27,12
0010+  F8E4~            #define BORDER_BL1 12
0011+  F8E4~            #define BORDER_B   27,13
0012+  F8E4~            #define BORDER_B1  13
0013+  F8E4~            #define BORDER_BR  27,24
0014+  F8E4~            #define BORDER_BR1 24
0015+  F8E4~            #define BORDER_L   27, 8
0016+  F8E4~            #define BORDER_L1  8
0017+  F8E4~            #define BORDER_R   27, 10
0018+  F8E4~            #define BORDER_R1  10
0019+  F8E4~            #define BORDER_H   27, 25
0020+  F8E4~            #define BORDER_H1  25
0021+  F8E4             #else
0022+  F8E4             BORDER_BL  = 15h
0023+  F8E4             BORDER_BL1 = 15h
0024+  F8E4             BORDER_B   = 14h
0025+  F8E4             BORDER_B1  = 14h
0026+  F8E4             BORDER_BR  = 16h
0027+  F8E4             BORDER_BR1 = 16h
0028+  F8E4             BORDER_L   = 11h
0029+  F8E4             BORDER_L1  = 11h
0030+  F8E4             BORDER_R   = 6
0031+  F8E4             BORDER_R1  = 6
0032+  F8E4             BORDER_H   = 6
0033+  F8E4             BORDER_H1  = 6
0034+  F8E4             #endif
0035+  F8E4             
0036+  F8E4             dlg_loadFile:	; Активная страница
0037+  F8E4 3A 45 D2    		lda	v_page
0038+  F8E7 E6 0F       		ani	0Fh
0039+  F8E9             		; Режим выбора файла (6 ой бит)
0040+  F8E9 F6 40       		ori	40h
0041+  F8EB 47          		mov	b, a
0042+  F8EC C3 92 F9    		jmp	dlg_main
0043+  F8EF             
0044+  F8EF             ; ---------------------------------------------------------------------------
0045+  F8EF             
0046+  F8EF             .include "fileSetAddr.inc"
0001++ F8EF             ;+---------------------------------------------------------------------------
0002++ F8EF             ; RAMFOS
0003++ F8EF             ; Стандартная точка входа F842
0004++ F8EF             ; Установка адреса загрузки в память текущего файла
0005++ F8EF             ;
0006++ F8EF             ; На входе
0007++ F8EF             ;   v_header2_name - имя файла
0008++ F8EF             ;   hl             - новый адрес
0009++ F8EF             ;
0010++ F8EF             ; 2013-11-01 Дизассемблировано vinxru
0011++ F8EF             ;----------------------------------------------------------------------------
0012++ F8EF             
0013++ F8EF             fileSetAddr:	; Ищем файл
0014++ F8EF E5          		push	h
0015++ F8F0 CD A9 F8    		 call	fileFind
0016++ F8F3 E1          		pop	h
0017++ F8F4             
0018++ F8F4             		; Файл не найден
0019++ F8F4 C0          		rnz
0020++ F8F5             
0021++ F8F5             		; Устаналиваем адрес загрузки
0022++ F8F5 C3 F5 FA    		jmp	fileLoadSetAddr
0047+  F8F8             .include "fileSave.inc"	; Продолжение
0001++ F8F8             ;+---------------------------------------------------------------------------
0002++ F8F8             ; RAMFOS
0003++ F8F8             ; Сохранить файл
0004++ F8F8             ;
0005++ F8F8             ; 2013-11-01 Дизассемблировано vinxru
0006++ F8F8             ;----------------------------------------------------------------------------
0007++ F8F8             
0008++ F8F8             fileSave:	; Найти свободную страницу и рассчитать контрольную сумму
0009++ F8F8 CD 3A F9    		call	fileFindFree
0010++ F8FB D8          		rc
0011++ F8FC             
0012++ F8FC             		; Общая функция
0013++ F8FC C3 1B F9    		jmp	fileSaveCom		
0014++ F8FF             
0015++ F8FF             ;----------------------------------------------------------------------------
0016++ F8FF             ; RAMFOS
0017++ F8FF             ; Сохранить файл с вводом имени с клавиатуры
0018++ F8FF             ;
0019++ F8FF             ; 2013-11-01 Дизассемблировано vinxru
0020++ F8FF             ; ---------------------------------------------------------------------------
0021++ F8FF             
0022++ F8FF             fileSaveDlg:	; Вывод текста "Сохранить?"
0023++ F8FF CD B2 FE    		call	printStringEx
0024++ F902 8B 90 20 F3 		.db C_INVERSE, C_BOTTOMLINE, ' ', 0F3h, 0CFh, 0C8h, 0D2h, 0C1h, 0CEh, 0C9h, 0D4h, 0D8h, 3Fh, C_NORMAL, 0
0024++ F906 CF C8 D2 C1 
0024++ F90A CE C9 D4 D8 
0024++ F90E 3F 8C 00 
0025++ F911             
0026++ F911             		; Ввод имени файла
0027++ F911 CD 45 C8    		call	j_inputFileName
0028++ F914 C8          		rz
0029++ F915             
0030++ F915             		; Поиск подходящей страницы
0031++ F915 CD 3A F9    		call	fileFindFree
0032++ F918             
0033++ F918             		; В случае ошибки вывести "мал диск" и ждать нажания ESC
0034++ F918 DA A3 FE    		jc	outOfSpace
0035++ F91B             
0036++ F91B             fileSaveCom:	; Запись заголовка файла на диск
0037++ F91B 01 F2 D1    		lxi	b, v_header2
0038++ F91E CD 2D FF    		call	fileSaveHeaderAny
0039++ F921             
0040++ F921             		; BC = начало файла, DE = длина файла - 1
0041++ F921 E5          		push	h
0042++ F922 CD B4 FD    		 call	fileGetStartAndSize2
0043++ F925 EB          		 xchg
0044++ F926 4D          		 mov	c, l
0045++ F927 44          		 mov	b, h
0046++ F928 E1          		pop	h
0047++ F929             
0048++ F929             		; Запись тела файла (запись на диск по адресу HL из памяти BC длиной DE+1)
0049++ F929 CD 33 FF    		call	pageWriteBlock 
0050++ F92C             
0051++ F92C             		; Продолжение в fileChanged		0048+  F92C             .include "fileChanged.inc"
0001++ F92C             ;+---------------------------------------------------------------------------
0002++ F92C             ; RAMFOS
0003++ F92C             ; Вызывается после создания/удаления файла
0004++ F92C             ;
0005++ F92C             ; Вход
0006++ F92C             ;  hl - Первый байт после тела файла. У второй функции соответственно +2.
0007++ F92C             ;
0008++ F92C             ; 2013-11-01 Дизассемблировано vinxru
0009++ F92C             ;----------------------------------------------------------------------------                   
0010++ F92C             
0011++ F92C             fileChanged2: 	; Пропускаем два байта, они будут заполнены при просмотре.
0012++ F92C 23          		inx	h
0013++ F92D 23          		inx	h
0014++ F92E             
0015++ F92E             fileChanged:    ; Обновляем указатель свободного места
0016++ F92E 22 7C D2    		shld	v_pageFreePtr
0017++ F931             
0018++ F931             		; Записываем значение 8 по этому адресу, что бы там ни 
0019++ F931             		; в коем случае не было D3, D3, D3
0020++ F931 0E 08       		mvi	c, 8
0021++ F933 CD D1 FF    		call	pageWrite
0022++ F936             
0023++ F936             		; Звуковой сигнал
0024++ F936 0D          		dcr	c
0025++ F937 C3 09 C8    		jmp	j_printChar
0049+  F93A             .include "fileFindFree.inc"
0001++ F93A             ;+---------------------------------------------------------------------------
0002++ F93A             ; RAMFOS
0003++ F93A             ; Расчет контрольной суммы сохраняемого файла, поиск страницы
0004++ F93A             ; с подходящим cвободным объемом, удаление файла с именем v_header2_name
0005++ F93A             ;
0006++ F93A             ; На входе
0007++ F93A             ;  v_header2_name  - Имя файла для удаления
0008++ F93A             ;  f_header2_start - Адрес начала файла
0009++ F93A             ;  f_header2_stop  - Адрес конца файла
0010++ F93A             ;
0011++ F93A             ; На выходе
0012++ F93A             ;  jnc             - Страница найдена
0013++ F93A             ;  f_header2_crc   - Контрольная сумма
0014++ F93A             ;  v_page, b       - Страница
0015++ F93A             ;
0016++ F93A             ; 2013-11-01 Дизассемблировано vinxru
0017++ F93A             ;----------------------------------------------------------------------------
0018++ F93A             
0019++ F93A             fileFindFree:	; Расчитываем контрольную сумму в v_header2_crc
0020++ F93A 22 0A D2    		shld	v_header2_start	
0021++ F93D EB          		xchg
0022++ F93E 22 0C D2    		shld	v_header2_end		
0023++ F941 EB          		xchg
0024++ F942 CD 2A C8    		call	j_calcCrc
0025++ F945 60          		mov	h, b
0026++ F946 69          		mov	l, c
0027++ F947 22 0E D2    		shld	v_header2_crc
0028++ F94A             
0029++ F94A             		; Поиск по всем страницам и удаление файла
0030++ F94A 06 20       		mvi	b, 20h
0031++ F94C CD AB F8    		call	fileFindEx
0032++ F94F             
0033++ F94F             		; Поиск файла начиная с нулевой страницы
0034++ F94F 06 20       		mvi	b, 20h
0035++ F951             fileFindFree_0:	 ; Определяем свободное место на странице
0036++ F951 CD C7 F8    		 call	fileFind1
0037++ F954             		 
0038++ F954             		 ; de = расчитываем требуемый размер файла, почему то в цикле.
0039++ F954 CD B4 FD    		 call	fileGetStartAndSize2
0040++ F957 11 21 00    		 lxi	d, FILE_HEADER_SIZE + 3
0041++ F95A 19          		 dad	d
0042++ F95B EB          		 xchg		
0043++ F95C             
0044++ F95C             		 ; Выходим с флагом NC, если места достаточно
0045++ F95C 2A 7A D2    		 lhld	v_pageFreeTotal
0046++ F95F D4 54 C8    		 cnc	j_cmp_hl_de
0047++ F962 D0          		 rnc		
0048++ F963             
0049++ F963             		 ; Следующая страница
0050++ F963 CD B8 F8    		 call	pageNext
0051++ F966 D2 51 F9    		jnc	fileFindFree_0
0052++ F969 C9          		ret0050+  F96A             
0051+  F96A             ; ---------------------------------------------------------------------------
0052+  F96A             ; УДАЛЕНИЕ ДАТЫ
0053+  F96A             
0054+  F96A             dlg_f2_alt:	; Если режим выбора файла, то выходим
0055+  F96A 78          		mov	a, b
0056+  F96B 17          		ral
0057+  F96C 17          		ral
0058+  F96D D8          		rc
0059+  F96E             
0060+  F96E             		; Вывод сообщения "дату удалить"
0061+  F96E 11 89 FF    		lxi	d, a_deleteDate
0062+  F971 CD BA F9    		call	dlg_msgYesNo
0063+  F974             
0064+  F974             .include "deleteDate.inc"
0001++ F974             ;+---------------------------------------------------------------------------
0002++ F974             ; RAMFOS
0003++ F974             ; Удаление текущей даты
0004++ F974             ; Последующая перерисовка верхней строки в init приведет в вызову функции 
0005++ F974             ; ввода даты
0006++ F974             ;
0007++ F974             ; 2013-11-01 Дизассемблировано vinxru
0008++ F974             ;----------------------------------------------------------------------------
0009++ F974             
0010++ F974~            #if DATE_IN_RAM
0011++ F974~            		; Сохраняем признак того, что дата не введена
0012++ F974~            		mvi	a, 8Ch 
0013++ F974~            		sta	v_header2_saved
0014++ F974             #else
0015++ F974             		; Сохраняем признак того, что дата не введена в ДОЗУ
0016++ F974             		; На входе A != 8Bh
0017++ F974 2A 1C C6    		lhld	v_aramPageEnd
0018++ F977 23          		inx	h
0019++ F978 CD D1 FF    		call	pageWrite
0020++ F97B             #endif
0021++ F97B             		; Функция продолжается в init0065+  F97B             
0066+  F97B             		; Далее init
0067+  F97B             
0068+  F97B             ; ---------------------------------------------------------------------------
0069+  F97B             
0070+  F97B             .include "init.inc"	; Продолжение в dlg_main
0001++ F97B             ;+---------------------------------------------------------------------------
0002++ F97B             ; RAMFOS
0003++ F97B             ; Стандартная точка входа F800
0004++ F97B             ; Инициализация
0005++ F97B             ;
0006++ F97B             ; 2013-11-01 vinxru
0007++ F97B             ;----------------------------------------------------------------------------
0008++ F97B             
0009++ F97B             init:		; Включение ОЗУ
0010++ F97B 32 FC FF    		sta	IO_PAGE_RAM
0011++ F97E             	
0012++ F97E             		; Инициализация	стека
0013++ F97E 31 FF D2    		lxi	sp, STACK_TOP
0014++ F981             
0015++ F981             		; Инициализация BIOS
0016++ F981 CD 00 C8    		call	j_biosInit
0017++ F984             
0018++ F984             		; Верхушка памяти
0019++ F984 21 FF 8F    		lxi	h, RAM_TOP
0020++ F987 CD 33 C8    		call	j_setMemTop
0021++ F98A             
0022++ F98A             		; Фильтр
0023++ F98A 21 75 FF    		lxi	h, a_12spaces + 9
0024++ F98D CD 58 FF    		call	fileSetType
0025++ F990             
0026++ F990             		; Диск
0027++ F990 06 00       		mvi	b, DLG_START_PAGE
0028++ F992             
0029++ F992             		; Продолжается в dlg_main0071+  F992             
0072+  F992             ; ---------------------------------------------------------------------------
0073+  F992             
0074+  F992             dlg_main:	
0075+  F992             		; Очищаем экран, перерисовываем заголовок и нижнюю строку
0076+  F992 CD C7 FC    		call	dlg_pageChanged
0077+  F995             	
0078+  F995             dlg_main_0:
0079+  F995             		; Сохраняем текущий файл и положение курсора
0080+  F995~            #if DLG_CURSOR_AT_TOP
0081+  F995~            		xchg
0082+  F995~            		lhld	v_curFile
0083+  F995~            		push	h
0084+  F995~            		lhld	v_cursorPos
0085+  F995~            		push	h
0086+  F995~            		xchg
0087+  F995             #endif	
0088+  F995             		; Выводим все файлы на экран
0089+  F995 CD 5E FB    dlg_main_1:	 call	fileLoadHeader
0090+  F998 F5          		 push	psw
0091+  F999 CD FD FB    		  call	dlg_printFile
0092+  F99C F1          		 pop	psw
0093+  F99D 2A 74 D2    		 lhld	f_nextFile
0094+  F9A0 CA 95 F9    		jz	dlg_main_1
0095+  F9A3             
0096+  F9A3~            #if NICE
0097+  F9A3~            dlg_z1:
0098+  F9A3~            		call	getCursorPos
0099+  F9A3~            		mov	a, h
0100+  F9A3~            		sui	16h
0101+  F9A3~            		jnc	dlg_z0
0102+  F9A3~            		; 46 пробелов
0103+  F9A3~            		lxi	b, (46 << 8) + ' '
0104+  F9A3~            		call	printChars	
0105+  F9A3~            		; Правая граница
0106+  F9A3~            		call	dlg_rightEdge
0107+  F9A3~            		jmp	dlg_z1
0108+  F9A3~            dlg_z0:		
0109+  F9A3             #endif		
0110+  F9A3             
0111+  F9A3             		; Рисуем нижнюю границу
0112+  F9A3 CD D9 F9    		call	dlg_bottomEdge
0113+  F9A6             		; Восстанавливаем положение курсора
0114+  F9A6~            #if DLG_CURSOR_AT_TOP
0115+  F9A6~            		pop	h
0116+  F9A6~            		shld	v_cursorPos
0117+  F9A6~            		pop	h
0118+  F9A6~            		shld	v_curFile
0119+  F9A6             #else
0120+  F9A6 2A 72 D2    		lhld    v_printedFile
0121+  F9A9             #endif	
0122+  F9A9 CD 3A FA    		call    dlg_reloadItem
0123+  F9AC             
0124+  F9AC CD B2 FE    		call    printStringEx
0125+  F9AF             #if NICE==0
0126+  F9AF 07          		.db C_BEEP
0127+  F9B0             #endif
0128+  F9B0 8E 93 8C 00 		.db C_POPCURSORL, C_PUSHCURSORS, C_NORMAL, 0
0129+  F9B4             
0130+  F9B4 2A 70 D2    		lhld	v_curFile
0131+  F9B7 C3 95 F9    		jmp	dlg_main_0
0132+  F9BA             
0133+  F9BA             ; ---------------------------------------------------------------------------
0134+  F9BA             
0135+  F9BA             dlg_msgYesNo:	; Вывод сообщения
0136+  F9BA CD 85 FD    		call	dlg_msg
0137+  F9BD             
0138+  F9BD             dlg_yesNo:	; Ввод строки из 4-х сиволов
0139+  F9BD 21 95 D2    		lxi	h, buffer
0140+  F9C0 11 FF 04    		lxi	d, 4FFh
0141+  F9C3 CD 36 C8    		call	j_input
0142+  F9C6 77          		mov	m, a
0143+  F9C7             
0144+  F9C7             		; Если нажат ENTER, печатаем символ 0E и выходим
0145+  F9C7 3E 0E       		mvi	a, 0Eh
0146+  F9C9 DA 0F C8    		jc	j_printCharA	; Выход
0147+  F9CC             
0148+  F9CC             		; Если нажат не ESC, повторяем
0149+  F9CC C2 BD F9    		jnz	dlg_yesNo
0150+  F9CF             
0151+  F9CF             		; Выкидываем адрес возрата
0152+  F9CF E1          		pop	h
0153+  F9D0             		
0154+  F9D0             loc_F9D0:	; Стираем то, что нарисовали
0155+  F9D0 CD D9 F9    		call	dlg_bottomEdge
0156+  F9D3             
0157+  F9D3             		; Перезагрузить и перерисовать выбранный файл
0158+  F9D3 2A 70 D2    		lhld    v_curFile
0159+  F9D6 C3 3A FA    		jmp     dlg_reloadItem
0160+  F9D9             
0161+  F9D9             ; ---------------------------------------------------------------------------
0162+  F9D9             ; Рисование нижней границы
0163+  F9D9             
0164+  F9D9             dlg_bottomEdge:
0165+  F9D9             		; Темный фон, восстановление курсора экрана, удаление, какой то символ
0166+  F9D9 CD B2 FE    		call	printStringEx
0167+  F9DC 8C 94 08 15 		.db 8Ch, 94h, 8, BORDER_BL, 0
0167+  F9E0 00 
0168+  F9E1             	
0169+  F9E1             		; 46 символов 0x14
0170+  F9E1 01 14 2E    		lxi	b, 2E00h | BORDER_B1
0171+  F9E4             
0172+  F9E4 CD 89 FC    		call	printChars
0173+  F9E7             
0174+  F9E7             		; Символ 16, восстановление курсора строки
0175+  F9E7 CD B2 FE    		call	printStringEx
0176+  F9EA 16 8E 00    		.db BORDER_BR, 8Eh, 0
0177+  F9ED             
0178+  F9ED C9          		ret
0179+  F9EE             
0180+  F9EE             ; ---------------------------------------------------------------------------
0181+  F9EE             ; Клавиша вниз.
0182+  F9EE             
0183+  F9EE             dlg_down:	; Если это последний файл, переходим на следующую страницу
0184+  F9EE CD AA FD    		call	dlg_isLastLine
0185+  F9F1 D2 06 FA    		jnc	dlg_nextPage
0186+  F9F4             
0187+  F9F4             		; Если это последняя строка на экране, перерисовываем экран
0188+  F9F4             		; так что наша строка оказывается сверху.
0189+  F9F4 3A 03 FC    		lda	v_dlgOffset+1
0190+  F9F7 3D          		dcr	a
0191+  F9F8 B9          		cmp	c
0192+  F9F9 CA CA FC    		jz	dlg_drawItems
0193+  F9FC             
0194+  F9FC             		; Помещаем в стек адрес следующего файла
0195+  F9FC 2A 74 D2    		lhld	f_nextFile
0196+  F9FF E5          		push	h
0197+  FA00             
0198+  FA00             		; Стираем курсор
0199+  FA00 CD DB FB    		call	printFileHeaderDark
0200+  FA03             		
0201+  FA03 C3 30 FA    		jmp	dlg_upDownInt
0202+  FA06             		
0203+  FA06             ; ---------------------------------------------------------------------------
0204+  FA06             
0205+  FA06             dlg_nextPage:	; Следующая страница (в регистре b)
0206+  FA06 CD B8 F8    		call	pageNext
0207+  FA09             
0208+  FA09             		; Это была последняя страница
0209+  FA09 D8          		rc
0210+  FA0A             
0211+  FA0A             		; Страница была изменена
0212+  FA0A C3 C7 FC    		jmp	dlg_pageChanged
0213+  FA0D             
0214+  FA0D             ; ---------------------------------------------------------------------------
0215+  FA0D             
0216+  FA0D             dlg_prevPage:	; Если это нулевая страница, выходим
0217+  FA0D 78          		mov	a, b
0218+  FA0E             #if ARAM_MAX_PAGE <= 7
0219+  FA0E E6 07       		ani	7
0220+  FA10~            #else
0221+  FA10~            		ani	0Fh	; Старшие биты выполняют спец функции
0222+  FA10             #endif
0223+  FA10 CA 3D FA    		jz	dlg_drawItem
0224+  FA13             
0225+  FA13             		; Уменьшаем страницу
0226+  FA13 05          		dcr	b
0227+  FA14 C3 C7 FC    		jmp	dlg_pageChanged
0228+  FA17             
0229+  FA17             ; ---------------------------------------------------------------------------
0230+  FA17             
0231+  FA17             dlg_up:		; Если это первая строка, то перейти на предыдущую страницу
0232+  FA17 2A 70 D2    		lhld	v_curFile
0233+  FA1A CD 54 C8    		call	j_cmp_hl_de
0234+  FA1D CA 0D FA    		jz	dlg_prevPage
0235+  FA20             
0236+  FA20             		; Непонятно что в с
0237+  FA20 79          		mov	a, c
0238+  FA21 FE 03       		cpi	3
0239+  FA23 CA C7 FC    		jz	dlg_pageChanged
0240+  FA26             
0241+  FA26             .include	"filePrev.inc"
0001++ FA26             ;+---------------------------------------------------------------------------
0002++ FA26             ; RAMFOS
0003++ FA26             ; Получить адрес предыдущего файла
0004++ FA26             ;
0005++ FA26             ; На входе
0006++ FA26             ;  hl - адрес файла
0007++ FA26             ;
0008++ FA26             ; На выходе
0009++ FA26             ;  bc - адрес предыдущего файла
0010++ FA26             ;
0011++ FA26             ; 2013-11-01 Дизассемблировано vinxru
0012++ FA26             ;----------------------------------------------------------------------------
0013++ FA26             
0014++ FA26             		; Последние два байта файла это указатель на начало.
0015++ FA26 2B          		dcx	h
0016++ FA27 CD C2 FF    		call	pageRead
0017++ FA2A 41          		mov	b, c
0018++ FA2B 2B          		dcx	h
0019++ FA2C CD C2 FF    		call	pageRead
0242+  FA2F             
0243+  FA2F             		; Сохраняем адрес файла
0244+  FA2F C5          		push	b
0245+  FA30             
0246+  FA30             dlg_upDownInt:	; Стираем курсор
0247+  FA30 CD DB FB    		call	printFileHeaderDark
0248+  FA33             
0249+  FA33             dlg_upDownInt2:
0250+  FA33             		; Перемещаем курсор вверх или вниз
0251+  FA33 3A 40 D2    		lda	v_lastKey
0252+  FA36 CD 0F C8    		call	j_printCharA
0253+  FA39             
0254+  FA39             		; Восстаналваем HL
0255+  FA39 E1          		pop	h
0256+  FA3A             
0257+  FA3A             dlg_reloadItem:	; Загрузить заголовок файла
0258+  FA3A CD 5E FB    		call	fileLoadHeader
0259+  FA3D             
0260+  FA3D             dlg_drawItem:	; Вывести название файла
0261+  FA3D CD D6 FB    		call	printFileHeaderLight
0262+  FA40 4A          		mov	c, d
0263+  FA41             
0264+  FA41             		; Ждем символ с кодом <0x20
0265+  FA41 CD 98 FA    dlg_0:		call	keyWaitNoCursor
0266+  FA44 FE 20       		cpi	20h
0267+  FA46 D2 41 FA    		jnc	dlg_0
0268+  FA49             
0269+  FA49 32 40 D2    		sta	v_lastKey
0270+  FA4C             
0271+  FA4C             		; de - начало диска
0272+  FA4C 2A 43 D2    		lhld	v_pageStart
0273+  FA4F EB          		xchg
0274+  FA50             
0275+  FA50 FE 19       		cpi	19h
0276+  FA52 CA 17 FA    		jz	dlg_up
0277+  FA55 FE 1A       		cpi	1Ah
0278+  FA57 CA EE F9    		jz	dlg_down
0279+  FA5A FE 0D       		cpi	0Dh
0280+  FA5C CA B0 FA    		jz	dlg_enter
0281+  FA5F FE 1B       		cpi	1Bh
0282+  FA61 CA 57 FB    		jz	dlg_esc		; ESC
0283+  FA64 B7          		ora	a
0284+  FA65 CA E2 FA    		jz	dlg_f1		; F1
0285+  FA68 3D          		dcr	a
0286+  FA69 CA C2 FD    		jz	dlg_f2		; F2
0287+  FA6C 3D          		dcr	a
0288+  FA6D CA 35 FE    		jz	dlg_f3		; F3
0289+  FA70 3D          		dcr	a
0290+  FA71 CA B8 FE    		jz	dlg_f4		; F4
0291+  FA74 3D          		dcr	a
0292+  FA75 CA 09 FF    		jz	dlg_f5		; F5
0293+  FA78 3D          		dcr	a
0294+  FA79 CA BD FC    		jz	dlg_f6		; F6
0295+  FA7C 3D          		dcr	a
0296+  FA7D C2 3D FA    		jnz	dlg_drawItem
0297+  FA80             		; Продолжение в startDebuger
0298+  FA80             
0299+  FA80             ; ---------------------------------------------------------------------------
0300+  FA80             
0301+  FA80             .include "startEditorDebuger.inc"
0001++ FA80             ;+---------------------------------------------------------------------------
0002++ FA80             ; RAMFOS
0003++ FA80             ; Запуск редатора и отладчика
0004++ FA80             ;
0005++ FA80             ; 2013-11-01 Дизассемблировано vinxru
0006++ FA80             ;----------------------------------------------------------------------------
0007++ FA80             
0008++ FA80~            #if NO_ROM_ENTRY
0009++ FA80~            		; Адрес подпрограммы в ПЗУ
0010++ FA80~            		lxi	h, a_debuger
0011++ FA80~            
0012++ FA80~            editorDebuger:	; В режиме выбора файла запускать нельзя
0013++ FA80~            		mov	a, b
0014++ FA80~            		add	a
0015++ FA80~            		rm
0016++ FA80~            
0017++ FA80~            		; Запуск
0018++ FA80~            		jmp	exec		
0019++ FA80~            		
0020++ FA80~            a_editor:	.db "Editor   EXE"
0021++ FA80~            a_debuger:	.db "Debuger  EXE"
0022++ FA80~            
0023++ FA80~            ; ---------------------------------------------------------------------------
0024++ FA80~            
0025++ FA80~            startEditor:	; Адрес подпрограммы в ПЗУ
0026++ FA80~            		lxi	h, a_editor
0027++ FA80~            		jmp	editorDebuger
0028++ FA80~            
0029++ FA80             #else ; ---------------------------------------------------------------------
0030++ FA80             
0031++ FA80             		; Адрес подпрограммы в ПЗУ
0032++ FA80 21 03 00    		lxi	h, 3
0033++ FA83             
0034++ FA83             editorDebuger:	; if(b & 0x40) return;
0035++ FA83 78          		mov	a, b
0036++ FA84 17          		ral
0037++ FA85 17          		ral
0038++ FA86 D8          		rc
0039++ FA87             
0040++ FA87             		; Помещаем в стек адрес возврата
0041++ FA87 E3          		xthl
0042++ FA88             
0043++ FA88             		; Сохраняем выбранный файл
0044++ FA88 CD 9F FB    		call	memcpy_fd_fd2
0045++ FA8B             
0046++ FA8B             		; Адрес загрузки
0047++ FA8B 21 00 E8    		lxi	h, 0E800h
0048++ FA8E             
0049++ FA8E             		; Включаем ПЗУ
0050++ FA8E 32 FE FF    		sta	IO_PAGE_ROM
0051++ FA91 C9          		ret
0052++ FA92             
0053++ FA92             ; ---------------------------------------------------------------------------
0054++ FA92             
0055++ FA92             startEditor:	; Адрес подпрограммы в ПЗУ
0056++ FA92 21 06 00    		lxi	h, 6
0057++ FA95 C3 83 FA    		jmp	editorDebuger
0058++ FA98             
0059++ FA98             #endif0302+  FA98             .include "keyWaitNoCursor.inc"
0001++ FA98             ;+---------------------------------------------------------------------------
0002++ FA98             ; RAMFOS
0003++ FA98             ; Ожидание нажатия клавиши без курсора
0004++ FA98             ;
0005++ FA98             ; 2013-11-01 Дизассемблировано vinxru
0006++ FA98             ;----------------------------------------------------------------------------
0007++ FA98             
0008++ FA98             ; Тут ошибка, курсор всётаки может промелькнуть
0009++ FA98             
0010++ FA98 CD 12 C8    keyWaitNoCursor:call	j_keyCheck
0011++ FA9B C2 03 C8    		jnz	j_keyWait
0012++ FA9E C3 98 FA    		jmp	keyWaitNoCursor0303+  FAA1             .include "memcmp_hl_de_c.inc"
0001++ FAA1             ;+---------------------------------------------------------------------------
0002++ FAA1             ; RAMFOS
0003++ FAA1             ; Сравнить с расширение текущего файла
0004++ FAA1             ;
0005++ FAA1             ; На входе
0006++ FAA1             ;  hl - адрес
0007++ FAA1             ; 
0008++ FAA1             ; На выходе
0009++ FAA1             ;  z  - если блоки равны
0010++ FAA1             ; 
0011++ FAA1             ; 2013-11-01 Дизассемблировано vinxru
0012++ FAA1             ;----------------------------------------------------------------------------
0013++ FAA1             
0014++ FAA1 11 5E D2    memcmp_ext:	lxi	d, v_header_ext
0015++ FAA4             
0016++ FAA4             ;----------------------------------------------------------------------------
0017++ FAA4             ; RAMFOS
0018++ FAA4             ; Сравнить 3 байта ОЗУ
0019++ FAA4             ;
0020++ FAA4             ; На входе
0021++ FAA4             ;  hl - адрес 1
0022++ FAA4             ;  de - адрес 2
0023++ FAA4             ; 
0024++ FAA4             ; На выходе
0025++ FAA4             ;  z  - если блоки равны
0026++ FAA4             ; 
0027++ FAA4             ; 2013-11-01 Дизассемблировано vinxru
0028++ FAA4             ;----------------------------------------------------------------------------
0029++ FAA4             
0030++ FAA4 0E 03       memcmp_hl_de_3:	mvi	c, 3
0031++ FAA6             
0032++ FAA6             ;----------------------------------------------------------------------------
0033++ FAA6             ; RAMFOS
0034++ FAA6             ; Сравнить ОЗУ
0035++ FAA6             ;
0036++ FAA6             ; На входе
0037++ FAA6             ;  hl - адрес 1
0038++ FAA6             ;  de - адрес 2
0039++ FAA6             ;  с  - размер
0040++ FAA6             ; 
0041++ FAA6             ; На выходе
0042++ FAA6             ;  z  - если блоки равны
0043++ FAA6             ; 
0044++ FAA6             ; 2013-11-01 Дизассемблировано vinxru
0045++ FAA6             ;----------------------------------------------------------------------------
0046++ FAA6             
0047++ FAA6             memcmp_hl_de_c:	 ; if(*de-- != *hl--) return;
0048++ FAA6 1A          		 ldax	d
0049++ FAA7 BE          		 cmp	m
0050++ FAA8 23          		 inx	h
0051++ FAA9 C0          		 rnz
0052++ FAAA 13          		 inx	d
0053++ FAAB 0D          		 dcr	c
0054++ FAAC C2 A6 FA    		jnz	memcmp_hl_de_c
0055++ FAAF C9          		ret
0304+  FAB0             
0305+  FAB0             ; ---------------------------------------------------------------------------
0306+  FAB0             
0307+  FAB0 CD AA FD    dlg_enter:	call	dlg_isLastLine
0308+  FAB3 CA 3D FA    		jz	dlg_drawItem
0309+  FAB6             
0310+  FAB6             #if OPEN_ANY_FILE==0
0311+  FAB6             		; Сравнить расширение выбранного файла с установленным расширением
0312+  FAB6 21 FE D1    		lxi	h, v_header2_ext
0313+  FAB9 CD A1 FA    		call	memcmp_ext
0314+  FABC             #endif
0315+  FABC             		; Если это режим выбора файла
0316+  FABC 78          		mov	a, b
0317+  FABD 17          		ral
0318+  FABE 17          		ral
0319+  FABF~            #if OPEN_ANY_FILE
0320+  FABF~            		jc	dlg_enter_1
0321+  FABF             #else
0322+  FABF DA CE FA    		jc	dlg_enter_0
0323+  FAC2             #endif	
0324+  FAC2             
0325+  FAC2             .include "rks.inc"
0001++ FAC2             ;+---------------------------------------------------------------------------
0002++ FAC2             ; RAMFOS
0003++ FAC2             ; Запуск RKS файла
0004++ FAC2             ;
0005++ FAC2             ; 2013-11-01 Разработано vinxru
0006++ FAC2             ;----------------------------------------------------------------------------
0007++ FAC2             
0008++ FAC2~            #if RKS_LOADER
0009++ FAC2~            		; Это RKS файл
0010++ FAC2~            		lxi	h, a_rks
0011++ FAC2~            		call	memcmp_ext
0012++ FAC2~            		jnz	defExec2
0013++ FAC2~            		
0014++ FAC2~            		; Загрузить его в память
0015++ FAC2~            		call	fileLoad2
0016++ FAC2~            		jnz	dlg_error
0017++ FAC2~            
0018++ FAC2~            		; Адрес запуска
0019++ FAC2~            		push	h
0020++ FAC2~            #if RKS_SHIFT_LOADER
0021++ FAC2~            		; Если нажат HP
0022++ FAC2~            		lda	IO_KEYB_B		
0023++ FAC2~            		ani	2
0024++ FAC2~            		rz
0025++ FAC2~            #endif
0026++ FAC2~            		; Найти файл Monitor2.sys
0027++ FAC2~            		lxi	h, a_monitor2_sys
0028++ FAC2~            		call	exec1
0029++ FAC2~            
0030++ FAC2~            		; Адрес запуска
0031++ FAC2~            		pop	h
0032++ FAC2~            
0033++ FAC2~            		jnz	dlg_error
0034++ FAC2~            		
0035++ FAC2~            		; При загрузке монитора стандартный стек будет уничтожен
0036++ FAC2~            		lxi	sp, 8FFFh
0037++ FAC2~            
0038++ FAC2~            		; Адрес программы
0039++ FAC2~            		push	h
0040++ FAC2~            		jmp	exec2
0041++ FAC2~            
0042++ FAC2~            a_rks:		.db "RKS"
0043++ FAC2~            a_monitor2_sys:	.db "Monitor2 SYS"
0044++ FAC2~            
0045++ FAC2~            defExec2:
0046++ FAC2             #endif0326+  FAC2             
0327+  FAC2             		; Допускаются только расширения EXE и COM
0328+  FAC2 21 78 FF    		lxi	h, a_exe		; "EXE"
0329+  FAC5 CD A1 FA    		call	memcmp_ext
0330+  FAC8 21 7B FF    		lxi	h, a_com		; "COM"
0331+  FACB C4 A1 FA    		cnz	memcmp_ext
0332+  FACE             
0333+  FACE             		; Недопустимое расширение, переходим в основной цикл
0334+  FACE C2 3D FA    dlg_enter_0:	jnz	dlg_drawItem
0335+  FAD1             
0336+  FAD1 2A 6A D2    dlg_enter_1:	lhld	v_header_start
0337+  FAD4 EB          		xchg
0338+  FAD5             
0339+  FAD5             		; Режим выбора
0340+  FAD5 DA FE FA    		jc	dlg_select
0341+  FAD8             
0342+  FAD8 CD 27 FB    		call	fileLoadComEx
0343+  FADB C2 8E FE    		jnz	dlg_error
0344+  FADE             
0345+  FADE             		;
0346+  FADE E3          		xthl
0347+  FADF C3 05 FB    		jmp	loc_FB05
0348+  FAE2             
0349+  FAE2             ; ---------------------------------------------------------------------------
0350+  FAE2             
0351+  FAE2             dlg_f1:		; Выводим сообщение
0352+  FAE2 11 7E FF    		lxi	d, a_copy
0353+  FAE5 CD 7F FD    		call	dlg_checkMsg
0354+  FAE8 C8          		rz
0355+  FAE9             
0356+  FAE9             		; Ввод числа в v_header_start
0357+  FAE9 CD BD F9    		call	dlg_yesNo
0358+  FAEC 2A 6A D2    		lhld	v_header_start	; Зачем?
0359+  FAEF FC 39 C8    		cm	j_strToHex	; Преобразовать строку DE в число HL
0360+  FAF2 CA 8E FE    		jz	dlg_error
0361+  FAF5             
0362+  FAF5             fileLoadSetAddr:; Установить новый адрес загрузки
0363+  FAF5             		; de = v_header_start = hl; 
0364+  FAF5             		; hl = v_header_stop  = f_fileBodySize + hl;
0365+  FAF5 CD 15 FB    		call	fileChangeAddr
0366+  FAF8             
0367+  FAF8             		; Если режим выбора файла, то сохраняем заголовок файла.
0368+  FAF8             		; В заголовке мы только что изменили адрес загрузки
0369+  FAF8 78          		mov	a, b
0370+  FAF9 17          		ral
0371+  FAFA 17          		ral
0372+  FAFB D2 25 FF    		jnc	fileSaveHeader
0373+  FAFE             		
0374+  FAFE             dlg_select:	; Загрузить файл в память
0375+  FAFE CD 27 FB    		call	fileLoadComEx
0376+  FB01 C2 8E FE    		jnz	dlg_error
0377+  FB04 E1          		pop	h
0378+  FB05             
0379+  FB05 C5          loc_FB05:	push	b
0380+  FB06             		 ; Вывести имя файла
0381+  FB06 CD EA FB    		 call	printFileHeaderName
0382+  FB09             		 ; Сохранить информацию о загруженном файле
0383+  FB09 CD 9F FB    		 call	memcpy_fd_fd2
0384+  FB0C C1          		pop	b
0385+  FB0D             
0386+  FB0D             loadDStartDStop:; de=v_header_stop, hl=v_header_start
0387+  FB0D 2A 6C D2    		lhld	v_header_stop
0388+  FB10 EB          		xchg
0389+  FB11 2A 6A D2    		lhld	v_header_start
0390+  FB14 C9          		ret
0391+  FB15             
0392+  FB15             ; ---------------------------------------------------------------------------
0393+  FB15             
0394+  FB15             ; de = v_header_start = hl; v_header_stop = f_fileBodySize+hl;
0395+  FB15             
0396+  FB15 22 6A D2    fileChangeAddr: shld	v_header_start
0397+  FB18 EB          		xchg
0398+  FB19 2A 76 D2    		lhld	f_fileBodySize
0399+  FB1C 19          		dad	d
0400+  FB1D 22 6C D2    		shld	v_header_stop
0401+  FB20 C9          		ret
0402+  FB21             
0403+  FB21             ; ---------------------------------------------------------------------------
0404+  FB21             
0405+  FB21             .include "fileLoad.inc"
0001++ FB21             ;+---------------------------------------------------------------------------
0002++ FB21             ; RAMFOS
0003++ FB21             ; Стандартная точка входа F84E
0004++ FB21             ; Загрузить текущий файл по адресу HL
0005++ FB21             ;
0006++ FB21             ; На входе
0007++ FB21             ;   hl     - Адрес загрузки файла
0008++ FB21             ;
0009++ FB21             ; На выходе
0010++ FB21             ;   z      - Файл загружен без ошибок
0011++ FB21             ;
0012++ FB21             ; 2013-11-01 Дизассемблировано vinxru
0013++ FB21             ;----------------------------------------------------------------------------
0014++ FB21             
0015++ FB21             fileLoad:	; Подменяем адрес загрузки в заголовке файла
0016++ FB21             		; de = v_header_start = hl; v_header_stop = f_fileBodySize + hl;
0017++ FB21 CD 15 FB    		call	fileChangeAddr
0018++ FB24             
0019++ FB24 C3 36 FB    		jmp	fileLoadCom
0020++ FB27             
0021++ FB27             ;----------------------------------------------------------------------------
0022++ FB27             ; RAMFOS
0023++ FB27             ; Загрузить текущий файл без проверки контрольной суммы
0024++ FB27             ;
0025++ FB27             ; На входе
0026++ FB27             ;   de     - Адрес загрузки файла
0027++ FB27             ;
0028++ FB27             ; 2013-11-01 Дизассемблировано vinxru
0029++ FB27             ;----------------------------------------------------------------------------
0030++ FB27             
0031++ FB27~            #if RKS_LOADER
0032++ FB27~            fileLoadNoCheck:; bc - длина файла
0033++ FB27~            		; hl - адрес тела файла в ДОЗУ
0034++ FB27~            		lhld	f_fileBodySize
0035++ FB27~            		push	h
0036++ FB27~            		 lhld	v_curFile ; указатель на заголовок
0037++ FB27~            		 lxi	b, 30	; длина заголовка
0038++ FB27~            		 dad	b
0039++ FB27~            		pop	b
0040++ FB27~            
0041++ FB27~            		; Читаем bc байт из ДОЗУ по адресу hl в ОЗУ по адресу de
0042++ FB27~            		jmp	pageReadBlock ; hl-диск,de-память,bc-длина-1
0043++ FB27~            
0044++ FB27~            ;----------------------------------------------------------------------------
0045++ FB27~            ; RAMFOS
0046++ FB27~            ; Загрузить текущий файл по адресу указанному в заголовке
0047++ FB27~            ; С выводом сообщения "Ждите!"
0048++ FB27~            ;
0049++ FB27~            ; На выходе
0050++ FB27~            ;   z      - Файл загружен без ошибок
0051++ FB27~            ;
0052++ FB27~            ; 2013-11-01 Дизассемблировано vinxru
0053++ FB27~            ;----------------------------------------------------------------------------
0054++ FB27~            	
0055++ FB27~            fileLoad2:	lhld	v_header_start
0056++ FB27~            		xchg
0057++ FB27             #endif
0058++ FB27             
0059++ FB27             ;----------------------------------------------------------------------------
0060++ FB27             ; RAMFOS
0061++ FB27             ; Загрузить текущий файлпо адресу в DE
0062++ FB27             ; С выводом сообщения "Ждите!"
0063++ FB27             ;
0064++ FB27             ; На входе
0065++ FB27             ;   de     - Адрес загрузки файла
0066++ FB27             ;
0067++ FB27             ; На выходе
0068++ FB27             ;   z      - Файл загружен без ошибок
0069++ FB27             ;
0070++ FB27             ; 2013-11-01 Дизассемблировано vinxru
0071++ FB27             ;----------------------------------------------------------------------------
0072++ FB27             	
0073++ FB27             ; Должен быть загружен заголовок
0074++ FB27             ; На выходе должно быть de = v_header_start
0075++ FB27             
0076++ FB27             fileLoadComEx:	; Вывод сообщения "Ждите!"
0077++ FB27 CD B2 FE    		call	printStringEx
0078++ FB2A 8E 8B 20 D6 		.db 8Eh, 8Bh, 20h, 0D6h, 0C4h, 0C9h, 0D4h, 0C5h, 21h, 20h, 8Eh, 0
0078++ FB2E C4 C9 D4 C5 
0078++ FB32 21 20 8E 00 
0079++ FB36             
0080++ FB36             fileLoadCom:
0081++ FB36~            #if RKS_LOADER
0082++ FB36~            		call	fileLoadNoCheck
0083++ FB36             #else
0084++ FB36             		; bc - длина файла
0085++ FB36             		; hl - адрес тела файла в ДОЗУ
0086++ FB36 2A 76 D2    		lhld	f_fileBodySize
0087++ FB39 E5          		push	h
0088++ FB3A 2A 70 D2    		 lhld	v_curFile ; указатель на заголовок
0089++ FB3D 01 1E 00    		 lxi	b, 30	; длина заголовка
0090++ FB40 09          		 dad	b
0091++ FB41 C1          		pop	b
0092++ FB42             
0093++ FB42             		; Читаем bc байт из ДОЗУ по адресу hl в ОЗУ по адресу de
0094++ FB42 CD 6F FD    		call	pageReadBlock ; hl-диск,de-память,bc-длина-1#endif
0095++ FB45             #endif
0096++ FB45             		; Расчитываем контрольную сумму от v_header_start до v_header_stop
0097++ FB45 1B          		dcx	d
0098++ FB46 2A 6A D2    		lhld	v_header_start
0099++ FB49 CD 2A C8    		call	j_calcCrc
0100++ FB4C             
0101++ FB4C             		; Сравнить bc и v_header_crc
0102++ FB4C C5          		push	b
0103++ FB4D D1          		pop	d		
0104++ FB4E 2A 6E D2    		lhld	v_header_crc
0105++ FB51 CD 54 C8    		call	j_cmp_hl_de
0106++ FB54             
0107++ FB54             		; de=v_header_stop, hl=v_header_start
0108++ FB54 C3 0D FB    		jmp	loadDStartDStop0406+  FB57             
0407+  FB57             ; ---------------------------------------------------------------------------
0408+  FB57             
0409+  FB57             dlg_esc:	; Если это не режим выбора файла, ничего не делаем
0410+  FB57 78          		mov	a, b
0411+  FB58 17          		ral
0412+  FB59 17          		ral
0413+  FB5A D0          		rnc
0414+  FB5B             
0415+  FB5B             		; Возвращаемся в программу		
0416+  FB5B E1          		pop	h
0417+  FB5C 3F          		cmc
0418+  FB5D C9          		ret
0419+  FB5E             
0420+  FB5E             ; ---------------------------------------------------------------------------
0421+  FB5E             
0422+  FB5E             .include "fileLoadHeader.inc"
0001++ FB5E             ;----------------------------------------------------------------------------
0002++ FB5E             ; RAMFOS
0003++ FB5E             ; Загрузить заголовок файла
0004++ FB5E             ;
0005++ FB5E             ; На входе
0006++ FB5E             ;   v_page          - Номер текущей страницы
0007++ FB5E             ;   hl              - Адрес текущего файла в ДОЗУ
0008++ FB5E             ;
0009++ FB5E             ; На выходе, если файл найден
0010++ FB5E             ;   b               - Текущая страница ДОЗУ
0011++ FB5E             ;   v_curFile       - Адрес текущего файла в ДОЗУ
0012++ FB5E             ;   v_header        - Заголовок файла
0013++ FB5E             ;   f_fileBodySize  - Длина файла без заголовка - 1
0014++ FB5E             ;   f_fileSize      - Длина файла с заголовком
0015++ FB5E             ;   f_nextFile      - Адрес следующего файла в ДОЗУ
0016++ FB5E             ;
0017++ FB5E             ;   Если не включено в ДОЗУ по адресу v_curFile + f_fileSize 
0018++ FB5E             ;   записывается v_curFile
0019++ FB5E             ;
0020++ FB5E             ; На выходе, если файл не найден
0021++ FB5E             ;   v_pageFreePtr, v_curFile - Адрес первого свободного байта
0022++ FB5E             ;   v_pageFreeTotal      - Свободно байт
0023++ FB5E             ;
0024++ FB5E             ; 2013-11-01 Дизассемблировано vinxru
0025++ FB5E             ;----------------------------------------------------------------------------
0026++ FB5E             
0027++ FB5E             fileLoadHeader:	; Сохраняем смещение текущего файла в v_curFile
0028++ FB5E 22 70 D2    		shld	v_curFile
0029++ FB61             
0030++ FB61             		; Читаем заголовок файла с диска в v_header
0031++ FB61 11 52 D2    		lxi	d, v_header
0032++ FB64 D5          		push	d
0033++ FB65 01 1D 00    		 lxi	b, FILE_HEADER_SIZE-1
0034++ FB68 CD 6F FD    		 call	pageReadBlock
0035++ FB6B D1          		pop	d
0036++ FB6C             
0037++ FB6C             		; Помещаем в В текущую страницу
0038++ FB6C 3A 45 D2    		lda	v_page
0039++ FB6F 47          		mov	b, a
0040++ FB70             
0041++ FB70             		; В начале файла должно быть D3,D3,D3
0042++ FB70 21 69 FF    		lxi	h, a_defHeader
0043++ FB73 CD A4 FA    		call	memcmp_hl_de_3	; b не изменяет
0044++ FB76             
0045++ FB76             		; Если маркер найден, то переходим к fileLoadHeader2
0046++ FB76 CA B0 FB    		jz	fileLoadHeader2
0047++ FB79             
0048++ FB79             		; Не найден маркер начала файла!
0049++ FB79             
0050++ FB79             		; Восстаналиваем заголовок в памяти
0051++ FB79 21 69 FF    		lxi	h, a_defHeader
0052++ FB7C 11 52 D2    		lxi	d, v_header
0053++ FB7F CD A5 FB    		call	memcpy_de_hl_15
0054++ FB82             
0055++ FB82             		; Устаналиваем конец страницы
0056++ FB82 2A 74 D2    		lhld	f_nextFile	
0057++ FB85 22 7C D2    		shld	v_pageFreePtr
0058++ FB88 EB          		xchg
0059++ FB89             
0060++ FB89             		; Получаем в HL размер страницы
0061++ FB89 2A 1C C6    		lhld	v_aramPageEnd
0062++ FB8C 3A 29 FD    		lda	a_panelOA
0063++ FB8F FE 4F       		cpi	'O'
0064++ FB91 C2 97 FB    		jnz	fileLoadHeader_0
0065++ FB94 21 00 C0    		 lxi	h, ROM_PAGE_END
0066++ FB97             fileLoadHeader_0:	
0067++ FB97                             ; Рассчитываем свободное место на диске
0068++ FB97 CD BB FD    		call	sub_hl_de
0069++ FB9A 22 7A D2    		shld	v_pageFreeTotal
0070++ FB9D             
0071++ FB9D             		; ?
0072++ FB9D 0D          		dcr	c
0073++ FB9E C9          		ret0423+  FB9F             
0424+  FB9F             ; ---------------------------------------------------------------------------
0425+  FB9F             ; Скопировать имя выбранного файла с v_header2_name
0426+  FB9F             
0427+  FB9F 21 52 D2    memcpy_fd_fd2:	lxi	h, v_header
0428+  FBA2 11 F2 D1    		lxi	d, v_header2
0429+  FBA5 0E 0E       memcpy_de_hl_15:mvi	c, 14
0430+  FBA7             
0431+  FBA7             .include "memcpy_de_hl_c.inc"
0001++ FBA7             ;+---------------------------------------------------------------------------
0002++ FBA7             ; RAMFOS
0003++ FBA7             ; Копирование ОЗУ
0004++ FBA7             ;
0005++ FBA7             ; На входе
0006++ FBA7             ;  hl - откуда
0007++ FBA7             ;  de - куда
0008++ FBA7             ;  с  - размер-1
0009++ FBA7             ; 
0010++ FBA7             ; 2013-11-01 Дизассемблировано vinxru
0011++ FBA7             ;----------------------------------------------------------------------------
0012++ FBA7             
0013++ FBA7 7E          memcpy_de_hl_c: mov	a, m
0014++ FBA8 12          		stax	d
0015++ FBA9 23          		inx	h
0016++ FBAA 13          		inx	d
0017++ FBAB 0D          		dcr	c
0018++ FBAC F2 A7 FB    		jp	memcpy_de_hl_c
0019++ FBAF C9          		ret
0432+  FBB0             .include "fileLoadHeader2.inc"
0001++ FBB0             ;+---------------------------------------------------------------------------
0002++ FBB0             ; RAMFOS
0003++ FBB0             ; Расчитать доп переменные загруженного заголовка файла
0004++ FBB0             ;
0005++ FBB0             ; На входе
0006++ FBB0             ;   v_curFile      - Адрес текущего файла в ДОЗУ
0007++ FBB0             ;   f_header       - Заголовок файла
0008++ FBB0             ;
0009++ FBB0             ; На выходе
0010++ FBB0             ;   f_fileBodySize - Длина файла без заголовка - 1
0011++ FBB0             ;   f_fileSize     - Длина файла с заголовком
0012++ FBB0             ;   f_nextFile     - Адрес следующего файла в ДОЗУ
0013++ FBB0             ;
0014++ FBB0             ;   Если не включено в ДОЗУ по адресу v_curFile + f_fileSize 
0015++ FBB0             ;   записывается v_curFile
0016++ FBB0             ;
0017++ FBB0             ; 2013-11-01 Дизассемблировано vinxru
0018++ FBB0             ;----------------------------------------------------------------------------
0019++ FBB0             
0020++ FBB0             fileLoadHeader2:; Длина файла без заголовка
0021++ FBB0             		; f_fileBodySize = v_header_stop - v_header_start
0022++ FBB0 CD 0D FB    		call	loadDStartDStop	
0023++ FBB3 EB          		xchg
0024++ FBB4 CD BB FD    		call	sub_hl_de
0025++ FBB7 22 76 D2    		shld	f_fileBodySize
0026++ FBBA             
0027++ FBBA             		; Длина файла с заголовом
0028++ FBBA             		; f_fileSize = f_fileBodySize+1
0029++ FBBA 11 1F 00    		lxi	d, FILE_HEADER_SIZE+1
0030++ FBBD 19          		dad	d
0031++ FBBE 22 78 D2    		shld	f_fileSize
0032++ FBC1             
0033++ FBC1             		; Конец файла
0034++ FBC1             		; de = v_curFile + f_fileSize
0035++ FBC1 EB          		xchg
0036++ FBC2 2A 70 D2    		lhld	v_curFile
0037++ FBC5 EB          		xchg
0038++ FBC6 19          		dad	d
0039++ FBC7             
0040++ FBC7             		; Обновляем в ДОЗУ указатель на наш файл, который находится
0041++ FBC7             		; перед следующим файлом.
0042++ FBC7 4B          		mov	c, e
0043++ FBC8 CD D1 FF    		call	pageWrite
0044++ FBCB 23          		inx	h
0045++ FBCC 4A          		mov	c, d
0046++ FBCD CD D1 FF    		call	pageWrite
0047++ FBD0 23          		inx	h
0048++ FBD1             
0049++ FBD1             		; Адрес следующего файла
0050++ FBD1             		; f_nextFile =  v_curFile + f_fileSize + 2
0051++ FBD1 22 74 D2    		shld	f_nextFile
0052++ FBD4             
0053++ FBD4             		; Возвращаем ноль и Z
0054++ FBD4 AF          		xra	a
0055++ FBD5 C9          		ret0433+  FBD6             
0434+  FBD6             ; ---------------------------------------------------------------------------
0435+  FBD6             
0436+  FBD6             printFileHeaderLight:
0437+  FBD6             		; Если сделать курсор цветным, то цвет будет задевать рамку. 
0438+  FBD6             
0439+  FBD6             		; Инверсия
0440+  FBD6 3E 8B       		mvi	a, C_INVERSE
0441+  FBD8 CD 0F C8    		call	j_printCharA
0442+  FBDB             
0443+  FBDB             printFileHeaderDark:
0444+  FBDB             		; Функция сохранит положение курсора строки, но не восстановит его
0445+  FBDB             		; Выведет на экран имя файла
0446+  FBDB             		; После вывода имени функция установит темный фон
0447+  FBDB CD E3 FB    		call	printFileHeaderName2
0448+  FBDE             
0449+  FBDE             popCursorLine2:	; Восстановить курсор строки
0450+  FBDE 3E 8E       		mvi	a, C_POPCURSORL
0451+  FBE0 C3 0F C8    		jmp	j_printCharA
0452+  FBE3             
0453+  FBE3             ; ---------------------------------------------------------------------------
0454+  FBE3             ; Функция сохранит положение курсора строки, но не восстановит его
0455+  FBE3             ; Выведет на экран имя файла
0456+  FBE3             ; После вывода имени функция установит темный фон
0457+  FBE3             
0458+  FBE3             printFileHeaderName2:
0459+  FBE3 CD 61 FD    		call	pushCursorLine2
0460+  FBE6 CD 1E C8    		call	j_getCursorPos
0461+  FBE9 EB          		xchg
0462+  FBEA             
0463+  FBEA             printFileHeaderName:
0464+  FBEA 0E 0C       		mvi	c, 12
0465+  FBEC 21 55 D2    		lxi	h, v_header_name
0466+  FBEF             printFileHeaderName_0:
0467+  FBEF 7E          		 mov	a, m
0468+  FBF0 23          		 inx	h
0469+  FBF1 CD 0F C8    		 call	j_printCharA
0470+  FBF4 0D          		 dcr	c
0471+  FBF5 C2 EF FB    		jnz	printFileHeaderName_0
0472+  FBF8             
0473+  FBF8             		; Установка темного фона
0474+  FBF8 3E 8C       		mvi	a, C_NORMAL
0475+  FBFA C3 0F C8    		jmp	j_printCharA
0476+  FBFD             
0477+  FBFD             ; ---------------------------------------------------------------------------
0478+  FBFD             
0479+  FBFD F5          dlg_printFile:	push	psw
0480+  FBFE CD 1E C8    		 call	j_getCursorPos
0481+  FC01 7C          		 mov	a, h
0482+  FC02 D6 16       v_dlgOffset:	 sui	16h
0483+  FC04 E1          		pop	h
0484+  FC05             
0485+  FC05             		; if(a >= 0x16)	return;
0486+  FC05 D0          		rnc			
0487+  FC06             		
0488+  FC06             		; D272 = v_curFile
0489+  FC06 E5          		push	h
0490+  FC07             #if DLG_CURSOR_AT_TOP==0
0491+  FC07 2A 70 D2    		 lhld	v_curFile
0492+  FC0A 22 72 D2    		 shld	v_printedFile
0493+  FC0D             #endif		
0494+  FC0D F1          		pop	psw
0495+  FC0E             
0496+  FC0E             		; Если на входе в функцию был NZ
0497+  FC0E C2 7A FC    		jnz	loc_FC7A
0498+  FC11             
0499+  FC11             		; Вывести имя файла
0500+  FC11 CD E3 FB    		call	printFileHeaderName2
0501+  FC14             
0502+  FC14             		; Разделитель
0503+  FC14 CD 66 FD    		call	dlg_printSep
0504+  FC17             
0505+  FC17             		; Если файл изменен
0506+  FC17 7E          		mov	a, m
0507+  FC18 CD 0F C8    		call	j_printCharA
0508+  FC1B 23          		inx	h
0509+  FC1C             
0510+  FC1C             		; Дата
0511+  FC1C 0E 03       		mvi	c, 3
0512+  FC1E 7E          loc_FC1E:        mov	a, m
0513+  FC1F 23          		 inx	h
0514+  FC20 CD 15 C8    		 call	j_printHex
0515+  FC23 0D          		 dcr	c
0516+  FC24~            #if NICE
0517+  FC24~            		 jz	loc_FC1E_
0518+  FC24~            		 mvi	a, '-'
0519+  FC24~            		 call	j_printCharA
0520+  FC24~            		jmp	loc_FC1E
0521+  FC24~            loc_FC1E_:
0522+  FC24             #else
0523+  FC24 C2 1E FC    		jnz	loc_FC1E
0524+  FC27             #endif
0525+  FC27             		
0526+  FC27             		; Разделитель
0527+  FC27 CD 66 FD    		call	dlg_printSep
0528+  FC2A             
0529+  FC2A             		; Информация о файле
0530+  FC2A CD 5D FC    		call	dlg_printFileInfo
0531+  FC2D             
0532+  FC2D             		; Выводим длину
0533+  FC2D 2A 76 D2    		lhld	f_fileBodySize
0534+  FC30 23          		inx	h
0535+  FC31             
0536+  FC31             printNumber:			
0537+  FC31             		; Разделитель
0538+  FC31 CD 66 FD    		call	dlg_printSep
0539+  FC34             
0540+  FC34             		; Вывод	HL на экран в 10чном виде
0541+  FC34 11 10 27    		lxi	d, 10000	
0542+  FC37 CD 91 FC    		call	divAndPrint
0543+  FC3A 11 E8 03    		lxi	d, 1000
0544+  FC3D CD 91 FC    		call	divAndPrint
0545+  FC40 11 64 00    		lxi	d, 100
0546+  FC43 CD 91 FC    		call	divAndPrint
0547+  FC46 11 0A 00    		lxi	d, 10
0548+  FC49 CD 91 FC    		call	divAndPrint
0549+  FC4C 7D          		mov	a, l
0550+  FC4D C6 30       		adi	'0'
0551+  FC4F CD 0F C8    		call	j_printCharA
0552+  FC52             		
0553+  FC52             		; Правая граница
0554+  FC52             dlg_rightEdge:
0555+  FC52~            #if ALL_CHARS
0556+  FC52~            		mvi	c, BORDER_R1
0557+  FC52~            		call	printCharAll
0558+  FC52             #else
0559+  FC52 3E 06       		mvi	a, BORDER_R1
0560+  FC54 CD 0F C8    		call	j_printCharA
0561+  FC57             #endif	
0562+  FC57             		; Правый край
0563+  FC57 21 58 FD    		lxi	h, a_rightEdge
0564+  FC5A C3 18 C8    		jmp	j_printString
0565+  FC5D             
0566+  FC5D             ; ---------------------------------------------------------------------------
0567+  FC5D             
0568+  FC5D             dlg_printFileInfo:		
0569+  FC5D CD 0D FB    		call	loadDStartDStop	; de=v_header_stop, hl=v_header_start
0570+  FC60~            #if NICE
0571+  FC60~            		mvi	c, '-'
0572+  FC60             #else
0573+  FC60 0E 2C       		mvi	c, ','
0574+  FC62             #endif
0575+  FC62 CD 6F FC    		call	printHexWord	; printHexWord(v_header_start)
0576+  FC65 EB          		xchg
0577+  FC66~            #if NICE
0578+  FC66~            		mvi	c, ' '
0579+  FC66             #else
0580+  FC66 0C          		inr	c		; c = '-'
0581+  FC67             #endif
0582+  FC67 CD 6F FC    		call	printHexWord	; printHexWord(v_header_stop)
0583+  FC6A~            #if NICE
0584+  FC6A~            		mvi	c, BORDER_H1
0585+  FC6A~            		call	printCharAll
0586+  FC6A             #endif
0587+  FC6A 2A 6E D2    		lhld	v_header_crc	; c = ?
0588+  FC6D 0E 8C       		mvi	c, C_NORMAL
0589+  FC6F             		; Продолжение на printHexWord
0590+  FC6F             
0591+  FC6F             ; ---------------------------------------------------------------------------
0592+  FC6F             
0593+  FC6F             .include "printHexWord.inc"
0001++ FC6F             ;+---------------------------------------------------------------------------
0002++ FC6F             ; RAMFOS
0003++ FC6F             ; Вывести HL в 16-ричном виде на экран и символ из C
0004++ FC6F             ;
0005++ FC6F             ; На входе
0006++ FC6F             ;  hl - число
0007++ FC6F             ;  с  - символ
0008++ FC6F             ;
0009++ FC6F             ; 2013-11-01 Дизассемблировано vinxru
0010++ FC6F             ;----------------------------------------------------------------------------
0011++ FC6F             
0012++ FC6F 7C          printHexWord:	mov	a, h
0013++ FC70 CD 15 C8    		call	j_printHex
0014++ FC73 7D          		mov	a, l
0015++ FC74 CD 15 C8    		call	j_printHex
0016++ FC77 C3 09 C8    		jmp	j_printChar0594+  FC7A             
0595+  FC7A             ; ---------------------------------------------------------------------------
0596+  FC7A             
0597+  FC7A             loc_FC7A:	; Функция сохранит положение курсора строки, но не восстановит его
0598+  FC7A             		; Выведет на экран имя файла
0599+  FC7A             		; После вывода имени функция установит темный фон
0600+  FC7A CD E3 FB    		call	printFileHeaderName2
0601+  FC7D             
0602+  FC7D~            #if NICE
0603+  FC7D~            		; 27 пробелов
0604+  FC7D~            		lxi	b, 1B20h	; b-колво, с-символ
0605+  FC7D             #else
0606+  FC7D             		; 26 пробелов
0607+  FC7D 01 20 1A    		lxi	b, 1A20h	; b-колво, с-символ
0608+  FC80             #endif
0609+  FC80 CD 89 FC    		call	printChars	
0610+  FC83             		
0611+  FC83             		; Свободное место
0612+  FC83 2A 7A D2    		lhld	v_pageFreeTotal
0613+  FC86 C3 31 FC    		jmp	printNumber
0614+  FC89             
0615+  FC89             ; ---------------------------------------------------------------------------
0616+  FC89             
0617+  FC89             .include "printChars.inc"
0001++ FC89             ;+---------------------------------------------------------------------------
0002++ FC89             ; RAMFOS
0003++ FC89             ; Вывод на экран нескольких символов
0004++ FC89             ;
0005++ FC89             ; На входе:
0006++ FC89             ;  b - кол-во
0007++ FC89             ;  с - символ
0008++ FC89             ;
0009++ FC89             ; 2013-11-01 Дизассемблировано vinxru
0010++ FC89             ;----------------------------------------------------------------------------
0011++ FC89             
0012++ FC89~            #if ALL_CHARS
0013++ FC89~                             
0014++ FC89~            printChars:	 push	b
0015++ FC89~            		  call	printCharAll
0016++ FC89~            		 pop	b
0017++ FC89~            		 dcr	b
0018++ FC89~            		jnz	printChars
0019++ FC89~            		ret
0020++ FC89~            
0021++ FC89             #else
0022++ FC89             
0023++ FC89 CD 09 C8    printChars:	 call	j_printChar
0024++ FC8C 05          		 dcr	b
0025++ FC8D C8          		 rz
0026++ FC8E C3 89 FC    		jmp	printChars
0027++ FC91             
0028++ FC91             #endif
0618+  FC91             
0619+  FC91             ; ---------------------------------------------------------------------------
0620+  FC91             
0621+  FC91 0E 2F       divAndPrint:	mvi	c, '0'-1
0622+  FC93 0C          loc_FC93:	 inr	c
0623+  FC94 CD BB FD    		 call	sub_hl_de
0624+  FC97 D2 93 FC    		jnc	loc_FC93
0625+  FC9A 19          		dad	d
0626+  FC9B C3 09 C8    		jmp	j_printChar
0627+  FC9E             		
0628+  FC9E             ; ---------------------------------------------------------------------------
0629+  FC9E             
0630+  FC9E             .include "filesetpage.inc"
0001++ FC9E             ;+---------------------------------------------------------------------------
0002++ FC9E             ; RAMFOS
0003++ FC9E             ; Установить активную страницу
0004++ FC9E             ;
0005++ FC9E             ; На входе
0006++ FC9E             ;  b - диск
0007++ FC9E             ;
0008++ FC9E             ; На выходе
0009++ FC9E             ;  v_pageStart = v_curFile = f_nextFile = начало страницы, заголовок первого файла
0010++ FC9E             ;  hl - начало страницы
0011++ FC9E             ;
0012++ FC9E             ; 2013-11-01 Дизассемблировано vinxru
0013++ FC9E             ;----------------------------------------------------------------------------
0014++ FC9E             
0015++ FC9E             fileSetPage:	; Начало RAM-диска
0016++ FC9E 2A 1E C6    		lhld	v_aramPageStart
0017++ FCA1             
0018++ FCA1             		; Диск
0019++ FCA1 78          		mov	a, b
0020++ FCA2 32 45 D2    		sta	v_page
0021++ FCA5             
0022++ FCA5             		; У ROM-диска другое начало
0023++ FCA5             		; Обновляем надпись RAM/ROM в заголовке файловой панели
0024++ FCA5 B7          		ora	a
0025++ FCA6 3E 41       		mvi	a, 'A'
0026++ FCA8 F2 B0 FC    		jp	fileSetPage_1
0027++ FCAB 3E 4F       		 mvi	a, 'O'
0028++ FCAD             		 ; Начало ROM-диска
0029++ FCAD 21 00 40    		 lxi	h, ROM_PAGE_START
0030++ FCB0 32 29 FD    fileSetPage_1:	sta	a_panelOA
0031++ FCB3             
0032++ FCB3                             ; Параметры диска
0033++ FCB3 22 43 D2    		shld	v_pageStart
0034++ FCB6 22 70 D2    		shld	v_curFile
0035++ FCB9 22 74 D2    		shld	f_nextFile
0036++ FCBC C9          		ret		0631+  FCBD             
0632+  FCBD             ; ---------------------------------------------------------------------------
0633+  FCBD             
0634+  FCBD             dlg_f6:		
0635+  FCBD             #if NO_MXDOS==0
0636+  FCBD             		; Если в номере диска 7, 6 биты не установлены, запускаем MXDOS
0637+  FCBD 78          		mov	a, b
0638+  FCBE E6 C0       		ani	0C0h
0639+  FCC0 CC 54 F8    		cz	loadMxDos
0640+  FCC3             #endif
0641+  FCC3             		; Запустить не удалось, меняем 7 бит на противоположный 
0642+  FCC3 78          		mov	a, b
0643+  FCC4~            #if NO_ROM_SWITCH_BUG
0644+  FCC4~            		ani	0F0h
0645+  FCC4             #endif
0646+  FCC4 EE 80       		xri	080h
0647+  FCC6 47          		mov	b, a
0648+  FCC7             
0649+  FCC7             dlg_pageChanged:; Устаналиваем активную страницу
0650+  FCC7 CD 9E FC    		call	fileSetPage
0651+  FCCA             
0652+  FCCA             dlg_drawItems:				; CODE XREF: dlg_down+Bj
0653+  FCCA E5          		push	h
0654+  FCCB             		 ; Копируем в заголовок установленный фильтр
0655+  FCCB 21 FE D1    		 lxi	h, v_header2_ext
0656+  FCCE 11 31 FD    		 lxi	d, a_panelFilter
0657+  FCD1 0E 02       		 mvi	c, 2
0658+  FCD3 CD A7 FB    		 call	memcpy_de_hl_c	; memcpy(de, hl, c+1)
0659+  FCD6             
0660+  FCD6             		 ; Копируем туда же активную страницу
0661+  FCD6 78          		 mov	a, b
0662+  FCD7             #if ARAM_MAX_PAGE <= 7
0663+  FCD7 E6 07       		 ani	7
0664+  FCD9~            #else
0665+  FCD9~            		 ani	0Fh	; Старшие биты выполняют спец функции
0666+  FCD9~            		 cpi	9
0667+  FCD9~            		 jc	correct
0668+  FCD9~            		  adi	'A'-9-'1'
0669+  FCD9~            correct:
0670+  FCD9             #endif
0671+  FCD9 C6 31       		 adi	'1'
0672+  FCDB~            #if NICE
0673+  FCDB~            		 sta	p_pageNum
0674+  FCDB             #else
0675+  FCDB 13          		 inx	d
0676+  FCDC 12          		 stax	d
0677+  FCDD             #endif
0678+  FCDD E1          		pop	h
0679+  FCDE             
0680+  FCDE             dlg_redraw:
0681+  FCDE             	        ; Выводим панель
0682+  FCDE CD B2 FE    		call	printStringEx
0683+  FCE1             
0684+  FCE1 8B 90       		.db C_INVERSE, C_BOTTOMLINE
0685+  FCE3 20 46 31 2D 		.text " F1-COPY F2-DELETE F3-MLOAD F4-MSAVE F5-EDIT F6-DOS F7-DEBUG"
0685+  FCE7 43 4F 50 59 
0685+  FCEB 20 46 32 2D 
0685+  FCEF 44 45 4C 45 
0685+  FCF3 54 45 20 46 
0685+  FCF7 33 2D 4D 4C 
0685+  FCFB 4F 41 44 20 
0685+  FCFF 46 34 2D 4D 
0685+  FD03 53 41 56 45 
0685+  FD07 20 46 35 2D 
0685+  FD0B 45 44 49 54 
0685+  FD0F 20 46 36 2D 
0685+  FD13 44 4F 53 20 
0685+  FD17 46 37 2D 44 
0685+  FD1B 45 42 55 47 
0686+  FD1F 8C          		.db C_NORMAL
0687+  FD20~            #if NICE
0688+  FD20~            		.db 0B0h				; Контрастно
0689+  FD20             #else
0690+  FD20 1F          		.db C_CLEARSCREEN			; очистка экрана
0691+  FD21             #endif
0692+  FD21~            #if NICE
0693+  FD21~            		.db 1Bh, 'Y', 20h+2, 20h+8		; положение панели
0694+  FD21             #else
0695+  FD21 1B 59 22 27 		.db 1Bh, 'Y', 20h+2, 20h+7		; положение панели
0696+  FD25             #endif
0697+  FD25 17 93 8B    		.db 17h, 93h, 8Bh
0698+  FD28 52          		.db 'R'
0699+  FD29 41 4D       a_panelOA:	.db "AM"
0700+  FD2B~            #if NICE
0701+  FD2B~            		.db '\'
0702+  FD2B~            p_pageNum	.text "0 "
0703+  FD2B~            a_panelFilter:	.text "          "
0704+  FD2B             #else
0705+  FD2B 5F 56 36 2E 		.text "_V6.0"
0705+  FD2F 30 
0706+  FD30 5C          		.db 92
0707+  FD31 5C 5C 5C    a_panelFilter:	.db 92,92,92
0708+  FD34 5C          		.db '\'
0709+  FD35 30 20 20    p_pageNum	.db "0  "
0710+  FD38             #endif
0711+  FD38 C4 C1 D4 C1 		.db 0C4h, 0C1h,	0D4h, 0C1h ; дата
0712+  FD3C 20 20 20 20 		.db  ' ', ' ', ' ', ' '
0713+  FD40 C1 C4 CE    		.db 0C1h, 0C4h, 0CEh ; "адн"
0714+  FD43 20          		.db ' '
0715+  FD44~            #if NICE
0716+  FD44~            		.db ' '
0717+  FD44~            		.db 0C1h, 0C4h, 0CBh ; "адк"
0718+  FD44~            		.db ' ', ' ', ' '
0719+  FD44~            		.db 0D3h, 0D5h, 0CDh, 0CDh, 0C1h ; "сумма"
0720+  FD44~            		.db ' '
0721+  FD44             #else
0722+  FD44 2C          		.db 2Ch
0723+  FD45 C1 C4 CB    		.db 0C1h, 0C4h, 0CBh ; "адк"
0724+  FD48 20          		.db ' '
0725+  FD49 2D          		.db 2Dh
0726+  FD4A D3 D5 CD CD 		.db 0D3h, 0D5h, 0CDh, 0CDh, 0C1h ; "сумма"
0726+  FD4E C1 
0727+  FD4F 20          		.db ' '
0728+  FD50 20          		.db ' '
0729+  FD51             #endif
0730+  FD51 C4 CC C9 CE 		.db 0C4h, 0CCh, 0C9h, 0CEh, 0C1h ; "длина"
0730+  FD55 C1 
0731+  FD56 20          		.db ' '
0732+  FD57 8C          		.db 8Ch ; темный фон
0733+  FD58~            #if NICE
0734+  FD58~            		.db 0B8h				; Серый фон
0735+  FD58             #endif
0736+  FD58 94 1A 08 11 a_rightEdge:	.db 94h, 1Ah, 8, BORDER_L, 93h, 0 ; восстановление курсора экрана, вниз, влево, |, запоминание курсора экрана
0736+  FD5C 93 00 
0737+  FD5E             #if NO_MXDOS==0
0738+  FD5E 32 F2 FF    		sta	IO_FLOPPY_HEAD
0739+  FD61             #endif	
0740+  FD61             pushCursorLine2:; Сохранить курсор строки
0741+  FD61 3E 8D       		mvi	a, 8Dh
0742+  FD63 C3 0F C8    		jmp	j_printCharA
0743+  FD66             
0744+  FD66             ; ---------------------------------------------------------------------------
0745+  FD66             
0746+  FD66 CD B2 FE    dlg_printSep:	call	printStringEx
0747+  FD69 8C 20 06    		.db C_NORMAL, ' ', BORDER_H, 
0748+  FD6C             #if NICE==0
0749+  FD6C 20          		.db ' '
0750+  FD6D             #endif
0751+  FD6D 00          		.db 0
0752+  FD6E C9          		ret
0753+  FD6F             
0754+  FD6F             ; ---------------------------------------------------------------------------
0755+  FD6F             
0756+  FD6F             .include "pageReadBlock.inc"
0001++ FD6F             ;+---------------------------------------------------------------------------
0002++ FD6F             ; RAMFOS
0003++ FD6F             ; Чтение блока данных из ДОЗУ/ПЗУ
0004++ FD6F             ;
0005++ FD6F             ; На входе:
0006++ FD6F             ;  hl - откуда, адрес в ДОЗУ/ПЗУ
0007++ FD6F             ;  de - куда, адрес в памяти
0008++ FD6F             ;  bc - длина-1
0009++ FD6F             ;
0010++ FD6F             ; 2013-11-01 Дизассемблировано vinxru
0011++ FD6F             ;----------------------------------------------------------------------------
0012++ FD6F             
0013++ FD6F             pageReadBlock:  ; Прочитать байт 
0014++ FD6F C5          		push	b		  
0015++ FD70 CD C2 FF    		 call	pageRead
0016++ FD73 23          		 inx	h
0017++ FD74 79          		 mov	a, c
0018++ FD75 C1          		pop	b
0019++ FD76             		; Сохранить байт
0020++ FD76 12          		stax	d
0021++ FD77 13          		inx	d
0022++ FD78             		; if(bc == 0) break;
0023++ FD78 79          		mov	a, c
0024++ FD79 B0          		ora	b
0025++ FD7A             		; bc--
0026++ FD7A 0B          		dcx	b
0027++ FD7B C2 6F FD    		jnz	pageReadBlock
0028++ FD7E C9          		ret
0757+  FD7F             
0758+  FD7F             ; ---------------------------------------------------------------------------
0759+  FD7F             
0760+  FD7F             dlg_checkMsg:	; Выйти с флагом Z, если выбрана последняя строка
0761+  FD7F D5          		push	d                
0762+  FD80 CD AA FD    		call	dlg_isLastLine
0763+  FD83 D1          		pop	d
0764+  FD84 C8          		rz
0765+  FD85             
0766+  FD85             dlg_msg:	; Вывод сообщения
0767+  FD85 F5          		push	psw
0768+  FD86 CD B2 FE    		 call	printStringEx
0769+  FD89 94 08 8B 20 		 .db C_POPCURSORS, C_LEFT, C_INVERSE, ' ', ' ', ' ', 0C6h, 0C1h, 0CAh, 0CCh ; файл тип
0769+  FD8D 20 20 C6 C1 
0769+  FD91 CA CC 
0770+  FD93 20 20 2E D4 		 .db ' ', ' ', 2Eh, 0D4h, 0C9h, 0D0h, ' ', 0Eh, ' ', 0
0770+  FD97 C9 D0 20 0E 
0770+  FD9B 20 00 
0771+  FD9D             		 
0772+  FD9D EB          		 xchg
0773+  FD9E CD 18 C8    		 call	j_printString
0774+  FDA1             
0775+  FDA1 CD B2 FE    		 call	printStringEx
0776+  FDA4 3A 3F       aa:		 .text ":?"
0777+  FDA6 08 00       		 .db C_LEFT, 0
0778+  FDA8 F1          		pop	psw
0779+  FDA9 C9          		ret
0780+  FDAA             
0781+  FDAA             ; ---------------------------------------------------------------------------
0782+  FDAA             
0783+  FDAA 2A 7C D2    dlg_isLastLine:	lhld	v_pageFreePtr
0784+  FDAD EB          		xchg
0785+  FDAE 2A 70 D2    		lhld	v_curFile
0786+  FDB1 C3 54 C8    		jmp	j_cmp_hl_de
0787+  FDB4             
0788+  FDB4             ; ---------------------------------------------------------------------------
0789+  FDB4             
0790+  FDB4             .include "fileGetStartAndSize2.inc"	; fileGetStartAndSize2 продолжается на sub_hl_de
0001++ FDB4             ;+---------------------------------------------------------------------------
0002++ FDB4             ; RAMFOS
0003++ FDB4             ; Получить смещение и длину файла из v_header2
0004++ FDB4             ;
0005++ FDB4             ; На выходе
0006++ FDB4             ;   DE - смещение  (v_header2_start)
0007++ FDB4             ;   HL - длина - 1 (v_header2_size-1)
0008++ FDB4             ;
0009++ FDB4             ; 2013-11-01 vinxru
0010++ FDB4             ;----------------------------------------------------------------------------                   
0011++ FDB4             
0012++ FDB4             fileGetStartAndSize2:
0013++ FDB4 2A 0A D2    		lhld	v_header2_start
0014++ FDB7 EB          		xchg
0015++ FDB8 2A 0C D2    		lhld	v_header2_end
0016++ FDBB             
0017++ FDBB             		; Продолжение на sub_hl_de
0791+  FDBB             .include "sub_hl_de.inc"
0001++ FDBB             ;+---------------------------------------------------------------------------
0002++ FDBB             ; RAMFOS
0003++ FDBB             ; Вычитание из HL DE
0004++ FDBB             ;
0005++ FDBB             ; 2013-11-01 Дизассемблировано vinxru
0006++ FDBB             ;----------------------------------------------------------------------------
0007++ FDBB             
0008++ FDBB 7D          sub_hl_de:	mov	a, l
0009++ FDBC 93          		sub	e
0010++ FDBD 6F          		mov	l, a
0011++ FDBE 7C          		mov	a, h
0012++ FDBF 9A          		sbb	d
0013++ FDC0 67          		mov	h, a
0014++ FDC1 C9          		ret
0792+  FDC2             
0793+  FDC2             ; ---------------------------------------------------------------------------
0794+  FDC2             
0795+  FDC2             dlg_f2:		; Вывод текста "удалить"
0796+  FDC2 11 8E FF    		lxi	d, a_delete
0797+  FDC5 CD 7F FD    		call	dlg_checkMsg
0798+  FDC8 CA 6A F9    		jz	dlg_f2_alt
0799+  FDCB             
0800+  FDCB             		; Пользователь должен нажать Enter
0801+  FDCB CD BD F9    		call	dlg_yesNo
0802+  FDCE             
0803+  FDCE             		; Удалить файл
0804+  FDCE CD EA FD    		call	fileDelete
0805+  FDD1             
0806+  FDD1             		; Сдвинуть экран вверх
0807+  FDD1             #if NICE==0
0808+  FDD1 CD B2 FE    		call	printStringEx
0809+  FDD4 8C 8E 19 9A 		.db C_NORMAL, C_POPCURSORL, 19h, C_SCROLLUPEX, 0
0809+  FDD8 00 
0810+  FDD9             #endif
0811+  FDD9             		; Перерисовать экран
0812+  FDD9 C9          		ret
0813+  FDDA             
0814+  FDDA             ; ---------------------------------------------------------------------------
0815+  FDDA             
0816+  FDDA             .include "compareFileName.inc"
0001++ FDDA             ;+---------------------------------------------------------------------------
0002++ FDDA             ; RAMFOS
0003++ FDDA             ; Сравнить имя текущего файла с именем заданным пользователем. 
0004++ FDDA             ; И опционально, если совпало, то удалить файл.
0005++ FDDA             ;
0006++ FDDA             ; На входе
0007++ FDDA             ;  v_header  - Файл 1, который будет удален, если b & 20h
0008++ FDDA             ;  v_header2 - Файл 2
0009++ FDDA             ;
0010++ FDDA             ; На выходе
0011++ FDDA             ;  jz        - файл найден. Но если b & 20h, то флаги неопределены.
0012++ FDDA             ;
0013++ FDDA             ; 2013-11-01 Дизассемблировано vinxru
0014++ FDDA             ;----------------------------------------------------------------------------
0015++ FDDA             
0016++ FDDA             compareFileName:; Сравнить идентификаторы и имена файлов 
0017++ FDDA 21 F2 D1    		lxi	h, v_header2
0018++ FDDD 11 52 D2    		lxi	d, v_header
0019++ FDE0 0E 0F       		mvi	c, 15
0020++ FDE2 CD A6 FA    		call	memcmp_hl_de_c
0021++ FDE5 C0          		rnz
0022++ FDE6             
0023++ FDE6             		; Если (b & 20h)==0 выходим (не удаляем)
0024++ FDE6 78          		mov	a, b
0025++ FDE7 E6 20       		ani	20h
0026++ FDE9 C8          		rz
0027++ FDEA             
0028++ FDEA             		; Переходим к функции fileDelete0817+  FDEA             .include "fileDelete.inc"
0001++ FDEA             ;+---------------------------------------------------------------------------
0002++ FDEA             ; RAMFOS
0003++ FDEA             ; Стандартная точка входа F851
0004++ FDEA             ; Удаление файла найденного программой F84B
0005++ FDEA             ;
0006++ FDEA             ; Файл должен быть обязательно найден функцией fileFind (F84B), иначе
0007++ FDEA             ; будет повреждена структура файлов.
0008++ FDEA             ;
0009++ FDEA             ; 2013-11-01 Дизассемблировано vinxru
0010++ FDEA             ;----------------------------------------------------------------------------
0011++ FDEA             
0012++ FDEA             fileDelete:	; Расчет длины полезных данных после нашего файла, которые
0013++ FDEA             		; надо сдвинуть.
0014++ FDEA             		; de = v_pageFreePtr - f_nextFile - 1 
0015++ FDEA 2A 74 D2    		lhld	f_nextFile
0016++ FDED EB          		xchg
0017++ FDEE 2A 7C D2    		lhld	v_pageFreePtr
0018++ FDF1 2B          		dcx	h		
0019++ FDF2 CD BB FD    		call	sub_hl_de
0020++ FDF5 EB          		xchg
0021++ FDF6             
0022++ FDF6             		; Помещаем в стек адрес следующего файла
0023++ FDF6 E5          		push	h
0024++ FDF7             
0025++ FDF7             		; Помещаем в HL адрес нашего файла
0026++ FDF7 2A 70 D2    		lhld	v_curFile
0027++ FDFA             
0028++ FDFA             		; Адрес следующего файла изменится после сдвига,
0029++ FDFA             		; а он используется в функции compareFileName
0030++ FDFA 22 74 D2    		shld	f_nextFile
0031++ FDFD             
0032++ FDFD             		; Если наш файл был посленим, ничего не перемещаем
0033++ FDFD DA 10 FE    		jc	fileDelete_1
0034++ FE00             
0035++ FE00             fileDelete_0:	 ; Чтение с диска
0036++ FE00 E3          		 xthl
0037++ FE01 CD C2 FF    		 call	pageRead
0038++ FE04 23          		 inx	h
0039++ FE05 E3          		 xthl
0040++ FE06             		 ; Запись на диск
0041++ FE06 CD D1 FF    		 call	pageWrite
0042++ FE09 23          		 inx	h
0043++ FE0A             		 ; if(de==0) break;
0044++ FE0A 7B          		 mov	a, e
0045++ FE0B B2          		 ora	d
0046++ FE0C             		 ; de--
0047++ FE0C 1B          		 dcx	d
0048++ FE0D C2 00 FE    		jnz	fileDelete_0
0049++ FE10             
0050++ FE10             fileDelete_1:	; Обновляем счетчик свободного места
0051++ FE10 E3          		xthl
0052++ FE11 E1          		pop	h
0053++ FE12 C3 2E F9    		jmp	fileChanged0818+  FE15             .include "fileFromTapeCom.inc"
0001++ FE15             ;+---------------------------------------------------------------------------
0002++ FE15             ; RAMFOS
0003++ FE15             ; Чтение первых 15 байт заголовка файла в v_header и вывод его на экран
0004++ FE15             ; Потом чтение длины тела (первые 2 байта) в DE
0005++ FE15             ;
0006++ FE15             ; Это общее начало функций fileFromTape, fileVerify
0007++ FE15             ;
0008++ FE15             ; 2013-11-01 Дизассемблировано vinxru
0009++ FE15             ;----------------------------------------------------------------------------
0010++ FE15             
0011++ FE15             fileFromTapeCom:; Ждем пилот тон
0012++ FE15             		; Читаем длину в DE, но игнорируем её.
0013++ FE15 21 52 D2    		lxi	h, v_header
0014++ FE18 CD 29 FE    		call	fileFromT_1
0015++ FE1B             
0016++ FE1B             		; Читаем 15 байт с магнитофона по адресу hl
0017++ FE1B 1E 0F       		mvi	e, 15
0018++ FE1D CD 06 C8    fileFromT_0:	 call	j_tapeRead
0019++ FE20 77          		 mov	m, a
0020++ FE21 23          		 inx	h
0021++ FE22 1D          		 dcr	e
0022++ FE23 C2 1D FE    		jnz	fileFromT_0
0023++ FE26             
0024++ FE26             		; Игнорируем D3,D3,D3
0025++ FE26             
0026++ FE26             		; Выводим имя на экран
0027++ FE26 CD EA FB    		call	printFileHeaderName
0028++ FE29             
0029++ FE29             fileFromT_1:	; Ждем пилот тон
0030++ FE29 CD 24 C8    		call	j_tapeReadPilot
0031++ FE2C             
0032++ FE2C             		; Читаем слово в DE
0033++ FE2C D4 06 C8    		cnc	j_tapeRead
0034++ FE2F 5F          		mov	e, a
0035++ FE30 D4 06 C8    		cnc	j_tapeRead
0036++ FE33 57          		mov	d, a
0037++ FE34 C9          		ret0819+  FE35             
0820+  FE35             ; ---------------------------------------------------------------------------
0821+  FE35             
0822+  FE35             dlg_f3:		; Выводим "сравнить"
0823+  FE35 11 A4 FF    		lxi	d, a_verify
0824+  FE38 CD 7F FD    		call	dlg_checkMsg
0825+  FE3B             
0826+  FE3B             		; Если файл не выбран
0827+  FE3B CA 59 FE    		jz	dlg_f3_alt
0828+  FE3E             
0829+  FE3E             		; ?
0830+  FE3E CD BD F9    		call	dlg_yesNo
0831+  FE41             
0832+  FE41             		; Продолжение в fileVerify
0833+  FE41             
0834+  FE41             ; ---------------------------------------------------------------------------
0835+  FE41             
0836+  FE41             .include "fileVerify.inc"
0001++ FE41             ;+---------------------------------------------------------------------------
0002++ FE41             ; RAMFOS
0003++ FE41             ; Сравнить текущий файл с магнитофоном
0004++ FE41             ;
0005++ FE41             ; Функция вызывается только из файловй панели.
0006++ FE41             ;
0007++ FE41             ; 2013-11-01 Дизассемблировано vinxru
0008++ FE41             ;----------------------------------------------------------------------------
0009++ FE41             
0010++ FE41             		; Чтение первых 15 байт заголовка файла в v_header и вывод его на экран
0011++ FE41             		; Потом чтение длины тела (первые 2 байта) в DE
0012++ FE41 CD 15 FE    		call	fileFromTapeCom
0013++ FE44             
0014++ FE44             		; Это не критично, но флаг C на выходе функции не проверяется.
0015++ FE44             
0016++ FE44             		; Адрес выбранного файла на диске
0017++ FE44 2A 70 D2    		lhld	v_curFile		 
0018++ FE47             verifyLoop:	 ; Читаем байт с диска
0019++ FE47 CD C2 FF    		 call	pageRead
0020++ FE4A             		 ; Читаем байт с магнитофона
0021++ FE4A CD 06 C8    		 call	j_tapeRead
0022++ FE4D             		 ; Если байты не равны, выводим ошибку
0023++ FE4D B9          		 cmp	c
0024++ FE4E C2 8E FE    		 jnz	dlg_error
0025++ FE51             		 ; Увеличиваем адрес на диске
0026++ FE51 23          		 inx	h
0027++ FE52             		 ; Цикл (Так как првоерка в конце, файлы нулевой длины не смогут проверится)
0028++ FE52 1B          		 dcx	d
0029++ FE53 7B          		 mov	a, e
0030++ FE54 B2          		 ora	d
0031++ FE55 C2 47 FE    		jnz	verifyLoop
0032++ FE58 C9          		ret
0837+  FE59             
0838+  FE59             ; ---------------------------------------------------------------------------
0839+  FE59             
0840+  FE59             dlg_f3_alt:	; Вывод на экран строки "Чтение"
0841+  FE59 11 96 FF    		lxi	d, a_load
0842+  FE5C CD BA F9    		call	dlg_msgYesNo
0843+  FE5F             
0844+  FE5F             .include "fileFromTape.inc"	; fileFromTape продолжается
0001++ FE5F             ;+---------------------------------------------------------------------------
0002++ FE5F             ; RAMFOS
0003++ FE5F             ; Чтение файла с магнитофона и сохранение в выбранную страницу
0004++ FE5F             ;
0005++ FE5F             ; Функция вызывается только из файловй панели.
0006++ FE5F             ;
0007++ FE5F             ; 2013-11-01 Дизассемблировано vinxru
0008++ FE5F             ;----------------------------------------------------------------------------
0009++ FE5F             
0010++ FE5F             fileFromTape:	; Читаем заголовок с диска
0011++ FE5F CD 15 FE    		call	fileFromTapeCom
0012++ FE62             
0013++ FE62             		; Выводим текст "ОШИБКА" + звуковой сигнал. 
0014++ FE62             		; Ждем нажатия ESC и выходим с установленным флагом C
0015++ FE62 DA 8E FE    		jc	fileFromTapeErr2
0016++ FE65             
0017++ FE65             		; Хватит ли места на диске для сохранения файла?
0018++ FE65 2A 7A D2    		lhld	v_pageFreeTotal
0019++ FE68 2B          		dcx	h
0020++ FE69 2B          		dcx	h
0021++ FE6A 2B          		dcx	h
0022++ FE6B CD 54 C8    		call	j_cmp_hl_de
0023++ FE6E             
0024++ FE6E             		; Выводим текст "МАЛ ДИСК" + звуковой сигнал. 
0025++ FE6E             		; Ждем нажатия ESC и выходим с установленным флагом C
0026++ FE6E DA A3 FE    		jc	outOfSpace
0027++ FE71             
0028++ FE71             		; Указатель записи на диск
0029++ FE71 2A 7C D2    		lhld	v_pageFreePtr
0030++ FE74             readLoop:	 ; Читаем байт с магнитофона
0031++ FE74 CD 06 C8    		 call	j_tapeRead		
0032++ FE77 DA 88 FE    		 jc	fileFromTapeErr
0033++ FE7A             		 ; Записываем байт A на диск по адресу HL
0034++ FE7A 4F          		 mov	c, a
0035++ FE7B CD D1 FF    		 call	pageWrite
0036++ FE7E 23          		 inx	h
0037++ FE7F             		 ; Цикл DE (Так как првоерка в конце, файлы нулевой длины не смогут загрузится)
0038++ FE7F 1B          		 dcx	d
0039++ FE80 7B          		 mov	a, e
0040++ FE81 B2          		 ora	d
0041++ FE82 C2 74 FE    		jnz	readLoop
0042++ FE85             
0043++ FE85             		; Файл прочитан
0044++ FE85 C3 2C F9    		jmp	fileChanged2
0045++ FE88             
0046++ FE88             ; ---------------------------------------------------------------------------
0047++ FE88             
0048++ FE88             fileFromTapeErr:
0049++ FE88             		; Устаналвиаем конец диска в v_curFile
0050++ FE88 2A 70 D2    		lhld	v_curFile
0051++ FE8B CD 2E F9    		call	fileChanged
0052++ FE8E             
0053++ FE8E             fileFromTapeErr2:
0054++ FE8E             		; Далее dlg_error
0845+  FE8E             
0846+  FE8E             dlg_error:	; Выводим сообщение "ОШИБКА" + звуковой сигнал
0847+  FE8E CD B2 FE    		call	printStringEx
0848+  FE91 CF DB C9 C2 		.db 0CFh, 0DBh,	0C9h, 0C2h, 0CBh, 0C1h,	C_BEEP, 0 ; ошибка
0848+  FE95 CB C1 07 00 
0849+  FE99             
0850+  FE99             waitEsc:	; Ждем, пока пользователь не нажмет ESC
0851+  FE99 CD 98 FA    		 call	keyWaitNoCursor
0852+  FE9C~            #if NICE
0853+  FE9C~            		 cpi	' '
0854+  FE9C             #else
0855+  FE9C FE 1F       		 cpi	1Fh
0856+  FE9E             #endif
0857+  FE9E C2 99 FE    		jnz	waitEsc
0858+  FEA1             		; Выходим с установленным флагом C
0859+  FEA1 37          		stc
0860+  FEA2 C9          		ret
0861+  FEA3             
0862+  FEA3             ; ---------------------------------------------------------------------------
0863+  FEA3             ; Вывод сообщения МАЛ ДИСК
0864+  FEA3             
0865+  FEA3 CD B2 FE    outOfSpace:	call	printStringEx
0866+  FEA6 CD C1 CC 20 		.db 0CDh, 0C1h,	0CCh, 20h, 0C4h, 0C9h, 0D3h, 0CBh, 0 ; мал диск
0866+  FEAA C4 C9 D3 CB 
0866+  FEAE 00 
0867+  FEAF C3 99 FE    		jmp	waitEsc
0868+  FEB2             
0869+  FEB2             ; ---------------------------------------------------------------------------
0870+  FEB2             
0871+  FEB2             .include "printStringEx.inc"
0001++ FEB2             ;+---------------------------------------------------------------------------
0002++ FEB2             ; RAMFOS
0003++ FEB2             ; Вывод строки на экран
0004++ FEB2             ;
0005++ FEB2             ; Строка размещается сразу же после комадны вызова
0006++ FEB2             ;
0007++ FEB2             ; 2013-11-01 Дизассемблировано vinxru
0008++ FEB2             ;----------------------------------------------------------------------------
0009++ FEB2             
0010++ FEB2 E3          printStringEx:	xthl
0011++ FEB3 CD 18 C8    		call	j_printString
0012++ FEB6 E3          		xthl
0013++ FEB7 C9          		ret
0872+  FEB8             
0873+  FEB8             ; ---------------------------------------------------------------------------
0874+  FEB8             ; Соханить файл на магнитофон
0875+  FEB8             
0876+  FEB8             dlg_f4:		; Если файл не выбран, выходим
0877+  FEB8 2A 74 D2    		lhld	f_nextFile
0878+  FEBB CD 54 C8    		call	j_cmp_hl_de
0879+  FEBE C8          		rz
0880+  FEBF             
0881+  FEBF             		; Вывод "запись"
0882+  FEBF 11 9D FF    		lxi	d, a_save
0883+  FEC2 CD BA F9    		call	dlg_msgYesNo
0884+  FEC5             
0885+  FEC5 CD AA FD    		call	dlg_isLastLine
0886+  FEC8 2A 43 D2    		lhld	v_pageStart
0887+  FECB CA E1 FE    		jz	fileToTape
0888+  FECE             
0889+  FECE 0E 8C       		mvi	c, C_NORMAL
0890+  FED0             
0891+  FED0 2A 70 D2    		lhld	v_curFile
0892+  FED3 11 0F 00    		lxi	d, 0Fh
0893+  FED6 19          		dad	d
0894+  FED7 CD D1 FF    		call	pageWrite
0895+  FEDA             		
0896+  FEDA 2A 78 D2    		lhld	f_fileSize
0897+  FEDD EB          		xchg
0898+  FEDE 2A 70 D2    		lhld	v_curFile
0899+  FEE1             
0900+  FEE1             .include "fileToTape.inc"
0001++ FEE1             ;+---------------------------------------------------------------------------
0002++ FEE1             ; RAMFOS
0003++ FEE1             ; Сохранить файл на магнитофон
0004++ FEE1             ;
0005++ FEE1             ; 2013-11-01 Дизассемблировано vinxru
0006++ FEE1             ;----------------------------------------------------------------------------
0007++ FEE1             
0008++ FEE1             fileToTape:	; Сначала записываем только 15 байт.
0009++ FEE1 E5          		push	h
0010++ FEE2 D5          		 push	d
0011++ FEE3 11 0F 00    		  lxi	d, 15
0012++ FEE6 CD EB FE    		  call	fileToTape_0
0013++ FEE9 D1          		 pop	d
0014++ FEEA E1          		pop	h
0015++ FEEB             
0016++ FEEB             		; Потом тот же блок данных, но целиком
0017++ FEEB             
0018++ FEEB             fileToTape_0:	; Пилот тон
0019++ FEEB CD 27 C8    		call	j_tapeWritePilot
0020++ FEEE             
0021++ FEEE             		; Запись длины
0022++ FEEE 4B          		mov	c, e
0023++ FEEF AF          		xra	a
0024++ FEF0 CD 0C C8    		call	j_tapeWrite
0025++ FEF3 4A          		mov	c, d
0026++ FEF4 AF          		xra	a
0027++ FEF5 CD 0C C8    		call	j_tapeWrite
0028++ FEF8             
0029++ FEF8             		; Укорочение первого импульса магниофона *15 тактов
0030++ FEF8 06 08       		mvi	b, 8		
0031++ FEFA             fileToTape_1:	 ; Если записывать нечего, выходим
0032++ FEFA 7B          		 mov	a, e
0033++ FEFB B2          		 ora	d
0034++ FEFC C8          		 rz
0035++ FEFD             		 ; Читаем байт с диска
0036++ FEFD CD C2 FF    		 call	pageRead
0037++ FF00 23          		 inx	h
0038++ FF01             		 ; Уменьшаем счетчик
0039++ FF01 1B          		 dcx	d
0040++ FF02             		 ; Записываем на магнитофон
0041++ FF02 78          		 mov	a, b
0042++ FF03 CD 0C C8    		 call	j_tapeWrite
0043++ FF06 C3 FA FE    		jmp	fileToTape_10901+  FF09             
0902+  FF09             ; ---------------------------------------------------------------------------
0903+  FF09             ; Переименовать файл
0904+  FF09             
0905+  FF09             dlg_f5:		; Вывести "имя:"
0906+  FF09 11 AD FF    		lxi	d, a_name
0907+  FF0C CD 7F FD    		call	dlg_checkMsg
0908+  FF0F             
0909+  FF0F             		; Если файл не выбран
0910+  FF0F CA 92 FA    		jz	startEditor
0911+  FF12             
0912+  FF12             dlg_f5_retry:	; Устанавливаем курсор на имя файла
0913+  FF12 CD DE FB    		call	popCursorLine2
0914+  FF15             
0915+  FF15             		; Редактирование имени файла
0916+  FF15 21 55 D2    		lxi	h, v_header_name
0917+  FF18 11 FF 0C    		lxi	d, 0CFFh
0918+  FF1B CD 36 C8    		call	j_input
0919+  FF1E             	
0920+  FF1E             		; Был нажат ESC	
0921+  FF1E CA D0 F9    		jz	loc_F9D0
0922+  FF21             
0923+  FF21             		; Была нажата служебная клавиша
0924+  FF21 D2 12 FF    		jnc	dlg_f5_retry
0925+  FF24             
0926+  FF24             		; Имя не введено, перерисовать
0927+  FF24 F0          		rp
0928+  FF25             
0929+  FF25             		; Продолжение в fileSaveHeader
0930+  FF25             
0931+  FF25             ; ---------------------------------------------------------------------------0365   FF25~            #if RELOCATE_FILE_FUNCTIONS
0366   FF25~            	jmp	fileSaveHeader
0367   FF25             #else
0368   FF25             .include "fileSaveHeader.inc"	; Їа®¤®«¦Ґ­ЁҐ ў pageWriteBlock
0001+  FF25             ;+---------------------------------------------------------------------------
0002+  FF25             ; RAMFOS
0003+  FF25             ; Записать заговлок текущего файла на диск
0004+  FF25             ;
0005+  FF25             ; 2013-11-01 Дизассемблировано vinxru
0006+  FF25             ;----------------------------------------------------------------------------
0007+  FF25             
0008+  FF25             fileSaveHeader:
0009+  FF25             		; Устанавливаем флаг "файл не был сохранен"
0010+  FF25 3E 8B       		mvi	a, 8Bh
0011+  FF27 32 61 D2    		sta	v_header_saved
0012+  FF2A             
0013+  FF2A             		; Сохранение заголовка на диск
0014+  FF2A 01 52 D2    		lxi	b, v_header
0015+  FF2D             		
0016+  FF2D             ;----------------------------------------------------------------------------
0017+  FF2D             ; RAMFOS
0018+  FF2D             ; Записать альтернативный заговлок файла на диск
0019+  FF2D             ; Используется для записи заговлока v_header2 при создании нового файла
0020+  FF2D             ;
0021+  FF2D             ; На входе
0022+  FF2D             ;  b - заголовок
0023+  FF2D             ;
0024+  FF2D             ; 2013-11-01 Дизассемблировано vinxru
0025+  FF2D             ;----------------------------------------------------------------------------
0026+  FF2D             
0027+  FF2D             fileSaveHeaderAny:
0028+  FF2D 11 1D 00    		lxi	d, FILE_HEADER_SIZE-1
0029+  FF30 2A 70 D2    		lhld	v_curFile
0030+  FF33             
0031+  FF33             		; Продолжение на pageWriteBlock
0032+  FF33             		0369   FF33             .include "pageWriteBlock.inc"
0001+  FF33             ;+---------------------------------------------------------------------------
0002+  FF33             ; RAMFOS
0003+  FF33             ; Запись блока данных в ДОЗУ/ПЗУ
0004+  FF33             ;
0005+  FF33             ; На входе:
0006+  FF33             ;  bc - откуда, адрес в памяти
0007+  FF33             ;  hl - куда, адрес в ДОЗУ/ПЗУ
0008+  FF33             ;  de - длина-1
0009+  FF33             ;
0010+  FF33             ; 2013-11-01 Дизассемблировано vinxru
0011+  FF33             ;----------------------------------------------------------------------------
0012+  FF33             
0013+  FF33             pageWriteBlock:	; Чтение байта
0014+  FF33 0A          		ldax	b
0015+  FF34             		; Запись байта
0016+  FF34 C5          		push	b
0017+  FF35 4F          		 mov	c, a
0018+  FF36 CD D1 FF    		 call	pageWrite
0019+  FF39 C1          		pop	b
0020+  FF3A             		; Увеличение адресов
0021+  FF3A 23          		inx	h
0022+  FF3B 03          		inx	b
0023+  FF3C             		; if(de == 0) break;
0024+  FF3C 7B          		mov	a, e
0025+  FF3D B2          		ora	d
0026+  FF3E             		; de--
0027+  FF3E 1B          		dcx	d
0028+  FF3F C2 33 FF    		jnz	pageWriteBlock
0029+  FF42 C9          		ret
0370   FF43             #endif
0371   FF43             .include "fileSetGetName.inc"
0001+  FF43             ;+---------------------------------------------------------------------------
0002+  FF43             ; RAMFOS
0003+  FF43             ; Стандартная точка входа F845
0004+  FF43             ; Получение имени последнего загруженного файла
0005+  FF43             ;
0006+  FF43             ; На входе
0007+  FF43             ;  hl - имя файла (12 байт)
0008+  FF43             ;
0009+  FF43             ; 2013-11-01 Дизассемблировано vinxru
0010+  FF43             ;----------------------------------------------------------------------------
0011+  FF43             
0012+  FF43 E5          fileGetName:	push	h
0013+  FF44 D5          		push	d
0014+  FF45 C5          		push	b
0015+  FF46 11 F5 D1    		lxi	d, v_header2_name
0016+  FF49 EB          		xchg
0017+  FF4A C3 53 FF    		jmp	fileSetName_0
0018+  FF4D             
0019+  FF4D             ;----------------------------------------------------------------------------
0020+  FF4D             ; RAMFOS
0021+  FF4D             ; Стандартная точка входа F848
0022+  FF4D             ; Установка имя для функций сохаранения/поиска
0023+  FF4D             ;
0024+  FF4D             ; На входе
0025+  FF4D             ;  hl - имя файла (12 байт)
0026+  FF4D             ;
0027+  FF4D             ; 2013-11-01 Дизассемблировано vinxru
0028+  FF4D             ;----------------------------------------------------------------------------
0029+  FF4D             
0030+  FF4D E5          fileSetName:	push	h
0031+  FF4E D5          		push	d
0032+  FF4F C5          		push	b
0033+  FF50 11 F5 D1    		lxi	d, v_header2_name
0034+  FF53 0E 0B       fileSetName_0:	mvi	c, 11
0035+  FF55 C3 60 FF    		jmp	memcpy_popa0372   FF58             #if RELOCATE_FILE_FUNCTIONS==0
0373   FF58             .include "fileSetType.inc"
0001+  FF58             ;+---------------------------------------------------------------------------
0002+  FF58             ; RAMFOS
0003+  FF58             ; Стандартная точка входа F82D
0004+  FF58             ; Установить расширение сохраняемого/загружаемого файла
0005+  FF58             ;
0006+  FF58             ; 2013-11-01 Дизассемблировано vinxru
0007+  FF58             ;----------------------------------------------------------------------------
0008+  FF58             
0009+  FF58 E5          fileSetType:	push	h
0010+  FF59 D5          		push	d
0011+  FF5A C5          		push	b
0012+  FF5B 11 FE D1    		 lxi	d, v_header2_ext
0013+  FF5E 0E 02       		 mvi	c, 2	; Размер -1
0014+  FF60 F5          memcpy_popa:	 push	psw
0015+  FF61 CD A7 FB    		  call	memcpy_de_hl_c
0016+  FF64 F1          		 pop	psw
0017+  FF65 C1          		pop	b
0018+  FF66 D1          		pop	d
0019+  FF67 E1          		pop	h
0020+  FF68 C9          		ret0374   FF69             #endif
0375   FF69~            #if NO_ROM_ENTRY | RKS_LOADER
0376   FF69~            .include "exec.inc"
0377   FF69             #endif
0378   FF69             
0379   FF69             ; ===========================================================================
0380   FF69             ; Џ…ђ…Њ…ЌЌ›…
0381   FF69             
0382   FF69 D3 D3 D3    a_defHeader:	.db 0D3h, 0D3h,	0D3h	; ¬ аЄҐа ­ з «  д ©«  (§  ­Ё¬ ®Ўп§ вҐ«м­® ¤®«¦Ґ­® Ё¤вЁ 12 Їа®ЎҐ«®ў)
0383   FF6C 20 20 20 20 a_12spaces:	.text "            "	; Їгбв®Ґ Ё¬п
0383   FF70 20 20 20 20 
0383   FF74 20 20 20 20 
0384   FF78 45 58 45    a_exe:		.text "EXE"
0385   FF7B 43 4F 4D    a_com:		.text "COM"
0386   FF7E CB CF D0 C9 a_copy:		.db 0CBh, 0CFh,	0D0h, 0C9h, 0D2h, 0CFh,	0D7h, 
0386   FF82 D2 CF D7 
0387   FF85 C1 D4 D8 00 		.db 0C1h, 0D4h, 0D8h, 0					; "Є®ЇЁа®ў вм"
0388   FF89 C4 C1 D4 D5 a_deleteDate:	.db 0C4h, 0C1h,	0D4h, 0D5h, 20h				; "¤ вг г¤ «Ёвм"
0388   FF8D 20 
0389   FF8E D5 C4 C1 CC a_delete:	.db 0D5h, 0C4h,	0C1h, 0CCh, 0C9h, 0D4h,	0D8h, 0		; "г¤ «Ёвм"
0389   FF92 C9 D4 D8 00 
0390   FF96 DE D4 C5 CE a_load:		.db 0DEh, 0D4h,	0C5h, 0CEh, 0C9h, 0C5h,	0		; "звҐ­ЁҐ"
0390   FF9A C9 C5 00 
0391   FF9D DA C1 D0 C9 a_save:		.db 0DAh, 0C1h,	0D0h, 0C9h, 0D3h, 0D8h,	0		; "§ ЇЁбм"
0391   FFA1 D3 D8 00 
0392   FFA4 D3 D2 C1 D7 a_verify:	.db 0D3h, 0D2h,	0C1h, 0D7h, 0CEh, 0C9h,	0D4h, 0D8h, 0	; "ба ў­Ёвм"
0392   FFA8 CE C9 D4 D8 
0392   FFAC 00 
0393   FFAD C9 CD D1 00 a_name:		.db 0C9h, 0CDh,	0D1h, 0					; Ё¬п
0394   FFB1             
0395   FFB1             ; ===========================================================================
0396   FFB1             ; ЋЉЌЋ ЏђЋ–…‘‘ЋђЂ
0397   FFB1             
0398   FFB1             .include "window.inc"
0001+  FFB1             ;+---------------------------------------------------------------------------
0002+  FFB1             ; RAMFOS
0003+  FFB1             ; 2013-11-01 Дизассемблировано vinxru
0004+  FFB1             ;----------------------------------------------------------------------------
0005+  FFB1             
0006+  FFB1             #if BIG_ROM != 1
0007+  FFB1             		
0008+  FFB1~            #if $ > 0FFB6h
0009+  FFB1~            Ошибка_часть_F800_не_влезла
0010+  FFB1             #endif
0011+  FFB6             .org 0FFB6h
0012+  FFB6             
0013+  FFB6 32 FE FF    pageWriteROM:	sta	IO_PAGE_ROM
0014+  FFB9 C3 DB FF    		jmp	pageWriteCom
0015+  FFBC             
0016+  FFBC 32 FE FF    pageReadROM:	sta	IO_PAGE_ROM
0017+  FFBF C3 CC FF    		jmp	pageReadCom
0018+  FFC2             
0019+  FFC2             #endif
0020+  FFC2             
0021+  FFC2             ; ---------------------------------------------------------------------------
0022+  FFC2             
0023+  FFC2~            #if $ > 0FFC2h
0024+  FFC2~            Ошибка_часть_F800_не_влезла
0025+  FFC2             #endif
0026+  FFC2             .org 0FFC2h
0027+  FFC2             
0028+  FFC2 3A 45 D2    pageRead:	lda	v_page
0029+  FFC5             
0030+  FFC5             ;----------------------------------------------------------------------------
0031+  FFC5             ; RAMFOS
0032+  FFC5             ; Стандартная точка входа F836
0033+  FFC5             ; Чтение байта из ДОЗУ
0034+  FFC5             ;
0035+  FFC5             ; На входе
0036+  FFC5             ;   a  - номер страницы
0037+  FFC5             ;   hl - адрес
0038+  FFC5             ;
0039+  FFC5             ; На выходе
0040+  FFC5             ;   с  - байт
0041+  FFC5             ;
0042+  FFC5             ; 2013-11-01 Дизассемблировано vinxru
0043+  FFC5             ;----------------------------------------------------------------------------
0044+  FFC5             
0045+  FFC5 B7          pageReadAny:	ora	a
0046+  FFC6~            #if BIG_ROM
0047+  FFC6~            		jm	bigRom
0048+  FFC6             #else
0049+  FFC6 FA BC FF    		jm	pageReadROM
0050+  FFC9             #endif
0051+  FFC9 32 FD FF    disableARAM1:	sta	IO_PAGE_ARAM		
0052+  FFCC 4E          pageReadCom:	mov	c, m
0053+  FFCD 32 FC FF    		sta	IO_PAGE_RAM
0054+  FFD0 C9          		ret
0055+  FFD1             
0056+  FFD1             ; ---------------------------------------------------------------------------
0057+  FFD1             
0058+  FFD1 3A 45 D2    pageWrite:	lda	v_page
0059+  FFD4             
0060+  FFD4             ;----------------------------------------------------------------------------
0061+  FFD4             ; RAMFOS
0062+  FFD4             ; Стандартная точка входа F839
0063+  FFD4             ; Запись байта в ДОЗУ
0064+  FFD4             ;
0065+  FFD4             ; На входе
0066+  FFD4             ;   a  - номер страницы
0067+  FFD4             ;   hl - адрес
0068+  FFD4             ;   c  - байт
0069+  FFD4             ;
0070+  FFD4             ; 2013-11-01 Дизассемблировано vinxru
0071+  FFD4             ;----------------------------------------------------------------------------
0072+  FFD4             
0073+  FFD4 B7          pageWriteAny:	ora	a
0074+  FFD5~            #if BIG_ROM
0075+  FFD5~            		jm	pageWriteRet
0076+  FFD5             #else
0077+  FFD5 FA B6 FF    		jm	pageWriteROM
0078+  FFD8             #endif
0079+  FFD8 32 FD FF    disableARAM2:	sta	IO_PAGE_ARAM
0080+  FFDB 71          pageWriteCom:	mov	m, c
0081+  FFDC 32 FC FF    		sta	IO_PAGE_RAM
0082+  FFDF C9          pageWriteRet:	ret0399   FFE0             
0400   FFE0             .end		tasm: Number of errors = 0
